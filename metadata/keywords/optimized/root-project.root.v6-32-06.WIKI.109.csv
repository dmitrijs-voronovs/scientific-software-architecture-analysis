quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"nctionCalls(); }; 295 ; 296 /// max iterations; 297 unsigned int MaxIterations() const { return fOptions.MaxIterations(); }; 298 ; 299 /// absolute tolerance; 300 double Tolerance() const { return fOptions.Tolerance(); }; 301 ; 302 /// precision of minimizer in the evaluation of the objective function; 303 /// ( a value <=0 corresponds to the let the minimizer choose its default one); 304 double Precision() const { return fOptions.Precision(); }; 305 ; 306 /// strategy; 307 int Strategy() const { return fOptions.Strategy(); }; 308 ; 309 /// status code of minimizer; 310 int Status() const { return fStatus; }; 311 ; 312 /// status code of Minos (to be re-implemented by the minimizers supporting Minos); 313 virtual int MinosStatus() const { return -1; }; 314 ; 315 /// return the statistical scale used for calculate the error; 316 /// is typically 1 for Chi2 and 0.5 for likelihood minimization; 317 double ErrorDef() const { return fOptions.ErrorDef(); }; 318 ; 319 ///return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit); 320 bool IsValidError() const { return fValidError; }; 321 ; 322 /// retrieve the minimizer options (implement derived class if needed); 323 virtual MinimizerOptions Options() const {; 324 return fOptions;; 325 }; 326 ; 327 /// set print level; 328 void SetPrintLevel(int level) { fOptions.SetPrintLevel(level); }; 329 ; 330 ///set maximum of function calls; 331 void SetMaxFunctionCalls(unsigned int maxfcn) { if (maxfcn > 0) fOptions.SetMaxFunctionCalls(maxfcn); }; 332 ; 333 /// set maximum iterations (one iteration can have many function calls); 334 void SetMaxIterations(unsigned int maxiter) { if (maxiter > 0) fOptions.SetMaxIterations(maxiter); }; 335 ; 336 /// set the tolerance; 337 void SetTolerance(double tol) { fOptions.SetTolerance(tol); }; 338 ; 339 /// set in the minimizer the objective function evaluation precision; 340 /// ( a value <=0 means the minimizer will choose its optimal value automatically, i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:14343,validat,validation,14343,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['validat'],['validation']
Security,"nctional-chain like approach ;  df001_introduction.py This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach ;  df002_dataModel.C This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame ;  df002_dataModel.py This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame ;  df003_profiles.C This tutorial illustrates how to use TProfiles in combination with the RDataFrame ;  df003_profiles.py This tutorial illustrates how to use TProfiles in combination with the RDataFrame ;  df004_cutFlowReport.C This tutorial shows how to get information about the efficiency of the filters applied ;  df004_cutFlowReport.py This tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial il",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:98804,expose,exposes,98804,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['expose'],['exposes']
Security,"nd (const char *=""~/"", const char *=0, const char *=0);  ; virtual Int_t GetFile (const char *, const char *, const char *=0);  ; virtual const char * GetMssUrl (Bool_t=kFALSE);  ; virtual TProofDesc * GetProofDesc (Int_t id);  Get TProofDesc instance corresponding to 'id'. ;  ; virtual TProofDesc * GetProofDesc (TProof *p);  Get TProofDesc instance corresponding to TProof object 'p'. ;  ; virtual Int_t GetRemoteProtocol () const;  ; virtual const char * GetUrl ();  ; virtual void Grep (const char *, const char *=0, const char *=0);  ; virtual Bool_t IsLite () const;  ; virtual Bool_t IsProofd () const;  ; virtual Bool_t IsValid () const;  ; virtual void Ls (const char *=""~/"", const char *=0, const char *=0);  ; virtual Bool_t MatchUrl (const char *url);  Checks if 'url' refers to the same user@host:port entity as the URL in memory. ;  ; virtual Int_t Md5sum (const char *, TString &, const char *=0);  ; virtual void More (const char *, const char *=0, const char *=0);  ; virtual Int_t PutFile (const char *, const char *, const char *=0);  ; virtual TList * QuerySessions (Option_t *opt=""S"");  Get list of sessions accessible to this manager. ;  ; virtual Int_t Reset (Bool_t hard=kFALSE, const char *usr=0);  Send a cleanup request for the sessions associated with the current user. ;  ; virtual Int_t Rm (const char *, const char *=0, const char *=0);  Run 'rm' on 'what'. Locally it is just a call to TSystem::Unlink . ;  ; virtual Int_t SendMsgToUsers (const char *, const char *=0);  Send a message to connected users. ;  ; virtual void SetAlias (const char *alias="""");  ; virtual void SetInvalid ();  ; virtual void SetMssUrl (const char *mss);  ; virtual Int_t SetROOTVersion (const char *);  ; virtual void ShowROOTVersions ();  ; virtual void ShowWorkers ();  Show available workers. ;  ; virtual void ShutdownSession (Int_t id);  ; virtual void ShutdownSession (TProof *p);  ; virtual Int_t Stat (const char *, FileStat_t &, const char *=0);  ; void StreamerNVirtual (TBuffer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgrLite.html:3357,access,accessible,3357,doc/master/classTProofMgrLite.html,https://root.cern,https://root.cern/doc/master/classTProofMgrLite.html,1,['access'],['accessible']
Security,"nd ;  CTChainA chain is a collection of files containg TTree objects ;  CTChainElementA TChainElement describes a component of a TChain ;  ►CTChainIndexA Chain Index ;  CTChainIndexEntryHolds a description of indices of trees in the chain ;  CTChair;  CTChirpFileRead and write data via a Chirp server ;  CTChirpSystem;  CTCivetweb;  CTCL;  ►CTClassThe ROOT global object gROOT contains a list of all defined classes ;  CInsertTClassInRegistryRAII;  CTDeclNameRegistry;  CTNameMapNode;  CTSpinLockGuard;  CTClassDocInfo;  CTClassDocOutput;  CTClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized way to create the TClass objects ;  CTClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe ;  CTClassRefTClassRef is used to implement a permanent reference to a TClass object ;  CTClassStreamer;  CTClassTableThis class registers for all classes their name, id and dictionary function in a hash table ;  CTClassTreeDraw inheritance tree and their relations for a list of classes ;  ►CTClingThis class defines an interface to the cling C++ interpreter ;  CCharPtrCmp_t;  CTUniqueString;  CTClingBaseClassInfoEmulation of the CINT BaseClassInfo class ;  CTClingCallbacks;  CTClingCallFuncEmulation of the CINT CallFunc class ;  CTClingClassInfoEmulation of the CINT ClassInfo class ;  CTClingDataMemberInfoEmulation of the CINT DataMemberInfo class ;  CTClingMethodArgInfoEmulation of the CINT MethodInfo class ;  CTClingMethodInfoEmulation of the CINT MethodInfo class ;  CTClingTypedefInfoEmulation of the CINT TypedefInfo class ;  CTClingTypeInfoEmulation of the CINT TypeInfo class ;  ►CTClingValueBridge between cling::Value and ROOT ;  CHasTheSameSizeAsClingValue;  CTClonesArrayAn array of clone (identical) objects ;  CTCollectionCollection abstract base class ;  CTCollectionClassStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTCollectionM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:115471,hash,hash,115471,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['hash'],['hash']
Security,"nd Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data members). We put private members first since that is the language default and it gives the developer a quick view on what data members are used in a class.; Avoid raw C types; Avoid the use of raw C types like int, long, float, double when using data that might be written to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:3201,access,access,3201,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['access'],['access']
Security,"nd location of file in a search path. ;  ; virtual const char * WorkingDirectory ();  Return working directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:20720,hash,hash,20720,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,6,['hash'],['hash']
Security,"nd of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsReal.; Definition at line 269 of file RooProfileLL.cxx. ◆ setAlwaysStartFromMin(). void RooProfileLL::setAlwaysStartFromMin ; (; bool ; flag). inline . Definition at line 30 of file RooProfileLL.h. ◆ Streamer(). void RooProfileLL::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooProfileLL::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 70 of file RooProfileLL.h. ◆ validateAbsMin(). void RooProfileLL::validateAbsMin ; (; ); const. protected . Check that parameters and likelihood value for 'best fit' are still valid. ; If not, because the best fit has never been calculated, or because constant parameters have changed value or parameters have changed const/float status, the minimum is recalculated ; Definition at line 187 of file RooProfileLL.cxx. Member Data Documentation. ◆ _absMin. double RooProfileLL::_absMin = 0.0. mutableprotected . absolute minimum of -log(L) ; Definition at line 60 of file RooProfileLL.h. ◆ _absMinValid. bool RooProfileLL::_absMinValid = false. mutableprotected . flag if absmin is up-to-date ; Definition at line 59 of file RooProfileLL.h. ◆ _minimizer. std::unique_ptr<RooMinimizer> RooProfileLL::_minimizer = nullptr. mutableprotected . ! Internal minimizer instance ; Definition at line 57 of file RooProfileLL.h. ◆ _neval. Int_t RooProfileLL::_neval = 0. mutableprotected . Number evaluations used in last minimization. ; Definition at line 64 of file RooProfileLL.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:66087,validat,validateAbsMin,66087,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"nd related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in his \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and he therefore has access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:11368,access,access,11368,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['access'],['access']
Security,"nd up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:11130,validat,validation,11130,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,3,['validat'],['validation']
Security,"nd use setAttribute() on the x object: objectToReplaceX.setAttribute(""ORIGNAME:x""); Now, the renamed object will be selected based on the attribute ""ORIGNAME:<name>"". ; [in]isRecursionStepInternal switch used when called from recursiveRedirectServers(). . Definition at line 1036 of file RooAbsArg.cxx. ◆ redirectServers() [2/2]. bool RooAbsArg::redirectServers ; (; std::unordered_map< RooAbsArg *, RooAbsArg * > const & ; replacements). Replace some servers of this object. ; If there are proxies that correspond to the replaced servers, these proxies are adjusted as well. Parameters. [in]replacementsMap that specifies which args replace which servers. . Definition at line 1150 of file RooAbsArg.cxx. ◆ redirectServersHook(). bool RooAbsArg::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). virtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsOptTestStatistic, RooAbsTestStatistic, RooAbsPdf, RooAbsReal, and RooProjectedPdf.; Definition at line 1313 of file RooAbsArg.cxx. ◆ registerCache(). void RooAbsArg::registerCache ; (; RooAbsCache & ; cache). Register RooAbsCache with this object. ; This function is called by RooAbsCache constructors for objects that are a datamember of this RooAbsArg. By registering itself the RooAbsArg is aware of all its cache data members and will forward server change and cache mode change cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:91196,inject,inject,91196,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['inject'],['inject']
Security,"nd using the; object's IsEqual() method. Returns 0 if obj is last in list. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is first in list. void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects; unless the TList is the owner (set via SetOwner()) and option; ""nodelete"" is not set.; If option=""nodelete"" then don't delete any heap objects that were; marked with the kCanDelete bit, otherwise these objects will be; deleted (this option is used by THashTable::Clear()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). void DeleteLink(TObjLink* lnk); Delete a TObjLink object. TObject * FindObject(const char* name) const; Find an object in this list using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. This method overrides the generic FindObject(); of TCollection for efficiency reasons. TObject * FindObject(const TObject* obj) const; Find an object in this list using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; This method overrides the generic FindObject() of TCollection for; efficiency reasons. TObjLink * FindLink(const TObject* obj, Int_t& idx) const; Returns the TObjLink object that contains object obj. In idx it returns; the position of the object in the list. TObject * First() const; Return the first object in the list. Returns 0 when list is empty. TObject ** GetObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TList.html:13894,access,access,13894,root/html528/TList.html,https://root.cern,https://root.cern/root/html528/TList.html,6,['access'],['access']
Security,"nd(""/ResetHPX"", ""/hpx/->Reset()"", ""button;rootsys/icons/ed_delete.png""); . Definition at line 1428 of file THttpServer.cxx. ◆ RegisterWS(). void THttpServer::RegisterWS ; (; std::shared_ptr< THttpWSHandler > ; ws). Register WS handler. ; Register WS handler to the THttpServer.; Only such handler can be used in multi-threaded processing of websockets ; Definition at line 1263 of file THttpServer.cxx. ◆ ReplaceJSROOTLinks(). void THttpServer::ReplaceJSROOTLinks ; (; std::shared_ptr< THttpCallArg > & ; arg, . const std::string & ; version = """" . ). protected . Replaces all references like ""jsrootsys/..."" or other pre-configured pathes. ; Either using pre-configured JSROOT installation from web or redirect to jsrootsys from the main server path to benefit from browser caching Creates appropriate importmap instead of placeholder ; Definition at line 847 of file THttpServer.cxx. ◆ Restrict(). void THttpServer::Restrict ; (; const char * ; path, . const char * ; options . ). Restrict access to specified object. ; See TRootSniffer::Restrict() for more details ; Definition at line 1386 of file THttpServer.cxx. ◆ SetCors(). void THttpServer::SetCors ; (; const std::string & ; domain = ""*""). inline . Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header. ; Definition at line 109 of file THttpServer.h. ◆ SetCorsCredentials(). void THttpServer::SetCorsCredentials ; (; const std::string & ; value = ""true""). inline . Enable/disable usage Access-Control-Allow-Credentials response header. ; Definition at line 118 of file THttpServer.h. ◆ SetDefaultPage(). void THttpServer::SetDefaultPage ; (; const std::string & ; filename = """"). Set default HTML page. ; Sets file name, delivered by the server when http address is opened in the browser.; By default, $ROOTSYS/js/files/online.htm page is used When empty filename is specified, default page will be used ; Definition at line 368 of file THttpServer.cxx. ◆ SetDrawPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:32706,access,access,32706,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['access']
Security,"nd) override;  Make GL context current. ;  ; void MarkForDirectCopy (Int_t devInd, Bool_t) override;  Selection-rotation support for TPad/TCanvas. ;  ; void PaintSingleObject (TVirtualGLPainter *) override;  Paint a single object. ;  ; void PanObject (TVirtualGLPainter *o, Int_t x, Int_t y) override;  Pan objects. ;  ; Bool_t PlotSelected (TVirtualGLPainter *plot, Int_t px, Int_t py) override;  Analog of TObject::DistancetoPrimitive. ;  ; void PrintViewer (TVirtualViewer3D *vv) override;  Print viewer. ;  ; void ReadGLBuffer (Int_t devInd) override;  GL buffer is read info buffer, after that lines are reordered into XImage, XImage copied into pixmap. ;  ; Bool_t ResizeOffScreenDevice (Int_t devInd, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Resize off screen device. ;  ; Bool_t SelectManip (TVirtualGLManip *manip, const TGLCamera *camera, const TGLRect *rect, const TGLBoundingBox *sceneBox) override;  Select manipulator. ;  ; void SelectOffScreenDevice (Int_t devInd) override;  Selects off-screen device to make it accessible by gVirtualX. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGLManager;  TGLManager ();  ;  TGLManager (const TGLManager &)=delete;  ; TGLManager & operator= (const TGLManager &)=delete;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTX11GLManager.html:2606,access,accessible,2606,doc/master/classTX11GLManager.html,https://root.cern,https://root.cern/doc/master/classTX11GLManager.html,1,['access'],['accessible']
Security,"ndRules( const TString &source, UInt_t checksum ) const; 349{; 350 TObject* obj;; 351 TObjArrayIter it( fAllRules );; 352 TMatches arr;; 353 // arr->SetOwner( kFALSE );; 354 ; 355 while( (obj = it.Next()) ) {; 356 TSchemaRule* rule = (TSchemaRule*)obj;; 357 if( rule->GetSourceClass() == source && rule->TestChecksum( checksum ) ); 358 arr.push_back( rule );; 359 }; 360 ; 361 return arr;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Return all the rules that applies to the specified version OR checksum of the given 'source' class.; 366/// User has to delete the returned array; 367 ; 368const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules( const TString &source, Int_t version, UInt_t checksum ) const; 369{; 370 TObject* obj;; 371 TObjArrayIter it( fAllRules );; 372 TMatches arr;; 373 // arr->SetOwner( kFALSE );; 374 ; 375 while( (obj = it.Next()) ) {; 376 TSchemaRule* rule = (TSchemaRule*)obj;; 377 if( rule->GetSourceClass() == source && ( rule->TestVersion( version ) || rule->TestChecksum( checksum ) ) ); 378 arr.push_back( rule );; 379 }; 380 ; 381 return arr;; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385 ; 386TClass* TSchemaRuleSet::GetClass(); 387{; 388 return fClass;; 389}; 390 ; 391////////////////////////////////////////////////////////////////////////////////; 392 ; 393UInt_t TSchemaRuleSet::GetClassCheckSum() const; 394{; 395 if (fCheckSum == 0 && fClass) {; 396 const_cast<TSchemaRuleSet*>(this)->fCheckSum = fClass->GetCheckSum();; 397 }; 398 return fCheckSum;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402 ; 403TString TSchemaRuleSet::GetClassName() const; 404{; 405 return fClassName;; 406}; 407 ; 408////////////////////////////////////////////////////////////////////////////////; 409 ; 410Int_t TSchemaRuleSet::GetClassVersion() const; 411{; 412 return fVersion;; 413}; 414 ; 415////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html:13903,checksum,checksum,13903,doc/master/TSchemaRuleSet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html,1,['checksum'],['checksum']
Security,"ndau and landaun are mutually exclusive in the same expression. Boolean optimization (kBoolOptmize) :. Those pseudo operation are used to implement lazy evaluation of; && and ||. When the left hand of the expression if false; (respectively true), the evaluation of the right is entirely skipped; (since it would not change the value of the expreession). && 142 11 (one operation on right) 142 21 (2 operations on right); || 142 12 (one operation on right) 142 22 (2 operations on right). * functions calls (kFunctionCall) :. f0 145 0 f1 145 1 etc.. Errors :. 1 : Division By Zero; 2 : Invalid Floating Point Operation; 4 : Empty String; 5 : invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected. /*; ; */. Special functions. By default, the formula is assigned fNumber=0. However, the following; formula built with simple functions are assigned fNumber:; ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:18426,access,accessible,18426,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,3,['access'],['accessible']
Security,"nded to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:9032,access,access,9032,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security,"nderSelTranspForHighlight(TGLRnrCtx& rnrCtx); virtual voidRenderTransp(TGLRnrCtx& rnrCtx); virtual Bool_tResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); voidSetAutoDestruct(Bool_t a); voidSetClip(TGLClip* p); voidSetLOD(Short_t lod); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSceneBase.html:3617,access,access,3617,root/html534/TGLSceneBase.html,https://root.cern,https://root.cern/root/html534/TGLSceneBase.html,1,['access'],['access']
Security,"ndex () override;  ; virtual TTree * GetTree () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:3960,hash,hash,3960,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,1,['hash'],['hash']
Security,"ndex (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id: TFITS.h 38935 2011-04-19 20:38:15Z pcanal $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFITSHDU.html:13088,access,access,13088,root/html530/TFITSHDU.html,https://root.cern,https://root.cern/root/html530/TFITSHDU.html,1,['access'],['access']
Security,"ndex (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id: TFITS.h 38935 2011-04-19 20:38:15Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFITSHDU.html:13088,access,access,13088,root/html532/TFITSHDU.html,https://root.cern,https://root.cern/root/html532/TFITSHDU.html,1,['access'],['access']
Security,"ndex(dotr);; 381 while (dotrIdx != kNPOS) {; 382 lastDotrIdx = dotrIdx;; 383 dotrIdx = suffix.Index(dotr, dotrIdx + 1);; 384 }; 385 if (lastDotrIdx != kNPOS) {; 386 // Add the part up until '.root' to the basename for globbing; 387 basename.Append(suffix, lastDotrIdx + dotrl);; 388 // Remove the part up until '.root' from the suffix; 389 suffix.Replace(0, lastDotrIdx + dotrl, """");; 390 }; 391 ; 392 // case with one single file; 393 if (!basename.MaybeWildcard()) {; 394 return AddFile(name, nentries);; 395 }; 396 ; 397 // wildcarding used in name; 398 Int_t nf = 0;; 399 std::vector<std::string> expanded_glob;; 400 try {; 401 expanded_glob = ROOT::Internal::TreeUtils::ExpandGlob(std::string(basename));; 402 } catch (const std::runtime_error &) {; 403 // The 'ExpandGlob' function may throw in case the directory from the glob; 404 // cannot be opened. We return 0 to signify no files were added.; 405 return nf;; 406 }; 407 ; 408 const TString hashMarkTreeName{""#"" + treename};; 409 for (const auto &path : expanded_glob) {; 410 if (suffix == hashMarkTreeName) {; 411 // See https://github.com/root-project/root/issues/11483; 412 // In case the input parameter 'name' contains both a glob and the; 413 // '?#' token to identify the tree name, the call to; 414 // `ParseTreeFileName` will produce a 'suffix' string of the form; 415 // '#treename'. Passing this to the `AddFile` call produces a bogus; 416 // file name that TChain won't be able to open afterwards. Thus,; 417 // we do not pass the 'suffix' as part of the file name, instead we; 418 // directly pass 'treename' to `AddFile`.; 419 nf += AddFile(path.c_str(), nentries, treename);; 420 } else {; 421 nf += AddFile(TString::Format(""%s%s"", path.c_str(), suffix.Data()), nentries);; 422 }; 423 }; 424 ; 425 if (fProofChain); 426 // This updates the proxy chain when we will really use PROOF; 427 ResetBit(kProofUptodate);; 428 ; 429 return nf;; 430}; 431 ; 432//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:15844,hash,hashMarkTreeName,15844,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,2,['hash'],['hashMarkTreeName']
Security,"ndex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » CORE; » METAUTILS; » TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); char*DemangleName(const char* mangled_name, int& errorCode); char*DemangleTypeIdName(const type_info& ti, int& errorCode); TClassEdit::EComplexTypeGetComplexType(const char*); stringGetLong64_Name(const char* original); stringGetLong64_Name(const string& original); voidGetNormalizedName(string& norm_name, string_view name); intGetSplit(const char* type, vector<string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); const char*GetUnqualifiedName(const char* name); voidInit(TClassEdit::TInterpreterLookupHelper* helper); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsDefHash(const char* hashname, const char* classname); boolIsDefPred(const char* predname, const char* classname); boolIsInterpreterDetail(const char* type); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); ROOT::ESTLTypeIsSTLCont(string_view type); intIsSTLCont(const char* type, int testAlloc); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); ROOT::ESTLTypeSTLKind(string_view type); ROOT::ESTLTypeUnderlyingIsSTLCont(string_view type). Data Members. Class Charts; Function documentation; void Init(TClassEdit::TInterpreterLookupHelper* helper). ROOT::ESTLType STLKind(string_view type); Converts STL container name to number. vector -> 1, etc..; If len is greater than 0, only look at that many characters in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClassEdit.html:1215,hash,hashname,1215,root/html604/TClassEdit.html,https://root.cern,https://root.cern/root/html604/TClassEdit.html,1,['hash'],['hashname']
Security,ndler.; Definition at line 704 of file TGLEventHandler.cxx. ◆ HandleCrossing(). Bool_t TGLEventHandler::HandleCrossing ; (; Event_t * ; event). overridevirtual . Handle generic Event_t type 'event' - provided to catch focus changes and terminate any interaction in viewer. ; Reimplemented from TGEventHandler.; Definition at line 403 of file TGLEventHandler.cxx. ◆ HandleDoubleClick(). Bool_t TGLEventHandler::HandleDoubleClick ; (; Event_t * ; event). overridevirtual . Handle mouse double click 'event'. ; Reimplemented from TGEventHandler.; Definition at line 672 of file TGLEventHandler.cxx. ◆ HandleEvent(). Bool_t TGLEventHandler::HandleEvent ; (; Event_t * ; event). overridevirtual . Handle generic Event_t type 'event' - provided to catch focus changes and terminate any interaction in viewer. ; Reimplemented from TGEventHandler.; Definition at line 351 of file TGLEventHandler.cxx. ◆ HandleExpose(). Bool_t TGLEventHandler::HandleExpose ; (; Event_t * ; event). virtual . Handle window expose 'event' - show. ; Definition at line 727 of file TGLEventHandler.cxx. ◆ HandleFocusChange(). Bool_t TGLEventHandler::HandleFocusChange ; (; Event_t * ; event). overridevirtual . Handle generic Event_t type 'event' - provided to catch focus changes and terminate any interaction in viewer. ; Reimplemented from TGEventHandler.; Definition at line 376 of file TGLEventHandler.cxx. ◆ HandleKey(). Bool_t TGLEventHandler::HandleKey ; (; Event_t * ; event). overridevirtual . Handle keyboard 'event'. ; Reimplemented from TGEventHandler.; Definition at line 746 of file TGLEventHandler.cxx. ◆ HandleMotion(). Bool_t TGLEventHandler::HandleMotion ; (; Event_t * ; event). overridevirtual . Handle mouse motion 'event'. ; Reimplemented from TGEventHandler.; Definition at line 890 of file TGLEventHandler.cxx. ◆ HandleTimer(). Bool_t TGLEventHandler::HandleTimer ; (; TTimer * ; t). overridevirtual . If mouse delay timer times out emit signal. ; Reimplemented from TObject.; Definition at line 990 of fi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEventHandler.html:23915,expose,expose,23915,doc/master/classTGLEventHandler.html,https://root.cern,https://root.cern/doc/master/classTGLEventHandler.html,1,['expose'],['expose']
Security,"ndlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRFIOSystem(); Create helper class that allows directory access via rfiod.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via rfiod. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via rfiod. const char * GetDirEntry(void* dirp); Get directory entry via rfiod. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* path); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. void * GetDirPtr() const; { return fDirp; }. virtual ~TRFIOSystem(); { }. » Author: Fons Rademakers 20/01/99 + Giulia Taurelli 29/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rfio:$Id: TRFIOFile.h 35330 2010-09-16 12:12:03Z pcanal $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOSystem.html:20753,access,access,20753,root/html530/TRFIOSystem.html,https://root.cern,https://root.cern/root/html530/TRFIOSystem.html,3,['access'],['access']
Security,"ndlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRFIOSystem(); Create helper class that allows directory access via rfiod.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via rfiod. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via rfiod. const char * GetDirEntry(void* dirp); Get directory entry via rfiod. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* path); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. void * GetDirPtr() const; { return fDirp; }. virtual ~TRFIOSystem(); { }. » Author: Fons Rademakers 20/01/99 + Giulia Taurelli 29/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rfio:$Id: TRFIOFile.h 35330 2010-09-16 12:12:03Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRFIOSystem.html:20846,access,access,20846,root/html532/TRFIOSystem.html,https://root.cern,https://root.cern/root/html532/TRFIOSystem.html,3,['access'],['access']
Security,"ndow. ;  ; float GetOperationTmout () const;  Returns timeout for synchronous WebWindow operations. ;  ; int GetSendQueueLength (unsigned connid) const;  Returns send queue length for specified connection. ;  ; THttpServer * GetServer ();  Return THttpServer instance serving requests to the window. ;  ; std::string GetUrl (bool remote=true);  Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:4936,authenticat,authentication,4936,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"ndow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31551,authenticat,authentication,31551,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['authenticat'],['authentication']
Security,"ndow.hxx:357; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1888; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1795; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1429; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1775; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:171; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:149; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:238; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1352; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:156; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:285; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:31940,authenticat,authentication,31940,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['authenticat'],['authentication']
Security,"ndricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_double_.html:4147,access,accessors,4147,root/html526/ROOT__Math__CylindricalEta3D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__CylindricalEta3D_double_.html,5,['access'],['accessors']
Security,"ndzioSolver or TMehrotraSolver; // The Gondzio method is more sophisticated and therefore numerically more involved; // If one want the Mehrotra method, simply replace ""Gondzio"" by ""Mehrotra"" .; ; TGondzioSolver *s = new TGondzioSolver(qp,prob);; const Int_t status = s->Solve(prob,vars,resid);; ; const TVectorD weight = vars->fX;; ; delete qp; delete prob; delete vars; delete resid; delete s;; if (status != 0) {; cout << ""Could not solve this problem."" <<endl;; return TVectorD(nrStocks);; }; ; return weight;; }; #endif; ; //---------------------------------------------------------------------------; void portfolio(); {; const Int_t sDay = 20000809;; const Int_t eDay = 20040602;; ; const char *fname = ""stock.root"";; TFile *f = 0;; if (!gSystem->AccessPathName(fname)) {; f = TFile::Open(fname);; } else if (!gSystem->AccessPathName(Form(""%s/quadp/%s"", TROOT::GetTutorialDir().Data(), fname))) {; f = TFile::Open(Form(""%s/quadp/%s"", TROOT::GetTutorialDir().Data(), fname));; } else {; printf(""accessing %s file from http://root.cern/files\n"",fname);; f = TFile::Open(Form(""http://root.cern/files/%s"",fname));; }; if (!f) return;; ; TArrayF *data = new TArrayF[nrStocks];; for (Int_t i = 0; i < nrStocks; i++) {; const TString symbol = stocks[i];; data[i] = StockReturn(f,symbol,sDay,eDay);; }; ; const Int_t nrData = data[0].GetSize();; ; TVectorD r(nrStocks);; for (Int_t i = 0; i < nrStocks; i++); r[i] = data[i].GetSum()/nrData;; ; TMatrixDSym Covar(nrStocks);; for (Int_t i = 0; i < nrStocks; i++) {; for (Int_t j = 0; j <= i; j++) {; Double_t sum = 0.;; for (Int_t k = 0; k < nrData; k++) {; sum += (data[i][k] - r[i]) * (data[j][k] - r[j]);; }; Covar(i,j) = Covar(j,i) = sum/nrData;; }; }; ; const TVectorD weight1 = OptimalInvest(2.0,r,Covar);; const TVectorD weight2 = OptimalInvest(10.,r,Covar);; ; cout << ""stock daily daily w1 w2"" <<endl;; cout << ""symb return sdv "" <<endl;; for (Int_t i = 0; i < nrStocks; i++); printf(""%s\t: %.3f %.3f %.3f %.3f\n"",stocks[i],r[i],TMath::Sqrt(Cova",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:11043,access,accessing,11043,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['access'],['accessing']
Security,"ne 325 of file RWebWindow.cxx. ◆ GetMaxQueueLength(). unsigned ROOT::RWebWindow::GetMaxQueueLength ; (; ); const. inline . Return maximal queue length of data which can be held by window. ; Definition at line 304 of file RWebWindow.hxx. ◆ GetOperationTmout(). float ROOT::RWebWindow::GetOperationTmout ; (; ); const. inline . Returns timeout for synchronous WebWindow operations. ; Definition at line 351 of file RWebWindow.hxx. ◆ GetRelativeAddr() [1/2]. std::string RWebWindow::GetRelativeAddr ; (; const RWebWindow & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1270 of file RWebWindow.cxx. ◆ GetRelativeAddr() [2/2]. std::string RWebWindow::GetRelativeAddr ; (; const std::shared_ptr< RWebWindow > & ; win); const. Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ; Definition at line 1260 of file RWebWindow.cxx. ◆ GetSendQueueLength(). int RWebWindow::GetSendQueueLength ; (; unsigned ; connid); const. Returns send queue length for specified connection. ; Parameters. connidconnection id, 0 - maximal value for all connections is returned If wrong connection id specified, -1 is return . Definition at line 1509 of file RWebWindow.cxx. ◆ GetServer(). THttpServer * RWebWindow::GetServer ; (; ). Return THttpServer instance serving requests to the window. ; Definition at line 181 of file RWebWindow.cxx. ◆ GetUrl(). std::string RWebWindow::GetUrl ; (; bool ; remote = true). Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ; Parameters. remoteis true, real HTTP server will be started automatically and widget can be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:33041,access,access,33041,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"ne 57 of file TApplicationRemote.h. Public Member Functions;  TARFileStat (const char *fn, TMD5 *md5, Long_t mt);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote_1_1TARFileStat.html:1308,hash,hash,1308,doc/master/classTApplicationRemote_1_1TARFileStat.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote_1_1TARFileStat.html,1,['hash'],['hash']
Security,"ne 58 of file TNamed.h. ◆ FillBuffer(). void TNamed::FillBuffer ; (; char *& ; buffer). virtual . Encode TNamed into output buffer. ; Reimplemented in TKeySQL, TSQLFile, TKeyXML, TXMLFile, TDirectoryFile, TFile, and TKey.; Definition at line 104 of file TNamed.cxx. ◆ GetName(). const char * TNamed::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 47 of file TNamed.h. ◆ GetTitle(). const char * TNamed::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTNamed.html:18528,hash,hash,18528,doc/v632/classTNamed.html,https://root.cern,https://root.cern/doc/v632/classTNamed.html,2,['hash'],['hash']
Security,"ne TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1224 of file TClass.cxx. ◆ TClass() [7/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1275 of file TClass.cxx. ◆ TClass() [8/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1304 of file TClass.cxx. ◆ ~TClass(). TClass::~TClass ; (; ). virtual . TClass dtor. Deletes all list that might have been created. ; Definition at line 1660 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 494 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Definition at line 511 of file TClass.cxx. ◆ AddImplFile(). void TClass::AddImplFile ; (; const char * ; filename, . int ; line . ). Definition at line 1952 of file TClass.cxx. ◆ AddInstance(). void TClass::AddInstance ; (; Bool_t ; heap = kFALSE). inline . Definition at line 381 of file TClass.h. ◆ AddRule(). Bool_t TClass::AddRule ; (; const char * ; rule). static . Add a schema evolution customization rule. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:51948,access,access,51948,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security,"ne TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1291 of file TClass.cxx. ◆ TClass() [7/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1342 of file TClass.cxx. ◆ TClass() [8/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1371 of file TClass.cxx. ◆ ~TClass(). TClass::~TClass ; (; ). virtual . TClass dtor. Deletes all list that might have been created. ; Definition at line 1727 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 555 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Definition at line 576 of file TClass.cxx. ◆ AddImplFile(). void TClass::AddImplFile ; (; const char * ; filename, . int ; line . ). Definition at line 2019 of file TClass.cxx. ◆ AddInstance(). void TClass::AddInstance ; (; Bool_t ; heap = kFALSE). inline . Definition at line 381 of file TClass.h. ◆ AddRule(). Bool_t TClass::AddRule ; (; const char * ; rule). static . Add a schema evolution customization rule. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:51949,access,access,51949,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security,"ne pychge. void Py1ent(Int_t line, Int_t kf, Double_t pe, Double_t theta, Double_t phi); Add one entry to the event record, i.e. either a parton or a; particle. IP: normally line number for the parton/particle. There are two; exceptions:. If IP = 0: line number 1 is used and PYEXEC is called.; If IP < 0: line -IP is used, with status code K(-IP,2)=2; rather than 1; thus a parton system may be built; up by filling all but the last parton of the; system with IP < 0.; KF: parton/particle flavour code (PDG code); PE: parton/particle energy. If PE is smaller than the mass,; the parton/particle is taken to be at rest.; THETA:; PHI: polar and azimuthal angle for the momentum vector of the; parton/particle. void SetupTest(); Exemplary setup of Pythia parameters:; Switches on processes 102,123,124 (Higgs generation) and switches off; interactions, fragmentation, ISR, FSR... TPythia6& operator=(const TPythia6& ). Pyjets_t* GetPyjets(); ****** accessors; FORTRAN indexing in accessing the arrays,; indices start from 1 !!!!!; ****** access to PYTHIA6 common-blocks; ****** /PYJETS. { return fPyjets; }. int GetN(); { return fPyjets->N; }. int GetNPAD(); { return fPyjets->NPAD; }. int GetK(int ip, int i); { return fPyjets->K[i-1][ip-1]; }. double GetP(int ip, int i); { return fPyjets->P[i-1][ip-1]; }. double GetV(int ip, int i); { return fPyjets->V[i-1][ip-1]; }. void SetN(int n); { fPyjets->N = n; }. void SetNPAD(int n); { fPyjets->NPAD = n; }. void SetK(int ip, int i, int k); { fPyjets->K[i-1][ip-1] = k; }. void SetP(int ip, int i, double p); { fPyjets->P[i-1][ip-1] = p; }. void SetV(int ip, int i, double v); { fPyjets->V[i-1][ip-1] = v; }. Pydat1_t* GetPydat1(); ****** /PYDAT1. { return fPydat1; }. int GetMSTU(int i); { return fPydat1->MSTU[i-1]; }. double GetPARU(int i); { return fPydat1->PARU[i-1]; }. int GetMSTJ(int i); { return fPydat1->MSTJ[i-1]; }. double GetPARJ(int i); { return fPydat1->PARJ[i-1]; }. void SetMSTU(int i, int m); { fPydat1->MSTU[i-1] = m; }. void SetPARU(i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia6.html:17519,access,accessors,17519,root/html528/TPythia6.html,https://root.cern,https://root.cern/root/html528/TPythia6.html,9,['access'],"['access', 'accessing', 'accessors']"
Security,"ne.h:19; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::GetTopNameconst char * GetTopName() constreturns name of top item in objects hierarchyDefinition THttpServer.h:130; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:11644,access,access,11644,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['access'],['access']
Security,"ne; to get passwd. Returns passwd (which must de deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns -1. GlobusAuth_t GetGlobusAuthHook(); Static method returning the globus authorization hook. const char * GetRSAPubExport(Int_t key = 0); Static method returning the RSA public keys. Int_t GetRSAInit(); Static method returning the RSA initialization flag. void SetDefaultRSAKeyType(Int_t key); Static method setting the default type of RSA key. void SetRSAInit(Int_t init = 1); Static method setting RSA initialization flag. TList * GetAuthInfo(); Static method returning the list with authentication details. TList * GetProofAuthInfo(); Static method returning the list with authentication directives; to be sent to proof. void AuthError(const char* where, Int_t error); Print error string depending on error code. void SetGlobalUser(const char* user); Set global user name to be used for authentication to rootd or proofd. void SetGlobalPasswd(const char* passwd); Set global passwd to be used for authentication to rootd or proofd. void SetGlobalPwHash(Bool_t pwhash); Set global passwd hash flag to be used for authentication to rootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:15422,authenticat,authentication,15422,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"neStrength(Float_t alpha = -1.0). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.0). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Fri Nov 26 14:26:55 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__CCPruner.html:1838,validat,validationSample,1838,root/html528/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html528/TMVA__CCPruner.html,4,['validat'],"['validation', 'validationSample']"
Security,"near part (Lorentzian. The output of the FittingDemo() example. 5.5 Result of the fit; Here we will show how to obtain the result of the fit (fitted function, parameter values, errors and eventually the covariance and correlation matrix).; 5.5.1 Associated Function; One or more objects (typically a TF1\*) can be added to the list of functions (fFunctions) associated to each histogram. A call to TH1::Fit adds the fitted function to this list. Given a histogram h, one can retrieve the associated function with:; TF1 *myfunc = h->GetFunction(""myfunc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180447,access,access,180447,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::FindTFunction * Find(DeclId_t id) constReturn the TMethod or TFunction describing the function corresponding to the Decl 'id'.Definition TListOfFunctions.cxx:250; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:471715,access,access,471715,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"ned int i, unsigned int j) constreturn correlation coefficient between variable i and j.Definition Minimizer.h:264; ROOT::Math::Minimizer::~Minimizervirtual ~Minimizer()Destructor (no operations).Definition Minimizer.h:127; ROOT::Math::Minimizer::ErrorDefdouble ErrorDef() constreturn the statistical scale used for calculate the error is typically 1 for Chi2 and 0....Definition Minimizer.h:317; ROOT::Math::Minimizer::fOptionsMinimizerOptions fOptionsminimizer optionsDefinition Minimizer.h:370; ROOT::Math::Minimizer::operator=Minimizer & operator=(Minimizer const &)=delete; ROOT::Math::Minimizer::SetFixedVariablevirtual bool SetFixedVariable(unsigned int ivar, const std::string &name, double val)set a new fixed variable (override if minimizer supports them )Definition Minimizer.cxx:44; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::IsValidErrorbool IsValidError() constreturn true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit)Definition Minimizer.h:320; ROOT::Math::Minimizer::Edmvirtual double Edm() constreturn expected distance reached from the minimum (re-implement if minimizer provides itDefinition Minimizer.h:222; ROOT::Math::Minimizer::GetMinosErrorvirtual bool GetMinosError(unsigned int ivar, double &errLow, double &errUp, int option=0)minos error for variable i, return false if Minos failed or not supported and the lower and upper err...Definition Minimizer.cxx:172; ROOT::Math::Minimizer::SetOptionsvoid SetOptions(const MinimizerOptions &opt)set all options in one goDefinition Minimizer.h:353; ROOT::Math::Minimizer::SetVariableValuesvirtual bool SetVariableValues(const double *x)set the values of all existing variables (array must be dimensioned to the size of the existing param...Definition Minimizer.h:187; ROOT::Math::Minimizer::Clearvirtual void Clear()reset for consecutive minimization - implement if neede",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:29772,validat,validation,29772,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['validat'],['validation']
Security,"ned int j);  read/write access to matrix element with indices starting from 0. ;  ; SMatrixRow_const operator[] (unsigned int i) const;  read only access to matrix element, with indices starting from 0 : m[i][j] ;  ; SMatrixRow operator[] (unsigned int i);  read/write access to matrix element with indices starting from 0 : m[i][j] ;  ; SMatrix< T, D1, D2, R > & operator+= (const T &rhs);  addition with a scalar ;  ; template<class R2 > ; SMatrix< T, D1, D2, R > & operator+= (const SMatrix< T, D1, D2, R2 > &rhs);  addition with another matrix of any compatible representation ;  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator+= (const Expr< A, T, D1, D2, R2 > &rhs);  addition with a compatible matrix expression ;  ; SMatrix< T, D1, D2, R > & operator-= (const T &rhs);  subtraction with a scalar ;  ; template<class R2 > ; SMatrix< T, D1, D2, R > & operator-= (const SMatrix< T, D1, D2, R2 > &rhs);  subtraction with another matrix of any compatible representation ;  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator-= (const Expr< A, T, D1, D2, R2 > &rhs);  subtraction with a compatible matrix expression ;  ; SMatrix< T, D1, D2, R > & operator*= (const T &rhs);  multiplication with a scalar ;  ; template<class R2 > ; SMatrix< T, D1, D2, R > & operator*= (const SMatrix< T, D1, D2, R2 > &rhs);  multiplication with another compatible matrix (it is a real matrix multiplication) Note that this operation does not avid to create a temporary to store intermediate result ;  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator*= (const Expr< A, T, D1, D2, R2 > &rhs);  multiplication with a compatible matrix expression (it is a real matrix multiplication) ;  ; SMatrix< T, D1, D2, R > & operator/= (const T &rhs);  division with a scalar ;  ; — Linear Algebra Functions —; bool Invert ();  Invert a square Matrix ( this method changes the current matrix). ;  ; SMatrix< T, D1, D2, R > Inverse (int &ifail) const;  Invert a square Mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:6371,access,access,6371,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,2,['access'],['access']
Security,"ned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; print result of minimization. void SetTraceObject(ROOT::Minuit2::MnTraceObject& obj); set an object to trace operation for each iteration; The object muust implement operator() (unsigned int, MinimumState & state). void SetStorageLevel(int level); set storage level = 1 : store all iteration states (default); = 0 : store only first and last state to save memory. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html:14107,access,accessing,14107,root/html602/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html,1,['access'],['accessing']
Security,"ned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; print result of minimization. void SetTraceObject(ROOT::Minuit2::MnTraceObject& obj); set an object to trace operation for each iteration; The object muust implement operator() (unsigned int, MinimumState & state). void SetStorageLevel(int level); set storage level = 1 : store all iteration states (default); = 0 : store only first and last state to save memory. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html:14053,access,accessing,14053,root/html534/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html,1,['access'],['accessing']
Security,"ned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; print result of minimization. void SetTraceObject(ROOT::Minuit2::MnTraceObject& obj); set an object to trace operation for each iteration; The object muust implement operator() (unsigned int, MinimumState & state). void SetStorageLevel(int level); set storage level = 1 : store all iteration states (default); = 0 : store only first and last state to save memory. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Minuit2__Minuit2Minimizer.html:14107,access,accessing,14107,root/html604/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html604/ROOT__Minuit2__Minuit2Minimizer.html,1,['access'],['accessing']
Security,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:38137,access,access,38137,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias sin the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:34710,access,access,34710,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['access'],['access']
Security,"needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; This 2 functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; int; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Access to TClonesArray.; If a branch (or member) is a TClonesArray (let's say fTracks), you can access the TClonesArray itself by using ->: fTracks->GetLast();; However this will load the full TClonesArray object and its content. To quickly read the size of the TClonesArray use (note the dot): fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been split. To access the content of the TClonesArray, use the [] operator: float px = fTracks[i].fPx; // fPx of the i-th track; Warning:; The variable actually use for access are 'wrapper' around the real data type (to add autoload for example) and hence getting to the data involves the implicit call to a C++ conversion operator. This conversion is automatic in most case. However it is not invoked in a few cases, in particular in variadic function (like printf). So when using printf you should either explicitly cast the value or use any intermediary variable: fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:34179,access,access,34179,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,"ner accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; TGenCollectionProxy::Proxies_tfProxyKeptOptimization: Keep proxies once they were created; TGenCollectionProxy::Proxies_tfProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); TGenCollectionProxy::Sizing_tfResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; TGenCollectionProxy::Staged_tfStagedOptimization: Keep staged array once they were created; TGenCollectionProxy::Info_tfTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); atomic<TGenCollectionProxy::Value*>fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy(const TGenCollectionProxy& copy); Build a proxy for an emulated container. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Build a proxy for a collection whose type is described by 'collectionClass'. TGenCollec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:5520,access,accessors,5520,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,6,['access'],['accessors']
Security,"nerated code includes the following:; Identification of the original Tree and Input file name; Connection of the Tree file; Declaration of Tree variables; Setting of branches addresses; A skeleton for the entry loop. To use this function:; connect your Tree file (eg: TFile f(""myfile.root"");); T->MakeCode(""anal.C""); where T is the name of the Tree in file myfile.root and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better function TTree::MakeClass() has been developed. ; Implements TVirtualTreePlayer.; Definition at line 1560 of file TTreePlayer.cxx. ◆ MakeProxy(). Int_t TTreePlayer::MakeProxy ; (; const char * ; proxyClassname, . const char * ; macrofilename = nullptr, . const char * ; cutfilename = nullptr, . const char * ; option = nullptr, . Int_t ; maxUnrolling = 3 . ). overridevirtual . Generate a skeleton analysis class for this Tree using TBranchProxy. ; TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton will then be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'. If the fileprefix contains a period, the right side of the period will be used as the extension (instead of 'h') and the left side will be used as the classname.; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source file which will be included in by the generated skeletong. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrollin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:31259,access,access,31259,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,"nerating images out of objects; 1.7.3 Methods execution; 1.7.4 Commands execution; 1.7.5 Performing multiple requests at once. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address “http://localhost:8080” in any modern browser (IE9, Firefox, Chrome, Opera) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a snapshot (frozen copy) of such server, running in tutorials/http/httpserver.C macro from ROOT tutorial.; <iframe width=“800” height=“500” src=“https://root.cern.ch/js/3.6/httpserver.C/?layout=simple&item=Canvases/c1”> ; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following parameters are supported:. thrds=N - number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:1453,access,access,1453,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ◆ ClearAuth(). Int_t TAuthenticate::ClearAuth ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwdhash . ). private . UsrPwd client authentication code. ; Returns 0 in case authentication failed 1 in case of success ; Definition at line 1509 of file TAuthenticate.cxx. ◆ DeclFileName(). static const char * TAuthenticate::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 207 of file TAuthenticate.h. ◆ DecodeRSAPublic(). Int_t TAuthenticate::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:24285,authenticat,authentication,24285,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:138370,access,accessed,138370,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['accessed']
Security,"new name. ; Definition at line 756 of file TSchemaRule.cxx. ◆ IsValid(). Bool_t TSchemaRule::IsValid ; (; ); const. Return kTRUE if this rule is valid. ; Definition at line 632 of file TSchemaRule.cxx. ◆ ls(). void TSchemaRule::ls ; (; Option_t * ; targetname = """"); const. overridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). ; Reimplemented from TObject.; Definition at line 177 of file TSchemaRule.cxx. ◆ operator=(). TSchemaRule & TSchemaRule::operator= ; (; const TSchemaRule & ; rhs). Copy operator. ; Definition at line 125 of file TSchemaRule.cxx. ◆ operator==(). Bool_t TSchemaRule::operator== ; (; const TSchemaRule & ; rhs); const. Return true if the rule have the same effects. ; Definition at line 147 of file TSchemaRule.cxx. ◆ ParseChecksum(). UInt_t TSchemaRule::ParseChecksum ; (; const char * ; checksum); const. private . Parse the checksum in the given string. ; Returns either the checksum or zero if the string is not a hex or decimal number. ; Definition at line 933 of file TSchemaRule.cxx. ◆ ProcessChecksum(). Bool_t TSchemaRule::ProcessChecksum ; (; const TString & ; checksum); const. private . Check if specified checksum string is correct and build checksum vector. ; Definition at line 887 of file TSchemaRule.cxx. ◆ ProcessDeclaration(). void TSchemaRule::ProcessDeclaration ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a declaration into as a TObjArray of TNamed(name,type). ; Definition at line 974 of file TSchemaRule.cxx. ◆ ProcessList(). void TSchemaRule::ProcessList ; (; TObjArray * ; array, . const TString & ; list . ). staticprivate . Split the list as a comma separated list into a TObjArray of TObjString. ; Definition at line 953 of file TSchemaRule.cxx. ◆ ProcessVersion(). Bool_t TSchemaRule::ProcessVersion ; (; const TString & ; version); const. private . Check if specified version string is correct and build version vector. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:22812,checksum,checksum,22812,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security,"newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; TObject * FindObject (const char *name) const override;  Find an object in this collection using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in this collection using the object's IsEqual() member function. ;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefArray.html:11396,hash,hash,11396,doc/master/classTRefArray.html,https://root.cern,https://root.cern/doc/master/classTRefArray.html,1,['hash'],['hash']
Security,"nfo == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:421311,authoriz,authorized,421311,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['authoriz'],"['authorization', 'authorized']"
Security,"nfo == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:421344,authoriz,authorized,421344,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['authoriz'],"['authorization', 'authorized']"
Security,"nfo elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output generated by prior runs of all known directives;; the output file names might have changes. void ExpandCPPLine(TString& lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:11606,hash,hashing,11606,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,6,['hash'],"['hash', 'hashing']"
Security,"nfo string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBuffer(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:43803,checksum,checksum,43803,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['checksum'],['checksum']
Security,"nfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TWebFile. ←. TS3WebFile. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:25724,access,accessible,25724,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['access'],['accessible']
Security,"nfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:17907,access,access,17907,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['access'],['access']
Security,"ng -lbzip2 explicitly otherwise linking will returns in undefined references. Otherwise we would need to check for libpng and libbzip2 on the system and adjust FREETYPE_LIBRARIES to include -lpng and -lbzip2. The current solution goes for the minimal configuration. The original request for this update was posted here.; 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class; When command is registered with THttpServer::RegisterCommand() method, one could configure additional arguments which should be submitted when command is executed with cmd.json requests; Introduce restriction rules for objects access with THttpServer::Restrict() method. Up to now general read-only flag was applied - either everything read-only or everything is fully accessible. Now one could restrict access to different parts of objects hierarchy or even fully ‘hide’ them from the client. Restriction based on user account name, which is applied when htdigest authentication is configured. One also able to allow execution of selected methods.; Implement multi.bin and multi.json requests. One could request many items with single HTTP request. Let optimize communication between server and client.; With SNIFF tag in ClassDef() comments one could expose different properties, which than exposed by the TRootSniffer to the client with h.json requests. Such possibility ease implementation of client-side code for custom classes.; Allow to bind http port with loopback address. This restrict access to http server only from localhost. One could either specify ‘loopback’ option in constructor: new THttpServer(“http:8080?loopback”) or in clear text specify IP address to which http socket should be bind: new THttpServer(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:18832,access,accessible,18832,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['accessible']
Security,"ng an histogram with reverse axis. ;  ; file  sparsehist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ; file  statsEditing.C;   Edit statistics box. ;  ; file  testSmooth.C;   Histogram smoothing. ;  ; file  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ; file  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ; file  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ; file  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ; file  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ; file  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ; file  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ; file  tprofile2polyRealistic.C;   Different charges depending on region ;  ; file  tprofile2polyRealisticModuleError.C;   Simulate faulty detector panel w.r.t. ;  ; file  transpad.C;   Example of a canvas showing two histograms with different scales. ;  ; file  twoscales.C;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  twoscales.py;   Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ;  ; file  xyplot.C;   Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ;  ; file  ZoomHistogram.C;   Changing the Range on the X-Axis of a Histogram ;  . ROOT master - Reference Guide Generated on Tue Nov ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__hist.html:6236,access,accessible,6236,doc/master/group__tutorial__hist.html,https://root.cern,https://root.cern/doc/master/group__tutorial__hist.html,1,['access'],['accessible']
Security,"ng char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; where target is a pointer or array to the type stored on this branch.; When count_buf points to a valid TBuffer and the branch has a branch count, count_buf will be filled (via a call to GetEntriesSerialized()) with the data from the branchCount. After deserialization those value can be used to calculate the number of elements corresponding to each entries.; For each entry the number of elements is the multiplication of; TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; auto len = leaf->GetLen();; and the value in the BranchCount corresponding to that entry (can be obtained from branch->GetBranchCount()).; NoteThis interface is not meant to be exposed to end users, but rather it should be wrapped by higher-level interfaces. See TBranch::GetBulkEntries() for an alternative that also performs byte swapping. ; Definition at line 1586 of file TBranch.cxx. ◆ GetEntry(). Int_t TBranch::GetEntry ; (; Long64_t ; entry = 0, . Int_t ; getall = 0 . ). virtual . Read all leaves of entry and return total number of bytes read. ; The input argument ""entry"" is the entry number in the current tree. In case of a TChain, the entry number in the current Tree must be found before calling this function. For example:; TChain* chain = ...;; Long64_t localEntry = chain->LoadTree(entry);; branch->GetEntry(localEntry);; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::LoadTreeLong64_t LoadTree(Long64_t entry) overrideFind the tree which contains entry, and set it as the current tree.Definition TChain.cxx:1324; The function returns the number of bytes read from the input bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:48378,expose,exposed,48378,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['expose'],['exposed']
Security,"ng it to 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or a THnSparse. See the Projection() members. To only project parts of the histogram, call THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; ; Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and its bin content. The coordinates are compacted to use as few bits as possible; e.g. a histogram with 10 bins in x and 20 bins in y will only use 4 bits for the x representation and 5 bits for the y representation. This is handled by the internal class THnSparseCompactBinCoord. Bin data (content and coordinates) are allocated in chunks of size fChunkSize; this parameter can be set when constructing a THnSparse. Each chunk is represented by an object of class THnSparseArrayChunk.; Translation from an n-dimensional bin coordinate to the linear index within the chunks is done by GetBin(). It creates a hash from the compacted bin coordinates (the hash of a bin coordinate is the compacted coordinate itself if it takes less than 8 bytes, the size of a Long64_t. This hash is used to lookup the linear index in the TExMap member fBins; the coordinates of the entry fBins points to is compared to the coordinates passed to GetBin(). If they do not match, these two coordinates have the same hash - which is extremely unlikely but (for the case where the compact bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to GetBin() will retrieve the matching bin. ; Definition at line 37 of file THnSparse.h. Public Member Functions;  ~THnSparse () override;  Destruct a THnSparse. ;  ; void AddBinContent (const Int_t *idx, Double_t v=1.);  Forwards to THnBase::AddBinContent(). ;  ; void AddBinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:4091,hash,hash,4091,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,2,['hash'],['hash']
Security,"ng the color palette; 2498 ; 2499 ; 2500To change the color palette `TStyle::SetPalette` should be used, eg:; 2501 ; 2502 gStyle->SetPalette(ncolors,colors);; 2503 ; 2504For example the option `COL` draws a 2D histogram with cells; 2505represented by a box filled with a color index which is a function; 2506of the cell content.; 2507If the cell content is N, the color index used will be the color number; 2508in `colors[N]`, etc. If the maximum cell content is greater than; 2509`ncolors`, all cell contents are scaled to `ncolors`.; 2510 ; 2511If ` ncolors <= 0`, a default palette (see below) of 50 colors is; 2512defined. This palette is recommended for pads, labels ...; 2513 ; 2514`if ncolors == 1 && colors == 0`, then a Pretty Palette with a; 2515Spectrum Violet->Red is created with 50 colors. That's the default rain bow; 2516palette.; 2517 ; 2518Other pre-defined palettes with 255 colors are available when `colors == 0`.; 2519The following value of `ncolors` give access to:; 2520 ; 2521 ; 2522 if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be viewed by selecting; 2541the item `colors` in the `VIEW` menu of the canvas tool bar.; 2542The red, green, and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:102289,access,access,102289,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['access'],['access']
Security,"ng values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:84973,access,access,84973,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['access'],['access']
Security,"ng variable ;  ; virtual bool SetVariableValues (const double *x);  set the values of all existing variables (array must be dimensioned to the size of the existing parameters) ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  ; virtual int VariableIndex (const std::string &name) const;  get index of variable given a variable given a name return -1 if variable is not found ;  ; virtual std::string VariableName (unsigned int ivar) const;  get name of variables (override if minimizer support storing of variable names) return an empty string if variable is not found ;  . Protected Member Functions; void GetGeneticOptions (ROOT::Math::MinimizerOptions &opt) const;  . Protected Attributes; TMVA::IFitterTarget * fFitness;  ; double fMinValue;  ; GeneticMinimizerParameters fParameters;  ; std::vector< TMVA::Interval * > fRanges;  ; std::vector< double > fResult;  ;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/GeneticMinimizer.h>. Inheritance diagram for ROOT::Math::GeneticMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GeneticMinimizer(). ROOT::Math::GeneticMinimizer::GeneticMinimizer ; (; int ; i = 0). Definition at line 99 of file GeneticMinimizer.cxx. ◆ ~GeneticMinimizer(). ROOT::Math::GeneticMinimizer::~GeneticMinimizer ; (; ). override . Definition at line 117 of file GeneticMinimizer.cxx. Member Function Documentation. ◆ Clear(). void ROOT::Math::GeneticMinimizer::Clear ; (; ). overridevirtual . reset for consecutive minimization - implement if needed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 126 of file GeneticMinim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html:10753,validat,validated,10753,doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,1,['validat'],['validated']
Security,"ng z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:191622,access,access,191622,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['access'],['access']
Security,"ng z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view containe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:209916,access,access,209916,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['access'],['access']
Security,"ng& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:30757,access,access,30757,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['access'],['access']
Security,"ng, std::string> Key is location name (with slash at the end) and value is file path. ;  ; static std::shared_ptr< RWebWindowsManager > & Instance ();  Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ;  ; static bool IsLoopbackMode ();  Returns true if loopback mode used by THttpServer for web widgets. ;  ; static bool IsMainThrd ();  Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ;  ; static void SetLoopbackMode (bool on=true);  Set loopback mode for THttpServer used for web widgets By default is on. ;  ; static void SetUseConnectionKey (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ;  ; float GetLaunchTmout () const;  Returns timeout for launching new browser process. ;  ; std::string GetUrl (RWebWindow &win, bool remote=false, std::string *produced_key=nullptr);  Provide URL address to access specified window from inside or from remote. ;  ; bool InformListener (const std::string &msg)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:3613,hash,hash,3613,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['hash'],['hash']
Security,"ng.cxx. ◆ RegisterLoadedSharedLibrary(). void TCling::RegisterLoadedSharedLibrary ; (; const char * ; name). private . Register a new shared library name with the interpreter; add it to fSharedLibs. ; Definition at line 3415 of file TCling.cxx. ◆ RegisterModule(). void TCling::RegisterModule ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payloadCode, . const char * ; fwdDeclsCode, . void(*)() ; triggerFunc, . const FwdDeclArgsToKeepCollection_t & ; fwdDeclsArgToSkip, . const char ** ; classesHeaders, . Bool_t ; lateRegistration = false, . Bool_t ; hasCxxModule = false . ). finalvirtual . Inject the module named ""modulename"" into cling; load all headers. ; headers is a 0-terminated array of header files to #include after loading the module. The module is searched for in all $LD_LIBRARY_PATH entries (or PATH% on Windows). This function gets called by the static initialization of dictionary libraries. The payload code is injected ""as is"" in the interpreter. The value of 'triggerFunc' is used to find the shared library location. ; Implements TInterpreter.; Definition at line 2010 of file TCling.cxx. ◆ RegisterPrebuiltModulePath(). bool TCling::RegisterPrebuiltModulePath ; (; const std::string & ; FullPath, . const std::string & ; ModuleMapName = ""module.modulemap"" . ); const. finalvirtual . Returnstrue if the module map was loaded, false on error or if the map was already loaded. ; Implements TInterpreter.; Definition at line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). private . Register Rdict data for future loading by LoadPCM;. ; Definition at line 1678 of file TCling.cxx. ◆ RegisterTClassUpdate(). void TCling::RegisterTClassUpdate ; (; TClass * ; oldcl, . DictFuncPtr_t ; dict . ). finalvirtual . Register classes that already existed prior to their dictionary loading and that al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:125191,inject,injected,125191,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['inject'],['injected']
Security,"ng64_t); - O : a boolean (Bool_t). By default, a variable will be copied to the buffer with the number of; bytes specified in the type descriptor character. However, if the type; consists of 2 characters, the second character is an integer that; specifies the number of bytes to be used when copying the variable; to the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:46290,access,access,46290,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['access'],['access']
Security,"ngReady_t = std::function< void(TPadWebSnapshot *)>;  Function called when pad painting produced. ;  . Protected Member Functions; void AddColorsPalette (TPadWebSnapshot &master);  Add special canvas objects with list of colors and color palette. ;  ; void AddCtrlMsg (unsigned connid, const std::string &key, const std::string &value);  Add control message for specified connection Same control message can be overwritten many time before it really sends to the client If connid == 0, message will be add to all connections After ctrl message is add to the output, short timer is activated and message send afterwards. ;  ; void AddCustomFonts (TPadWebSnapshot &master);  Add special canvas objects with custom fonts. ;  ; void AddSendQueue (unsigned connid, const std::string &msg);  Add message to send queue for specified connection If connid == 0, message will be add to all connections. ;  ; void AssignStatusBits (UInt_t bits);  Assign clients bits. ;  ; UInt_t CalculateColorsHash ();  Calculate hash function for all colors and palette. ;  ; virtual Bool_t CanCreateObject (const std::string &);  ; Bool_t CheckCanvasModified (bool force_modified=false);  Check if any pad on the canvas was modified If yes, increment version of correspondent pad Returns true when canvas really modified. ;  ; Bool_t CheckDataToSend (unsigned connid=0);  Check if any data should be send to client If connid != 0, only selected connection will be checked. ;  ; void CheckPadModified (TPad *pad);  Returns true if any pad in the canvas were modified Reset modified flags, increment canvas version (if inc_version is true) ;  ; void CreateObjectSnapshot (TPadWebSnapshot &master, TPad *pad, TObject *obj, const char *opt, TWebPS *masterps=nullptr);  Creates representation of the object for painting in web browser. ;  ; TVirtualPadPainter * CreatePadPainter () override;  Creates web-based pad painter. ;  ; void CreatePadSnapshot (TPadWebSnapshot &paddata, TPad *pad, Long64_t version, PadPaintingReady_t fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:9619,hash,hash,9619,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['hash'],['hash']
Security,"ng_view eyh = """"); 2280 {; 2281 auto graph = std::make_shared<::TGraphAsymmErrors>();; 2282 const std::vector<std::string_view> columnViews = {x, y, exl, exh, eyl, eyh};; 2283 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2284 ? ColumnNames_t(); 2285 : ColumnNames_t(columnViews.begin(), columnViews.end());; 2286 ; 2287 const auto validatedColumns = GetValidatedColumnNames(6, userColumns);; 2288 ; 2289 // We build a default name and title based on the input columns; 2290 const auto g_name = validatedColumns[1] + ""_vs_"" + validatedColumns[0];; 2291 const auto g_title = validatedColumns[1] + "" vs "" + validatedColumns[0];; 2292 graph->SetNameTitle(g_name.c_str(), g_title.c_str());; 2293 graph->GetXaxis()->SetTitle(validatedColumns[0].c_str());; 2294 graph->GetYaxis()->SetTitle(validatedColumns[1].c_str());; 2295 ; 2296 return CreateAction<RDFInternal::ActionTags::GraphAsymmErrors, X, Y, EXL, EXH, EYL, EYH>(validatedColumns, graph,; 2297 graph, fProxiedPtr);; 2298 }; 2299 ; 2300 ////////////////////////////////////////////////////////////////////////////; 2301 /// \brief Fill and return a one-dimensional profile (*lazy action*).; 2302 /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2303 /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2304 /// \param[in] model The model to be considered to build the new return value.; 2305 /// \param[in] v1Name The name of the column that will fill the x axis.; 2306 /// \param[in] v2Name The name of the column that will fill the y axis.; 2307 /// \return the monodimensional profile wrapped in a RResultPtr.; 2308 ///; 2309 /// This action is *lazy*: upon invocation of this method the calculation is; 2310 /// booked but not executed. Also see RResultPtr.; 2311 ///; 2312 /// ### Example usage:; 2313 /// ~~~{.cpp}; 2314 /// // Deduce column types (this invocation needs jitting internall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:128886,validat,validatedColumns,128886,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['validat'],['validatedColumns']
Security,"nge and binning; specified in xlo,xhi and nBins. The dimensions of the arrays xlo,xhi,; nBins should match the number of objects in vars. TH1 * createHistogram(const char* name, RooArgList& vars, const char* tAxisLabel, const RooAbsBinning** bins); Create a 1,2, or 3D-histogram with appropriate scale and labels.; Binning and ranges are taken from the variables themselves and can be changed by; calling their setPlotMin/Max() and setPlotBins() methods. A histogram can be filled; using RooAbsReal::fillHistogram() or RooTreeData::fillHistogram().; The caller takes ownership of the returned object and is responsible for deleting it. Bool_t isJacobianOK(const RooArgSet& depList) const; Interface function to indicate that this lvalue; has a unit or constant jacobian terms with respect to; the observable passed as argument. This default implementation; always returns true (i.e. jacobian is constant). inline RooAbsRealLValue(); Constructors, assignment etc. { }. void setVal(Double_t value); Parameter value and error accessors. RooAbsArg& operator=(const RooAbsReal& other). RooAbsArg& operator=(Double_t newValue). Int_t getBin(const char* rangeName = 0) const; { return getBinning(rangeName).binNumber(getVal()) ; }. Int_t numBins(const char* rangeName = 0) const; { return getBins(rangeName) ; }. Double_t getBinWidth(Int_t i, const char* rangeName = 0) const; { return getBinning(rangeName).binWidth(i) ; }. Double_t volume(const char* rangeName) const; { return getMax(rangeName)-getMin(rangeName) ; }. const RooAbsBinning* getBinningPtr(const char* rangeName) const; { return &getBinning(rangeName) ; }. Int_t getBin(const RooAbsBinning* ptr) const; { return ptr->binNumber(getVal()) ; }. Int_t getBin(const RooAbsBinning& binning) const; { return binning.binNumber(getVal()) ; }. Int_t numBins(const RooAbsBinning& binning) const; { return binning.numBins() ; }. Double_t getBinWidth(Int_t i, const RooAbsBinning& binning) const; { return binning.binWidth(i) ; }. Double_t volume(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:52051,access,accessors,52051,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,2,['access'],['accessors']
Security,"nger; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:13979,hash,hash,13979,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,6,['hash'],['hash']
Security,"ngine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:57644,access,access,57644,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['access']
Security,"ngth () const;  ; virtual Float_t GetZ () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMixture.html:2660,hash,hash,2660,doc/master/classTMixture.html,https://root.cern,https://root.cern/doc/master/classTMixture.html,1,['hash'],['hash']
Security,"nheritance. TClass * GetBaseClass(const TClass* base); Return pointer to the base class ""cl"". Returns 0 in case ""cl""; is not a base class. Takes care of multiple inheritance. Int_t GetBaseClassOffsetRecurse(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:26430,access,accessor,26430,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['access'],['accessor']
Security,"nheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:5655,access,accessors,5655,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,5,['access'],['accessors']
Security,"nidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCompactCoord() const; 839{; 840 if (!fCompactCoord) {; 841 Int_t *bins = new Int_t[fNdimensions];; 842 for (Int_t d = 0; d < fNdimensions; ++d); 843 bins[d] = GetAxis(d)->GetNbins();; 844 const_cast<THnSparse*>(this)->fCompactCoord; 845 = new THnSparseCompactBinCoord(fNdimensions, bins);; 846 delete [] bins;; 847 }; 848 return fCompactCoord;; 849}; 850 ; 851////////////////////////////////////////////////////////////////////////////////; 852/// Return the amount of filled bins over all bins; 853 ; 854Double_t THnSparse::GetSparseFractionBins() const {; 855 Double_t nbinsTotal = 1.;; 856 for (Int_t d = 0; d < fNdimensions; ++d); 857 nbinsTotal *= GetAxis(d)->GetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:30898,hash,hash,30898,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,nimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).; TEveVector4 Float four-vector.; TEveViewer Reve representation of TGLViewer.; TEveViewerList List of Viewers providing common operations on TEveViewer collections.; TEveViewerListEditor GUI editor for TEveViewerList.; TEveWindow Abstract base-class for eve-windows.; TEveWindowEditor GUI editor for TEveWindow.; TEveWindowFrame Eve-window containing any TGFrame.; TEveWindowManager Manager for EVE windows.; TEveWindowPack Eve-window containing a TGPack.; TEveWindowSlot An unoccupied eve-window slot.; TEveWindowTab Eve-window containing a TGTab.; TEventIter Event iterator used by TProofPlayer's; TEventIterObj Event iterator for objects; TEventIterTree Event iterator for Trees; TEventIterUnit Event iterator for objects; TEventList A list of selected entries in a TTree.; TExMap Map with external hash; TExMapIter TExMap iterator; TExec To execute a CINT command; TF1 The Parametric 1-D function; TF12 Projection of a TF2 along x or y; TF1Editor user interface for TF1 objects; TF2 The Parametric 2-D function; TF2GL GL renderer for TF2 and TF3.; TF3 The Parametric 3-D function; TFFTComplex ; TFFTComplexReal ; TFFTReal ; TFFTRealComplex ; TFTP File Transfer Protocol class using rootd; TFcnAdapter wrapper class implementing the Minuit2 interface for TMinuit2-like objective functions; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMerger File copying and merging services; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:65270,hash,hash,65270,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['hash'],['hash']
Security,"ning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:14508,authenticat,authenticates,14508,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['authenticat'],['authenticates']
Security,"ningTree() const { return Data()->GetNTrainingEvents() != 0; }; 514 ; 515 // ---------- protected auxiliary methods ------------------------------------; 516 ; 517 protected:; 518 ; 519 // make ROOT-independent C++ class for classifier response (classifier-specific implementation); 520 virtual void MakeClassSpecific( std::ostream&, const TString& = """" ) const {}; 521 ; 522 // header and auxiliary classes; 523 virtual void MakeClassSpecificHeader( std::ostream&, const TString& = """" ) const {}; 524 ; 525 // static pointer to this object - required for ROOT finder (to be solved differently)(solved by Omar); 526 //static MethodBase* GetThisBase();; 527 ; 528 // some basic statistical analysis; 529 void Statistics( Types::ETreeType treeType, const TString& theVarName,; 530 Double_t&, Double_t&, Double_t&,; 531 Double_t&, Double_t&, Double_t& );; 532 ; 533 // if TRUE, write weights only to text files; 534 Bool_t TxtWeightsOnly() const { return kTRUE; }; 535 ; 536 protected:; 537 ; 538 // access to event information that needs method-specific information; 539 ; 540 Bool_t IsConstructedFromWeightFile() const { return fConstructedFromWeightFile; }; 541 ; 542 private:; 543 ; 544 // ---------- private definitions --------------------------------------------; 545 // Initialisation; 546 void InitBase();; 547 void DeclareBaseOptions();; 548 void ProcessBaseOptions();; 549 ; 550 // used in efficiency computation; 551 enum ECutOrientation { kNegative = -1, kPositive = +1 };; 552 ECutOrientation GetCutOrientation() const { return fCutOrientation; }; 553 ; 554 // ---------- private accessors ---------------------------------------------; 555 ; 556 // reset required for RootFinder; 557 void ResetThisBase();; 558 ; 559 // ---------- private auxiliary methods --------------------------------------; 560 ; 561 // PDFs for classifier response (required to compute signal probability and Rarity); 562 void CreateMVAPdfs();; 563 ; 564 // for root finder; 565 //virtual method to find ROOT; 566 v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:23519,access,access,23519,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['access'],['access']
Security,"nit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Dec 7 13:45:36 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCollection.html:19039,hash,hash,19039,root/html526/RooAbsCollection.html,https://root.cern,https://root.cern/root/html526/RooAbsCollection.html,1,['hash'],['hash']
Security,"nit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Sat Oct 9 22:38:28 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCollection.html:19121,hash,hash,19121,root/html528/RooAbsCollection.html,https://root.cern,https://root.cern/root/html528/RooAbsCollection.html,1,['hash'],['hash']
Security,"nit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCollection.html:19382,hash,hash,19382,root/html530/RooAbsCollection.html,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html,1,['hash'],['hash']
Security,"nitHashTableCapacity, . Int_t ; rehashlevel = 0 . ). Create a THashTable object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehashlevel is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehashlevel then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehashlevel=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing. ; Definition at line 43 of file THashTable.cxx. ◆ ~THashTable(). THashTable::~THashTable ; (; ). virtual . Delete a hashtable. ; Objects are not deleted unless the THashTable is the owner (set via SetOwner()). ; Definition at line 65 of file THashTable.cxx. Member Function Documentation. ◆ Add(). void THashTable::Add ; (; TObject * ; obj). overridevirtual . Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. ; Implements TCollection.; Definition at line 92 of file THashTable.cxx. ◆ AddAll(). void THashTable::AddAll ; (; const TCollection * ; col). overridevirtual . Add all objects from collection col to this collection. ; Implemented for more efficient rehashing. ; Reimplemented from TCollection.; Definition at line 138 of file THashTable.cxx. ◆ AddBefore(). void THashTable::AddBefore ; (; const TObject * ; before, . TObject * ; obj . ). Add object to the hash table. ; Its position in the table will be determined by the value returned by its Hash() function. If and only if 'before' is in the same bucket as obj, obj is added in front of 'before' within the bucket's list. ; Definition at line 112 of file THashTable.cxx. ◆ AddImpl(). void THashTable::AddImpl ; (; Int_t ; slot, . TObject * ; obj . ). inlineprivate . Helper function doing the actual add to the table give a slot and objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:17328,hash,hash,17328,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"nitializes the X system. ;  ; Int_t InitWindow (ULong_t window) override;  Creates a new window and return window number. ;  ; Atom_t InternAtom (const char *atom_name, Bool_t only_if_exist) override;  Returns the atom identifier associated with the specified ""atom_name"" string. ;  ; void IntersectRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the intersection of two regions. ;  ; Bool_t IsCmdThread () const override;  ; Bool_t IsCocoaDraw () const;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist) override;  Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ;  ; Int_t KeysymToKeycode (UInt_t keysym) override;  Converts the ""keysym"" to the appropriate keycode. ;  ; char ** ListFonts (const char *fontname, Int_t max, Int_t &count) override;  Returns list of font names matching fontname regexp, like ""-*-times-*"". ;  ; FontStruct_t LoadQueryFont (const char *font_name) override;  Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ;  ; void LookupString (Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) override;  Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ;  ; void LowerWindow (Window_t wid) override;  Lowers the specified window ""id"" to the bottom of the stack so that it does not obscure any sibling windows. ;  ; Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:19719,access,accessing,19719,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,1,['access'],['accessing']
Security,"nition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:213077,access,access,213077,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security,"nition TH1.h:405; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; THStackThe Histogram stack class.Definition THStack.h:40; THStack::Addvirtual void Add(TH1 *h, Option_t *option="""")Add a new histogram to the list.Definition THStack.cxx:366; THStack::Drawvoid Draw(Option_t *chopt="""") overrideDraw this stack with its current attributes.Definition THStack.cxx:453; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TStringBasic string class.Definition TString.h:139; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ptTPaveText * ptDefinition entrylist_figure1.C:7; c1return c1Definition legend1.C:41; arrowDefinition RArrowDS.hxx:17; AuthorRene Brun ; Definition in file cernstaff.C. tutorialstreecernstaff.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernstaff_8C.html:6264,access,access,6264,doc/master/cernstaff_8C.html,https://root.cern,https://root.cern/doc/master/cernstaff_8C.html,2,['access'],['access']
Security,"nition at line 166 of file TMath.h. ◆ Gn(). constexpr Double_t TMath::Gn ; (; ). constexpr . Standard acceleration of gravity in \( m s^{-2} \). ; Definition at line 174 of file TMath.h. ◆ GnUncertainty(). constexpr Double_t TMath::GnUncertainty ; (; ). constexpr . Standard acceleration of gravity uncertainty. ; Definition at line 181 of file TMath.h. ◆ GUncertainty(). constexpr Double_t TMath::GUncertainty ; (; ). constexpr . Gravitational constant uncertainty. ; Definition at line 150 of file TMath.h. ◆ H(). constexpr Double_t TMath::H ; (; ). constexpr . Planck's constant in \( J s \): \( h \). ; Definition at line 188 of file TMath.h. ◆ Hash() [1/2]. ULong_t TMath::Hash ; (; const char * ; str). Definition at line 1416 of file TMath.cxx. ◆ Hash() [2/2]. ULong_t TMath::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). Calculates hash index from any char string. ; Based on pre-calculated table of 256 specially selected numbers. These numbers are selected in such a way, that for string length == 4 (integer number) the hash is unambiguous, i.e. from hash value we can recalculate input (no degeneration).; The quality of hash method is good enough, that ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N) tested by <R>, <R*R>, <Ri*Ri+1> gives the same result as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*)); V.Perev; This function is kept for back compatibility. The code previously in this function has been moved to the static function TString::Hash . Definition at line 1408 of file TMath.cxx. ◆ Hbar(). constexpr Double_t TMath::Hbar ; (; ). constexpr . \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ; Definition at line 211 of file TMath.h. ◆ Hbarcgs(). constexpr Double_t TMath::Hbarcgs ; (; ). constexpr . \( erg s \) ; Definition at line 218 of file TMath.h. ◆ HbarUncertainty(). constexpr Double_t TMath::HbarUncertainty ; (; ). constexpr .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:46936,hash,hash,46936,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['hash'],['hash']
Security,"nition at line 95 of file TListOfEnums.h. ◆ Delete(). void TListOfEnums::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete all TDataMember object files. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 168 of file TListOfEnums.cxx. ◆ Find(). TEnum * TListOfEnums::Find ; (; DeclId_t ; id); const. Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ; Definition at line 179 of file TListOfEnums.cxx. ◆ FindObject() [1/3]. TObject * TListOfEnums::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 190 of file TListOfEnums.cxx. ◆ FindObject() [2/3]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 52 of file THashList.cxx. ◆ FindUnloaded(). TEnum * TListOfEnums::FindUnloaded ; (; const char * ; name). inlineprotected . Definition at line 64 of file TListOfEnums.h. ◆ Get(). TEnum * TListOfEnums::Get ; (; DeclId_t ; id, . const char * ; name . ). protected . Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfEnums.cxx. ◆ GetClass(). TClass * TListOfEnums::GetClass ; (; ); const. inlineprotected . Definition at line 62 of file TListOfEnums.h. ◆ GetIds(). TExMap * TListOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:28360,hash,hash,28360,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hash']
Security,"nix domain connections to it. ; Returns socket fd or -1. ; Definition at line 4458 of file TUnixSystem.cxx. ◆ UnixUnixService() [2/2]. int TUnixSystem::UnixUnixService ; (; int ; port, . int ; backlog . ). staticprotected . Open a socket, bind to it and start listening for Unix domain connections to it. ; Returns socket fd or -1. ; Definition at line 4432 of file TUnixSystem.cxx. ◆ UnixWaitchild(). int TUnixSystem::UnixWaitchild ; (; ). staticprotected . Wait till child is finished. ; Definition at line 4130 of file TUnixSystem.cxx. ◆ Unlink(). int TUnixSystem::Unlink ; (; const char * ; name). overridevirtual . Unlink, i.e. ; remove, a file or directory. Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1708 of file TUnixSystem.cxx. ◆ Unload(). void TUnixSystem::Unload ; (; const char * ; module). overridevirtual . Unload a shared library. ; Reimplemented from TSystem.; Definition at line 2832 of file TUnixSystem.cxx. ◆ Unsetenv(). void TUnixSystem::Unsetenv ; (; const char * ; name). overridevirtual . Unset environment variable. ; Reimplemented from TSystem.; Definition at line 2145 of file TUnixSystem.cxx. ◆ Utime(). int TUnixSystem::Utime ; (; const char * ; file, . Long_t ; modtime, . Long_t ; actime . ). overridevirtual . Set a files modification and access times. ; If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error. ; Reimplemented from TSystem.; Definition at line 1910 of file TUnixSystem.cxx. ◆ WorkingDirectory(). const char * TUnixSystem::WorkingDirectory ; (; ). overridevirtual . Return working directory. ; Reimplemented from TSystem.; Definition at line 1445 of file TUnixSystem.cxx. Libraries for TUnixSystem:. [legend]; The documentation for this class was generated from the following files:; core/unix/inc/TUnixSystem.h; core/unix/src/TUnixSystem.cxx. TUnixSystem. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:42 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:80759,access,access,80759,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['access'],['access']
Security,"nk* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:14025,hash,hash,14025,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,2,['hash'],['hash']
Security,"nkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; Bool_t_useNptr!. private:. static RooLinkedListImplDetails::Pool*_pool!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinkedList.html:7190,hash,hash,7190,root/html534/RooLinkedList.html,https://root.cern,https://root.cern/root/html534/RooLinkedList.html,1,['hash'],['hash']
Security,"nkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; Bool_t_useNptr!. private:. static RooLinkedList::Pool*_pool!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinkedList.html:6766,hash,hashing,6766,root/html602/RooLinkedList.html,https://root.cern,https://root.cern/root/html602/RooLinkedList.html,2,['hash'],['hashing']
Security,"nline . Definition at line 140 of file TAuthenticate.h. ◆ GetHostAuth() [2/2]. THostAuth * TAuthenticate::GetHostAuth ; (; const char * ; host, . const char * ; user = """", . Option_t * ; opt = ""R"", . Int_t * ; exact = nullptr . ). static . Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ; If opt = ""P"" use fgProofAuthInfo list instead If no entry is found fHostAuth is not changed ; Definition at line 1972 of file TAuthenticate.cxx. ◆ GetKrb5Principal(). const char * TAuthenticate::GetKrb5Principal ; (; ). static . Static method returning the principal to be used to init Krb5 tickets. ; Definition at line 1042 of file TAuthenticate.cxx. ◆ GetPromptUser(). Bool_t TAuthenticate::GetPromptUser ; (; ). static . Static method returning the prompt user settings. ; Definition at line 1059 of file TAuthenticate.cxx. ◆ GetProofAuthInfo(). TList * TAuthenticate::GetProofAuthInfo ; (; ). static . Static method returning the list with authentication directives to be sent to proof. ; Definition at line 1249 of file TAuthenticate.cxx. ◆ GetProtocol(). const char * TAuthenticate::GetProtocol ; (; ); const. inline . Definition at line 141 of file TAuthenticate.h. ◆ GetPwHash(). Bool_t TAuthenticate::GetPwHash ; (; ); const. inlineprivate . Definition at line 78 of file TAuthenticate.h. ◆ GetRandString(). char * TAuthenticate::GetRandString ; (; Int_t ; opt, . Int_t ; len . ). private . Allocates and fills a 0 terminated buffer of length len+1 with len random characters. ; Returns pointer to the buffer (to be deleted by the caller) opt = 0 any non dangerous char 1 letters and numbers (upper and lower case) 2 hex characters (upper and lower case) ; Definition at line 2745 of file TAuthenticate.cxx. ◆ GetRemoteHost(). const char * TAuthenticate::GetRemoteHost ; (; ); const. inline . Definition at line 142 of file TAuthenticate.h. ◆ GetRSAInit(). Int_t TAuthenticate::GetRSAInit ; (; ). static . Static method returning the RSA i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:29681,authenticat,authentication,29681,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"nlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TNetFile.h. ◆ Close(). void TNetFile::Close ; (; Option_t * ; option = """"). overridevirtual . Close remote file. ; Reimplemented from TFile.; Definition at line 208 of file TNetFile.cxx. ◆ ConnectServer(). void TNetFile::ConnectServer ; (; Int_t * ; stat, . EMessageTypes * ; kind, . Int_t ; netopt, . Int_t ; tcpwindowsize, . Bool_t ; forceOpen, . Bool_t ; forceRead . ). protectedvirtual . Connect to remote rootd server. ; Definition at line 570 of file TNetFile.cxx. ◆ Create() [1/2]. void TNetFile::Create ; (; const char * ; url, . Option_t * ; option, . Int_t ; netopt . ). protectedvirtual . Create a NetFile object. ; A net file is the same as a TFile except that it is being accessed via a rootd server. The url argument must be of the form: root[k]://host.dom.ain/file.root. When protocol is ""rootk"" try using kerberos5 authentication. If the file specified in the URL does not exist, is not accessable or can not be created the kZombie bit will be set in the TNetFile object. Use IsZombie() to see if the file is accessable. If the remote daemon thinks the file is still connected, while you are sure this is not the case you can force open the file by preceding the option argument with an ""-"", e.g.: ""-recreate"". Do this only in cases when you are very sure nobody else is using the file. To bypass the writelock on a file, to allow the reading of a file that is being written by another process, explicitly specify the ""+read"" option (""read"" being the default option). The netopt argument can be used to specify the size of the tcp window in bytes (for more info see: http://www.psc.edu/networking/perf_tune.html). The default and minimum tcp window size is 65535 bytes. If netopt < -1 then |netopt| is the number of parallel sockets that will be used to connect to rootd. This option should be used on fat pipes (i.e. high bandwidth, high latency links). The ideal number of parallel sockets depends o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:45612,access,accessable,45612,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['access'],['accessable']
Security,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:172908,access,accesstime,172908,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['accesstime']
Security,"nment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:3508,hash,hash,3508,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,1,['hash'],['hash']
Security,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum TDocParser::fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<std::string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:9371,access,access,9371,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,6,['access'],['access']
Security,"nning*_binning! Pointer to default binning definition; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooErrorVar.html:39489,access,access,39489,root/html602/RooErrorVar.html,https://root.cern,https://root.cern/root/html602/RooErrorVar.html,2,['access'],['access']
Security,"node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTreeNode.html:7354,validat,validation,7354,root/html528/TMVA__DecisionTreeNode.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html,4,['validat'],['validation']
Security,"non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40590,checksum,checksum,40590,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"nostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101155,access,access,101155,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"nostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101187,access,access,101187,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:44274,access,access,44274,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,2,['access'],['access']
Security,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:24168,access,access,24168,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,12,['access'],['access']
Security,"ns function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = new TSQLFile(dbname, ""recreate"", username, userpass);; // Write with standard I/O functions; arr->Write(""arr"", TObject::kSingleKey);; h1->Write(""histo"");; // Close connection to DB; delete f;. example of a session read data from SQL data base. // Open database again in read-only mode; TSQLFile* f = new TSQLFile(dbname, ""open"", username, userpass);; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:5693,access,accessed,5693,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['access'],['accessed']
Security,"ns in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection refered to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:70920,access,access,70920,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['access'],['access']
Security,"ns in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:76549,access,access,76549,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"ns take precedence over short options and short option groups. E.g. -file would be interpreted as --file and not as -f -i -l -e (assuming a long option named ""file"" exists). ; bufmaxThe greatest index in the buffer[] array that parse() will write to is bufmax-1. If there are more options, they will be processed (in particular their CheckArg will be called) but not stored. ; If you used Stats::buffer_max to dimension this array, you can pass -1 (or not pass bufmax at all) which tells parse() that the buffer is ""large enough"". . AttentionRemember that options and buffer store Option objects, not pointers. Therefore it is not possible for the same object to be in both arrays. For those options that are found in both buffer[] and options[] the respective objects are independent copies. And only the objects in options[] are properly linked via Option::next() and Option::prev(). You can iterate over buffer[] to process all options in the order they appear in the argument vector, but if you want access to the other Options with the same Descriptor::index, then you must access the linked list via options[]. You can get the linked list in options from a buffer object via something like options[buffer[i].index()]. ; Definition at line 1081 of file OptionParser.h. ◆ Parser() [3/5]. ROOT::option::Parser::Parser ; (; bool ; gnu, . const Descriptor ; usage[], . int ; argc, . char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . Parser(...) with non-const argv. ; Definition at line 1089 of file OptionParser.h. ◆ Parser() [4/5]. ROOT::option::Parser::Parser ; (; const Descriptor ; usage[], . int ; argc, . const char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX Parser(...) (gnu==false). ; Definition at line 1097 of file OptionParser.h. ◆ Parser() [5/5]. ROOT::option::Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html:8493,access,access,8493,doc/v632/classROOT_1_1option_1_1Parser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html,4,['access'],['access']
Security,"ns take precedence over short options and short option groups. E.g. -file would be interpreted as --file and not as -f -i -l -e (assuming a long option named ""file"" exists). ; bufmaxThe greatest index in the buffer[] array that parse() will write to is bufmax-1. If there are more options, they will be processed (in particular their CheckArg will be called) but not stored. ; If you used Stats::buffer_max to dimension this array, you can pass -1 (or not pass bufmax at all) which tells parse() that the buffer is ""large enough"". . AttentionRemember that options and buffer store Option objects, not pointers. Therefore it is not possible for the same object to be in both arrays. For those options that are found in both buffer[] and options[] the respective objects are independent copies. And only the objects in options[] are properly linked via Option::next() and Option::prev(). You can iterate over buffer[] to process all options in the order they appear in the argument vector, but if you want access to the other Options with the same Descriptor::index, then you must access the linked list via options[]. You can get the linked list in options from a buffer object via something like options[buffer[i].index()]. ; Definition at line 1500 of file OptionParser.h. ◆ parse() [3/4]. void ROOT::option::Parser::parse ; (; const Descriptor ; usage[], . int ; argc, . char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX parse() (gnu==false) with non-const argv. ; Definition at line 1186 of file OptionParser.h. ◆ parse() [4/4]. void ROOT::option::Parser::parse ; (; const Descriptor ; usage[], . int ; argc, . const char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX parse() (gnu==false). ; Definition at line 1179 of file OptionParser.h. ◆ shift(). static void ROOT::op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html:16539,access,access,16539,doc/v632/classROOT_1_1option_1_1Parser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html,4,['access'],['access']
Security,"ns.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro ;  udpserver.c;  ► physics;  PhaseSpace.C Example of use of TGenPhaseSpace ;  ► proof;  EmptyInclude.hEmpty file to test TProof::Load in runProof.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ;  finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ;  getProof.CAttaches to a PROOF session, possibly at the indicated URL ;  ProcFileElements.CClass to hold information about the processed elements of a file ;  ProcFileElements.hClass to hold information about the processed elements of a file ;  ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ;  ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ;  ProofEvent.CSelector for generic processing with Event ;  ProofEvent.hSelector for generic p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:135142,authenticat,authentication,135142,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['authenticat'],['authentication']
Security,"nsFor ""VariationsFor()"". In between these steps, no other change; 1038to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; 1039through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; 1040results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; 1041explicitly, this is not required for ROOT macros. ; 1042 ; 1043An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:; 1044 ; 1045~~~{.cpp}; 1046auto nominal_hx =; 1047 df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); 1048 .Filter(""pt > pt_cut""); 1049 .Define(""x"", someFunc, {""pt""}); 1050 .Histo1D<float>(""x"");; 1051 ; 1052// request the generation of varied results from the nominal_hx; 1053ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1054 ; 1055// the event loop runs here, upon first access to any of the results or varied results:; 1056hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1057hx[""pt:down""].Draw(""SAME"");; 1058hx[""pt:up""].Draw(""SAME"");; 1059~~~; 1060 ; 1061A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1062as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1063this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1064to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1065""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1066 ; 1067Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1068the resulting histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:61343,access,access,61343,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"nsactionsOff ; kTransactionsAuto ; kTransactionsUser . Definition at line 175 of file TSQLFile.h. Constructor & Destructor Documentation. ◆ TSQLFile() [1/3]. TSQLFile::TSQLFile ; (; const TSQLFile & ; ). privatedelete . ◆ TSQLFile() [2/3]. TSQLFile::TSQLFile ; (; ). default TSQLFile constructor ; Definition at line 271 of file TSQLFile.cxx. ◆ TSQLFile() [3/3]. TSQLFile::TSQLFile ; (; const char * ; dbname, . Option_t * ; option = ""read"", . const char * ; user = ""user"", . const char * ; pass = ""pass"" . ). Connects to SQL server with provided arguments. ; If the constructor fails in any way IsZombie() will return true. Use IsOpen() to check if the file is (still) open. . Option Description . NEW or CREATE Create a ROOT tables in database if the tables already exists connection is not opened. . RECREATE Create completely new tables. Any existing table will be deleted. . UPDATE Open an existing database for writing. If data base open by other TSQLFile instance for writing, . write access will be rejected.| | BREAKLOCK | Special case when lock was not correctly released by TSQLFile instance. This may happen if program crashed when TSQLFile was open with write access mode.| | READ / OPEN | Open an existing data base for reading.|; For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. ; Definition at line 297 of file TSQLFile.cxx. ◆ ~TSQLFile(). TSQLFile::~TSQLFile ; (; ). override . destructor of TSQLFile object ; Definition at line 689 of file TSQLFile.cxx. Member Function Documentation. ◆ AddIdEntry(). void TSQLFile::AddIdEntry ; (; Long64_t ; tableid, . Int_t ; subid, . Int_t ; type, . const char * ; name, . const char * ; sqlname, . const char * ; info . ). protected . Add entry into IdsTable, where all tables names and columns names are listed. ; Definition at line 2018 of file TSQLFile.cxx. ◆ Class(). static TClass * TSQLFile::Class ; (; ). static . ReturnsTClass describing this class . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:61123,access,access,61123,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"nsert new TFunction-s. TList* GetListForObject(const char* name) const; Return the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfFunctions.html:14350,hash,hash,14350,root/html602/TListOfFunctions.html,https://root.cern,https://root.cern/root/html602/TListOfFunctions.html,1,['hash'],['hash']
Security,"nsient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:38763,access,access,38763,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,1,['access'],['access']
Security,"nst Event *);  insert a new ""event"" in the binary tree ;  ; virtual TClass * IsA () const;  ; Float_t Max (Types::ESBType sb, UInt_t var);  access to Maximum for signal and background for each variable ;  ; Float_t Mean (Types::ESBType sb, UInt_t var);  access to mean for signal and background for each variable ;  ; Float_t Min (Types::ESBType sb, UInt_t var);  access to Minimum for signal and background for each variable ;  ; void NormalizeTree ();  Normalisation of tree. ;  ; Float_t RMS (Types::ESBType sb, UInt_t var);  access to RMS for signal and background for each variable ;  ; Float_t RMS (UInt_t var);  access to RMS for each variable ;  ; BinarySearchTreeNode * Search (Event *event) const;  search the tree to find the node matching ""event"" ;  ; Double_t SearchVolume (Volume *, std::vector< const TMVA::BinarySearchTreeNode * > *events=nullptr);  search the whole tree and add up all weights of events that lie within the given volume ;  ; Int_t SearchVolumeWithMaxLimit (TMVA::Volume *, std::vector< const TMVA::BinarySearchTreeNode * > *events=nullptr, Int_t=-1);  recursively walk through the daughter nodes and add up all weights of events that lie within the given volume a maximum number of events can be given ;  ; void SetNormalize (Bool_t norm);  ; void SetPeriode (Int_t p);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::BinaryTree;  BinaryTree (void);  constructor for a yet ""empty"" tree. Needs to be filled afterwards ;  ; virtual ~BinaryTree ();  destructor (deletes the nodes and ""events"" if owned by the tree ;  ; virtual void * AddXMLTo (void *parent) const;  add attributes to XML ;  ; UInt_t CountNodes (Node *n=nullptr);  return the number of nodes in the tree. (make a new count --> takes time) ;  ; Node * GetLeftDaughter (Node *n);  get left daughter node current node ""n"" ;  ; UInt_t GetNNodes () const;  ; Node * GetRightDaughter (Node *n);  get right ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:2164,access,access,2164,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,2,['access'],['access']
Security,"nst RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tfindRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidfixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidfixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidforceNumInt(Bool_t flag = kTRUE); RooFunctor*functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tgetForceN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:11768,hash,hash,11768,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['hash'],['hash']
Security,"nst TS3HTTPRequest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TS3HTTPRequest&SetAccessKey(const TString& accessKey); TS3HTTPRequest&SetAuthKeys(const TString& accessKey, const TString& secretKey); TS3HTTPRequest&SetAuthType(TS3HTTPRequest::EAuthType authType); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); TS3HTTPRequest&SetBucket(const TString& bucket); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TS3HTTPRequest&SetHost(const TString& host); TS3HTTPRequest&SetObjectKey(const TString& objectKey); static voidTObject::SetObjectStat(Bool_t stat); TS3HTTPRequest&SetSecretKey(const TString& secretKey); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TS3HTTPRequest(); TS3HTTPRequest(const TS3HTTPRequest& m); TS3HTTPRequest(TS3HTTPRequest::EHTTPVerb httpVerb, const TString& host, const TString& bucket, const TString& objectKey, TS3HTTPRequest::EAuthType authType, const TString& accessKey, const TString& secretKey); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:6121,access,accessKey,6121,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,2,['access'],['accessKey']
Security,"nst char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:29591,hash,hash,29591,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,9,['hash'],['hash']
Security,"nst char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TMVAGui.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::CrossValidationClass to perform cross validation, splitting the dataloader into folds.Definition CrossValidation.h:124; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition Da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:28190,validat,validation,28190,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['validat'],['validation']
Security,"nst char* host, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); Create hostauth object.; 'host' may contain also the server for whicb these directives; are valid in the form 'host:server' or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THostAuth.html:9549,authenticat,authentication,9549,root/html528/THostAuth.html,https://root.cern,https://root.cern/root/html528/THostAuth.html,6,['authenticat'],['authentication']
Security,"nst char* where = 0); Run 'ls' on the nodes. void More(const char* what, const char* how = 0, const char* where = 0); Run 'more' on the nodes. Int_t Rm(const char* what, const char* how = 0, const char* where = 0); Run 'rm' on the nodes. The user is prompted before removal, unless 'how'; contains ""--force"" or a combination of single letter options including 'f',; e.g. ""-fv"". void Tail(const char* what, const char* how = 0, const char* where = 0); Run 'tail' on the nodes. Int_t Md5sum(const char* what, TString& sum, const char* where = 0); Run 'md5sum' on one of the nodes. Int_t Stat(const char* what, FileStat_t& st, const char* where = 0); Run 'stat' on one of the nodes. TObjString * Exec(Int_t action, const char* what, const char* how, const char* where); Execute 'action' (see EAdminExecType in 'XProofProtocol.h') at 'where'; (default master), with options 'how', on 'what'. The option specified by; 'how' are typically unix option for the relate commands. In addition to; the unix authorizations, the limitations are:. action = kRm limited to the sandbox (but basic dirs cannot be; removed) and on files owned by the user in the; allowed directories; action = kTail option '-f' is not supported and will be ignored. Int_t GetFile(const char* remote, const char* local, const char* opt = 0); Get file 'remote' into 'local' from the master.; If opt contains ""force"", the file, if it exists remotely, is copied in all cases,; otherwise a check is done on the MD5sum.; If opt contains ""silent"" standard notificatons are not printed (errors and; warnings and prompts still are).; Return 0 on success, -1 on error. Int_t PutFile(const char* local, const char* remote, const char* opt = 0); Put file 'local'to 'remote' to the master; If opt is ""force"", the file, if it exists remotely, is copied in all cases,; otherwise a check is done on the MD5sum.; Return 0 on success, -1 on error. void CpProgress(const char* pfx, Long64_t bytes, Long64_t size, TStopwatch* watch, Bool_t cr = kFALSE); Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofMgr.html:14724,authoriz,authorizations,14724,root/html528/TXProofMgr.html,https://root.cern,https://root.cern/root/html528/TXProofMgr.html,6,['authoriz'],['authorizations']
Security,"nst std::string &secondname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;  Generate the TClass and TStreamerInfo for the requested pair. ;  ; TVirtualStreamerInfo * GenerateInfoForPair (const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;  Generate the TClass and TStreamerInfo for the requested pair. ;  ; TClassStreamer * GenExplicitClassStreamer (const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;  Generate class streamer from static functions. ;  ; TVirtualCollectionProxy * GenExplicitProxy (const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;  Generate proxy from static functions. ;  ; TClass * GetActualClass (const void *obj) const override;  Assuming that obj points to (the part of) an object that is of the type described by this streamerInfo, return the actual type of the object (i.e. ;  ; UInt_t GetCheckSum () const override;  ; UInt_t GetCheckSum (TClass::ECheckSum code) const;  Recalculate the checksum of this TStreamerInfo based on its code. ;  ; TClass * GetClass () const override;  ; Int_t GetClassVersion () const override;  ; Int_t GetDataMemberOffset (TDataMember *dm, TMemberStreamer *&streamer) const;  Compute data member offset. ;  ; TStreamerElement * GetElem (Int_t id) const override;  ; TStreamerElement * GetElement (Int_t id) const override;  ; Int_t GetElementOffset (Int_t id) const override;  ; TObjArray * GetElements () const override;  ; Int_t GetLength (Int_t id) const;  ; ULongptr_t GetMethod (Int_t id) const;  ; Int_t GetNdata () const;  ; Int_t GetNelement () const;  ; Int_t GetNewType (Int_t id) const;  ; Int_t GetNumber () const override;  ; Int_t GetOffset (const char *) const override;  Return the offset of the data member as indicated by this StreamerInfo. ;  ; Int_t GetOffset (Int_t id) const override;  ; Version_t GetOldVersion () const override;  ; Int_t GetOnFileClassVersion () const override;  ; TStreamerInfoActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:7262,checksum,checksum,7262,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['checksum'],['checksum']
Security,"nst {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:29849,hash,hash,29849,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:13426,access,access,13426,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,4,['access'],['access']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:11200,access,access,11200,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,2,['access'],['access']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:13427,access,access,13427,root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,1,['access'],['access']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:12688,access,access,12688,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,4,['access'],['access']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:11200,access,access,11200,root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,2,['access'],['access']
Security,"nst. Data Members; private:. ROOT::Math::PtEtaPhiM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:12689,access,access,12689,root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,1,['access'],['access']
Security,"nst. inline . Definition at line 46 of file TObjString.h. ◆ Hash(). ULong_t TObjString::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjString::HashULong_t Hash() const overrideReturn hash value for this object.Definition TObjString.h:39; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 39 of file TObjString.h. ◆ IsA(). TClass * TObjString::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 50 of file TObjString.h. ◆ IsEqual(). Bool_t TObjString::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Return kTRUE if the argument has the same content as this object. ; Reimplemented from TObject.; Definition at line 45 of file TObjString.cxx. ◆ IsSortable(). Bool_t TObjString::IsSortable ; (; ); const. inlineoverridevirtual . Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjString.html:13062,hash,hash,13062,doc/master/classTObjString.html,https://root.cern,https://root.cern/doc/master/classTObjString.html,1,['hash'],['hash']
Security,"nst; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:16400,hash,hash,16400,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,1,['hash'],['hash']
Security,"nst; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:16716,hash,hash,16716,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,2,['hash'],['hash']
Security,"nst; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Int_tGetClassSize() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*GetCurrentStreamerInfo(); TDataMember*GetDataMember",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:3978,checksum,checksum,3978,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['checksum'],['checksum']
Security,"nst;  Write this object to the current directory. ;  . Static Public Member Functions; static void Add (const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits);  Add a class to the class table (this is a static function). ;  ; static void Add (TProtoClass *protoClass);  Add a class to the class table (this is a static function). ;  ; static ROOT::TClassAlt * AddAlternate (const char *normname, const char *alternate);  ; static char * At (UInt_t index);  Returns class at index from sorted class table. ;  ; static Bool_t Check (const char *cname, std::string &normname);  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static DictFuncPtr_t GetDict (const char *cname);  Given the class name returns the Dictionary() function of a class (uses hash of name). ;  ; static DictFuncPtr_t GetDict (const std::type_info &info);  Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ;  ; static DictFuncPtr_t GetDictNorm (const char *cname);  Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ;  ; static Version_t GetID (const char *cname);  Returns the ID of a class. ;  ; static Int_t GetPragmaBits (const char *name);  Returns the pragma bits as specified in the LinkDef.h file. ;  ; static TProtoClass * GetProto (const char *cname);  Given the class name returns the TClassProto object for the class. ;  ; static TProtoClass * GetProtoNorm (const char *cname);  Given the class normalized name returns the TClassProto object for the class. ;  ; static void Init ();  ; static char * Next ();  Returns next class from sorted class table. ;  ; static void PrintTable ();  Print the class table. ;  ; static void Remove (const char *cname);  Remove a class from the class table. ;  ; static void RemoveAlternate (ROOT::TClassAlt *alt);  ; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:10494,hash,hash,10494,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"nt (const char *comment);  Add comment line on the top of the xml document This line can only be seen in xml editor and cannot be accessed later with TXMLFile methods. ;  ; Bool_t AddXmlLine (const char *line);  Add just one line on the top of xml document For instance, line can contain special xml processing instructions Line should has correct xml syntax that later it can be decoded by xml parser To be parsed later by TXMLFile again, this line should contain either xml comments or xml processing instruction. ;  ; Bool_t AddXmlStyleSheet (const char *href, const char *type=""text/css"", const char *title=nullptr, int alternate=-1, const char *media=nullptr, const char *charset=nullptr);  Adds style sheet definition on the top of xml document Creates <?xml-stylesheet alternate=""yes"" title=""compact"" href=""small-base.css"" type=""text/css""?> Attributes href and type must be supplied, other attributes: title, alternate, media, charset are optional if alternate==0, attribute alternate=""no"" will be created, if alternate>0, attribute alternate=""yes"" if alternate<0, attribute will not be created This style sheet definition cannot be later access with TXMLFile methods. ;  ; void Close (Option_t *option="""") final;  Close a XML file For more comments see TFile::Close() function. ;  ; TKey * CreateKey (TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize) final;  create XML key, which will store object in xml structures ;  ; TKey * CreateKey (TDirectory *mother, const void *obj, const TClass *cl, const char *name, Int_t bufsize) final;  create XML key, which will store object in xml structures ;  ; void DrawMap (const char *=""*"", Option_t *="""") final;  Draw map of objects in this file. ;  ; void FillBuffer (char *&) final;  Encode file output buffer. ;  ; void Flush () final;  Synchronize a file's in-memory and on-disk states. ;  ; Long64_t GetEND () const final;  ; Int_t GetErrno () const final;  Method returning errno. ;  ; Int_t GetIOVersion () const;  ; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:1901,access,access,1901,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['access']
Security,"nt boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:35024,access,access,35024,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,2,['access'],['access']
Security,"nt boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:34910,access,access,34910,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,4,['access'],['access']
Security,"nt solution goes for the minimal configuration. The original request for this update was posted here.; 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class; When command is registered with THttpServer::RegisterCommand() method, one could configure additional arguments which should be submitted when command is executed with cmd.json requests; Introduce restriction rules for objects access with THttpServer::Restrict() method. Up to now general read-only flag was applied - either everything read-only or everything is fully accessible. Now one could restrict access to different parts of objects hierarchy or even fully ‘hide’ them from the client. Restriction based on user account name, which is applied when htdigest authentication is configured. One also able to allow execution of selected methods.; Implement multi.bin and multi.json requests. One could request many items with single HTTP request. Let optimize communication between server and client.; With SNIFF tag in ClassDef() comments one could expose different properties, which than exposed by the TRootSniffer to the client with h.json requests. Such possibility ease implementation of client-side code for custom classes.; Allow to bind http port with loopback address. This restrict access to http server only from localhost. One could either specify ‘loopback’ option in constructor: new THttpServer(“http:8080?loopback”) or in clear text specify IP address to which http socket should be bind: new THttpServer(“http:127.0.0.1:8080”) If host has several network interfaces, one could select one for binding: new THttpServer(“http:192.168.1.17:8080”); TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:19028,authenticat,authentication,19028,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['authenticat'],['authentication']
Security,"nt the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& b); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2); Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot *frame, const RooAbsArg &par1, const RooAbsArg &par2,			 const char *options= ""ME""); Add objects to a 2D plot. void setMinNLL(Double_t val); { _minNLL = val ; }. void setEDM(Double_t val); { _edm = val ; }. void setStatus(Int_t val); { _status = val ; }. void setCovQual(Int_t val); { _covQual = val ; }. void setNumInvalidNLL(Int_t val); { _numBadNLL=val ; }. » Last changed: Mon Dec 7 13:47:38 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:16861,access,accessors,16861,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,1,['access'],['accessors']
Security,"nt! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:34795,access,access,34795,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,3,['access'],['access']
Security,"nt, returns 0 in case extension is not supported and returns -1 in case of error (like server not initialized). ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:30051,hash,hash,30051,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['hash'],['hash']
Security,"nt::kSTLunorderedmultiset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLunorderedset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLvector; static TObject::(anonymous)TObject::kSingleKey; static TStreamerElement::(anonymous)TStreamerElement::kWholeObject; static TStreamerElement::(anonymous)TStreamerElement::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; ClassConvStreamerFunc_tfConvStreamerFunc!Pointer to a wrapper around a custom convertion streamer member function.; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo for the baset class.; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerBase.html:10380,checksum,checksum,10380,root/html604/TStreamerBase.html,https://root.cern,https://root.cern/root/html604/TStreamerBase.html,1,['checksum'],['checksum']
Security,"ntEncoding, Cache-Control and so on ; Definition at line 55 of file THttpCallArg.h. ◆ fMethod. TString THttpCallArg::fMethod. protected . ! request method like GET or POST ; Definition at line 43 of file THttpCallArg.h. ◆ fNotifyFlag. Bool_t THttpCallArg::fNotifyFlag {kFALSE}. protected . ! indicate that notification called ; Definition at line 58 of file THttpCallArg.h. ◆ fPathName. TString THttpCallArg::fPathName. protected . ! item path ; Definition at line 44 of file THttpCallArg.h. ◆ fPostData. std::string THttpCallArg::fPostData. private . ! data received with post request - text - or binary ; Definition at line 68 of file THttpCallArg.h. ◆ fQuery. TString THttpCallArg::fQuery. protected . ! additional arguments ; Definition at line 47 of file THttpCallArg.h. ◆ fRequestHeader. TString THttpCallArg::fRequestHeader. protected . ! complete header, provided with request ; Definition at line 54 of file THttpCallArg.h. ◆ fTopName. TString THttpCallArg::fTopName. protected . ! top item name ; Definition at line 42 of file THttpCallArg.h. ◆ fUserName. TString THttpCallArg::fUserName. protected . ! authenticated user name (if any) ; Definition at line 46 of file THttpCallArg.h. ◆ fWSEngine. std::shared_ptr<THttpWSEngine> THttpCallArg::fWSEngine. private . ! web-socket engine, which supplied to run created web socket ; Definition at line 65 of file THttpCallArg.h. ◆ fWSId. UInt_t THttpCallArg::fWSId {0}. protected . ! websocket identifier, used in web-socket related operations ; Definition at line 49 of file THttpCallArg.h. ◆ fZipping. Int_t THttpCallArg::fZipping {kNoZip}. protected . ! indicate if and when content should be compressed ; Definition at line 56 of file THttpCallArg.h. Libraries for THttpCallArg:. [legend]; The documentation for this class was generated from the following files:; net/http/inc/THttpCallArg.h; net/http/src/THttpCallArg.cxx. THttpCallArg. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpCallArg.html:34534,authenticat,authenticated,34534,doc/master/classTHttpCallArg.html,https://root.cern,https://root.cern/doc/master/classTHttpCallArg.html,1,['authenticat'],['authenticated']
Security,"ntVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11738,access,access,11738,root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,5,['access'],['access']
Security,"nt_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPointSet3D.html:8072,hash,hash,8072,doc/master/classTPointSet3D.html,https://root.cern,https://root.cern/doc/master/classTPointSet3D.html,2,['hash'],['hash']
Security,"nt_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [options] = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1432 of file TSocket.cxx. ◆ DeclFileName(). static const char * TSocket::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TSocket.h. ◆ GetBytesRecv(). UInt_t TSocket::GetBytesRecv ; (; ); const. inline . Definition at line 120 of file TSocket.h. ◆ GetBytesSent(). UInt_t TSocket::GetBytesSent ; (; ); const. inline . Definition at line 119 of file TSocket.h. ◆ GetClientProtocol(). Int_t TSocket::GetClientProtocol ; (; ). static . Static method returning supported client protocol. ; Definition at line 1469 of file TSocket.cxx. ◆ GetCompressionAlgorithm(). Int_t TSocket::GetCompressionAlgorithm ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:25940,authenticat,authentication,25940,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authentication']
Security,"nt_t Children;; Int_t Grade;; Int_t Step;; Int_t Hrweek;; Int_t Cost;; Char_t Division[4];; Char_t Nation[3];; ; //The input file cern.dat is a copy of the CERN staff data base; //from 1988; TString filename = ""cernstaff.root"";; TString dir = gROOT->GetTutorialDir();; dir.Append(""/tree/"");; dir.ReplaceAll(""/./"",""/"");; FILE *fp = fopen(Form(""%scernstaff.dat"",dir.Data()),""r"");; ; TFile *hfile = 0;; if (getFile) {; // if the argument getFile =1 return the file ""cernstaff.root""; // if the file does not exist, it is created; if (!gSystem->AccessPathName(dir+""cernstaff.root"",kFileExists)) {; hfile = TFile::Open(dir+""cernstaff.root""); //in $ROOTSYS/tutorials/tree; if (hfile) return hfile;; }; //otherwise try $PWD/cernstaff.root; if (!gSystem->AccessPathName(""cernstaff.root"",kFileExists)) {; hfile = TFile::Open(""cernstaff.root""); //in current dir; if (hfile) return hfile;; }; }; //no cernstaff.root file found. Must generate it !; //generate cernstaff.root in $ROOTSYS/tutorials/tree if we have write access; if (gSystem->AccessPathName(""."",kWritePermission)) {; printf(""you must run the script in a directory with write access\n"");; return 0;; }; hfile = TFile::Open(filename,""RECREATE"");; TTree *tree = new TTree(""T"",""CERN 1988 staff data"");; tree->Branch(""Category"",&Category,""Category/I"");; tree->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; if (print) tree->Print();; tree->Write();; ; fclose(fp);; delete hfile;; if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/cernbuild_8C.html:1410,access,access,1410,doc/master/cernbuild_8C.html,https://root.cern,https://root.cern/doc/master/cernbuild_8C.html,1,['access'],['access']
Security,"nt_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outputDsi; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void PrintTransformation(ostream& ); {}. const std::vector<TMVA::Variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariableTransformBase.html:11651,access,accessors,11651,root/html602/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html602/TMVA__VariableTransformBase.html,2,['access'],['accessors']
Security,"nt_t event, Int_t px, Int_t py)TObjectvirtual; fAllRulesROOT::Detail::TSchemaRuleSetprivate; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fCheckSumROOT::Detail::TSchemaRuleSetprivate; fClassROOT::Detail::TSchemaRuleSetprivate; fClassNameROOT::Detail::TSchemaRuleSetprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindRules(const TString &source) constROOT::Detail::TSchemaRuleSet; FindRules(const TString &source, Int_t version) constROOT::Detail::TSchemaRuleSet; FindRules(const TString &source, UInt_t checksum) constROOT::Detail::TSchemaRuleSet; FindRules(const TString &source, Int_t version, UInt_t checksum) constROOT::Detail::TSchemaRuleSet; fPersistentRulesROOT::Detail::TSchemaRuleSetprivate; fRemainingRulesROOT::Detail::TSchemaRuleSetprivate; fUniqueIDTObjectprivate; fVersionROOT::Detail::TSchemaRuleSetprivate; GetClass()ROOT::Detail::TSchemaRuleSet; GetClassCheckSum() constROOT::Detail::TSchemaRuleSet; GetClassName() constROOT::Detail::TSchemaRuleSet; GetClassVersion() constROOT::Detail::TSchemaRuleSet; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetName() constTObjectvirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPersistentRules() constROOT::Detail::TSchemaRuleSet; GetRules() constROOT::Detail::TSchemaRuleSet; GetTitle() constTObjectvirtual; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() constTObjectvirtual; HasInconsistentHash() constTObjectinline; HasRuleWithSourceClass(const TString &source) constROOT::Detail::TSchemaRuleSet; Info(const char *method, const char *msgfmt,...) constTObjectvirtual; InheritsFrom(const char *classname) constTObjectvirtual; InheritsFrom(const TClass *cl) constTObjectvirtual; Inspect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet-members.html:2605,checksum,checksum,2605,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet-members.html,2,['checksum'],['checksum']
Security,"nt_t oldsize = fNClusterRange;; 6427 for(Int_t i = 0, j = 0; j < oldsize; ++j) {; 6428 if (fClusterRangeEnd[j] > entriesOffset) {; 6429 fClusterRangeEnd[i] = fClusterRangeEnd[j] - entriesOffset;; 6430 ++i;; 6431 } else {; 6432 --fNClusterRange;; 6433 }; 6434 }; 6435 }; 6436 fEntries = maxEntries;; 6437 fReadEntry = -1;; 6438}; 6439 ; 6440////////////////////////////////////////////////////////////////////////////////; 6441/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; 6442///; 6443/// If maxmemory is non null and positive SetMaxVirtualSize is called; 6444/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:252186,access,access,252186,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"nt_tTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude poly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLH2PolyPainter.html:4679,validat,validated,4679,root/html532/TGLH2PolyPainter.html,https://root.cern,https://root.cern/root/html532/TGLH2PolyPainter.html,2,['validat'],['validated']
Security,"nt_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. Int_t entries() const; { return _entries ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by method chosen in constructor. » Last changed: Sat Jun 20 16:42:25 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHashTable.html:7187,hash,hash,7187,root/html534/RooHashTable.html,https://root.cern,https://root.cern/root/html534/RooHashTable.html,4,['hash'],"['hash', 'hashArg']"
Security,"nt_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. Int_t entries() const; { return _entries ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by method chosen in constructor. » Last changed: Sat Jun 20 17:30:14 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooHashTable.html:7719,hash,hash,7719,root/html604/RooHashTable.html,https://root.cern,https://root.cern/root/html604/RooHashTable.html,4,['hash'],"['hash', 'hashArg']"
Security,"nt_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. Int_t entries() const; { return _entries ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by method chosen in constructor. » Last changed: Tue Jun 30 14:33:24 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHashTable.html:7719,hash,hash,7719,root/html602/RooHashTable.html,https://root.cern,https://root.cern/root/html602/RooHashTable.html,4,['hash'],"['hash', 'hashArg']"
Security,"ntag, const char* monid, const char* monsubid, const char* option); TMonaLisaWriter&operator=(const TMonaLisaWriter&); Bool_tSendFileCheckpoint(TFile* file). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. ApMon*fApmon! connection to MonaLisa; TStopwatchfFileStopwatchtime measurements for data access throughputs; TStringfHostname! hostname of MonaLisa server; Bool_tfInitializedtrue if initialized; TStringfJobId! job id; Double_tfLastFCloseSendTimeIn order not to flood ML servers; time_tfLastProgressTimetimestamp of the last send command for player process; Double_tfLastRWSendTimetimestamp of the last send command for file reads/writes; map<UInt_t,MonitoredTFileInfo*>*fMonInfoRepo! repo to gather per-file-instance mon info;; Int_tfPid! process id; Int_tfReportIntervalinterval after which to send the latest value; TStopwatchfStopwatchcpu and time measurement for job and proc status; TStringfSubJobId! sub job id; Bool_tfVerboseverbocity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); Create MonaLisa write object. void Init(const char* monserver, const char* montag, const char* monid, const char* monsubid, const char* option); Creates a TMonaLisaWriter object to send monitoring information to a; MonaLisa server using the MonaLisa ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:8413,access,access,8413,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['access'],['access']
Security,"ntains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsFolder (void *obj) const;  Return kTRUE if the class has elements. ;  ; Bool_t IsForeign () const;  Return kTRUE is the class is Foreign (the class does not have a Streamer method). ;  ; Bool_t IsLoaded () const;  Return true if the shared library of this class is currently in the a process's memory. ;  ; Bool_t IsStartingWithTObject () const;  Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ;  ; Bool_t IsSyntheticPair () const;  ; Bool_t IsTObject () const;  Return kTRUE is the class inherits from TObject. ;  ; Bool_t IsVersioned () const;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:19599,checksum,checksum,19599,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,12,['checksum'],['checksum']
Security,"ntation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example for the training and testing of the TMVA; 5/// multiclass classification; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Root Macro: TMVAMulticlass; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <iostream>; 16#include <map>; 17#include <string>; 18 ; 19#include ""TFile.h""; 20#include ""TTree.h""; 21#include ""TString.h""; 22#include ""TSystem.h""; 23#include ""TROOT.h""; 24 ; 25 ; 26#include ""TMVA/Tools.h""; 27#include ""TMVA/Factory.h""; 28#include ""TMVA/DataLoader.h""; 29#include ""TMVA/TMVAMultiClassGui.h""; 30 ; 31 ; 32using namespace TMVA;; 33 ; 34void TMVAMulticlass( TString myMethodList = """" ); 35{; 36 ; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // to get access to the GUI and all tmva macros; 41 //; 42 // TString tmva_dir(TString(gRootDir) + ""/tmva"");; 43 // if(gSystem->Getenv(""TMVASYS"")); 44 // tmva_dir = TString(gSystem->Getenv(""TMVASYS""));; 45 // gROOT->SetMacroPath(tmva_dir + ""/test/:"" + gROOT->GetMacroPath() );; 46 // gROOT->ProcessLine("".L TMVAMultiClassGui.C"");; 47 ; 48 ; 49 //---------------------------------------------------------------; 50 // Default MVA methods to be trained + tested; 51 std::map<std::string,int> Use;; 52 Use[""MLP""] = 1;; 53 Use[""BDTG""] = 1;; 54#ifdef R__HAS_TMVAGPU; 55 Use[""DL_CPU""] = 1;; 56 Use[""DL_GPU""] = 1;; 57#else; 58 Use[""DL_CPU""] = 1;; 59 Use[""DL_GPU""] = 0;; 60#endif; 61 Use[""FDA_GA""] = 0;; 62 Use[""PDEFoam""] = 1;; 63 ; 64 //---------------------------------------------------------------; 65 ; 66 std::cout << std::endl;; 67 std::cout << ""==> Start TMVAMulticlass"" << std::endl;; 68 ; 69 if (myMethodList != """") {; 70 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 71 ; 72 std::vector<TString> mlist = TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:1112,access,access,1112,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,1,['access'],['access']
Security,"ntation. ◆ TWinNTSystem(). TWinNTSystem::TWinNTSystem ; (; ). ctor ; Definition at line 985 of file TWinNTSystem.cxx. ◆ ~TWinNTSystem(). TWinNTSystem::~TWinNTSystem ; (; ). virtual . dtor ; Definition at line 1048 of file TWinNTSystem.cxx. Member Function Documentation. ◆ Abort(). void TWinNTSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 3949 of file TWinNTSystem.cxx. ◆ AcceptConnection(). int TWinNTSystem::AcceptConnection ; (; int ; socket). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 5525 of file TWinNTSystem.cxx. ◆ AccessPathName(). Bool_t TWinNTSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the WinNT access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 2557 of file TWinNTSystem.cxx. ◆ AddDynamicPath(). void TWinNTSystem::AddDynamicPath ; (; const char * ; dir). overridevirtual . Add a new directory to the dynamic path. ; Reimplemented from TSystem.; Definition at line 4077 of file TWinNTSystem.cxx. ◆ AddFileHandler(). void TWinNTSystem::AddFileHandler ; (; TFileHandler * ; h). overridevirtual . Add a file handler to the list of system file handlers. ; Only adds the handler if it is not already in the list of file handlers. ; Reimplemented from TSystem.; Definition at line 1335 of file TWinNTSystem.cxx. ◆ AddSignalHandler(). void TWinNTSystem::AddSignalHandler ; (; TSignalHandler * ; h). overridevirtual . Add a signal handler to list of system signal handlers. ; Only adds the handler if it is not already in the list of signal handlers. ; Reimplemented from TSystem.; Definition at line 1371 of file TWinNTSystem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:37903,access,access,37903,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['access'],['access']
Security,"nted in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 72 of file THashList.h. ◆ operator=(). THashList & THashList::operator= ; (; const THashList & ; ). privatedelete . ◆ RecursiveRemove(). void THashList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 310 of file THashList.cxx. ◆ Rehash(). void THashList::Rehash ; (; Int_t ; newCapacity). Rehash the hashlist. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 378 of file THashList.cxx. ◆ Remove() [2/2]. TObject * THashList::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:31952,hash,hashlist,31952,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashlist']
Security,"nteger values for parameter npar. Bool_t SetVUInt(Int_t npar, const vector<UInt_t> value, const char* schemaName, const char* typeName); Set vector of unsigned integer values for parameter npar. Bool_t SetVLong(Int_t npar, const vector<Long_t> value, const char* schemaName, const char* typeName); Set vector of long integer values for parameter npar. Bool_t SetVLong64(Int_t npar, const vector<Long64_t> value, const char* schemaName, const char* typeName); Set vector of 64-bit integer values for parameter npar. Bool_t SetVULong64(Int_t npar, const vector<ULong64_t> value, const char* schemaName, const char* typeName); Set vector of unsigned 64-bit integer values for parameter npar. Bool_t SetVDouble(Int_t npar, const vector<Double_t> value, const char* schemaName, const char* typeName); Set vector of double values for parameter npar. Bool_t NextIteration(); Add next iteration for statement with parameters. Bool_t StoreResult(); Store result of statement processing.; Required to access results of SELECT queries. Bool_t SetMaxFieldSize(Int_t nfield, Long_t maxsize); Defines maximum size for field which must be used for read or write operation; Some Oracle types as LONG (long binary continer) requires this call; before any data can be read from database. Call it once before first call to NextResultRow(). Int_t GetNumFields(); Returns number of fields in result set. const char* GetFieldName(Int_t nfield); Return field name in result set. Bool_t NextResultRow(); Move cursor to next row in result set.; For Oracle it may lead to additional request to database. Bool_t IsNull(Int_t ); Checks if fieled value in result set is NULL. Int_t GetInt(Int_t npar); return field value as integer. UInt_t GetUInt(Int_t npar); return field value as unsigned integer. Long_t GetLong(Int_t npar); return field value as long integer. Long64_t GetLong64(Int_t npar); return field value as 64-bit integer. ULong64_t GetULong64(Int_t npar); return field value as unsigned 64-bit integer. Double_t GetDo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleStatement.html:13132,access,access,13132,root/html528/TOracleStatement.html,https://root.cern,https://root.cern/root/html528/TOracleStatement.html,1,['access'],['access']
Security,"ntegration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components with cache-and-track. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sat Sep 5 16:39:52 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:51607,access,access,51607,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,1,['access'],['access']
Security,"ntents. ; Indentation is used to identify the file tree. Subdirectories are listed first, then objects in memory, then objects on the file. ; Reimplemented from TDirectoryFile.; Definition at line 1457 of file TFile.cxx. ◆ MakeFree(). void TFile::MakeFree ; (; Long64_t ; first, . Long64_t ; last . ). virtual . Mark unused bytes on the file. ; The list of free segments is in the fFree linked list. When an object is deleted from the file, the freed space is added into the FREE linked list (fFree). The FREE list consists of a chain of consecutive free segments on the file. At the same time, the first 4 bytes of the freed record on the file are overwritten by GAPSIZE where GAPSIZE = -(Number of bytes occupied by the record). ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1484 of file TFile.cxx. ◆ MakeProject(). void TFile::MakeProject ; (; const char * ; dirname, . const char * ; classes = ""*"", . Option_t * ; option = ""new"" . ). virtual . Generate source code necessary to access the objects stored in the file. ; Generate code in directory dirname for all classes specified in argument classes If classes = ""*"" (default and currently the only supported value), the function generates an include file for each class in the StreamerInfo list for which a TClass object does not exist.; The code generated includes:; dirnameProjectHeaders.h, which contains one #include statement per generated header file; dirnameProjectSource.cxx,which contains all the constructors and destructors implementation. and one header per class that is not nested inside another class. The header file name is the fully qualified name of the class after all the special characters ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class are replaced by a vector of pair. set and multiset when the tempalte parameter is a class are replaced by a vec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:74281,access,access,74281,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"nterface for the documentation of the methods available. ; Definition at line 1630 of file RDataFrame.cxx. ◆ RDataFrame() [6/10]. ROOT::RDataFrame::RDataFrame ; (; ULong64_t ; numEntries). Build a dataframe that generates numEntries entries. ; Parameters. [in]numEntriesThe number of entries to generate. An empty-source dataframe constructed with a number of entries will generate those entries on the fly when some action is triggered, and it will do so for all the previously-defined columns. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1643 of file RDataFrame.cxx. ◆ RDataFrame() [7/10]. ROOT::RDataFrame::RDataFrame ; (; std::unique_ptr< ROOT::RDF::RDataSource > ; ds, . const ColumnNames_t & ; defaultColumns = {} . ). Build dataframe associated to data source. ; Parameters. [in]dsThe data source object. ; [in]defaultColumnsCollection of default column names to fall back to when none is specified. A dataframe associated to a data source will query it to access column values. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1656 of file RDataFrame.cxx. ◆ RDataFrame() [8/10]. ROOT::RDataFrame::RDataFrame ; (; ROOT::RDF::Experimental::RDatasetSpec ; spec). Build dataframe from an RDatasetSpec object. ; Parameters. [in]specThe dataset specification object. A dataset specification includes trees and file names, as well as an optional friend list and/or entry range. Example usage from Python:; spec = (; ROOT.RDF.Experimental.RDatasetSpec(); .AddSample((""data"", ""tree"", ""file.root"")); .WithGlobalFriends(""friendTree"", ""friend.root"", ""alias""); .WithGlobalRange((100, 200)); ); df = ROOT.RDataFrame(spec); ROOT::RDF::Experimental::RDatasetSpecThe dataset specification for RDataFrame.Definition RDatasetSpec.hxx:47; See also ROOT::RDataFrame::FromSpec(). ; Definition at line 1680 of file RDataFrame.cxx. ◆ RDataFrame() [9/10]. ROOT::RDataFrame::RDataFrame ; (; const RDataFrame & ; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:109670,access,access,109670,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"nterface for the documentation of the methods available. ; Definition at line 1807 of file RDataFrame.cxx. ◆ RDataFrame() [6/10]. ROOT::RDataFrame::RDataFrame ; (; ULong64_t ; numEntries). Build a dataframe that generates numEntries entries. ; Parameters. [in]numEntriesThe number of entries to generate. An empty-source dataframe constructed with a number of entries will generate those entries on the fly when some action is triggered, and it will do so for all the previously-defined columns. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1820 of file RDataFrame.cxx. ◆ RDataFrame() [7/10]. ROOT::RDataFrame::RDataFrame ; (; std::unique_ptr< ROOT::RDF::RDataSource > ; ds, . const ColumnNames_t & ; defaultColumns = {} . ). Build dataframe associated to data source. ; Parameters. [in]dsThe data source object. ; [in]defaultColumnsCollection of default column names to fall back to when none is specified. A dataframe associated to a data source will query it to access column values. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1833 of file RDataFrame.cxx. ◆ RDataFrame() [8/10]. ROOT::RDataFrame::RDataFrame ; (; ROOT::RDF::Experimental::RDatasetSpec ; spec). Build dataframe from an RDatasetSpec object. ; Parameters. [in]specThe dataset specification object. A dataset specification includes trees and file names, as well as an optional friend list and/or entry range. Example usage from Python:; spec = (; ROOT.RDF.Experimental.RDatasetSpec(); .AddSample((""data"", ""tree"", ""file.root"")); .WithGlobalFriends(""friendTree"", ""friend.root"", ""alias""); .WithGlobalRange((100, 200)); ); df = ROOT.RDataFrame(spec); ROOT::RDF::Experimental::RDatasetSpecThe dataset specification for RDataFrame.Definition RDatasetSpec.hxx:47; See also ROOT::RDataFrame::FromSpec(). ; Definition at line 1857 of file RDataFrame.cxx. ◆ RDataFrame() [9/10]. ROOT::RDataFrame::RDataFrame ; (; const RDataFrame & ; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:117037,access,access,117037,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"nterface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:6378,access,access,6378,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"nterface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html:5858,access,access,5858,root/html526/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"nterface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html:5728,access,access,5728,root/html526/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"nternal condition variable ; Definition at line 287 of file TReentrantRWLock.hxx. ◆ fMutex. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . MutexT ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fMutex. private . ! RWlock internal mutex ; Definition at line 286 of file TReentrantRWLock.hxx. ◆ fReaderReservation. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fReaderReservation. private . ! A reader wants access ; Definition at line 283 of file TReentrantRWLock.hxx. ◆ fReaders. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fReaders. private . ! Number of readers ; Definition at line 282 of file TReentrantRWLock.hxx. ◆ fRecurseCounts. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . RecurseCountsT ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fRecurseCounts. private . ! Trackers for re-entry in the lock by the same thread. ; Definition at line 289 of file TReentrantRWLock.hxx. ◆ fWriter. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<bool> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fWriter. private . ! Is there a writer? ; Definition at line 285 of file TReentrantRWLock.hxx. ◆ fWriterReservation. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . std::atomic<int> ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::fWriterReservation. private . ! A writer wants access ; Definition at line 284 of file TReentrantRWLock.hxx. core/thread/src/TReentrantRWLock.hxx; core/thread/src/TReentrantRWLock.cxx. ROOTTReentrantRWLock. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TReentrantRWLock.html:7105,access,access,7105,doc/master/classROOT_1_1TReentrantRWLock.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TReentrantRWLock.html,1,['access'],['access']
Security,"ntext. ;  ; void setVerbose (bool verbose=true);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimSplitGenContext.html:3742,hash,hash,3742,doc/master/classRooSimSplitGenContext.html,https://root.cern,https://root.cern/doc/master/classRooSimSplitGenContext.html,2,['hash'],['hash']
Security,"ntified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:53920,access,access,53920,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,2,['access'],['access']
Security,"ntless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:454817,access,access,454817,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:454850,access,access,454850,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"nto this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TFunctionTemplate *func);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:3797,hash,hashlist,3797,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['hash'],['hashlist']
Security,"ntries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:279408,access,access,279408,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ntries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:279440,access,access,279440,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"ntrol variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768513,access,access,768513,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ntryList is owned by the TChain and gets deleted when the chain is deleted. This TEntryList is returned by GetEntryList() function, and after GetEntryList() function is called, the TEntryList is not owned by the chain any more and will not be deleted with it. ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 2868 of file TChain.cxx. ◆ SetMakeClass(). void TChain::SetMakeClass ; (; Int_t ; make). inlineoverridevirtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented from TTree.; Definition at line 166 of file TChain.h. ◆ SetName(). void TChain::SetName ; (; const char * ; name). overridevirtual . Change the name of this TChain. ; Reimplemented from TNamed.; Reimplemented in TProofChain.; Definition at line 2943 of file TChain.cxx. ◆ SetPacketSize(). void TChain::SetPacketSize ; (; Int_t ; size = 100). virtual . Set number of entries per packet for parallel root. ; Definition at line 2965 of file TChain.cxx. ◆ SetProof(). void TChain::SetProof ; (; bool ; on = true, . bool ; refresh = false, . bool ; gettreeheader = false . ). virtual . Enable/Disable PROOF processing on the current default Proof (gProof). ; ""Draw"" and ""Processed"" commands will be handled by PROOF. The refresh and gettreeheader are meaningful only if on == true. If refresh is true the underlying fProofChain (chain proxy) is always rebuilt (even if already existing). If g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:101147,access,access,101147,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['access'],['access']
Security,"ntryList is owned by the TChain and gets deleted when the chain is deleted. This TEntryList is returned by GetEntryList() function, and after GetEntryList() function is called, the TEntryList is not owned by the chain any more and will not be deleted with it. ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 2894 of file TChain.cxx. ◆ SetMakeClass(). void TChain::SetMakeClass ; (; Int_t ; make). inlineoverridevirtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented from TTree.; Definition at line 166 of file TChain.h. ◆ SetName(). void TChain::SetName ; (; const char * ; name). overridevirtual . Change the name of this TChain. ; Reimplemented from TNamed.; Reimplemented in TProofChain.; Definition at line 2969 of file TChain.cxx. ◆ SetPacketSize(). void TChain::SetPacketSize ; (; Int_t ; size = 100). virtual . Set number of entries per packet for parallel root. ; Definition at line 2991 of file TChain.cxx. ◆ SetProof(). void TChain::SetProof ; (; bool ; on = true, . bool ; refresh = false, . bool ; gettreeheader = false . ). virtual . Enable/Disable PROOF processing on the current default Proof (gProof). ; ""Draw"" and ""Processed"" commands will be handled by PROOF. The refresh and gettreeheader are meaningful only if on == true. If refresh is true the underlying fProofChain (chain proxy) is always rebuilt (even if already existing). If g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:101768,access,access,101768,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['access'],['access']
Security,"nts in each bin is much smaller than the total number of events in each template (so that multinomial uncertainties can be replaced with Poisson uncertainties).; Biased fit uncertainties may result if these conditions are not fulfilled (see e.g. arXiv:0803.2711). Instantiation; A fit object is instantiated through TFractionFitter* fit = new TFractionFitter(data, mc); A number of basic checks (intended to ensure that the template histograms represent the same ""kind"" of distribution as the data one) are carried out. The TVirtualFitter object is then addressed and all fit parameters (the template fractions) declared (initially unbounded). Applying constraints; Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit); however, a function fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values; The function ROOT::Fit::Fitter* fitter = fit->GetFitter();; is provided for direct access to the ROOT::Fit::Fitter object. This allows to set and fix parameter values, limits and set step sizes directly via fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);; ; Restricting the fit range; The fit range can be restricted through fit->SetRangeX(first bin #, last bin #);; and freed using fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering. Any bins excluded in this way can be included again using the corresponding fit->IncludeBin(bin #);; ; Weights histograms; Weights histograms (for a motivation see the abov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:4231,access,access,4231,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['access'],['access']
Security,"nts.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returnin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12793,secur,secure,12793,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,14,"['password', 'secur']","['password', 'secure']"
Security,"nts: 0.877 sec ; BDT : [dataset] : Evaluation of BDT on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0172 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_BDT.class.C␛[0m; : TMVA_CNN_ClassificationOutput.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: TMVA_DNN_CPU for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 8 Input = ( 1, 1, 256 ) Batch size = 100 Loss function = C; Layer 0 DENSE Layer: ( Input = 256 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 1 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 2 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 3 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 4 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 5 BATCH NORM Layer: Input/Output = ( 100 , 100 , 1 ) Norm dim = 100 axis = -1; ; Layer 6 DENSE Layer: ( Input = 100 , Width = 100 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 7 DENSE Layer: ( Input = 100 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 1280 events for training and 320 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 119.005; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:11166,validat,validation,11166,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,ntsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; TIterator*_catIter! Iterator over set of input categories; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxy,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:24263,access,access,24263,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['access'],['access']
Security,"ntzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:12778,access,access,12778,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,2,['access'],"['access', 'accessors']"
Security,"ntzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:12778,access,access,12778,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,2,['access'],"['access', 'accessors']"
Security,"nuit instance ;  ; void RetrieveErrorMatrix ();  retrieve error matrix from TMinuit ;  ; void RetrieveParams ();  retrieve minimum parameters and errors from TMinuit ;  . Static Protected Member Functions; static void Fcn (int &, double *, double &f, double *, int);  implementation of FCN for Minuit ;  ; static void FcnGrad (int &, double *g, double &f, double *, int);  implementation of FCN for Minuit when user provided gradient is used ;  . Private Attributes; std::vector< double > fCovar;  ; unsigned int fDim;  ; std::vector< double > fErrors;  ; bool fMinosRun;  ; int fMinosStatus = -1;  ; TMinuit * fMinuit;  ; std::vector< double > fParams;  ; ROOT::Minuit::EMinimizerType fType;  ; bool fUsed;  . Static Private Attributes; static TMinuit * fgMinuit = nullptr;  ; static bool fgUsed = false;  ; static bool fgUseStaticMinuit = true;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <TMinuitMinimizer.h>. Inheritance diagram for TMinuitMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TMinuitMinimizer() [1/2]. TMinuitMinimizer::TMinuitMinimizer ; (; ROOT::Minuit::EMinimizerType ; type = ROOT::Minuit::kMigrad, . unsigned int ; ndim = 0 . ). Default constructor. ; Definition at line 57 of file TMinuitMinimizer.cxx. ◆ TMinuitMinimizer() [2/2]. TMinuitMinimizer::TMinuitMinimizer ; (; const char * ; type, . unsigned int ; ndim = 0 . ). Constructor from a char * (used by PM) ; Definition at line 73 of file TMinuitMinimizer.cxx. ◆ ~TMinuitMinimizer(). TMinuitMinimizer::~TMinuitMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 101 of file TMinuitMinimizer.cxx. Member Function Documentation.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuitMinimizer.html:11944,validat,validated,11944,doc/master/classTMinuitMinimizer.html,https://root.cern,https://root.cern/doc/master/classTMinuitMinimizer.html,1,['validat'],['validated']
Security,"nuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Print();; }; }; c#define c(i)Definition RSha256.hxx:101; RooAbsPdf.h; RooDataSet.h; RooGaussian.h; RooMomentMorphFuncND.h; RooPlot.h; RooRealVar.h; RooUniform.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Construct representation of -log(L) of PDF with given dataset.Definition RooAbsPdf.h:163; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf616__morphing_8C.html:5909,access,access,5909,doc/master/rf616__morphing_8C.html,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html,1,['access'],['access']
Security,"null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Fri Dec 2 14:26:52 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:9770,hash,hash,9770,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,1,['hash'],['hash']
Security,"numerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902 md5Enumeration.Append(""::"");; 903 md5Enumeration.Append(enumeration);; 904 md5Enumeration.Append(enumeration);; 905 // We make the URL for the scope ""scopeName"".; 906 TString url(UrlGenerator(scopeName, scopeType));; 907 // Then we have to append ""#a"" and the hashed text.; 908 url.Append(""#a"");; 909 url.Append(md5Enumeration.MD5());; 910 return url;; 911}; 912} // namespace; 913 ; 914namespace {; 915enum EMethodKind { kURLforMethod, kURLforStructor };; 916////////////////////////////////////////////////////////////////////////////////; 917/// The function generates URL for any member function (including Constructor/; 918/// Destructor) of ""scopeName"". Doxygen first generates the URL for the scope.; 919/// We do that with the help of ""UrlGenerator"". Then we append ""#a"" and a; 920/// hashed with MD5 text. It consists of:; 921/// ""ReturnType ScopeName::MethodNameMethodName(Method arguments)"".; 922/// For constructor/destructor of a class, the return type is not appended.; 923///; 924/// \param[in] scopeName the name of the class/namespace/struct; 925/// \param[in] methodName the name of the method from the scope; 926/// \param[in] func pointer to the method; 927/// \param[in] methodType enumerator for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:34167,hash,hashed,34167,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security,"numeratorPROTOCOL_TYPE_HTTP1 ; PROTOCOL_TYPE_WEBSOCKET ; PROTOCOL_TYPE_HTTP2 . Definition at line 2428 of file civetweb.c. Function Documentation. ◆ abort_cgi_process(). static int abort_cgi_process ; (; void * ; data). static . Definition at line 11243 of file civetweb.c. ◆ accept_new_connection(). static void accept_new_connection ; (; const struct socket * ; listener, . struct mg_context * ; ctx . ). static . Definition at line 19105 of file civetweb.c. ◆ addenv(). static void addenv ; (; struct cgi_environment * ; env, . const char * ; fmt, .  ; ... . ). static . Definition at line 10975 of file civetweb.c. ◆ alloc_vprintf(). static int alloc_vprintf ; (; char ** ; out_buf, . char * ; prealloc_buf, . size_t ; prealloc_size, . const char * ; fmt, . va_list ; ap . ). static . Definition at line 6855 of file civetweb.c. ◆ alloc_vprintf2(). static int alloc_vprintf2 ; (; char ** ; buf, . const char * ; fmt, . va_list ; ap . ). static . Definition at line 6822 of file civetweb.c. ◆ authorize(). static int authorize ; (; struct mg_connection * ; conn, . struct mg_file * ; filep, . const char * ; realm . ). static . Definition at line 8615 of file civetweb.c. ◆ bin2str(). static void bin2str ; (; char * ; to, . const unsigned char * ; p, . size_t ; len . ). static . Definition at line 8192 of file civetweb.c. ◆ check_acl(). static int check_acl ; (; struct mg_context * ; phys_ctx, . const union usa * ; sa . ). static . Definition at line 15442 of file civetweb.c. ◆ check_authorization(). static int check_authorization ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 8668 of file civetweb.c. ◆ check_password(). static int check_password ; (; const char * ; method, . const char * ; ha1, . const char * ; uri, . const char * ; nonce, . const char * ; nc, . const char * ; cnonce, . const char * ; qop, . const char * ; response . ). static . Definition at line 8230 of file civetweb.c. ◆ close_all_listening_sockets(). static void close",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:43741,authoriz,authorize,43741,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['authoriz'],['authorize']
Security,"nums::IsLoaded ; (; ); const. inline . Definition at line 80 of file TListOfEnums.h. ◆ Load(). void TListOfEnums::Load ; (; ). private . Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 337 of file TListOfEnums.cxx. ◆ MapObject(). void TListOfEnums::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 56 of file TListOfEnums.cxx. ◆ operator=(). TListOfEnums & TListOfEnums::operator= ; (; const TListOfEnums & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfEnums::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 293 of file TListOfEnums.cxx. ◆ Remove() [1/2]. TObject * TListOfEnums::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 305 of file TListOfEnums.cxx. ◆ Remove() [2/2]. TObject * TListOfEnums::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 321 of file TListOfEnums.cxx. ◆ SetClass(). void TListOfEnums::SetClass ; (; TClass * ; cl). inlineprivate . Definition at line 56 of file TListOfEnums.h. ◆ Streamer(). void TListOfEnums::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from THashList.; Reimplemented in TListOfE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:31006,hash,hash,31006,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hash']
Security,"nvalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:609873,authenticat,authentication,609873,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authenticat'],['authentication']
Security,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:609906,authenticat,authentication,609906,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authenticat'],['authentication']
Security,"nvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12438,password,password,12438,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,14,"['hash', 'password']","['hash', 'password']"
Security,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. TBtree(Int_t ordern = 3); virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBtree.html:7205,access,access,7205,root/html526/TBtree.html,https://root.cern,https://root.cern/root/html526/TBtree.html,5,['access'],['access']
Security,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBtree.html:7205,access,access,7205,root/html602/TBtree.html,https://root.cern,https://root.cern/root/html602/TBtree.html,2,['access'],['access']
Security,"ny other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according to the WLCG Bearer Token Discovery specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:27847,secur,security,27847,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['secur'],['security']
Security,"nymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; Bool_t_useNptr!. private:. static RooLinkedList::Pool*_pool!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinkedList.html:7603,hash,hash-table,7603,root/html602/RooLinkedList.html,https://root.cern,https://root.cern/root/html602/RooLinkedList.html,2,['hash'],['hash-table']
Security,"o applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.HessianPar(x, hess);; 160 ```; 161 ; 162 \anchor FormulaFuncs; 163 ### List of predefined functions; 164 ; 165 The list of available predefined functions which can be used as s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:4890,access,accessed,4890,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['access'],['accessed']
Security,"o chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogramming image: Image Processing io: Input/Output math: Maths and Statistics functions matrix: Matrices (TMatrix) examples mlp: Neural networks with TMultiLayerPerceptron net: Network classes (client/server examples) physics: LorentzVectors, phase space pyroot: Python tutorials pythia: Example with pythia8 quadp: Quadratic Programming smatrix: Matrices with a templated package spectrum: Peak finder, background, deconvolutions splot: Example of the TSplot class (signal/background estimator) sql: Interfaces to SQL (mysql, oracle, etc) thread: Using Threads tmva: Examples of the MultiVariate Analysis classes tree: Creating Trees, Playing with Trees unuran: Interface with the unuram random generator library xml: Writing/Reading xml files; You can execute the scripts in $ROOTSYS/tutorials (or sub-directories) by setting your current directory in the script directory or from any user directory with write access. Several tutorials create new files. If you have write access to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutoria",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:26609,access,access,26609,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"o invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigetst” file. When starting the server, the following arguments should be specified:; root [0] new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; root [6] serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; root [7] serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:4267,password,password,4267,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['password'],['password']
Security,"o not have the library defining the class. void StreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:61058,access,accessor,61058,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['accessor']
Security,"o obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Jul 4 15:23:14 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:9214,hash,hash,9214,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['hash'],['hash']
Security,"o own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:35120,access,access,35120,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['access'],['access']
Security,"o store TObject's.Definition THashTable.h:35; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::Initializevirtual void Initialize()=0; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TInterpreter::kFatal@ kFatalDefinition TInterpreter.h:76; TIterDefinition TCollection.h:235; TIter::GetOptionOption_t * GetOption() constDefinition TCollection.h:253; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete all TDataMember object files.Definition TListOfDataMembers.cxx:171; TListOfDataMembers::Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfDataMembers.cxx:542; TListOfDataMembers::GetTDictionary * Get(DeclId_t id)Return (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:216; TListOfDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection.Definition TListOfDataMembers.cxx:399; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:137969,access,access,137969,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['access']
Security,"o the processing chain; of this MCStudy object. Bool_t run(Bool_t generate, Bool_t fit, Int_t nSamples, Int_t nEvtPerSample, Bool_t keepGenData, const char* asciiFilePat); Run engine method. Generate and/or fit, according to flags, 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory and can be accessed; later via genData(). When generating, data sets will be written out in ascii form if the pattern string is supplied; The pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. When fitting only, data sets may optionally be read from ascii files, using the same file; pattern. Bool_t generateAndFit(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate and fit 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory and can be accessed; later via genData(). Data sets will be written out is ascii form if the pattern string is supplied.; The pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t generate(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory; and can be accessed later via genData(). Data sets will be written out in ascii form if the pattern string is supplied.; The pattern, which is a template for sprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t fit(Int_t nSamples, const char* asciiFilePat); Fit 'nSamples' datasets, which are read from ASCII files. The ascii file pattern, which is a templat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:16203,access,accessed,16203,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['access'],['accessed']
Security,"o this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:98582,access,access,98582,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['access'],['access']
Security,"o use transactions function himself. By default only indexes for basic tables are created. In most cases usage of indexes increase performance to data reading, but it also can increase time of writing data to database. There are several modes of index usage available in SetUseIndexes() method There is MakeSelectQuery(TClass*) method, which produces SELECT statement to get objects data of specified class. Difference from simple statement like: mysql> SELECT * FROM TH1I_ver1 that not only data for that class, but also data from parent classes will be extracted from other tables and combined in single result table. Such select query can be useful for external access to objects data.; Up to now MySQL 4.1 and Oracle 9i were tested. Some extra work is required for other SQL databases. Hopefully, this should be straightforward.; Known problems and open questions.; TTree is not supported by TSQLFile. There is independent development of TTreeSQL class, which allows to store trees directly in SQL database; TClonesArray is store objects in raw format, which can not be accessed outside ROOT. This will be changed later.; TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); Streamer infos are not written to file, therefore schema evolution is not yet supported. All eforts are done to enable this feature in the near future. Example how TSQLFile can be used; A session saving data to a SQL data base; auto dbname = ""mysql://host.domain:3306/dbname"";; auto username = ""username"";; auto userpass = ""userpass"";; ; // Clean data base and create primary tables; auto f = new TSQLFile(dbname, ""recreate"", username, userpass);; // Write with standard I/O functions; arr->Write(""arr"", TObject::kSingleKey);; h1->Write(""histo"");; // Close connection to DB; delete f;; f#define f(i)Definition RSha256.hxx:104; TObject::kSingleKey@ kSingleKeywrite collection with single keyDefinition TObject.h:91; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:5796,access,accessed,5796,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['accessed']
Security,"o {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:302287,validat,validation,302287,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['validat'],['validation']
Security,"o {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:302320,validat,validation,302320,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['validat'],['validation']
Security,"o(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the infor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:18368,checksum,checksum,18368,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,12,['checksum'],['checksum']
Security,"o=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:21234,authenticat,authenticated,21234,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,2,['authenticat'],"['authenticated', 'authentication']"
Security,"oAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnblindCPAsymVar.html:34062,access,access,34062,root/html534/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html534/RooUnblindCPAsymVar.html,4,['access'],['access']
Security,"oAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Deault constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Mon Dec 7 13:47:06 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:33443,validat,validation,33443,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,1,['validat'],['validation']
Security,"oAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:41791,access,access,41791,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,1,['access'],['access']
Security,"oAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, const char* title, RooAbsCategory& blindState, const char* unit = """"); Constructor. RooAbsHiddenReal(const RooAbsHiddenReal& other, const char* name = 0); Copy constructor. ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. inline RooAbsHiddenReal(); Constructors, assignment etc. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. Double_t getValV(const RooArgSet* nset = 0) const; This is dubious from a C++ point of view, but it blocks the interactive user; from accidentally calling getVal() without explicit cast, which is the whole; point of this class. » Last changed: Tue Jun 2 15:27:07 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsHiddenReal.html:38756,access,accessor,38756,root/html604/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html604/RooAbsHiddenReal.html,1,['access'],['accessor']
Security,"oActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction.; The collection needs to be a split TClonesArray or a split vector of pointers. Int_t ReadSequence(const TStreamerInfoActions::TActionSequence& sequence, void* start_collection, void* end_collection); Read one collection of objects from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:46594,hash,hashtable,46594,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,2,['hash'],['hashtable']
Security,"oAdd(ROOT::DirAutoAdd_t autoAddFunc); 7029{; 7030 fDirAutoAdd = autoAddFunc;; 7031}; 7032 ; 7033////////////////////////////////////////////////////////////////////////////////; 7034/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7035 ; 7036TVirtualStreamerInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:270424,checksum,checksum,270424,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"oAdd(ROOT::DirAutoAdd_t autoAddFunc); 7096{; 7097 fDirAutoAdd = autoAddFunc;; 7098}; 7099 ; 7100////////////////////////////////////////////////////////////////////////////////; 7101/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7102 ; 7103TVirtualStreamerInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7104{; 7105 TVirtualStreamerInfo *guess = fLastReadInfo;; 7106 if (guess && guess->GetCheckSum() == checksum) {; 7107 return guess;; 7108 } else {; 7109 if (fCheckSum == checksum); 7110 return GetStreamerInfo(0, isTransient);; 7111 ; 7112 R__LOCKGUARD(gInterpreterMutex);; 7113 ; 7114 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7115 for (Int_t i=-1;i<ninfos;++i) {; 7116 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7117 // so we have to use At and should not use UncheckedAt; 7118 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7119 if (info && info->GetCheckSum() == checksum) {; 7120 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7121 info->BuildOld();; 7122 if (info->IsCompiled()) fLastReadInfo = info;; 7123 return info;; 7124 }; 7125 }; 7126 return nullptr;; 7127 }; 7128}; 7129 ; 7130////////////////////////////////////////////////////////////////////////////////; 7131/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7132 ; 7133TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7134{; 7135 R__LOCKGUARD(gInterpreterMutex);; 7136 Int_t ninfos = arr->GetEntriesFast()-1;; 7137 for (Int_t i=-1;i<ninfos;i++) {; 7138 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7139 // so we have to use At and should not use UncheckedAt; 7140 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7141 if (!info) continue;; 7142 if (info->GetCheckSum() == checksum) {; 7143 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:273175,checksum,checksum,273175,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"oBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:35828,access,accessor,35828,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['access'],['accessor']
Security,"oClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  . Protected Attributes; Bool_t fBdown;  ; TGCanvas * fCanvas;  pointer to canvas ;  ; Bool_t fDragging;  true if in dragging mode ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TString fKeyInput;  keyboard input (buffer) ;  ; TTimer * fKeyTimer;  keyboard timer ;  ; Bool_t fKeyTimerActive;  kTRUE - keyboard timer is active ;  ; TGFrameElement * fLastActiveEl;  last active item ;  ; Bool_t fLastCase;  case sensitivity of last search ;  ; Bool_t fLastDir;  direction of last search ;  ; TString fLastName;  the name of object of last search ;  ; Bool_t fLastSubstring;  substring search option of last search ;  ; const TGWindow * fMsgWindow;  window handling container messages ;  ; Bool_t fOnMouseOver;  kTRUE when mouse pointer is over entry ;  ; Bool_t fScrolling;  kTRUE - when scrolling is ON ;  ; TTimer * fScrollTimer;  autoscroll timer ;  ; Int_t fSelected;  number of selected items ;  ; Int_t fTotal;  total items ;  ; TGViewPort * fViewPort;  container viewport ;  ; Int_t fX0;  ; Int_t fXDND;  ; Int_t fXf;  ; Int_t fXp;  ; Int_t fY0;  corner of rubber band box ;  ; Int_t fYDND;  ; Int_t fYf;  other corner of rubber band box ;  ; Int_t fYp;  previous pointer position ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGContainer.html:32776,expose,exposed,32776,doc/master/classTGContainer.html,https://root.cern,https://root.cern/doc/master/classTGContainer.html,1,['expose'],['exposed']
Security,"oError(int level, const char* location, const char* fmt, va_list va) const; voidInitStreaming(); voidTObject::MakeZombie(). private:. TStreamerBase(const TStreamerBase&); TStreamerBase&operator=(const TStreamerBase&). Data Members; public:. enum TStreamerElement::ESTLtype { kSTL; kSTLstring; kSTLvector; kSTLlist; kSTLdeque; kSTLmap; kSTLmultimap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerBase.html:8263,checksum,checksum,8263,root/html534/TStreamerBase.html,https://root.cern,https://root.cern/root/html534/TStreamerBase.html,2,['checksum'],['checksum']
Security,"oFit::xRooBrowser Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; ROOT::Experimental::XRooFit::xRooBrowser Class ReferenceRooFit » xRooFit. ; A version of the TBrowser that can be used to interact with RooFit models and datasets. . Also available under the ROOT::Experimental::RooBrowser alias.; To get started with the xRooBrowser, open any ROOT file containing a workspace and then create an instance of the xRooBrowser just like creating an instance of a TBrowser. A window will be displayed with a navigable tree structure on the left that lets you explore the content of the workspaces present in the loaded file. Note that additional files, including json workspace files, can be loaded through the Browser --> Open menu in the top left corner.; The context menu for each node (access by right clicking on the node) in the tree structure can be used to get more information about the node. In particular, the Draw command can be selected on many of the nodes that are part of a statistical model, which will visualize that part of the model in the browser window. A number of options are available for the Draw command, including (some options can be combined):. ""e"" : calculate and visualize propagated model uncertainty; ""auxratio"" : Draw a ratio auxiliary plot below the main plot; ""auxsignif"" : Draw a significance auxiliary plot below the main plot; ""pull"" : show panel of current parameter values, which can be dragged in order to change the values and visualize the effect on the model (very experimental feature). Once a node has been drawn, the styling of subsequent draws can be controlled through TStyle objects that will now appear in the objects folder in the workspace.; A model can be fit to a dataset from the workspace using the fitTo context menu command and specifying the name of a dataset in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html:993,access,access,993,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html,1,['access'],['access']
Security,"oLinkedList::rbegin ; (; ); const. Definition at line 769 of file RooLinkedList.cxx. ◆ RecursiveRemove(). void RooLinkedList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 481 of file RooLinkedList.cxx. ◆ Remove(). bool RooLinkedList::Remove ; (; TObject * ; arg). virtual . Remove object from collection. ; Definition at line 449 of file RooLinkedList.cxx. ◆ rend(). RooLinkedListIterImpl RooLinkedList::rend ; (; ); const. Definition at line 773 of file RooLinkedList.cxx. ◆ Replace(). bool RooLinkedList::Replace ; (; const TObject * ; oldArg, . const TObject * ; newArg . ). Replace object 'oldArg' in collection with new object 'newArg'. ; If 'oldArg' is not found in collection false is returned ; Definition at line 510 of file RooLinkedList.cxx. ◆ setHashTableSize(). void RooLinkedList::setHashTableSize ; (; Int_t ; size). Change the threshold for hash-table use to given size. ; If a hash table exists when this method is called, it is regenerated. ; Definition at line 331 of file RooLinkedList.cxx. ◆ SetName(). void RooLinkedList::SetName ; (; const char * ; name). inline . Definition at line 105 of file RooLinkedList.h. ◆ size(). std::size_t RooLinkedList::size ; (; ); const. inline . Definition at line 70 of file RooLinkedList.h. ◆ Sort(). void RooLinkedList::Sort ; (; bool ; ascend = true). Definition at line 779 of file RooLinkedList.cxx. ◆ Streamer(). void RooLinkedList::Streamer ; (; TBuffer & ; R__b). overridevirtual . Custom streaming handling schema evolution w.r.t past implementations. ; Reimplemented from TObject.; Definition at line 903 of file RooLinkedList.cxx. ◆ StreamerNVirtual(). void RooLinkedList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 149 of file RooLinkedList.h. ◆ useNptr(). void RooLinkedList::useNptr ; (; bool ; flag). inline . Definition at line 107 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:24934,hash,hash-table,24934,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash-table']
Security,"oManager::Import ; (; const char * ; filename, . const char * ; name = """", . Option_t * ; option = """" . ). static . static function Import a geometry from a gdml or ROOT file . Case 1: gdml if filename ends with "".gdml"" the foreign geometry described with gdml is imported executing some python scripts in $ROOTSYS/gdml. NOTE that to use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml; Case 2: root file (.root) or root/xml file (.xml) Import in memory from filename the geometry with key=name. if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one) before importing the new object. ; Definition at line 4096 of file TGeoManager.cxx. ◆ Init(). void TGeoManager::Init ; (; ). private . Initialize manager class. ; Definition at line 416 of file TGeoManager.cxx. ◆ InitArrayPNE(). Bool_t TGeoManager::InitArrayPNE ; (; ); const. private . Initialize PNE array for fast access via index and unique-id. ; Definition at line 4214 of file TGeoManager.cxx. ◆ InitTrack() [1/2]. TGeoNode * TGeoManager::InitTrack ; (; const Double_t * ; point, . const Double_t * ; dir . ). Initialize current point and current direction vector (normalized) in MARS. ; Return corresponding node. ; Definition at line 2856 of file TGeoManager.cxx. ◆ InitTrack() [2/2]. TGeoNode * TGeoManager::InitTrack ; (; Double_t ; x, . Double_t ; y, . Double_t ; z, . Double_t ; nx, . Double_t ; ny, . Double_t ; nz . ). Initialize current point and current direction vector (normalized) in MARS. ; Return corresponding node. ; Definition at line 2865 of file TGeoManager.cxx. ◆ InsertPNEId(). Bool_t TGeoManager::InsertPNEId ; (; Int_t ; uid, . Int_t ; ientry . ). private . Insert a PN entry in the sorted array of indexes. ; Definition at line 3415 of file TGeoManager.cxx. ◆ InspectState(). void TGeoManager::InspectState ; (; ); const. Inspects path and all flags for the current state. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:107029,access,access,107029,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['access'],['access']
Security,oPatternY;  CTGeoPatternZ;  CTGeoPcon;  CTGeoPconEditor;  CTGeoPconSection;  ►CTGeoPgon;  CThreadData_t;  CTGeoPgonEditor;  CTGeoPhysicalNode;  CTGeoPNEntry;  CTGeoPolygon;  CTGeoRCExtension;  CTGeoRCPtr;  CTGeoRotation;  CTGeoRotationEditor;  CTGeoScale;  CTGeoScaledShape;  CTGeoShape;  CTGeoShapeAssembly;  CTGeoShapeDialog;  CTGeoSphere;  CTGeoSphereEditor;  CTGeoStateInfo;  CTGeoSubtraction;  CTGeoTabManager;  CTGeoToOCC;  CTGeoTorus;  CTGeoTorusEditor;  CTGeoToStep;  CTGeoTrack;  CTGeoTransientPanel;  CTGeoTranslation;  CTGeoTranslationEditor;  CTGeoTrap;  CTGeoTrapEditor;  CTGeoTrd1;  CTGeoTrd1Editor;  CTGeoTrd2;  CTGeoTrd2Editor;  CTGeoTreeDialog;  CTGeoTube;  CTGeoTubeEditor;  CTGeoTubeSeg;  CTGeoTubeSegEditor;  CTGeoUniformMagField;  CTGeoUnion;  CTGeoVolume;  ►CTGeoVolumeAssembly;  CThreadData_t;  CTGeoVolumeDialog;  CTGeoVolumeEditor;  CTGeoVolumeMulti;  CTGeoVoxelFinder;  ►CTGeoXtru;  CThreadData_t;  CTGEventHandler;  CTGFALFileRead and write data via the underlying Grid access mechanism ;  CTGFALSystemDirectory handler for GFAL ;  CTGFileBrowser;  CTGFileContainer;  CTGFileDialog;  CTGFileInfo;  CTGFileItem;  CTGFont;  ►CTGFontDialog;  CFontProp_t;  CTGFontPool;  CTGFontTypeComboBox;  CTGFrame;  CTGFrameElement;  CTGFrameElementPack;  CTGFSComboBox;  CTGGC;  CTGGCPool;  CTGGotoDialog;  CTGGroupFrame;  CTGHButtonGroup;  CTGHeaderFrame;  CTGHorizontal3DLine;  CTGHorizontalFrame;  CTGHorizontalLayout;  CTGHotString;  CTGHProgressBar;  CTGHScrollBar;  CTGHSlider;  CTGHSplitter;  CTGHtml;  CTGHtmlAnchor;  CTGHtmlBlock;  CTGHtmlBrowser;  CTGHtmlCell;  CTGHtmlElement;  CTGHtmlForm;  CTGHtmlHr;  CTGHtmlImage;  CTGHtmlImageMarkup;  CTGHtmlInput;  CTGHtmlLayoutContext;  CTGHtmlLi;  CTGHtmlListStart;  CTGHtmlMapArea;  CTGHtmlMarkupElement;  CTGHtmlRef;  CTGHtmlScript;  CTGHtmlSpaceElement;  CTGHtmlTable;  CTGHtmlTextElement;  CTGHtmlUri;  CTGIcon;  CTGIconLBEntry;  CTGIdleHandler;  CTGImageMap;  CTGInputDialog;  CTGInsets;  CTGItemContextEmpty object used as context,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:120816,access,access,120816,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"oRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. return getVal(const RooArgSet* nset = 0) const. » Last changed: Mon Dec 7 13:45:39 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:33245,access,accessor,33245,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,1,['access'],['accessor']
Security,"oSink; , kConnectedToSource; };  During its lifetime, a field undergoes the following possible state transitions: More...;  ; using RConstSchemaIterator = RSchemaIteratorTemplate< true >;  ; using RSchemaIterator = RSchemaIteratorTemplate< false >;  ;  Static Public Attributes inherited from ROOT::Experimental::RFieldBase; static constexpr std::uint32_t kInvalidTypeVersion = -1U;  ; static constexpr int kTraitMappable = 0x04;  A field of a fundamental type that can be directly mapped via RField<T>::Map(), i.e. ;  ; static constexpr int kTraitTriviallyConstructible = 0x01;  No constructor needs to be called, i.e. ;  ; static constexpr int kTraitTriviallyDestructible = 0x02;  The type is cleaned up just by freeing its memory. I.e. the destructor performs a no-op. ;  ; static constexpr int kTraitTrivialType = kTraitTriviallyConstructible | kTraitTriviallyDestructible;  Shorthand for types that are both trivially constructible and destructible. ;  ; static constexpr int kTraitTypeChecksum = 0x08;  The TClass checksum is set and valid. ;  ;  Protected Member Functions inherited from ROOT::Experimental::RClassField; std::size_t AppendImpl (const void *from) final;  Operations on values of complex types, e.g. ;  ; std::unique_ptr< RFieldBase > CloneImpl (std::string_view newName) const final;  Called by Clone(), which additionally copies the on-disk ID. ;  ; void ConstructValue (void *where) const final;  Constructs value in a given location of size at least GetValueSize(). Called by the base class' CreateValue(). ;  ; std::unique_ptr< RDeleter > GetDeleter () const final;  ; void OnConnectPageSource () final;  Called by ConnectPageSource() once connected; derived classes may override this as appropriate. ;  ; void ReadGlobalImpl (NTupleSize_t globalIndex, void *to) final;  ; void ReadInClusterImpl (RClusterIndex clusterIndex, void *to) final;  ;  Protected Member Functions inherited from ROOT::Experimental::RFieldBase; size_t AddReadCallback (ReadCallback_t func);  Set a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:7075,checksum,checksum,7075,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['checksum'],['checksum']
Security,"o_t *minfo) const finalDefinition TCling.cxx:9075; TCling::CreateListOfMethodsvoid CreateListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:445580,hash,hash,445580,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['hash'],['hash']
Security,"oading the file contents, namely HTTP or HTTPS. The 's3', 's3https', 'gs' and 'gshttps' schemes imply using HTTPS as the transport protocol. The 's3http', 'as3' and 'gshttp' schemes imply using HTTP as the transport protocol.; The 'options' argument can contain 'NOPROXY' if you want to bypass the HTTP proxy when retrieving this file's contents. As for any TWebFile-derived object, the URL of the web proxy can be specified by setting an environmental variable 'http_proxy'. If this variable is set, we ask that proxy to route our requests HTTP(S) requests to the file server.; In addition, you can also use the 'options' argument to provide the access key and secret key to be used for authentication purposes for this file by using a string of the form ""AUTH=myAccessKey:mySecretkey"". This may be useful to open several files hosted by different providers in the same program/macro, where the environemntal variables solution is not convenient (see below).; To use AWS temporary security credentials you need to specify the session token. This can be added to the options argument with a string of the form TOKEN=mySessionToken. The temporary access and secret keys must also be available, either via the AUTH option or by environmental variable.; If you need to specify more than one option separate them by ' ' (blank), for instance: ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+""; Examples: TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f3 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""TOKEN=AQoDYXdzEM///////////wEa8AHEYmCinjD+TsGEjtgKSMAT6wnY"");; If there is no authentication information in the 'options' argument (i.e. not AUTH=""...."") the values of the environmental variables S3_AC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:49869,secur,security,49869,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['secur'],['security']
Security,"object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; TIterator end () and range-based for loops."") ;  ; RooLinkedListIter end () and range-based for loops."") ;  ; RooFIter end () and range-based for loops."") ;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &otherColl) const;  Check if this and other collection have identically-named contents. ;  ; RooAbsArg * find (const char *name) const;  Find object with given name in list. ;  ; RooAbsArg * find (const RooAbsArg &) const;  Find object with given name in list. ;  ; TObject * FindObject (const char *name) const override;  Find object by name in the collection. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object in the collection, Note: matching by object name, like the find() method. ;  ; RooAbsArg * first () const;  ; RooFIter fwdIterator () const R__DEPRECATED(6;  One-time forward iterator. ;  ; Storage_t const & get () const;  Const access to the underlying stl container. ;  ; Int_t getCatIndex (const char *name, Int_t defVal=0, bool verbose=false) const;  Get index value of a RooAbsCategory stored in set with given name. ;  ; const char * getCatLabel (const char *name, const char *defVal="""", bool verbose=false) const;  Get state name of a RooAbsCategory stored in set with given name. ;  ; Int_t getHashTableSize () const;  Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; const char * GetName () const override;  Returns name of object. ;  ; double getRealValue (const char *name, double defVal=0.0, bool verbose=false) const;  Get value of a RooAbsReal stored in set with given name. ;  ; Int_t getSize () const;  Return the number of elements in the collection. ;  ; const char * getStringValue (const char *name, const char *defVal="""", bool verbose=false) const;  Get string value of a RooStringVar stored in set with given name. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:7291,access,access,7291,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['access'],['access']
Security,"objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncPtr_t GetDictNorm(const char* cname); Given the normalized class name returns the Dictionary() function of a class; (uses hash of name). TProtoClass * GetProto(const char* cname); Given the class name returns the TClassProto object for the class.; (uses hash of name). TProtoClass * GetProtoNorm(const char* cname); Given the class normalized name returns the TClassProto object for the class.; (uses hash of name). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassTable.html:9709,hash,hash,9709,root/html602/TClassTable.html,https://root.cern,https://root.cern/root/html602/TClassTable.html,2,['hash'],['hash']
Security,"objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $ » Last generated: 2010-09-23 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:14519,hash,hash,14519,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,1,['hash'],['hash']
Security,"objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THashList.html:14638,hash,hash,14638,root/html530/THashList.html,https://root.cern,https://root.cern/root/html530/THashList.html,1,['hash'],['hash']
Security,"objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $ » Last generated: 2011-11-03 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THashList.html:14638,hash,hash,14638,root/html532/THashList.html,https://root.cern,https://root.cern/root/html532/THashList.html,1,['hash'],['hash']
Security,"obusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:17573,authenticat,authentication,17573,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"oc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 177 ; 1782. Transform the dataframe by:; 179 ; 180 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 181 ; 182 - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset.; 183 ; 1843. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time.; 185 ; 186Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; 187 ; 188The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; 189[crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; 190<table>; 191<tr>; 192 <td>; 193 <b>TTreeReader</b>; 194 </td>; 195 <td>; 196 <b>ROOT::RDataFrame</b>; 197 </td>; 198</tr>; 199<tr>; 200 <td>; 201~~~{.cpp}; 202TTreeReader reader(""myTree"", file);; 203TTreeReaderValue<A_t> a(reader, ""A"");; 204TTreeReaderValue<B_t> b(reader, ""B"");; 205TTreeReaderValue<C_t> c(reader, ""C"");; 206while(reader.Next()) {; 207 if(IsGoodEvent(*a, *b, *c)); 208 DoStuff(*a, *b, *c);; 209}; 210~~~; 211 </td>; 212 <td>; 213~~~{.cpp}; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:14503,access,accessed,14503,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"oc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well.; 181 ; 1822. Transform the dataframe by:; 183 ; 184 - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset.; 185 ; 186 - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset.; 187 ; 1883. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time.; 189 ; 190Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; 191 ; 192The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; 193[crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; 194<table>; 195<tr>; 196 <td>; 197 <b>TTreeReader</b>; 198 </td>; 199 <td>; 200 <b>ROOT::RDataFrame</b>; 201 </td>; 202</tr>; 203<tr>; 204 <td>; 205~~~{.cpp}; 206TTreeReader reader(""myTree"", file);; 207TTreeReaderValue<A_t> a(reader, ""A"");; 208TTreeReaderValue<B_t> b(reader, ""B"");; 209TTreeReaderValue<C_t> c(reader, ""C"");; 210while(reader.Next()) {; 211 if(IsGoodEvent(*a, *b, *c)); 212 DoStuff(*a, *b, *c);; 213}; 214~~~; 215 </td>; 216 <td>; 217~~~{.cpp}; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:14945,access,accessed,14945,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"ocDirective; virtual void DeleteOutput () const;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocHtmlDirective.html:1884,hash,hash,1884,doc/master/classTDocHtmlDirective.html,https://root.cern,https://root.cern/doc/master/classTDocHtmlDirective.html,1,['hash'],['hash']
Security,"ocOutput & ; docOutput, . TClass * ; cl . ). Constructor called for parsing class sources. ; Definition at line 150 of file TDocParser.cxx. ◆ TDocParser() [2/2]. TDocParser::TDocParser ; (; TDocOutput & ; docOutput). constructor called for parsing text files with Convert() ; Definition at line 190 of file TDocParser.cxx. ◆ ~TDocParser(). TDocParser::~TDocParser ; (; ). override . destructor, checking whether all methods have been found for gDebug > 3 ; Definition at line 211 of file TDocParser.cxx. Member Function Documentation. ◆ AddClassDataMembersRecursively(). void TDocParser::AddClassDataMembersRecursively ; (; TBaseClass * ; bc). protected . Add data members of fCurrentClass and of bc to datamembers, recursively. ; Real data members are in idx 0..2 (public, protected, private access), enum constants in idx 3..5. ; Definition at line 306 of file TDocParser.cxx. ◆ AddClassMethodsRecursively(). void TDocParser::AddClassMethodsRecursively ; (; TBaseClass * ; bc). protected . Add accessible (i.e. ; non-private) methods of base class bc and its base classes' methods to methodNames. If bc==0, we add fCurrentClass's methods (and also private functions). ; Definition at line 235 of file TDocParser.cxx. ◆ AnchorFromLine(). void TDocParser::AnchorFromLine ; (; const TString & ; line, . TString & ; anchor . ). static . Create an anchor from the given line, by hashing it and convertig the hash into a custom base64 string. ; Definition at line 381 of file TDocParser.cxx. ◆ Class(). static TClass * TDocParser::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDocParser::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDocParser::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 187 of file TDocParser.h. ◆ Context(). EParseContext TDocParser::Context ; (; ); const. inlineprotected . Definition at line 129 of file TDocParser.h. ◆ Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:19134,access,accessible,19134,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['access'],['accessible']
Security,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKSocket.html:5887,authenticat,authentication,5887,root/html604/TKSocket.html,https://root.cern,https://root.cern/root/html604/TKSocket.html,1,['authenticat'],['authentication']
Security,"ocket(TSocket* s = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TKSocket::EEncodingkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TKSocket::EEncodingkPriv; static TKSocket::EEncodingkSafe; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. krb5_auth_contextfAuthContextper connection kerberos authentication context; krb5_principalfServerserver principal; TSocket*fSocketunderlying socket; static krb5_ccachefgCCDefshared default credential cache; static krb5_principalfgClientclient principal; static krb5_contextfgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKSocket.html:5887,authenticat,authentication,5887,root/html602/TKSocket.html,https://root.cern,https://root.cern/root/html602/TKSocket.html,1,['authenticat'],['authentication']
Security,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:47179,secur,security,47179,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['secur'],['security']
Security,"ocumentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the file compression attribute is set (default).; 39Branches may be written to different files (see T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:1131,access,access,1131,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"od, ""PROPFIND"")) {; 14510 handle_propfind(conn, path, &file.stat);; 14511 return;; 14512 }; 14513 /* 13.2. Handle OPTIONS for files */; 14514 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14515 /* This standard handler is only used for real files.; 14516 * Scripts should support the OPTIONS method themselves, to allow a; 14517 * maximum flexibility.; 14518 * Lua and CGI scripts may fully support CORS this way (including; 14519 * preflights). */; 14520 send_options(conn);; 14521 return;; 14522 }; 14523 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14524 if ((0 != strcmp(ri->request_method, ""GET"")); 14525 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14526 mg_send_http_error(conn,; 14527 405,; 14528 ""%s method not allowed"",; 14529 conn->request_info.request_method);; 14530 return;; 14531 }; 14532 ; 14533 /* 14. directories */; 14534 if (file.stat.is_directory) {; 14535 /* Substitute files have already been handled above. */; 14536 /* Here we can either generate and send a directory listing,; 14537 * or send an ""access denied"" error. */; 14538 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14539 ""yes"")) {; 14540 handle_directory_request(conn, path);; 14541 } else {; 14542 mg_send_http_error(conn,; 14543 403,; 14544 ""%s"",; 14545 ""Error: Directory listing denied"");; 14546 }; 14547 return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:428330,access,access,428330,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"od, ""PROPFIND"")) {; 14511 handle_propfind(conn, path, &file.stat);; 14512 return;; 14513 }; 14514 /* 13.2. Handle OPTIONS for files */; 14515 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14516 /* This standard handler is only used for real files.; 14517 * Scripts should support the OPTIONS method themselves, to allow a; 14518 * maximum flexibility.; 14519 * Lua and CGI scripts may fully support CORS this way (including; 14520 * preflights). */; 14521 send_options(conn);; 14522 return;; 14523 }; 14524 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14525 if ((0 != strcmp(ri->request_method, ""GET"")); 14526 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14527 mg_send_http_error(conn,; 14528 405,; 14529 ""%s method not allowed"",; 14530 conn->request_info.request_method);; 14531 return;; 14532 }; 14533 ; 14534 /* 14. directories */; 14535 if (file.stat.is_directory) {; 14536 /* Substitute files have already been handled above. */; 14537 /* Here we can either generate and send a directory listing,; 14538 * or send an ""access denied"" error. */; 14539 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14540 ""yes"")) {; 14541 handle_directory_request(conn, path);; 14542 } else {; 14543 mg_send_http_error(conn,; 14544 403,; 14545 ""%s"",; 14546 ""Error: Directory listing denied"");; 14547 }; 14548 return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:428363,access,access,428363,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"odType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expressions of input variables. { return DataInfo().GetVariableInfo(i).GetInternalName(); }. const TString& GetInputLabel(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetLabel(); }. const TString& GetInputTitle(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetTitle(); }. Double_t GetMean(Int_t ivar) const; normalisation and limit accessors. { return GetTransformationHandler().GetMean(ivar); }. Double_t GetRMS(Int_t ivar) const; { return GetTransformationHandler().GetRMS(ivar); }. Double_t GetXmin(Int_t ivar) const; { return GetTransformationHandler().GetMin(ivar); }. Double_t GetXmax(Int_t ivar) const; { return GetTransformationHandler().GetMax(ivar); }. Double_t GetSignalReferenceCut() const; sets the minimum requirement on the MVA output to declare an event signal-like. { return fSignalReferenceCut; }. Double_t GetSignalReferenceCutOrientation() const; { return fSignalReferenceCutOrientation; }. void SetSignalReferenceCut(Double_t cut); sets the minimum requirement on the MVA output to declare an event signal-like. { fSignalReferenceCut = cut; }. void SetSignalReferenceCutOrientation(Double_t cutOrientation); { fSignalReferenceCutOrientation = cutOrientation; }. void SetMethodDir(TDirectory* methodDir); { fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:32759,access,accessors,32759,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,5,['access'],['accessors']
Security,"odType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expressions of input variables. { return DataInfo().GetVariableInfo(i).GetInternalName(); }. const TString& GetInputLabel(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetLabel(); }. const TString& GetInputTitle(Int_t i) const; { return DataInfo().GetVariableInfo(i).GetTitle(); }. Double_t GetMean(Int_t ivar) const; normalisation and limit accessors. { return GetTransformationHandler().GetMean(ivar); }. Double_t GetRMS(Int_t ivar) const; { return GetTransformationHandler().GetRMS(ivar); }. Double_t GetXmin(Int_t ivar) const; { return GetTransformationHandler().GetMin(ivar); }. Double_t GetXmax(Int_t ivar) const; { return GetTransformationHandler().GetMax(ivar); }. Double_t GetSignalReferenceCut() const; sets the minimum requirement on the MVA output to declare an event signal-like. { return fSignalReferenceCut; }. void SetSignalReferenceCut(Double_t cut); sets the minimum requirement on the MVA output to declare an event signal-like. { fSignalReferenceCut = cut; }. void SetMethodDir(TDirectory* methodDir); { fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:31489,access,accessors,31489,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['access'],['accessors']
Security,"od_root installed; TStringfMsgGetHeadcache GetHead() msg; TStringfMsgReadBuffercache ReadBuffer() msg; TStringfMsgReadBuffer10cache ReadBuffer10() msg; Bool_tfNoProxydon't use proxy; TUrlfProxyproxy URL; Long64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.1 (stays alive between calls); TUrlfUrlOrgsave original url in case of temp redirection; static TUrlfgProxyglobally set proxy URL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:23333,authenticat,authentication,23333,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,2,['authenticat'],['authentication']
Security,"ode identifier. ; Try first to get network address, if no network interface try random info based on some machine parameters. ; Definition at line 426 of file TUUID.cxx. ◆ GetRandomInfo(). void TUUID::GetRandomInfo ; (; UChar_t ; seed[16]). protected . Get random info based on some machine parameters. ; Definition at line 511 of file TUUID.cxx. ◆ GetSystemTime(). void TUUID::GetSystemTime ; (; uuid_time_t * ; timestamp). protected . Get system time with 100ns precision. Time is since Oct 15, 1582. ; Definition at line 393 of file TUUID.cxx. ◆ GetTime(). TDatime TUUID::GetTime ; (; ); const. Get time from UUID. ; Definition at line 670 of file TUUID.cxx. ◆ GetUUID(). void TUUID::GetUUID ; (; UChar_t ; uuid[16]); const. Return uuid in specified buffer (16 byte = 128 bits). ; Definition at line 695 of file TUUID.cxx. ◆ GetUUIDNumber(). UInt_t TUUID::GetUUIDNumber ; (; ); const. inline . Definition at line 79 of file TUUID.h. ◆ Hash(). UShort_t TUUID::Hash ; (; ); const. Compute 16-bit hash value of the UUID. ; Definition at line 586 of file TUUID.cxx. ◆ IsA(). virtual TClass * TUUID::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 87 of file TUUID.h. ◆ Print(). void TUUID::Print ; (; ); const. Print UUID. ; Definition at line 563 of file TUUID.cxx. ◆ ReadBuffer(). void TUUID::ReadBuffer ; (; char *& ; buffer). Stream UUID from input buffer. ; Definition at line 291 of file TUUID.cxx. ◆ SetFromString(). void TUUID::SetFromString ; (; const char * ; uuid_str). protected . Set this UUID to the value specified in uuid ((which must be in TUUID::AsString() format). ; Definition at line 219 of file TUUID.cxx. ◆ SetUUID(). void TUUID::SetUUID ; (; const char * ; uuid_str). Set this UUID to the value specified in uuid ((which must be in TUUID::AsString() format). ; Definition at line 704 of file TUUID.cxx. ◆ SetUUIDNumber(). void TUUID::SetUUIDNumber ; (; UInt_t ; index). inline . Definition at line 80 of file TUUID.h. ◆ Sizeof(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:10573,hash,hash,10573,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['hash'],['hash']
Security,"ode, Bool_t interpretDirectives);  Parse text file ""in"", add links etc, and write output to ""out"". ;  ; virtual void DecorateKeywords (std::ostream &out, const char *text);  Expand keywords in text, writing to out. ;  ; virtual void DecorateKeywords (TString &text);  Find keywords in line and create URLs around them. ;  ; void DecrementMethodCount (const char *name);  reduce method count for method called name, removing it from fMethodCounts once the count reaches 0. ;  ; virtual void DeleteDirectiveOutput () const;  Delete output generated by prior runs of all known directives; the output file names might have changes. ;  ; TClass * GetCurrentClass () const;  ; void GetCurrentModule (TString &out_module) const;  Return the name of module for which sources are currently parsed. ;  ; const TList * GetDataMembers (EAccess access) const;  ; TDocOutput * GetDocOutput () const;  ; const TList * GetEnums (EAccess access) const;  ; Long_t GetLineNumber () const;  ; const TList * GetMethods (EAccess access) const;  ; const char * GetSourceInfo (ESourceInfo type) const;  ; UInt_t InContext (Int_t context) const;  checks whether we are in a parse context, return the entry closest to the current context. ;  ; TClass * IsA () const override;  ; virtual void Parse (std::ostream &out);  Locate methods, starting in the source file, then inline, then immediately inside the class declaration. ;  ; void SetCurrentModule (const char *module);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:2838,access,access,2838,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,3,['access'],['access']
Security,"ode. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(const TMVA::BinaryTree&); UInt_tBuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); Double_tCheckEvent(const TMVA::Event*, Bool_t UseYesNoLeaf = kFALSE) const; voidCheckEventWithPrunedTree(const TMVA::Event*) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCleanTree(TMVA::DecisionTreeNode* node = __null); voidClearTree(); UInt_tCountLeafNodes(TMVA::Node* n = __null); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = __null); static TMVA::DecisionTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = 262656); virtual TMVA::DecisionTreeNode*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::DecisionTreeDecisionTree(); TMVA::DecisionTreeDecisionTree(const TMVA::DecisionTree& d); TMVA::DecisionTreeDecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); voidDescendTree(TMVA::Node* n = __null); Bool_tDoRegression() const; voidFillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); voidFillTree(const TMVA::DecisionTree::EventList& eventSample); TMVA::Types::EAnalysisTypeGetAnalysisType(); TMVA::DecisionTreeNode*GetEventNode(const TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:1924,validat,validationSample,1924,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,1,['validat'],['validationSample']
Security,"ode. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(); TMVA::BinaryTreeTMVA::BinaryTree::BinaryTree(const TMVA::BinaryTree&); UInt_tBuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = __null); Double_tCheckEvent(const TMVA::Event*, Bool_t UseYesNoLeaf = kFALSE) const; voidCheckEventWithPrunedTree(const TMVA::Event*) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCleanTree(TMVA::DecisionTreeNode* node = __null); voidClearTree(); UInt_tCountLeafNodes(TMVA::Node* n = __null); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = __null); static TMVA::DecisionTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = 262657); virtual TMVA::DecisionTreeNode*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::DecisionTreeDecisionTree(); TMVA::DecisionTreeDecisionTree(const TMVA::DecisionTree& d); TMVA::DecisionTreeDecisionTree(TMVA::SeparationBase* sepType, Float_t minSize, Int_t nCuts, TMVA::DataSetInfo* = __null, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); voidDescendTree(TMVA::Node* n = __null); Bool_tDoRegression() const; voidFillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); voidFillTree(const TMVA::DecisionTree::EventList& eventSample); TMVA::Types::EAnalysisTypeGetAnalysisType(); TMVA::DecisionTreeNode*GetEventNode(const TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__DecisionTree.html:1932,validat,validationSample,1932,root/html604/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html604/TMVA__DecisionTree.html,1,['validat'],['validationSample']
Security,"ode="""", const char *title="""", Int_t compress=1, Int_t netopt=0, Bool_t parallelopen=kFALSE);  Constructor. ;  ; virtual ~TNetXNGFile ();  Destructor. ;  ; void Close (const Option_t *option="""") override;  Close the file. ;  ; void Flush () override;  Synchronize a file's in-memory and on-disk states. ;  ; TString GetNewUrl () override;  ; Long64_t GetSize () const override;  Get the file size. ;  ; void Init (Bool_t create) override;  Initialize the file. ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  Check if the file is open. ;  ; Bool_t ReadBuffer (char *buffer, Int_t length) override;  Read a data chunk of the given size. ;  ; Bool_t ReadBuffer (char *buffer, Long64_t position, Int_t length) override;  Read a data chunk of the given size, starting from the given offset. ;  ; Bool_t ReadBuffers (char *buffer, Long64_t *position, Int_t *length, Int_t nbuffs) override;  Read scattered data chunks in one operation. ;  ; Int_t ReOpen (Option_t *modestr) override;  Reopen the file with the new access mode. ;  ; void Seek (Long64_t offset, ERelativeTo position=kBeg) override;  Set the position within the file. ;  ; virtual void SetAsyncOpenStatus (EAsyncOpenStatus status);  Set the status of an asynchronous file open. ;  ; void Streamer (TBuffer &) override;  Stream a TFile object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t WriteBuffer (const char *buffer, Int_t length) override;  Write a data chunk. ;  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Opens or creates a local ROOT file. ;  ;  ~TFile () override;  File destructor. ;  ; void Close (Option_t *option="""") override;  Close a file. ;  ; void Copy (TObject &) const override;  Copy this to obj. ;  ; virtual Bool_t Cp (const char *dst, Bool_t progressbar=kTRUE, UInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:1610,access,access,1610,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['access'],['access']
Security,oefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doFloorIntroduce floor at zero in pdf; static Bool_t_doFloorGlobalGlobal flag for introducing floor at zero in pdf; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoef; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealSumPdf.html:42572,access,access,42572,root/html602/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html602/RooRealSumPdf.html,2,['access'],['access']
Security,"of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message isued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimzation is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issueing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimzation result. The state at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:41319,access,accessed,41319,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['access'],['accessed']
Security,"of epochs to train; TObjArray*fNetworkTObjArray of TObjArrays representing network; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:18413,access,access,18413,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,2,['access'],['access']
Security,"of file RNTupleWriteOptions.hxx. ◆ SetUseImplicitMT(). void ROOT::Experimental::RNTupleWriteOptions::SetUseImplicitMT ; (; EImplicitMT ; val). inline . Definition at line 137 of file RNTupleWriteOptions.hxx. ◆ SetWriteBufferSize(). void ROOT::Experimental::RNTupleWriteOptions::SetWriteBufferSize ; (; std::size_t ; val). inline . Definition at line 134 of file RNTupleWriteOptions.hxx. Member Data Documentation. ◆ fApproxZippedClusterSize. std::size_t ROOT::Experimental::RNTupleWriteOptions::fApproxZippedClusterSize = 100 * 1000 * 1000. protected . Approximation of the target compressed cluster size. ; Definition at line 64 of file RNTupleWriteOptions.hxx. ◆ fCompression. int ROOT::Experimental::RNTupleWriteOptions::fCompression {RCompressionSetting::EDefaults::kUseGeneralPurpose}. protected . Definition at line 62 of file RNTupleWriteOptions.hxx. ◆ fEnablePageChecksums. bool ROOT::Experimental::RNTupleWriteOptions::fEnablePageChecksums = true. protected . If set, checksums will be calculated and written for every page. ; Definition at line 95 of file RNTupleWriteOptions.hxx. ◆ fInitialNElementsPerPage. std::size_t ROOT::Experimental::RNTupleWriteOptions::fInitialNElementsPerPage = 64. protected . Initially, columns start with a page large enough to hold the given number of elements. ; The initial page size is the given number of elements multiplied by the column's element size. If more elements are needed, pages are increased up until the byte limit given by fMaxUnzippedPageSize or until the total page buffer limit is reached (as a sum of all page buffers). The total write buffer limit needs to be large enough to hold the initial pages of all columns. ; Definition at line 73 of file RNTupleWriteOptions.hxx. ◆ fMaxKeySize. std::uint64_t ROOT::Experimental::RNTupleWriteOptions::fMaxKeySize = kDefaultMaxKeySize. protected . Specifies the max size of a payload storeable into a single TKey. ; When writing an RNTuple to a ROOT file, any payload whose size exceeds this will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:9415,checksum,checksums,9415,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['checksum'],['checksums']
Security,"of file RPadBase.cxx. ◆ Divide(). std::vector< std::vector< std::shared_ptr< RPad > > > RPadBase::Divide ; (; int ; nHoriz, . int ; nVert, . const RPadExtent & ; padding = {} . ). Divide this pad into a grid of subpads with padding in between. ; Divide pad on nHoriz X nVert subpads Return array of array of pads.; Parameters. nHorizNumber of horizontal pads. ; nVertNumber of vertical pads. ; paddingPadding between pads. . Returnsvector of vector (ret[x][y]) of created pads. ; Definition at line 154 of file RPadBase.cxx. ◆ Draw() [1/3]. template<class T , class... ARGS> . std::shared_ptr< T > ROOT::Experimental::RPadBase::Draw ; (; ARGS... ; args). inline . Create drawable of specified class T. ; Definition at line 95 of file RPadBase.hxx. ◆ Draw() [2/3]. template<class T , class... ARGS> . auto ROOT::Experimental::RPadBase::Draw ; (; const std::shared_ptr< T > & ; what, . ARGS... ; args . ). inline . Add object to be painted. ; Correspondent drawable will be created via GetDrawable() function which should be defined and be accessed at calling time. If required, extra arguments for GetDrawable() function can be provided. ; Definition at line 81 of file RPadBase.hxx. ◆ Draw() [3/3]. std::shared_ptr< RDrawable > ROOT::Experimental::RPadBase::Draw ; (; std::shared_ptr< RDrawable > && ; drawable). inline . Add existing drawable instance to canvas. ; Definition at line 120 of file RPadBase.hxx. ◆ FindPadForPrimitiveWithDisplayId(). const RPadBase * RPadBase::FindPadForPrimitiveWithDisplayId ; (; const std::string & ; display_id); const. Find subpad which contains primitive with given display id. ; Definition at line 87 of file RPadBase.cxx. ◆ FindPrimitive(). std::shared_ptr< RDrawable > RPadBase::FindPrimitive ; (; const std::string & ; id); const. Find primitive with specified id. ; Definition at line 40 of file RPadBase.cxx. ◆ FindPrimitiveByDisplayId(). std::shared_ptr< RDrawable > RPadBase::FindPrimitiveByDisplayId ; (; const std::string & ; display_id); const. Find pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPadBase.html:9144,access,accessed,9144,doc/master/classROOT_1_1Experimental_1_1RPadBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPadBase.html,1,['access'],['accessed']
Security,"of file TDavixFile.cxx. ◆ ReadBufferAsync(). Bool_t TDavixFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented from TFile.; Definition at line 774 of file TDavixFile.cxx. ◆ ReadBuffers(). Bool_t TDavixFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 790 of file TDavixFile.cxx. ◆ Seek(). void TDavixFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Reimplemented from TFile.; Definition at line 710 of file TDavixFile.cxx. ◆ setCACheck(). void TDavixFile::setCACheck ; (; Bool_t ; check). Enable or disable certificate authority check. ; Definition at line 827 of file TDavixFile.cxx. ◆ Streamer(). virtual void TDavixFile::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TDavixFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TDavixFile.h. ◆ WriteBuffer(). Bool_t TDavixFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). virtual . Write a buffer to the file. ; This is the basic low level write operation. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 809 of file TDavixFile.cxx. Member Data Documentation. ◆ d_ptr. TDavixFileInternal* TDavixFile::d_ptr. private . Definition at line 72 of file TDavixFile.h. Libraries for TDavixFile:. [legend]; The documentation for this class was generated from the following files:; net/davix/inc/TDavixFile.h; net/davix/src/TDavixFile.cxx. TDavixFile. ROOT master - Reference Gu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:47284,certificate,certificate,47284,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['certificate'],['certificate']
Security,"of file TEveText.h. Public Member Functions;  TEveText (const char *txt="""");  Constructor. ;  ;  ~TEveText () override;  ; void ComputeBBox () override;  Fill bounding-box information. ;  ; Bool_t GetAutoLighting () const;  ; Float_t GetExtrude () const;  ; Int_t GetFontFile () const;  ; Int_t GetFontMode () const;  ; Int_t GetFontSize () const;  ; Bool_t GetLighting () const;  ; const TGPicture * GetListTreeIcon (Bool_t open=kFALSE) override;  Return TEveText icon. ;  ; Float_t GetPolygonOffset (Int_t i) const;  ; const char * GetText () const;  ; TClass * IsA () const override;  ; void Paint (Option_t *option="""") override;  Paint this object. Only direct rendering is supported. ;  ; void SetAutoLighting (Bool_t isOn);  ; void SetExtrude (Float_t x);  ; void SetFontFile (const char *name);  Set font file regarding to static TGLFontManager fgFontFileArray. ;  ; void SetFontFile (Int_t file);  ; void SetFontMode (Int_t mode);  Set FTFont class ID. ;  ; void SetFontSize (Int_t size, Bool_t validate=kTRUE);  Set valid font size. ;  ; void SetLighting (Bool_t isOn);  ; void SetPolygonOffset (Float_t factor, Float_t units);  Set the scale and units used to calculate depth values. ;  ; void SetText (const char *t);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveElement;  TEveElement ();  Default constructor. ;  ;  TEveElement (Color_t &main_color);  Constructor. ;  ;  TEveElement (const TEveElement &e);  Copy constructor. ;  ; virtual ~TEveElement ();  Destructor. ;  ; virtual Bool_t AcceptElement (TEveElement *el);  Check if el can be added to this element. ;  ; virtual void AddElement (TEveElement *el);  Add el to the list of children. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TEveElement *parent);  Add this render element into ltree to all items belonging to parent. ;  ; virtual TGListTreeItem * AddIntoListTree (TGListTree *ltree, TGListTreeIte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveText.html:1496,validat,validate,1496,doc/master/classTEveText.html,https://root.cern,https://root.cern/doc/master/classTEveText.html,1,['validat'],['validate']
Security,"of file THashTable.cxx. ◆ AverageCollisions(). Float_t THashTable::AverageCollisions ; (; ); const. inline . Definition at line 85 of file THashTable.h. ◆ Class(). static TClass * THashTable::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THashTable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THashTable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 82 of file THashTable.h. ◆ Clear(). void THashTable::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the table. ; Does not delete the objects unless the THashTable is the owner (set via SetOwner()). ; Implements TCollection.; Definition at line 167 of file THashTable.cxx. ◆ Collisions() [1/2]. Int_t THashTable::Collisions ; (; const char * ; name); const. Returns the number of collisions for an object with a certain name (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 191 of file THashTable.cxx. ◆ Collisions() [2/2]. Int_t THashTable::Collisions ; (; TObject * ; obj); const. Returns the number of collisions for an object (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 205 of file THashTable.cxx. ◆ DeclFileName(). static const char * THashTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 82 of file THashTable.h. ◆ Delete(). void THashTable::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the table AND delete all heap based objects. ; Implements TCollection.; Definition at line 220 of file THashTable.cxx. ◆ Empty(). Bool_t THashTable::Empty ; (; ); const. inline . Definition at line 66 of file THashTable.h. ◆ FindObject() [1/2]. TObject * THashTable::FindObject ; (; const char * ; name); const. overridevirtual . Find",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:19396,hash,hash,19396,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"of the event-loop, see the following two code snippets. We assume our ROOT file has branches a, b and c.; The correct way - the dataset is only processed once. df_correct = ROOT.RDataFrame(treename, filename);; ; h_a = df_correct.Histo1D(""a""); h_b = df_correct.Histo1D(""b""); h_c = df_correct.Histo1D(""c""); ; h_a_val = h_a.GetValue(); h_b_val = h_b.GetValue(); h_c_val = h_c.GetValue(); ; print(f""How many times was the data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; An incorrect way - the dataset is processed three times. df_incorrect = ROOT.RDataFrame(treename, filename);; ; h_a = df_incorrect.Histo1D(""a""); h_a_val = h_a.GetValue(); ; h_b = df_incorrect.Histo1D(""b""); h_b_val = h_b.GetValue(); ; h_c = df_incorrect.Histo1D(""c""); h_c_val = h_c.GetValue(); ; print(f""How many times was the data set processed? {df_wrong.GetNRuns()} times."") # The answer will be 3 times. ; It is therefore good practice to declare all your transformations and actions before accessing their results, allowing RDataFrame to run the loop once and produce all results in one go. Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores. The only modification required to the snippets would be the addition of this line before constructing the main dataframe object: ROOT::EnableImplicitMT();; Simple as that. More details are given below. Working with collections and object selections; RDataFrame reads collections as the special type ROOT::RVec: for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way.; RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays.; For example, to fill a histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:26936,access,accessing,26936,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['accessing']
Security,"of this class . ◆ Class_Version(). static constexpr Version_t TS3WebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 105 of file TS3WebFile.h. ◆ DeclFileName(). static const char * TS3WebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 105 of file TS3WebFile.h. ◆ GetAccessKey(). const TString & TS3WebFile::GetAccessKey ; (; ); const. inline . Definition at line 96 of file TS3WebFile.h. ◆ GetBucket(). const TString & TS3WebFile::GetBucket ; (; ); const. inline . Definition at line 98 of file TS3WebFile.h. ◆ GetCredentialsFromEnv(). Bool_t TS3WebFile::GetCredentialsFromEnv ; (; const char * ; accessKeyEnv, . const char * ; secretKeyEnv, . const char * ; tokenEnv, . TString & ; outAccessKey, . TString & ; outSecretKey, . TString & ; outToken . ). private . Sets the access and secret keys from the environmental variables, if they are both set. ; Sets the security session token if it is given. ; Definition at line 366 of file TS3WebFile.cxx. ◆ GetHead(). Int_t TS3WebFile::GetHead ; (; ). overrideprotectedvirtual . Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this file. ; Uses TS3HTTPRequest to generate an HTTP HEAD request which includes the authorization header expected by the S3 server. ; Reimplemented from TWebFile.; Definition at line 287 of file TS3WebFile.cxx. ◆ GetObjectKey(). const TString & TS3WebFile::GetObjectKey ; (; ); const. inline . Definition at line 99 of file TS3WebFile.h. ◆ GetSecretKey(). const TString & TS3WebFile::GetSecretKey ; (; ); const. inline . Definition at line 97 of file TS3WebFile.h. ◆ GetUrl(). const TUrl & TS3WebFile::GetUrl ; (; ); const. inline . Definition at line 100 of file TS3WebFile.h. ◆ IsA(). TClass * TS3WebFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFile.; Definition at line 105 of file TS3WebFile.h. ◆ ParseOptions(). B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:52763,secur,security,52763,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['secur'],['security']
Security,"of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl, Bool_t recurse = kTRUE) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:31602,access,accessible,31602,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['access'],['accessible']
Security,"of::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. ◆ CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket * ; s, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. ◆ CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave * ; sl, . Int_t ; port . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. ◆ CreateSlave(). TSlave * TProof::CreateSlave ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . const char * ; workdir . ). protected . Create a new TSlave of type TSlave::kSlave. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 1853 of file TProof.cxx. ◆ CreateSubmaster(). TSlave * TProof::CreateSubmaster ; (; const char * ; url, . const char * ; ord, . const char * ; image, . const char * ; msd, . Int_t ; nwk = 1 . ). protected . Create a new TSlave of type TSlave::kMaster. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:79314,access,accessed,79314,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['access'],['accessed']
Security,"offset);; 229public:; 230 void Update(const TClass *oldClass, TClass *newClass) override;; 231 ; 232 /// \brief Generate the TClass and TStreamerInfo for the requested pair.; 233 /// This creates a TVirtualStreamerInfo for the pair and trigger the BuildCheck/Old to; 234 /// provokes the creation of the corresponding TClass. This relies on the dictionary for; 235 /// std::pair<const int, int> to already exist (or the interpreter information being available); 236 /// as it is used as a template.; 237 /// \note The returned object is owned by the caller.; 238 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 239 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &firstname, const std::string &secondname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 240 ; 241 TVirtualCollectionProxy *GenEmulatedProxy(const char* class_name, Bool_t silent) override;; 242 TClassStreamer *GenEmulatedClassStreamer(const char* class_name, Bool_t silent) override;; 243 TVirtualCollectionProxy *GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 244 TClassStreamer *GenExplicitClassStreamer(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 245 ; 246 static TStreamerElement *GetCurrentElement();; 247 ; 248public:; 249 // For access by the StreamerInfoActions.; 250 template <class T>; 251 Int_t WriteBufferAux (TBuffer &b, const T &arr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr,Int_t eoffset,Int_t mode);; 252 ; 253 //WARNING this class version must be the same as TVirtualStreamerInfo; 254 ClassDefOverride(TStreamerInfo,9) //Streamer information for one class version; 255};; 256 ; 257 ; 258#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; ULong_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:15125,access,access,15125,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['access'],['access']
Security,"ofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ws.C;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:126583,access,access,126583,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['access'],['access']
Security,"og)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209946,secur,secure,209946,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['secur'],['secure']
Security,"ogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);. returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3.; Alphanumeric Bin Labels; By default, an histogram axis is drawn with i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:4259,access,access,4259,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['access'],['access']
Security,ogram with a float per channel (see TH1 documentation)} ;  CTH2GLRendering of TH2 and derived classes ;  CTH2I2-D histogram with an int per channel (see TH1 documentation)} ;  CTH2Poly2D Histogram with Polygonal Bins ;  CTH2PolyBinHelper class to represent a bin in the TH2Poly histogram ;  CTH2S2-D histogram with a short per channel (see TH1 documentation) ;  CTH3The 3-D histogram classes derived from the 1-D histogram classes ;  CTH3C3-D histogram with a byte per channel (see TH1 documentation) ;  CTH3D3-D histogram with a double per channel (see TH1 documentation)} ;  CTH3F3-D histogram with a float per channel (see TH1 documentation)} ;  CTH3GLOpenGL renderer class for TH3 ;  CTH3I3-D histogram with an int per channel (see TH1 documentation)} ;  CTH3S3-D histogram with a short per channel (see TH1 documentation) ;  CTHaarMatrixT;  CTHashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject's ;  CTHashTableTHashTable implements a hash table to store TObject's ;  CTHashTableIterIterator of hash table ;  CTHbookBranchHBOOK Branch ;  CTHbookFileThis class is an interface to the Hbook objects in Hbook files ;  CTHbookKeyHBOOK Key ;  CTHbookTreeA wrapper class supporting Hbook ntuples (CWN and RWN) ;  CTHDFSFileReads and writes its data via the HDFS protocols ;  CTHDFSSystemDirectory handler for HDFS (THDFSFile) ;  CTHelixTHelix has two different constructors ;  CTHilbertMatrixT;  CTHilbertMatrixTSym;  CTHistPainterThe histogram painter class ;  CTHistRenderingRegion;  CTHLimitsFinderClass to compute nice axis limits ;  CTHnMultidimensional histogram ;  CTHnBaseMultidimensional histogram base ;  CTHnChainA class to chain together multiple histograms ;  CTHnIterIterator over THnBase bins ;  CTHnSparseEfficient multidimensional histogram ;  CTHnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse ;  CTHnSparseTTemplated implementation of the abstract base THnSparse ;  CTHnTTemplated implementation of the a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:179554,hash,hash,179554,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['hash'],['hash']
Security,ograms (one char per channel); TH2D 2-Dim histograms (one double per channel); TH2Editor TH2 editor; TH2F 2-Dim histograms (one float per channel); TH2GL GL renderer for TH2.; TH2I 2-Dim histograms (one 32 bits integer per channel); TH2Poly 2-Dim histogram with polygon bins; TH2PolyBin 2-Dim polygon bins; TH2S 2-Dim histograms (one short per channel); TH3 3-Dim histogram base class; TH3C 3-Dim histograms (one char per channel); TH3D 3-Dim histograms (one double per channel); TH3F 3-Dim histograms (one float per channel); TH3GL GL renderer class for TH3.; TH3I 3-Dim histograms (one 32 bits integer per channel); TH3S 3-Dim histograms (one short per channel); THLimitsFinder Class to find best axis limits; THStack A collection of histograms; THYPE HYPE shape; THaarMatrixT<double> ; THaarMatrixT<float> ; THashList Doubly linked list with hashtable for lookup; THashTable A hash table; THashTableIter Hash table iterator; THbookBranch A branch for a THbookTree; THbookFile ROOT interface to Hbook/PAW files; THbookKey Hbook id descriptor; THbookTree A wrapper class supporting Hbook ntuples (CWN and RWN); THelix A Helix drawn as a PolyLine3D; THilbertMatrixT<double> ; THilbertMatrixT<float> ; THilbertMatrixTSym<double> ; THilbertMatrixTSym<float> ; THistPainter Helper class to draw histograms; THn Base class for multi-dimensional histogram; THnBase Common base for n-dimensional histogram; THnIter Iterator over bins of a THnBase.; THnSparse Interfaces of sparse n-dimensional histogram; THnSparseArrayChunk chunks of linearized bins; THnSparseT<TArrayC> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayD> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayF> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THnT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:94471,hash,hashtable,94471,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['hash'],"['hash', 'hashtable']"
Security,"oid *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; char * EscapeChars (const char *text) const;  Introduce an escape character (@) in front of a special chars. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const char *onfile_classname, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const TClass *onfile_cl, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindStreamerInfo (UInt_t checksum, Bool_t isTransient=kFALSE) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; TVirtualStreamerInfo * FindStreamerInfoAbstractEmulated (UInt_t checksum) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; void ForceReload (TClass *oldcl);  we found at least one equivalent. ;  ; TClass * GetActualClass (const void *object) const;  Return a pointer to the real class of the object. ;  ; TClass * GetBaseClass (const char *classname);  Return pointer to the base class ""classname"". ;  ; TClass * GetBaseClass (const TClass *base);  Return pointer to the base class ""cl"". ;  ; Int_t GetBaseClassOffset (const TClass *toBase, void *address=nullptr, bool isDerivedObject=true);  ; TClass * GetBaseDataMember (const char *datamember);  Return pointer to (base) class that contains datamember. ;  ; UInt_t GetCheckSum (Bool_t &isvalid) const;  Return GetCheckSum(kCurrentCheckSum,isvalid);. ;  ; UInt_t GetCheckSum (ECheckSum code, Bool_t &isvalid) const;  Compute and/or return the class check sum. ;  ; UInt_t GetCheckSum (ECheckSum code=kCurrentCheckSum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:9222,checksum,checksum,9222,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['checksum'],['checksum']
Security,"oid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TStatsFeedback::HashULong_t Hash() const overrideReturn hash value for this object.Definition TStatsFeedback.h:42. Reimplemented from TObject.; Definition at line 42 of file TStatsFeedback.h. ◆ IsA(). TClass * TStatsFeedback::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 44 of file TStatsFeedback.h. ◆ Streamer(). void TStatsFeedback::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TStatsFeedback::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file TStatsFeedback.h. Member Data Documentation. ◆ fName. TString TStatsFeedback::fName. protected . Definition at line 34 of file TStatsFeedback.h. ◆ fProof. TProof* TStatsFeedback::fProof. protected . Definition at line 35 of file TStatsFeedback.h. proof/proofplayer/inc/TStatsFeedback.h; proof/proofplayer/src/TStatsFeedback.cxx. TStatsFeedback. ROOT ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatsFeedback.html:17418,hash,hash,17418,doc/master/classTStatsFeedback.html,https://root.cern,https://root.cern/doc/master/classTStatsFeedback.html,1,['hash'],['hash']
Security,"oid Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. ULong_t * GetElems() const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t * GetOffsets() const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return TestBit(kIsCompiled); }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name). TClassStreamer * GenEmulatedClassStreamer(const char* class_name). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualStreamerInfo.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualStreamerInfo.html:12631,checksum,checksum,12631,root/html528/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TVirtualStreamerInfo.html,1,['checksum'],['checksum']
Security,"oid Compile(). void ForceWriteInfo(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. ULong_t * GetElems() const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t * GetOffsets() const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return TestBit(kIsCompiled); }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name). TClassStreamer * GenEmulatedClassStreamer(const char* class_name). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualStreamerInfo.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualStreamerInfo.html:12700,checksum,checksum,12700,root/html530/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html530/TVirtualStreamerInfo.html,1,['checksum'],['checksum']
Security,"oid* feed(void *from, void *to, size_t size) {; 386 PCont_t c = PCont_t(to);; 387 PValue_t m = PValue_t(from);; 388 for (size_t i=0; i<size; ++i, ++m); 389 c->push_back(*m);; 390 return nullptr;; 391 }; 392 static int value_offset() {; 393 return 0;; 394 }; 395 };; 396 ; 397 /** @class ROOT::Detail::TCollectionProxyInfo::Pushfront; 398 *; 399 * Small helper to encapsulate all necessary data accesses for; 400 * containers like forward_list; 401 *; 402 * @author D.Piparo; 403 * @version 1.0; 404 * @date 26/02/2015; 405 */; 406 template <class T> struct Pushfront : public Type<T> {; 407 typedef T Cont_t;; 408 typedef typename T::iterator Iter_t;; 409 typedef typename T::value_type Value_t;; 410 typedef Environ<Iter_t> Env_t;; 411 typedef Env_t *PEnv_t;; 412 typedef Cont_t *PCont_t;; 413 typedef Value_t *PValue_t;; 414 static void resize(void* obj, size_t n) {; 415 PCont_t c = PCont_t(obj);; 416 c->resize(n);; 417 }; 418 static void* feed(void *from, void *to, size_t size) {; 419 PCont_t c = PCont_t(to);; 420 if (size==0) return nullptr;; 421 PValue_t m = &(PValue_t(from)[size-1]); // Take the last item; 422 // Iterate backwards not to revert ordering; 423 for (size_t i=0; i<size; ++i, --m){; 424 c->push_front(*m);; 425 }; 426 return nullptr;; 427 }; 428 static int value_offset() {; 429 return 0;; 430 }; 431 };; 432 ; 433 /** @class ROOT::Detail::TCollectionProxyInfo::Insert; 434 *; 435 * Small helper to encapsulate all necessary data accesses for; 436 * containers like set, multiset etc.; 437 *; 438 * @author M.Frank; 439 * @version 1.0; 440 * @date 10/10/2004; 441 */; 442 template <class T> struct Insert : public Type<T> {; 443 typedef T Cont_t;; 444 typedef typename T::iterator Iter_t;; 445 typedef typename T::value_type Value_t;; 446 typedef Environ<Iter_t> Env_t;; 447 typedef Env_t *PEnv_t;; 448 typedef Cont_t *PCont_t;; 449 typedef Value_t *PValue_t;; 450 static void* feed(void *from, void *to, size_t size) {; 451 PCont_t c = PCont_t(to);; 452 PValue_t m = PValue_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:14225,access,accesses,14225,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security,"oid*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; TMethod*GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:3795,checksum,checksum,3795,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"oidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Terminate(); Deletes the class table (this static class function calls the dtor). TClassTable(). » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClassTable.html:8171,hash,hash,8171,root/html534/TClassTable.html,https://root.cern,https://root.cern/root/html534/TClassTable.html,2,['hash'],['hash']
Security,"oidStreamerNVirtual(TBuffer& b); voidSuppressMinuitWarnings(bool nowarn = true); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:5128,validat,validated,5128,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,1,['validat'],['validated']
Security,"oidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(const void* obj, Bool_t noAddr = kFALSE) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); const void*DynamicCast(const TClass* base, const void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tGetCheckSum(Bool_t& isvalid) const; UInt_tGetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tGetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:3531,checksum,checksum,3531,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"oid StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Validate () const;  Validate this overlap. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoOverlap.html:4493,hash,hash,4493,doc/master/classTGeoOverlap.html,https://root.cern,https://root.cern/doc/master/classTGeoOverlap.html,1,['hash'],['hash']
Security,"olAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:35678,access,access,35678,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,2,['access'],['access']
Security,"ol_t MatchLegacyCheckSum(UInt_t checksum) const;; 198 TVirtualStreamerInfo *NewInfo(TClass *cl) override { return new TStreamerInfo(cl); }; 199 void *New(void *obj = nullptr) override;; 200 void *NewArray(Long_t nElements, void* ary = nullptr) override;; 201 void Destructor(void* p, Bool_t dtorOnly = kFALSE) override;; 202 void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) override;; 203 void PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;; 204 void PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 205 void PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 206 ; 207 template <class T>; 208 Int_t ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr=1,Int_t eoffset=0,Int_t mode=0);; 209 template <class T>; 210 Int_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 211 template <class T>; 212 Int_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 213 template <class T>; 214 Int_t ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 215 ; 216 Int_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset);; 217 Int_t ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE );; 218 void SetCheckSum(UInt_t checksum) override { fCheckSum = checksum; }; 219 void SetClass(TClass *cl) override;; 220 void SetClassVersion(Int_t vers) override { fClassVersion = vers; }; 221 void SetOnFileClassVersion(Int_t vers) { fOnFileClassVersion = vers; }; 222 void TagFile(TFile *fFile) override;; 223private:; 224 // Try to remove those functions from the public interface.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:13009,checksum,checksum,13009,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,2,['checksum'],['checksum']
Security,"ol_t a); voidSetClip(TGLClip* p); voidSetLOD(Short_t lod); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; TGLSceneBase(); virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&); TGLSceneBase(const TGLSceneBase&). Data Members; public:. static TGLLockable::ELockTGLLockable::kDrawLock; static TGLLockable::ELockTGLLockable::kModifyLock; static TGLLockable::ELockTGLLockable::kSelectLock; static TGLLockable::ELockTGLLockable::kUnlocked. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; TGLSceneBase::ViewerList_tfViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSceneBase(); Default constructor. ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSceneBase.html:3801,access,access,3801,root/html602/TGLSceneBase.html,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html,2,['access'],['access']
Security,"ol_t needingAlloc ) const;; 35 Bool_t HasRuleWithTarget( const TString& name, Bool_t willset ) const;; 36 };; 37 ; 38 enum EConsistencyCheck {; 39 kNoCheck = 0,; 40 kCheckAll = 1,; 41 kCheckConflict = 2; 42 };; 43 ; 44 TSchemaRuleSet();; 45 virtual ~TSchemaRuleSet();; 46 ; 47 Bool_t AddRule(TSchemaRule *rule, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 48 Bool_t AddRules(TSchemaRuleSet *rules, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 49 Bool_t HasRuleWithSourceClass( const TString &source) const;; 50 const TMatches FindRules( const TString &source ) const;; 51 const TMatches FindRules( const TString &source, Int_t version ) const;; 52 const TMatches FindRules( const TString &source, UInt_t checksum ) const;; 53 const TMatches FindRules( const TString &source, Int_t version, UInt_t checksum ) const;; 54 TClass* GetClass();; 55 UInt_t GetClassCheckSum() const;; 56 TString GetClassName() const;; 57 Int_t GetClassVersion() const;; 58 const TObjArray* GetRules() const;; 59 const TObjArray* GetPersistentRules() const;; 60 void RemoveRule( TSchemaRule* rule );; 61 void RemoveRules( TObjArray* rules );; 62 void SetClass( TClass* cls );; 63 ; 64 void ls(Option_t *option="""") const override;; 65 void AsString(TString &out) const;; 66 ; 67 private:; 68 TObjArray* fPersistentRules; // Array of the rules that will be embeded in the file; 69 TObjArray* fRemainingRules; //! Array of non-persistent rules - just for cleanup purposes - owns the elements; 70 TObjArray* fAllRules; //! Array of all rules; 71 TClassRef fClass; //! Target class pointer (for consistency checking); 72 TString fClassName; // Target class name; 73 Int_t fVersion; // Target class version; 74 UInt_t fCheckSum; // Target class checksum; 75 ; 76 ClassDefOverride( TSchemaRuleSet, 1 ); 77 ; 78 };; 79 ; 80} // End of Namespace Detail; 81} // End of Namespace ROOT; 82 ; 83#endif // ROOT_TSchemaRuleSet; Option_tconst char Option_tDefinition RtypesCore.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html:2753,checksum,checksum,2753,doc/master/TSchemaRuleSet_8h_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html,1,['checksum'],['checksum']
Security,"ol_t fgInit = kFALSE;  ; static UInt_t fgLastButton = 0;  ; static Time_t fgLastClick = 0;  ; static const TGGC * fgShadowGC = nullptr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGMdiDecorFrame.h>. Inheritance diagram for TGMdiTitleIcon:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGMdiTitleIcon(). TGMdiTitleIcon::TGMdiTitleIcon ; (; const TGWindow * ; p, . const TGWindow * ; titlebar, . const TGPicture * ; pic, . Int_t ; w, . Int_t ; h . ). TGMdiTitleIcon constructor. ; the TGMdiTitleIcon is the left icon used also for the MDI popup menu allowing access to MDI commands as : restore, move, size, minimize and close. ; Definition at line 688 of file TGMdiDecorFrame.cxx. ◆ ~TGMdiTitleIcon(). TGMdiTitleIcon::~TGMdiTitleIcon ; (; ). override . TGMdiTitleIcon destructor. ; Definition at line 715 of file TGMdiDecorFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGMdiTitleIcon::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGMdiTitleIcon::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGMdiTitleIcon::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 170 of file TGMdiDecorFrame.h. ◆ DeclFileName(). static const char * TGMdiTitleIcon::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TGMdiDecorFrame.h. ◆ DoRedraw(). void TGMdiTitleIcon::DoRedraw ; (; ). overrideprotectedvirtual . Redraw i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMdiTitleIcon.html:29002,access,access,29002,doc/master/classTGMdiTitleIcon.html,https://root.cern,https://root.cern/doc/master/classTGMdiTitleIcon.html,1,['access'],['access']
Security,"olean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSecondMoment.html:33501,access,access,33501,root/html534/RooSecondMoment.html,https://root.cern,https://root.cern/root/html534/RooSecondMoment.html,1,['access'],['access']
Security,"olean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooRealProxy_ixfInt(X*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:33389,access,access,33389,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,2,['access'],['access']
Security,"ollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyListStack of recursive proxies; TObjArray*TGenCollectionProxy::fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(); Some hack to avoid const-n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedCollectionProxy.html:5398,access,accessors,5398,root/html528/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedCollectionProxy.html,6,['access'],['accessors']
Security,"ollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyListStack of recursive proxies; TObjArray*TGenCollectionProxy::fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReadMap(int nElements, TBuffer& b); Map input streamer. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedMapProxy.html:5658,access,accessors,5658,root/html528/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedMapProxy.html,6,['access'],['accessors']
Security,"ollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextContainer accessors: generic iteration: next; TClass*TGenCollectionProxy::fOnFileClassOn file class; Bool_tTGenCollectionProxy::fPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >TGenCollectionProxy::fProxyListStack of recursive proxies; TObjArray*TGenCollectionProxy::fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*TGenCollectionProxy::fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:5454,access,accessors,5454,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,6,['access'],['accessors']
Security,"ollectionProxyInfo::Iterators< Cont_t, true >::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:206; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::nextstatic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:192; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:182; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::destruct1static void destruct1(void *begin_ptr)Definition TCollectionProxyInfo.h:202; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::copystatic void * copy(void *, const void *source_ptr)Definition TCollectionProxyInfo.h:187; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:179; ROOT::Detail::TCollectionProxyInfo::IteratorsSmall helper to implement the function to create,access and destroy iterators.Definition TCollectionProxyInfo.h:94; ROOT::Detail::TCollectionProxyInfo::Iterators::nextstatic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:108; ROOT::Detail::TCollectionProxyInfo::Iterators::copystatic void * copy(void *dest_arena, const void *source_ptr)Definition TCollectionProxyInfo.h:103; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:122; ROOT::Detail::TCollectionProxyInfo::Iterators::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:98; ROOT::Detail::TCollectionProxyInfo::Iterators::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:95; ROOT::Detail::TCollectionProxyInfo::Iterators::iteratorCont_t::iterator iteratorDefinition TCollectionProxyInfo.h:96; ROOT::Detail::TCollectionProxyInfo::Iterat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:41713,access,access,41713,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['access']
Security,"ollowing options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2777,validat,validation,2777,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security,"ollowing options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=20,Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mTMVA_DNN␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:7312,validat,validation,7312,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['validat'],['validation']
Security,"olor behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:6952,access,accessibility,6952,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['accessibility']
Security,"olor(kRed));; ; // S a v i n g a n d l o a d i n g f r o m f i l e; // -------------------------------------------------------; ; // Datasets can be persisted with ROOT I/O; cout << endl << "">> Persisting d via ROOT I/O"" << endl;; TFile f(""rf402_datahandling.root"", ""RECREATE"");; d.Write();; f.ls();; ; // To read back in future session:; // > TFile f(""rf402_datahandling.root"") ;; // > RooDataSet* d = (RooDataSet*) f.FindObject(""d"") ;; ; new TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600);; gPad->SetLeftMargin(0.15);; yframe->GetYaxis()->SetTitleOffset(1.4);; yframe->Draw();; }; d#define d(i)Definition RSha256.hxx:102; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RooCategory.h; RooDataHist.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; Int_tint Int_tDefinition RtypesCore.h:45; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TFile.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsCollection::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition RooAbsCollection.h:315; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::mergebool merge(RooDataSet *data1, RooDataSet *data2=nullptr, RooDataSet *data3=nullptr, RooDataSet *data4=nullptr, RooDataSet *data5=nullptr, RooDataSet *data6=nullptr)Definition RooDataSet.cxx:1079; RooDataSet::appendvoid append(RooDataSet &data)Add all data points of given data set to this data set.Definition RooDataSet.cxx:1138; RooPlotPlot frame and a container for gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:6527,access,access,6527,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['access'],['access']
Security,"ols,; 14227 &ws_connect_handler,; 14228 &ws_ready_handler,; 14229 &ws_data_handler,; 14230 &ws_close_handler,; 14231 NULL,; 14232 &callback_data,; 14233 &handler_info)) {; 14234 /* 5.2.1. A callback will handle this request. All requests; 14235 * handled by a callback have to be considered as requests; 14236 * to a script resource. */; 14237 is_callback_resource = 1;; 14238 is_script_resource = 1;; 14239 is_put_or_delete_request = is_put_or_delete_method(conn);; 14240 } else {; 14241 no_callback_resource:; 14242 ; 14243 /* 5.2.2. No callback is responsible for this request. The URI; 14244 * addresses a file based resource (static content or Lua/cgi; 14245 * scripts in the file system). */; 14246 is_callback_resource = 0;; 14247 interpret_uri(conn,; 14248 path,; 14249 sizeof(path),; 14250 &file.stat,; 14251 &is_found,; 14252 &is_script_resource,; 14253 &is_websocket_request,; 14254 &is_put_or_delete_request,; 14255 &is_template_text_file);; 14256 }; 14257 ; 14258 /* 6. authorization check */; 14259 /* 6.1. a custom authorization handler is installed */; 14260 if (get_request_handler(conn,; 14261 AUTH_HANDLER,; 14262 NULL,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 &auth_handler,; 14269 &auth_callback_data,; 14270 NULL)) {; 14271 if (!auth_handler(conn, auth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:419316,authoriz,authorization,419316,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"ols,; 14228 &ws_connect_handler,; 14229 &ws_ready_handler,; 14230 &ws_data_handler,; 14231 &ws_close_handler,; 14232 NULL,; 14233 &callback_data,; 14234 &handler_info)) {; 14235 /* 5.2.1. A callback will handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script_resource = 1;; 14240 is_put_or_delete_request = is_put_or_delete_method(conn);; 14241 } else {; 14242 no_callback_resource:; 14243 ; 14244 /* 5.2.2. No callback is responsible for this request. The URI; 14245 * addresses a file based resource (static content or Lua/cgi; 14246 * scripts in the file system). */; 14247 is_callback_resource = 0;; 14248 interpret_uri(conn,; 14249 path,; 14250 sizeof(path),; 14251 &file.stat,; 14252 &is_found,; 14253 &is_script_resource,; 14254 &is_websocket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:419349,authoriz,authorization,419349,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"olstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:454049,access,access,454049,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"olstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:454082,access,access,454082,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"olume copy number; opSurfaceName name of optical surface which this border belongs to; (Geant4 only); Define the optical skin surface; name skin surface name; volName volume name; opSurfaceName name of optical surface which this border belongs to; (Geant4 only). void SetMaterialProperty(Int_t itmed, const char* propertyName, Double_t value); Define material property via a table of values; itmed tracking medium id; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only); Define material property via a value; itmed tracking medium id; propertyName property name; value property value; (Geant4 only). Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Define optical surface property via a table of values; surfaceName optical surface name; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id - NEW. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:25147,access,access,25147,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,2,['access'],['access']
Security,"olume copy number; opSurfaceName name of optical surface which this border belongs to; (Geant4 only); Define the optical skin surface; name skin surface name; volName volume name; opSurfaceName name of optical surface which this border belongs to; (Geant4 only). void SetMaterialProperty(Int_t itmed, const char* propertyName, Double_t value); Define material property via a table of values; itmed tracking medium id; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only); Define material property via a value; itmed tracking medium id; propertyName property name; value property value; (Geant4 only). Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Define optical surface property via a table of values; surfaceName optical surface name; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMC.html:23911,access,access,23911,root/html534/TVirtualMC.html,https://root.cern,https://root.cern/root/html534/TVirtualMC.html,3,['access'],['access']
Security,"olume copy number; opSurfaceName name of optical surface which this border belongs to; (Geant4 only); Define the optical skin surface; name skin surface name; volName volume name; opSurfaceName name of optical surface which this border belongs to; (Geant4 only). void SetMaterialProperty(Int_t itmed, const char* propertyName, Double_t value); Define material property via a table of values; itmed tracking medium id; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only); Define material property via a value; itmed tracking medium id; propertyName property name; value property value; (Geant4 only). Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Define optical surface property via a table of values; surfaceName optical surface name; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the volume specified by; the volumeName. void DrawOneSpec(const char* name); Return the medium parameters for the volume specified by the; volumeName. functions for drawing; to be removed with complete move to TGeo. Deprecated - Geant3. void Gsatt(const char* name, const char* att, Int_t val); Deprecated - Geant3. void Gdraw(const char* , Double_t theta = 30, Double_t phi = 30, Double_t psi = 0, Double_t u0 = 10, Double_t v0 = 10, Double_t ul = 0.01, Double_t vl = 0.01); Deprecated - Geant3. void SetRootGeometry(); Write out the geometry of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:25401,access,access,25401,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['access'],['access']
Security,"olume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:136724,access,access,136724,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['access']
Security,"olumn.; 708 /// \param[in] expression A C++ callable that computes the new value of the defined column.; 709 /// \return the first node of the computation graph for which the new quantity is defined.; 710 ///; 711 /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; 712 /// where:; 713 /// - `T` is the type of the defined column; 714 /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; 715 /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; 716 /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; 717 /// being processed (see the class docs for more information).; 718 ///; 719 /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; 720 /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; 721 /// starts rather than at every entry.; 722 ///; 723 /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; 724 ///; 725 /// ### Example usage:; 726 /// ~~~{.cpp}; 727 /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; 728 /// df.DefinePerSample(""weightbysample"",; 729 /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); 730 /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; 731 /// ~~~; 732 // clang-format on; 733 // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch; 734 template <typename F, typename RetType_t = typename TTraits::CallableTraits<F>::ret_type>; 735 RInterface<Proxied, DS_t> DefinePerSample(std::string_view name, F expression); 736 {; 737 RDFInternal::CheckValidCppVarName(name, ""DefinePerSample"");; 738 RDFInternal::CheckForRedefinition(""DefinePerSampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:38092,inject,inject,38092,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['inject'],['inject']
Security,"olution between V1 and V2 persistent binnings. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsBinning.html:4203,hash,hash,4203,doc/master/classRooAbsBinning.html,https://root.cern,https://root.cern/doc/master/classRooAbsBinning.html,1,['hash'],['hash']
Security,"olved by Omar); 526 //static MethodBase* GetThisBase();; 527 ; 528 // some basic statistical analysis; 529 void Statistics( Types::ETreeType treeType, const TString& theVarName,; 530 Double_t&, Double_t&, Double_t&,; 531 Double_t&, Double_t&, Double_t& );; 532 ; 533 // if TRUE, write weights only to text files; 534 Bool_t TxtWeightsOnly() const { return kTRUE; }; 535 ; 536 protected:; 537 ; 538 // access to event information that needs method-specific information; 539 ; 540 Bool_t IsConstructedFromWeightFile() const { return fConstructedFromWeightFile; }; 541 ; 542 private:; 543 ; 544 // ---------- private definitions --------------------------------------------; 545 // Initialisation; 546 void InitBase();; 547 void DeclareBaseOptions();; 548 void ProcessBaseOptions();; 549 ; 550 // used in efficiency computation; 551 enum ECutOrientation { kNegative = -1, kPositive = +1 };; 552 ECutOrientation GetCutOrientation() const { return fCutOrientation; }; 553 ; 554 // ---------- private accessors ---------------------------------------------; 555 ; 556 // reset required for RootFinder; 557 void ResetThisBase();; 558 ; 559 // ---------- private auxiliary methods --------------------------------------; 560 ; 561 // PDFs for classifier response (required to compute signal probability and Rarity); 562 void CreateMVAPdfs();; 563 ; 564 // for root finder; 565 //virtual method to find ROOT; 566 virtual Double_t GetValueForRoot ( Double_t ); // implementation; 567 ; 568 // used for file parsing; 569 Bool_t GetLine( std::istream& fin, char * buf );; 570 ; 571 // fill test tree with classification or regression results; 572 virtual void AddClassifierOutput ( Types::ETreeType type );; 573 virtual void AddClassifierOutputProb( Types::ETreeType type );; 574 virtual void AddRegressionOutput ( Types::ETreeType type );; 575 virtual void AddMulticlassOutput ( Types::ETreeType type );; 576 ; 577 private:; 578 ; 579 void AddInfoItem( void* gi, const TString& name,; 580 const TString& value) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:24113,access,accessors,24113,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['access'],['accessors']
Security,"om TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual Bool_t AccessPathName (const char *path, EAccessMode mode=kFileExists);  Returns FALSE if one can access a file using the specified access mode. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual void AddTimer (TTimer *t);  Add timer to list of system timers. ;  ; virtual int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1);  Announce TCP/IP service. ;  ; virtual int AnnounceUdpService (int port, int bac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:2047,access,access,2047,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,2,['access'],['access']
Security,"om the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TEnum * Find(TListOfEnums::DeclId_t id) const; Return the TEnum corresponding to the Decl 'id' or NULL if it does not; exist. TEnum * Get(TListOfEnums::DeclId_t id, const char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:14196,hash,hash,14196,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,2,['hash'],['hash']
Security,"om. After this script is executed we have a ROOT file called tree1.root with a tree called t1. There is a possibility to fill branches one by one using the method TBranch::Fill(). In this case you do not need to call TTree::Fill() method. The entries can be set by TTree::SetEntries(Double_t n). Calling this method makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555411,access,access,555411,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"om_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TObject.h; TString.h; TEnvParserTEnv Parser.Definition TEnv.cxx:106; TEnvRecDefinition TEnv.h:86; TEnvRec::fValueTString fValueDefinition TEnv.h:96; TEnvRec::ChangeValuevoid ChangeValue(const char *v, const char *t, EEnvLevel l, Bool_t append=kFALSE, Bool_t ignoredup=kFALSE)Change the value of a resource.Definition TEnv.cxx:293; TEnvRec::GetTypeconst char * GetType() constDefinition TEnv.h:111; TEnvRec::fLevelEEnvLevel fLevelDefinition TEnv.h:97; TEnvRec::GetLevelEEnvLevel GetLevel() constDefinition TEnv.h:112; TEnvRec::TEnvRecTEnvRec()Definition TEnv.h:107; TEnvRec::GetValueconst char * GetValue() constDefinition TEnv.h:110; TEnvRec::ExpandValueTString ExpandValue(const char *v)Replace all strings by the value defined in the shell (obtained via TSystem::Getenv()).Definition TEnv.cxx:334; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TEnvRec::fNameTString fNameDefinition TEnv.h:94; TEnvRec::fTypeTString fTypeDefinition TEnv.h:95; TEnvRec::fModifiedBool_t fModifiedDefinition TEnv.h:98; TEnvRec::GetNameconst char * GetName() const overrideReturns name of object.Definition TEnv.h:109; TEnvRec::~TEnvRec~TEnvRec()TNamed destructor.Definition TEnv.cxx:284; TEnvRec::CompareInt_t Compare(const TObject *obj) const overrideComparison function for resources.Definition TEnv.cxx:325; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::fTableTHashList * fTableDefinition TEnv.h:127; TEnv::Printvoid Print(Option_t *option="""") const overridePrint all resources or the global, user or local resources separately.Definition TEnv.cxx:556; TEnv::PrintEnvvirtual void PrintEnv(EEnvLevel level=kEnvAll) constPrint all resources for a certain level (global, user, local, changed).Definition TEnv.cxx:574; TEnv::GetValuevirtual Int_t GetValu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8h_source.html:9266,hash,hash,9266,doc/master/TEnv_8h_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html,1,['hash'],['hash']
Security,"omboBoxPopup;  CTGCommandPlugin;  CTGCompositeFrame;  CTGContainer;  CTGDimension;  CTGDMAssignmentHelper;  CTGDMLBaseTGDMMapHelper;  CTGDMLParseThis class contains the implementation of the GDML parser associated to all the supported GDML elements ;  CTGDMLReflThis class is a helper class for TGDMLParse ;  ►CTGDMLWriteThis class contains implementation of converting ROOT's gGeoManager geometry to GDML file ;  CNameLst;  CStructLst;  CXyz;  CTGDMMapHelper;  CTGDNDManager;  CTGDockableFrame;  CTGDockButton;  CTGDockHideButton;  CTGDoubleHSlider;  CTGDoubleSlider;  CTGDoubleVSlider;  CTGDragWindow;  CTGedEditor;  ►CTGedFrame;  CTGedSubFrame;  CTGedMarkerPopup;  CTGedMarkerSelect;  CTGedNameFrame;  CTGedPatternFrame;  CTGedPatternPopup;  CTGedPatternSelect;  CTGedPatternSelector;  CTGedPopup;  CTGedSelect;  ►CTGenCollectionProxyProxy around an arbitrary container, which implements basic functionality and iteration ;  CMethodSmall helper to execute (compiler) generated function for the access to STL or other containers ;  CMethod0;  CStreamHelperHelper class to facilitate I/O ;  CTStagingSmall helper to stage the content of an associative container when reading and before inserting it in the actual collection ;  CValueSmall helper to describe the Value_type or the key_type of an STL container ;  CTGenCollectionStreamer;  CTGeneratorThe interface to various event generators ;  ►CTGenericCollectionIterator;  CRegularIterator;  CVectorIterator;  ►CTGenericTable;  Citerator;  CTGenPhaseSpaceUtility class to generate n-body event, with constant cross-section (default) or with Fermi energy dependence (opt=""Fermi"") ;  CTGeoArb8An arbitrary trapezoid with less than 8 vertices standing on two parallel planes perpendicular to Z axis ;  CTGeoAttVisualization and tracking attributes for volumes and nodes ;  ►CTGeoBatemanSol;  CBtCoef_t;  CTGeoBBoxBox class ;  CTGeoBBoxEditorEditor for a TGeoBBox ;  ►CTGeoBoolNodeBase class for Boolean operations between two shapes ;  CThreadData_t; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:156515,access,access,156515,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['access'],['access']
Security,"ompatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. ◆ CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwhash, . Bool_t ; srppwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; First ~/.rootnetrc is tried, after that ~/.netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ◆ ClearAuth(). Int_t TAuthenticate::ClearAuth ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwdhash . ). private . UsrPwd client authentication code. ; Returns 0 in case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:23923,secur,secure,23923,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['password', 'secur']","['password', 'secure']"
Security,"ompressionLevel(Int_t level = 1); *-*-*-*-*-*-*-*Set the branch/subbranches compression level; *-* ============================================. void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:24719,access,access,24719,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,1,['access'],['access']
Security,"on $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:5996,access,access,5996,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"on $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with ano",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html:5476,access,access,5476,root/html526/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"on $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with anoth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html:5346,access,access,5346,root/html526/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"on %d recorded the version number %d for this base class (%s)."",; 3006 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3007 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseVersion(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStreamerInfo(otherBase->GetBaseCheckSum());; 3015 if (localBaseInfo == otherBaseInfo ||; 3016 localBaseInfo->CompareContent(0,otherBaseInfo,kFALSE,kFALSE,file) ) {; 3017 // They are equivalent, no problem.; 3018 continue;; 3019 }; 3020 TString msg;; 3021 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3022 "" has the same version (=%d) as the active class but a different checksum.\n""; 3023 "" You should update the version to ClassDef(%s,%d).\n""; 3024 "" The objects on this file might not be readable because:\n""; 3025 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 3026 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3027 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseCheckSum(),; 3028 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 3029 otherBase->SetErrorMessage(msg);; 3030 }; 3031 }; 3032 }; 3033 if (!result && !complete) {; 3034 return result;; 3035 }; 3036 // Next the datamembers; 3037 done = kFALSE;; 3038 next.Reset();; 3039 infonext.Reset();; 3040 ; 3041 TMemberInfo local(GetClass());; 3042 TMemberInfo other(cl ? cl : info->GetClass());; 3043 while(!done) {; 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:121679,checksum,checksum,121679,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"on (or reference frame transformation) ;  CTQueryDescription;  CTQueryResultA container class for query results ;  CTQueryResultManagerClass managing the query-result area ;  CTQUndoManagerRecorder of operations for undo and redo ;  CTrack;  CTRadialGradientDefine a radial color gradient ;  CTRandomThis is the base class for the ROOT Random number generators ;  CTRandom1The Ranlux Random number generator class ;  CTRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer ;  CTRandom3Random number generator class based on M ;  CTRandomEngine;  CTRandomGen;  CTRangeDynCastTRangeDynCast is an adaptater class that allows the typed iteration through a TCollection ;  CTRatioPlotClass for displaying ratios, differences and fit residuals ;  CTRealDataManages the effective list of all data members for a given class ;  CTReaperTimer;  CTRecCmdEvent;  CTRecEvent;  CTRecExtraEvent;  CTRecGuiEvent;  CTRecorder;  CTRecorderInactive;  CTRecorderPaused;  CTRecorderRecording;  CTRecorderReplaying;  CTRecorderState;  CTRecWinPair;  CTRedirectOutputGuard;  CTRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject ;  CTRefArrayAn array of references to TObjects ;  CTRefArrayIterIterator of object array ;  CTRefArrayProxyA container proxy, which allows to access references stored in a TRefArray from TTree::Draw ;  CTRefCntDefinitions for TRefCnt, base class for reference counted objects ;  CTRefProxy;  CTRefTableA TRefTable maintains the association between a referenced object and the parent object supporting this referenced object ;  CTRegexpRegular expression class ;  CTRemoteObjectProtocol for browsing ROOT objects from a remote ROOT session ;  CTResponseTable;  CTRFIOFileA ROOT file that reads/writes via a rfiod server ;  CTRFIOSystemDirectory handler for RFIO ;  Ctriangulateio;  CTRint;  CTRobustEstimatorMinimum Covariance Determinant Estimator - a Fast Algorithm invented by Peter J.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:200969,access,access,200969,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['access'],['access']
Security,"on - ROOT JSON representation for object and objects members; root.xml - ROOT XML representation; root.png - PNG image (if object drawing implemented); root.gif - GIF image; root.jpeg - JPEG image; exe.json - method execution in the object; exe.bin - method execution, return result in binary form; cmd.json - command execution; item.json - item (object) properties, specified on the server; multi.json - perform several requests at once; multi.bin - perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.7.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: “title”.; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all).; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH1 object shown in the table:. Request; Size. root.bin; 1658 bytes. root.bin.gz; 782 bytes. root.json; 7555 bytes. root.json?compact=3; 5381 bytes. root.json.gz?compact=3; 1207 bytes. One should remember that JSON representation always includes names of the data fields which are ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:11046,access,access,11046,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"on = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TObjArray*FindRules(const TString& source) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version) const; const ROOT::TSchemaMatch*FindRules(const TString& source, UInt_t checksum) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version, UInt_t checksum) const; TClass*GetClass(); UInt_tGetClassCheckSum() const; TStringGetClassName() const; Int_tGetClassVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TObjArray*GetPersistentRules() const; const TObjArray*GetRules() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasRuleWithSourceClass(const TString& source) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRuleSet.html:1984,checksum,checksum,1984,root/html526/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRuleSet.html,7,['checksum'],['checksum']
Security,"on TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::GetContextMenuTitleconst char * GetContextMenuTitle() constDefinition TClass.h:438; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:66071,access,accessor,66071,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['accessor']
Security,"on TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetContextMenuTitleconst char * GetContextMenuTitle() constDefinition TClass.h:438; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:585; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7488; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:3014; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:6014; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:65899,access,accessor,65899,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['accessor']
Security,"on TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:457; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:23696,access,access,23696,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['access'],['access']
Security,"on TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:23695,access,access,23695,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['access'],['access']
Security,"on at line 157 of file TSQLFile.h. ◆ fOtherTypes. const char** TSQLFile::fOtherTypes. protected . ! pointer on list of other SQL types like TEXT or blob ; Definition at line 161 of file TSQLFile.h. ◆ fQuerisCounter. Int_t TSQLFile::fQuerisCounter. protected . ! how many query was applied ; Definition at line 158 of file TSQLFile.h. ◆ fSQL. TSQLServer* TSQLFile::fSQL. protected . ! interface to SQL database ; Definition at line 146 of file TSQLFile.h. ◆ fSQLClassInfos. TList* TSQLFile::fSQLClassInfos. protected . ! list of SQL class infos ; Definition at line 148 of file TSQLFile.h. ◆ fSQLIOversion. Int_t TSQLFile::fSQLIOversion. protected . ! version of SQL I/O which is stored in configurations ; Definition at line 151 of file TSQLFile.h. ◆ fStmtCounter. Int_t TSQLFile::fStmtCounter. protected . ! count numbers of active statements ; Definition at line 168 of file TSQLFile.h. ◆ fTablesType. TString TSQLFile::fTablesType. protected . ! type, used in CREATE TABLE statements ; Definition at line 154 of file TSQLFile.h. ◆ fUseIndexes. Int_t TSQLFile::fUseIndexes. protected . ! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables ; Definition at line 156 of file TSQLFile.h. ◆ fUserName. TString TSQLFile::fUserName. protected . ! user name, used to access objects from database ; Definition at line 163 of file TSQLFile.h. ◆ fUseSuffixes. Bool_t TSQLFile::fUseSuffixes. protected . ! use suffixes in column names like fValue:Int_t or fObject:pointer ; Definition at line 150 of file TSQLFile.h. ◆ fUseTransactions. Int_t TSQLFile::fUseTransactions. protected . ! use transaction statements for writing data into the tables ; Definition at line 155 of file TSQLFile.h. Libraries for TSQLFile:. [legend]; The documentation for this class was generated from the following files:; io/sql/inc/TSQLFile.h; io/sql/src/TSQLFile.cxx. TSQLFile. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:106085,access,access,106085,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"on at line 33 of file TWebFile.h. Public Member Functions;  TWebFile (const char *url, Option_t *opt="""");  Create a Web file object. ;  ;  TWebFile (TUrl url, Option_t *opt="""");  Create a Web file object. ;  ; virtual ~TWebFile ();  Cleanup. ;  ; void Close (Option_t *option="""") override;  Close a Web file. ;  ; Long64_t GetSize () const override;  Return maximum file size. ;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  A TWebFile that has been correctly constructed is always considered open. ;  ; Bool_t ReadBuffer (char *buf, Int_t len) override;  Read specified byte range from remote file via HTTP daemon. ;  ; Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read specified byte range from remote file via HTTP daemon. ;  ; Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf) override;  Read specified byte ranges from remote file via HTTP daemon. ;  ; Int_t ReOpen (Option_t *mode) override;  Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ;  ; void Seek (Long64_t offset, ERelativeTo pos=kBeg) override;  Set position from where to start reading. ;  ; void Streamer (TBuffer &) override;  Stream a TFile object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Opens or creates a local ROOT file. ;  ;  ~TFile () override;  File destructor. ;  ; void Copy (TObject &) const override;  Copy this to obj. ;  ; virtual Bool_t Cp (const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy this file to the dst URL. ;  ; virtual TKey * CreateKey (TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize);  Creates key for object and converts data to buffer. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:1378,access,access,1378,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['access']
Security,"on at line 34 of file TColorGradient.h. Member Enumeration Documentation. ◆ ECoordinateMode. enum TColorGradient::ECoordinateMode. EnumeratorkPadMode ; kObjectBoundingMode . Definition at line 41 of file TColorGradient.h. Constructor & Destructor Documentation. ◆ TColorGradient() [1/3]. TColorGradient::TColorGradient ; (; ). inline . Definition at line 70 of file TColorGradient.h. ◆ TColorGradient() [2/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Color_t * ; colorIndices, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 41 of file TColorGradient.cxx. ◆ TColorGradient() [3/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Double_t * ; colors, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 57 of file TColorGradient.cxx. Member Function Documentation. ◆ Class(). static TClass * TColorGradient::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TColorGradient::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TColorGradient::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TColorGradient.h. ◆ DeclFileName(). static const char * TColorGradient::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TColorGradient.h. ◆ GetColorAlpha(). Double_t TColorGradient::GetColorAlpha ; (; UInt_t ; indx); const. Return alpha parameter of selected color. ; Definition at line 134 of file TColorGradient.cxx. ◆ GetColorPositions(). const Double_t * TColorGradient::GetColorPositions ; (; ); const. Get c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColorGradient.html:22581,validat,validate,22581,doc/master/classTColorGradient.html,https://root.cern,https://root.cern/doc/master/classTColorGradient.html,1,['validat'],['validate']
Security,on at line 456 of file TSchemaRule.cxx. ◆ SetTarget(). void TSchemaRule::SetTarget ; (; const TString & ; target). Set the target member of this rule (i.e. the in memory data member). ; Definition at line 492 of file TSchemaRule.cxx. ◆ SetTargetClass(). void TSchemaRule::SetTargetClass ; (; const TString & ; classname). Set the target class of this rule (i.e. the in memory class). ; Definition at line 474 of file TSchemaRule.cxx. ◆ SetVersion(). Bool_t TSchemaRule::SetVersion ; (; const TString & ; version). Set the version string - returns kFALSE if the format is incorrect. ; Definition at line 381 of file TSchemaRule.cxx. ◆ Streamer(). void ROOT::TSchemaRule::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ROOT::TSchemaRule::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TSchemaRule.h. ◆ TestChecksum(). Bool_t TSchemaRule::TestChecksum ; (; UInt_t ; checksum); const. Check if given checksum is defined in this rule. ; Definition at line 437 of file TSchemaRule.cxx. ◆ TestVersion(). Bool_t TSchemaRule::TestVersion ; (; Int_t ; version); const. Check if given version number is defined in this rule. ; Definition at line 402 of file TSchemaRule.cxx. Member Data Documentation. ◆ fAttributes. TString ROOT::TSchemaRule::fAttributes. private . Definition at line 118 of file TSchemaRule.h. ◆ fChecksum. TString ROOT::TSchemaRule::fChecksum. private . Source version vector (for searching purposes) ; Definition at line 103 of file TSchemaRule.h. ◆ fChecksumVect. std::vector<UInt_t>* ROOT::TSchemaRule::fChecksumVect. mutableprivate . Definition at line 104 of file TSchemaRule.h. ◆ fCode. TString ROOT::TSchemaRule::fCode. private . Includes vector. ; Definition at line 113 of file TSchemaRule.h. ◆ fEmbed. Bool_t ROOT::TSchemaRule::fEmbed. private . Definition at line 114 of file TSchemaRule.h. ◆ fInclude. TString ROOT::TSchemaRule,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:27083,checksum,checksum,27083,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['checksum'],['checksum']
Security,on at line 739 of file TRootCanvas.cxx. ◆ HandleContainerButton(). Bool_t TRootCanvas::HandleContainerButton ; (; Event_t * ; ev). private . Handle mouse button events in the canvas container. ; Definition at line 1733 of file TRootCanvas.cxx. ◆ HandleContainerConfigure(). Bool_t TRootCanvas::HandleContainerConfigure ; (; Event_t * ; ev). private . Handle configure (i.e. resize) event. ; Definition at line 1799 of file TRootCanvas.cxx. ◆ HandleContainerCrossing(). Bool_t TRootCanvas::HandleContainerCrossing ; (; Event_t * ; ev). private . Handle enter/leave events. Only leave is activated at the moment. ; Definition at line 1955 of file TRootCanvas.cxx. ◆ HandleContainerDoubleClick(). Bool_t TRootCanvas::HandleContainerDoubleClick ; (; Event_t * ; ev). private . Handle mouse button double click events in the canvas container. ; Definition at line 1780 of file TRootCanvas.cxx. ◆ HandleContainerExpose(). Bool_t TRootCanvas::HandleContainerExpose ; (; Event_t * ; ev). private . Handle expose events. ; Definition at line 1943 of file TRootCanvas.cxx. ◆ HandleContainerKey(). Bool_t TRootCanvas::HandleContainerKey ; (; Event_t * ; ev). private . Handle keyboard events in the canvas container. ; Definition at line 1821 of file TRootCanvas.cxx. ◆ HandleContainerMotion(). Bool_t TRootCanvas::HandleContainerMotion ; (; Event_t * ; ev). private . Handle mouse motion event in the canvas container. ; Definition at line 1921 of file TRootCanvas.cxx. ◆ HandleDNDDrop(). Bool_t TRootCanvas::HandleDNDDrop ; (; TDNDData * ; data). overrideprivatevirtual . Handle drop events. ; Reimplemented from TGFrame.; Definition at line 1971 of file TRootCanvas.cxx. ◆ HandleDNDEnter(). Atom_t TRootCanvas::HandleDNDEnter ; (; Atom_t * ; typelist). overrideprivatevirtual . Handle drag enter events. ; Reimplemented from TGFrame.; Definition at line 2046 of file TRootCanvas.cxx. ◆ HandleDNDLeave(). Bool_t TRootCanvas::HandleDNDLeave ; (; ). overrideprivatevirtual . Handle drag leave events. ; Reimplem,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:47540,expose,expose,47540,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['expose'],['expose']
Security,"on at line 856 of file TProofPerfAnalysis.cxx. ◆ PrintWrkInfo() [2/2]. void TProofPerfAnalysis::PrintWrkInfo ; (; Int_t ; showlast = 10). Print information for all or the slowest showlast workers. ; Use showlast < 0 to print all ; Definition at line 838 of file TProofPerfAnalysis.cxx. ◆ RatePlot(). void TProofPerfAnalysis::RatePlot ; (; const char * ; wrks = 0). Show event processing or MB processing rate plot vs time. ; Definition at line 1504 of file TProofPerfAnalysis.cxx. ◆ SetDebug(). void TProofPerfAnalysis::SetDebug ; (; Int_t ; d = 0). Static setter for the verbosity level. ; Definition at line 1394 of file TProofPerfAnalysis.cxx. ◆ SetgDebug(). void TProofPerfAnalysis::SetgDebug ; (; Bool_t ; on = kTRUE). static . Static setter for the verbosity level. ; Definition at line 1472 of file TProofPerfAnalysis.cxx. ◆ SetSaveResult(). Int_t TProofPerfAnalysis::SetSaveResult ; (; const char * ; file = ""results.root"", . Option_t * ; mode = ""RECREATE"" . ). Set save result mode and validate 'file' according to 'mode'. ; Return 0 on success, -1 if any problem with the file is encountered (save result mode is not enabled in such a case). If 'file' is null saving is disabled. ; Definition at line 1429 of file TProofPerfAnalysis.cxx. ◆ Streamer(). void TProofPerfAnalysis::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed. ◆ StreamerNVirtual(). void TProofPerfAnalysis::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 118 of file TProofPerfAnalysis.h. ◆ Summary(). void TProofPerfAnalysis::Summary ; (; Option_t * ; opt = """", . const char * ; out = """" . ). Print summary of query. ; Use opt = 'S' for compact version. Output to 'out' or to screen. ; Definition at line 1240 of file TProofPerfAnalysis.cxx. ◆ WorkerActivity(). void TProofPerfAnalysis::WorkerActivity ; (; ). Measure the worker activity. ; Definition at line 761 of file TProofPerfAnalysis.cxx. ◆ WrkInfoOK(). Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis.html:22969,validat,validate,22969,doc/master/classTProofPerfAnalysis.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis.html,1,['validat'],['validate']
Security,"on col from this collection. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. TCollection(const TCollection& ). void operator=(const TCollection& ). TCollection(); { }. virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollection.html:14003,access,accessible,14003,root/html602/TCollection.html,https://root.cern,https://root.cern/root/html602/TCollection.html,2,['access'],['accessible']
Security,"on col from this collection. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). TIter begin() const; { return ++(TIter(this)); }. TIter end() const; { return TIter::End(); }. void operator=(const TCollection& ). virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCollection.html:13412,access,accessible,13412,root/html534/TCollection.html,https://root.cern,https://root.cern/root/html534/TCollection.html,1,['access'],['accessible']
Security,"on in the dataset.; Example code can be found in; tutorials/tree/hsimpleReader.C; tutorials/tree/h1analysisTreeReader.C; This example. You can generate a skeleton of TTreeReaderValue<T> and TTreeReaderArray<T> declarations for all of a tree's branches using TTree::MakeSelector().; Roottest contains an example showing the full power.; A simpler analysis example can be found below: it histograms a function of the px and py branches.; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values store",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:1720,access,access,1720,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['access'],['access']
Security,"on integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBinomialEfficiencyFitter.html:9253,access,access,9253,root/html526/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html526/TBinomialEfficiencyFitter.html,5,['access'],['access']
Security,"on is a 4-component mathematic object quite convenient when dealing with space rotation (or reference frame transformation) ;  CTQueryDescription;  CTQueryResultA container class for query results ;  CTQueryResultManagerClass managing the query-result area ;  CTQUndoManagerRecorder of operations for undo and redo ;  CTrack;  CTrackD;  CTrackD32;  CTRadialGradientDefine a radial color gradient ;  CTRandomThis is the base class for the ROOT Random number generators ;  CTRandom1The Ranlux Random number generator class ;  CTRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer ;  CTRandom3Random number generator class based on M ;  CTRandomEngine;  CTRandomGen;  CTRatioPlotClass for displaying ratios, differences and fit residuals ;  CTRealDataManages the effective list of all data members for a given class ;  CTReaperTimer;  CTRecCmdEvent;  CTRecEvent;  CTRecExtraEvent;  CTRecGuiEvent;  CTRecorder;  CTRecorderInactive;  CTRecorderPaused;  CTRecorderRecording;  CTRecorderReplaying;  CTRecorderState;  CTRecWinPair;  CTRedirectOutputGuard;  CTRefPersistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject ;  CTRefArrayAn array of references to TObjects ;  CTRefArrayIterIterator of object array ;  CTRefArrayProxyA container proxy, which allows to access references stored in a TRefArray from TTree::Draw ;  CTRefCntDefinitions for TRefCnt, base class for reference counted objects ;  CTRefProxy;  CTRefTableA TRefTable maintains the association between a referenced object and the parent object supporting this referenced object ;  CTRegexpRegular expression class ;  CTRemoteObjectProtocol for browsing ROOT objects from a remote ROOT session ;  CTResponseTable;  CTRFIOFileA ROOT file that reads/writes via a rfiod server ;  CTRFIOSystemDirectory handler for RFIO ;  Ctriangulateio;  CTRint;  CTRobustEstimatorMinimum Covariance Determinant Estimator - a Fast Algorithm invented by Peter J.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:182998,access,access,182998,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['access'],['access']
Security,"on the window at position (x,y) in new parent. ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void Resize (UInt_t w, UInt_t h);  Resize the window. ;  ; virtual void SetBackgroundColor (Pixel_t color);  set background color ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetEditable (Bool_t on=kTRUE);  ; virtual void SetEditDisabled (UInt_t on=kEditDisable);  ; virtual void SetMapSubwindows (Bool_t);  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UnmapWindow ();  unmap window ;  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWindow.html:4570,hash,hash,4570,doc/master/classTGWindow.html,https://root.cern,https://root.cern/doc/master/classTGWindow.html,1,['hash'],['hash']
Security,"on's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofOutputList.html:7789,access,accessible,7789,doc/master/classTProofOutputList.html,https://root.cern,https://root.cern/doc/master/classTProofOutputList.html,1,['access'],['accessible']
Security,"on(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStreamerInfo(otherBase->GetBaseCheckSum());; 3015 if (localBaseInfo == otherBaseInfo ||; 3016 localBaseInfo->CompareContent(0,otherBaseInfo,kFALSE,kFALSE,file) ) {; 3017 // They are equivalent, no problem.; 3018 continue;; 3019 }; 3020 TString msg;; 3021 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3022 "" has the same version (=%d) as the active class but a different checksum.\n""; 3023 "" You should update the version to ClassDef(%s,%d).\n""; 3024 "" The objects on this file might not be readable because:\n""; 3025 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 3026 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3027 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseCheckSum(),; 3028 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 3029 otherBase->SetErrorMessage(msg);; 3030 }; 3031 }; 3032 }; 3033 if (!result && !complete) {; 3034 return result;; 3035 }; 3036 // Next the datamembers; 3037 done = kFALSE;; 3038 next.Reset();; 3039 infonext.Reset();; 3040 ; 3041 TMemberInfo local(GetClass());; 3042 TMemberInfo other(cl ? cl : info->GetClass());; 3043 while(!done) {; 3044 local.Clear();; 3045 other.Clear();; 3046 el = (TStreamerElement*)next();; 3047 while (el && (el->IsBase() || el->IsA() == TStreamerArtificial::Class())) {; 3048 el = (TStreamerElement*)next();; 3049 }; 3050 if (el) {; 3051 local.SetName( el->GetName() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:121902,checksum,checksum,121902,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['checksum'],['checksum']
Security,"on, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|100,TANH|50,TANH|10,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""GPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DL_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; ␛[31m<ERROR> : CUDA backend not enabled. Please make sure you have CUDA installed and it was successfully detected by CMAKE by using -Dtmva-gpu=On ␛[0m; : Will now use instead the CPU architecture !; : Will now use the CPU architec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:6114,validat,validation,6114,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['validat'],['validation']
Security,"on, const char* fmt, va_list va) const; ULong_thash(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. enum HashMethod { Pointer; Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHashTable.html:6594,hash,hashArg,6594,root/html532/RooHashTable.html,https://root.cern,https://root.cern/root/html532/RooHashTable.html,2,['hash'],['hashArg']
Security,"on, const char* fmt, va_list va) const; ULong_thash(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. enum HashMethod { Pointer; Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHashTable.html:6456,hash,hashArg,6456,root/html528/RooHashTable.html,https://root.cern,https://root.cern/root/html528/RooHashTable.html,2,['hash'],['hashArg']
Security,"on, const char* fmt, va_list va) const; ULong_thash(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. enum HashMethod { Pointer; Name; Intrinsic; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name); Return the object with given name from the table. TObject* find(const TObject* hashArg); Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHashTable.html:6470,hash,hashArg,6470,root/html526/RooHashTable.html,https://root.cern,https://root.cern/root/html526/RooHashTable.html,1,['hash'],['hashArg']
Security,"on. ◆ TClass() [1/8]. TClass::TClass ; (; const TClass & ; tc). privatedelete . ◆ TClass() [2/8]. TClass::TClass ; (; ). Internal, default constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1065 of file TClass.cxx. ◆ TClass() [3/8]. TClass::TClass ; (; const char * ; name, . Bool_t ; silent = kFALSE . ). Create a TClass object. ; This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Only useful to get a temporary TClass interface to an interpreted class. Used by TTabCom.; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1103 of file TClass.cxx. ◆ TClass() [4/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1151 of file TClass.cxx. ◆ TClass() [5/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . EState ; theState, . Bool_t ; silent = kFALSE . ). Internal constructor, mimicing the case of a class fwd declared in the interpreter. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1179 of file TClass.cxx. ◆ TClass() [6/8]. TClass::TClass ; (; ClassInfo_t * ; classInfo, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; Create a TClass object. This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:50116,access,access,50116,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security,"on. ◆ TClass() [1/8]. TClass::TClass ; (; const TClass & ; tc). privatedelete . ◆ TClass() [2/8]. TClass::TClass ; (; ). Internal, default constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1132 of file TClass.cxx. ◆ TClass() [3/8]. TClass::TClass ; (; const char * ; name, . Bool_t ; silent = kFALSE . ). Create a TClass object. ; This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Only useful to get a temporary TClass interface to an interpreted class. Used by TTabCom.; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1170 of file TClass.cxx. ◆ TClass() [4/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1218 of file TClass.cxx. ◆ TClass() [5/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . EState ; theState, . Bool_t ; silent = kFALSE . ). Internal constructor, mimicing the case of a class fwd declared in the interpreter. ; NoteUse TClass::GetClass(""ClassName"") to get access to a TClass object for a certain class! ; Definition at line 1246 of file TClass.cxx. ◆ TClass() [6/8]. TClass::TClass ; (; ClassInfo_t * ; classInfo, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; Create a TClass object. This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:50117,access,access,50117,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security,"on::(anonymous)TCollection::kIsOwner. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTable.html:9734,hash,hashtable,9734,root/html602/THashTable.html,https://root.cern,https://root.cern/root/html602/THashTable.html,2,['hash'],['hashtable']
Security,"on; TXMLPlayer(); default constructor. ~TXMLPlayer(); destructor of TXMLPlayer object. TString GetStreamerName(TClass* cl); returns streamer function name for given class. Bool_t ProduceCode(TList* cllist, const char* filename); Produce streamers for provide class list; TList should include list of classes, for which code should be generated.; filename specify name of file (without extension), where streamers should be; created. Function produces two files: header file and source file.; For instance, if filename is ""streamers"", files ""streamers.h"" and ""streamers.cxx""; will be created. TString GetMemberTypeName(TDataMember* member); returns name of simple data type for given data member. TString GetBasicTypeName(TStreamerElement* el); return simple data types for given TStreamerElement object. TString GetBasicTypeReaderMethodName(Int_t type, const char* realname); return functions name to read simple data type from xml file. const char* ElementGetter(TClass* cl, const char* membername, int specials = 0); produce code to access member of given class.; Parameter specials has following meaning:; 0 - nothing special; 1 - cast to data type; 2 - produce pointer on given member; 3 - skip casting when produce pointer by buf.P() function. const char* ElementSetter(TClass* cl, const char* membername, char* endch); Produce code to set value to given data member.; endch should be output after value is specified. void ProduceStreamerSource(ostream& fs, TClass* cl, TList* cllist); Produce source code of streamer function for specified class. void ReadSTLarg(ostream& fs, TString& argname, int argtyp, Bool_t isargptr, TClass* argcl, TString& tname, TString& ifcond); Produce code to read argument of stl container from xml file. void WriteSTLarg(ostream& fs, const char* accname, int argtyp, Bool_t isargptr, TClass* argcl); Produce code to write argument of stl container to xml file. Bool_t ProduceSTLstreamer(ostream& fs, TClass* cl, TStreamerSTL* el, Bool_t isWriting); Produce code of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLPlayer.html:10626,access,access,10626,root/html528/TXMLPlayer.html,https://root.cern,https://root.cern/root/html528/TXMLPlayer.html,6,['access'],['access']
Security,"onPointerReadFuncPtr_t GetReadFunctionPointer() constGet the pointer to the function to be run for the rule (if it is a read rule).Definition TSchemaRule.cxx:716; ROOT::TSchemaRule::GetVersionconst char * GetVersion() constGet the version string.Definition TSchemaRule.cxx:393; ROOT::TSchemaRule::GetAttributesconst char * GetAttributes() constGet the attributes code of this rule.Definition TSchemaRule.cxx:664; ROOT::TSchemaRule::GetEmbedBool_t GetEmbed() constReturn true if this rule should be saved in the ROOT File.Definition TSchemaRule.cxx:624; ROOT::TSchemaRule::GetCodeconst char * GetCode() constGet the source code of this rule.Definition TSchemaRule.cxx:648; ROOT::TSchemaRule::SetSourceClassvoid SetSourceClass(const TString &classname)Set the source class of this rule (i.e. the onfile class).Definition TSchemaRule.cxx:456; ROOT::TSchemaRule::TSchemaRuleTSchemaRule()Default Constructor.Definition TSchemaRule.cxx:89; ROOT::TSchemaRule::SetChecksumBool_t SetChecksum(const TString &checksum)Set the checksum string - returns kFALSE if the format is incorrect.Definition TSchemaRule.cxx:425; ROOT::TSchemaRule::fVersionTString fVersionDefinition TSchemaRule.h:101; ROOT::TSchemaRule::GetIncludeconst TObjArray * GetInclude() constReturn the list of header files to include to be able to compile this rule as a TObjArray of TObjStri...Definition TSchemaRule.cxx:599; ROOT::TSchemaRule::IsAliasRuleBool_t IsAliasRule() constReturn kTRUE if the rule is a strict renaming of one of the data member of the class.Definition TSchemaRule.cxx:748; ROOT::TSchemaRule::GetTargetClassconst char * GetTargetClass() constGet the targte class of this rule (i.e. the in memory class).Definition TSchemaRule.cxx:484; ROOT::TSchemaRule::ProcessDeclarationstatic void ProcessDeclaration(TObjArray *array, const TString &list)Split the list as a declaration into as a TObjArray of TNamed(name,type).Definition TSchemaRule.cxx:974; ROOT::TSchemaRule::ProcessVersionBool_t ProcessVersion(const TString &versi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:45379,checksum,checksum,45379,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,4,['checksum'],['checksum']
Security,"onProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:4242,access,accessors,4242,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,6,['access'],['accessors']
Security,"onVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::Math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:8601,access,access,8601,root/html526/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:11958,hash,hashtable,11958,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],"['hash', 'hashtable']"
Security,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THashTable.html:12517,hash,hashtable,12517,root/html604/THashTable.html,https://root.cern,https://root.cern/root/html604/THashTable.html,3,['hash'],"['hash', 'hashtable']"
Security,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTable.html:12517,hash,hashtable,12517,root/html602/THashTable.html,https://root.cern,https://root.cern/root/html602/THashTable.html,3,['hash'],"['hash', 'hashtable']"
Security,"onding to the buffer. ;  . Private Attributes; std::unique_ptr< RHashMap > fHashMap;  ; std::unique_ptr< ROOT::TRWSpinLock > fRWLock;  . #include <ROOT/RConcurrentHashColl.hxx>; Constructor & Destructor Documentation. ◆ RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::RConcurrentHashColl ; (; ). Definition at line 41 of file RConcurrentHashColl.cxx. ◆ ~RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::~RConcurrentHashColl ; (; ). default . Member Function Documentation. ◆ Find(). const RUidColl * ROOT::Internal::RConcurrentHashColl::Find ; (; const HashValue & ; hash); const. Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ; Definition at line 46 of file RConcurrentHashColl.cxx. ◆ Hash(). RConcurrentHashColl::HashValue ROOT::Internal::RConcurrentHashColl::Hash ; (; char * ; buf, . int ; len . ). static . Return the hash object corresponding to the buffer. ; Definition at line 56 of file RConcurrentHashColl.cxx. ◆ Insert(). bool ROOT::Internal::RConcurrentHashColl::Insert ; (; const HashValue & ; hash, . RUidColl && ; coll . ); const. If the hash is there, return false. ; Otherwise, insert the hash and UID collection and return true. ; Definition at line 61 of file RConcurrentHashColl.cxx. Member Data Documentation. ◆ fHashMap. std::unique_ptr<RHashMap> ROOT::Internal::RConcurrentHashColl::fHashMap. mutableprivate . Definition at line 32 of file RConcurrentHashColl.hxx. ◆ fRWLock. std::unique_ptr<ROOT::TRWSpinLock> ROOT::Internal::RConcurrentHashColl::fRWLock. mutableprivate . Definition at line 33 of file RConcurrentHashColl.hxx. Libraries for ROOT::Internal::RConcurrentHashColl:. [legend]; The documentation for this class was generated from the following files:; core/thread/inc/ROOT/RConcurrentHashColl.hxx; core/thread/src/RConcurrentHashColl.cxx. ROOTInternalRConcurrentHashColl. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html:2163,hash,hash,2163,doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,3,['hash'],['hash']
Security,"one of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; TObject * FindObject (const char *name) const override;  Find an object in this collection using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in this collection using the object's IsEqual() member function. ;  ; virtual Int_t GetEntries () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:13804,hash,hash,13804,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,2,['hash'],['hash']
Security,"onent; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:34893,access,access,34893,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,1,['access'],['access']
Security,"onents into data specified by an iterator begin; 484 and another to the end of the desired data (12 past start).; 485 */; 486 template<class IT>; 487 void GetComponents(IT begin, IT end) const {; 488 for (int i = 0; i <12; ++i) {; 489 *begin = fM[i];; 490 ++begin;; 491 }; 492 (void)end;; 493 assert (end==begin);; 494 }; 495 ; 496 /**; 497 Get the 12 matrix components into data specified by an iterator begin; 498 */; 499 template<class IT>; 500 void GetComponents(IT begin) const {; 501 std::copy(fM, fM + 12, begin);; 502 }; 503 ; 504 /**; 505 Set components from a linear algebra matrix of size at least 3x4,; 506 which must support operator()(i,j) to obtain elements (0,0) thru (2,3).; 507 The 3x3 sub-block is assumed to be the rotation part and the translations vector; 508 are described by the 4-th column; 509 */; 510 template<class ForeignMatrix>; 511 void; 512 SetTransformMatrix (const ForeignMatrix & m) {; 513 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2); fM[kDX]=m(0,3);; 514 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2); fM[kDY]=m(1,3);; 515 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2); fM[kDZ]=m(2,3);; 516 }; 517 ; 518 /**; 519 Get components into a linear algebra matrix of size at least 3x4,; 520 which must support operator()(i,j) for write access to elements; 521 (0,0) thru (2,3).; 522 */; 523 template<class ForeignMatrix>; 524 void; 525 GetTransformMatrix (ForeignMatrix & m) const {; 526 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ]; m(0,3)=fM[kDX];; 527 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ]; m(1,3)=fM[kDY];; 528 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ]; m(2,3)=fM[kDZ];; 529 }; 530 ; 531 ; 532 /**; 533 Set the components from 12 scalars; 534 */; 535 void SetComponents(T xx, T xy, T xz, T dx, T yx, T yy, T yz, T dy, T zx, T zy, T zz, T dz); 536 {; 537 fM[kXX]=xx; fM[kXY]=xy; fM[kXZ]=xz; fM[kDX]=dx;; 538 fM[kYX]=yx; fM[kYY]=yy; fM[kYZ]=yz; fM[kDY]=dy;; 539 fM[kZX]=zx; fM[kZY]=zy; fM[kZZ]=zz; fM[kDZ]=dz;; 540 }; 541 ; 542 /**; 543 Get the comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:17977,access,access,17977,doc/master/GenVector_2Transform3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html,1,['access'],['access']
Security,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:2917,access,accesstype,2917,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,2,['access'],"['access', 'accesstype']"
Security,"ongptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:44521,access,accessor,44521,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['accessor']
Security,"ongptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4550; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5751; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6770; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:3006; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5725; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3808; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * Ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:44349,access,accessor,44349,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['accessor']
Security,"onnect user-defined extension to the material. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMixture.html:7557,hash,hash,7557,doc/master/classTGeoMixture.html,https://root.cern,https://root.cern/doc/master/classTGeoMixture.html,1,['hash'],['hash']
Security,"onnection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:22568,authenticat,authenticated,22568,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,10,['authenticat'],"['authenticated', 'authentication']"
Security,"ons described by 'sopt'. ;  ; static Int_t ScanFile (TFileInfo *fileinfo, Bool_t notify);  Open the file described by 'fileinfo' to extract the relevant meta-information. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BrowseDataSets (const char *group, const char *user, const char *dsName, UInt_t option, TObject *target);  Adds the dataset in the folder of group, user to the list in target. ;  ; Int_t ChecksumDataSet (const char *path, const char *md5path, TString &checksum);  Calculate the checksum of the indicated dataset at 'path' and save it to the appropriate file 'md5path'. ;  ; Int_t CreateLsFile (const char *group, const char *user, Long_t &mtime, TString &checksum);  Create or recreate the dataset lists for 'uri'. ;  ; Bool_t ExistsDataSet (const char *group, const char *user, const char *dsName);  Checks if the indicated dataset exits. ;  ; Int_t FillLsDataSet (const char *group, const char *user, const char *dsName, TList *out, UInt_t option);  Check for the 'ls.txt' for 'group' and 'user' and fill the path for the ls file in 'out'. ;  ; const char * GetDataSetPath (const char *group, const char *user, const char *dsName);  ; const char * GetDataSetPath (const char *group, const char *user, const char *dsName, TString &md5path, Bool_t local=kFALSE);  Returns path of the indicated dataset. ;  ; void Init ();  Do the real inititialization. ;  ; Bool_t RemoveDataSet (const char *group, const char *user, const char *dsName);  Removes the indicated dataset. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:15168,checksum,checksum,15168,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,2,['checksum'],['checksum']
Security,"ons |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TS3WebFile Class ReferenceInput/Output Library. ; A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. ; This class is meant to be as generic as possible to be used with files hosted not only by Amazon S3 servers but also by other providers implementing the core of the S3 protocol.; The S3 protocol works on top of HTTPS (and HTTP) and imposes that each HTTP request be signed using a specific convention: the request must include an 'Authorization' header which contains the signature of a concatenation of selected request fields. For signing the request, an 'Access Key Id' and a 'Secret Access Key' need to be known. These keys are used by the S3 servers to identify the client and to authenticate the request as genuine.; As an end user, you must know the Access Key and Secret Access Key in order to access each S3 file. They are provided to you by your S3 service provider. Those two keys can be provided to ROOT when initializing an object of this class by two means: a. by using the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY, or b. by specifying them when opening each file.; You can use AWS temporary security credentials (temporary access key and secret access key), but you must also give the associated session token. The token may be set in the S3_SESSION_TOKEN environmental variable, or on open in the TOKEN option.; The first method is convenient if all the S3 files you want to access are hosted by a single provider. The second one is more flexible as it allows you to specify which credentials to use on a per-file basis. See the documentation of the constructor of this class for details on the syntax.; For generating and signing the HTTP request, this class uses TS3HTTPRequest.; For more information on the details of S3 protocol please r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:1191,access,access,1191,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['access']
Security,"ons::TActionSequence * GetReadMemberWiseActions(Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1798; TGenCollectionProxy::fFirstMethod fFirstContainer accessors: generic iteration: first.Definition TGenCollectionProxy.h:304; TGenCollectionProxy::fValuestd::atomic< Value * > fValueDescriptor of the container value type.Definition TGenCollectionProxy.h:311; TGenCollectionProxy::fFunctionNextIteratorNext_t fFunctionNextIteratorDefinition TGenCollectionProxy.h:326; TGenCollectionProxy::Insertvoid Insert(const void *data, void *container, size_t size) overrideInsert data into the container where data is a C-style array of the actual type contained in the coll...Definition TGenCollectionProxy.cxx:1269; TGenCollectionProxy::fPointersBool_t fPointersFlag to indicate if containee has pointers (key or value)Definition TGenCollectionProxy.h:300; TGenCollectionProxy::fNextMethod fNextContainer accessors: generic iteration: next.Definition TGenCollectionProxy.h:305; TGenCollectionProxy::Streamervirtual void Streamer(TBuffer &refBuffer)Streamer Function.Definition TGenCollectionProxy.cxx:1427; TGenCollectionProxy::fWriteMemberWiseTStreamerInfoActions::TActionSequence * fWriteMemberWiseDefinition TGenCollectionProxy.h:293; TGenCollectionProxy::Allocatevoid * Allocate(UInt_t n, Bool_t forceDelete) overrideAllocate the needed space.Definition TGenCollectionProxy.cxx:1192; TGenCollectionProxy::ResetBool_t Reset() overrideReset the info gathered from StreamerInfos and value's TClass.Definition TGenCollectionProxy.cxx:779; TGenCollectionProxy::fTypeinfoInfo_t fTypeinfoType information.Definition TGenCollectionProxy.h:321; TGenCollectionProxy::fValOffsetint fValOffsetOffset from key to value (in maps)Definition TGenCollectionProxy.h:315; TGenCollectionProxy::TGenCollectionProxyTGenCollectionProxy(); TGenCollectionProxy::GetValueClassTClass * GetValueClass() const overrideRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:77247,access,accessors,77247,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['access'],['accessors']
Security,"ons::TActionSequence * TStreamerInfo::GetWriteTextActions ; (; ). inline . Definition at line 172 of file TStreamerInfo.h. ◆ InsertArtificialElements(). void TStreamerInfo::InsertArtificialElements ; (; std::vector< const ROOT::TSchemaRule * > & ; rules). private . Insert new members as expressed in the array of TSchemaRule(s). ; Definition at line 4541 of file TStreamerInfo.cxx. ◆ IsA(). TClass * TStreamerInfo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 254 of file TStreamerInfo.h. ◆ ls(). void TStreamerInfo::ls ; (; Option_t * ; option = """"); const. overridevirtual . List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ; Implements TVirtualStreamerInfo.; Definition at line 4684 of file TStreamerInfo.cxx. ◆ MatchLegacyCheckSum(). Bool_t TStreamerInfo::MatchLegacyCheckSum ; (; UInt_t ; checksum); const. Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ; Definition at line 3270 of file TStreamerInfo.cxx. ◆ New(). void * TStreamerInfo::New ; (; void * ; obj = nullptr). overridevirtual . An emulated object is created at address obj, if obj is null we allocate memory for the object. ; Implements TVirtualStreamerInfo.; Definition at line 4769 of file TStreamerInfo.cxx. ◆ NewArray(). void * TStreamerInfo::NewArray ; (; Long_t ; nElements, . void * ; ary = nullptr . ). overridevirtual . An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ; Implements TVirtualStreamerInfo.; Definition at line 4918 of file TStreamerInfo.cxx. ◆ NewInfo(). TVirtualStreamerInfo * TStreamerInfo::NewInfo ; (; TClass * ; cl). inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 198 of file TStreamerInfo.h. ◆ operator=(). T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:59653,checksum,checksum,59653,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['checksum'],['checksum']
Security,"onsequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); These methods return a TSeqCollection, meaning a collection of objects, and they can be used to do list operations such as finding an object, or traversing the list and calling a method for each of the members. See the TCollection class description for the full set of methods supported for a collection. For example, to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59941,access,access,59941,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"onst FCNBase& fcn, const MnUserParameterState& state, const MnStrategy& stra, unsigned int nfcn = 0); constructor from non-gradient functions. MnApplication(const FCNGradientBase& fcn, const MnUserParameterState& state, const MnStrategy& stra, unsigned int nfcn = 0); constructor from gradient function. virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.10000000000000001). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__MnApplication.html:4327,access,access,4327,root/html602/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__MnApplication.html,2,['access'],['access']
Security,"onst PositionVector3D<OtherCoords,Tag> & rhs) {; 145 SetXYZ(rhs.x(), rhs.y(), rhs.z());; 146 return *this;; 147 }; 148 ; 149 ; 150 /**; 151 Assignment from a foreign 3D vector type, for example, Hep3Vector; 152 Precondition: v must implement methods x(), y() and z(); 153 */; 154 template <class ForeignVector>; 155 DisplacementVector3D & operator= ( const ForeignVector & v) {; 156 SetXYZ( v.x(), v.y(), v.z() );; 157 return *this;; 158 }; 159 ; 160 ; 161#ifdef LATER; 162 /**; 163 assign from a generic linear algebra vector of at least size 3; 164 implementing operator []. This could be also a C array; 165 \par v LAVector; 166 \par index0 index where coordinates starts (typically zero); 167 It works for all Coordinates types,; 168 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 169 */; 170 template <class LAVector>; 171 DisplacementVector3D & assignFrom(const LAVector & v, size_t index0 = 0) {; 172 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 173 return *this;; 174 }; 175#endif; 176 ; 177 // ------ Set, Get, and access coordinate data ------; 178 ; 179 /**; 180 Retrieve a copy of the coordinates object; 181 */; 182 CoordSystem Coordinates() const {; 183 return fCoordinates;; 184 }; 185 ; 186 /**; 187 Set internal data based on a C-style array of 3 Scalar numbers; 188 */; 189 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( const Scalar src[] ); 190 { fCoordinates.SetCoordinates(src); return *this; }; 191 ; 192 /**; 193 Set internal data based on 3 Scalar numbers; 194 */; 195 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b, Scalar c ); 196 { fCoordinates.SetCoordinates(a, b, c); return *this; }; 197 ; 198 /**; 199 Set internal data based on 3 Scalars at *begin to *end; 200 */; 201 template <class IT>; 202 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:5889,access,access,5889,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['access'],['access']
Security,"onst ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<Double32_t,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5518,access,access,5518,root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,4,['access'],"['access', 'accessing']"
Security,"onst ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<Double32_t,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5518,access,access,5518,root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,4,['access'],"['access', 'accessing']"
Security,"onst ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<Double32_t,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5518,access,access,5518,root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,4,['access'],"['access', 'accessing']"
Security,"onst ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<Double32_t,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5518,access,access,5518,root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,4,['access'],"['access', 'accessing']"
Security,"onst TDatabasePDG& db); TDatabasePDG(const TDatabasePDG& db). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArray*fListOfClasseslist of classes (leptons etc.); TStringTNamed::fNameobject identifier; THashList*fParticleListlist of PDG particles; TExMap*fPdgMap!hash-map from pdg-code to particle; TStringTNamed::fTitleobject title; static TDatabasePDG*fgInstanceprotect against multiple instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatabasePDG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDatabasePDG.html:7499,hash,hash-map,7499,root/html602/TDatabasePDG.html,https://root.cern,https://root.cern/root/html602/TDatabasePDG.html,2,['hash'],['hash-map']
Security,"onst TExMap &map);  Copy constructor. ;  ;  TExMap (Int_t mapSize=100);  Create a TExMap. ;  ;  ~TExMap ();  Delete TExMap. ;  ; void Add (Long64_t key, Long64_t value);  ; void Add (ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. The key should be unique. ;  ; void AddAt (UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. ;  ; Int_t Capacity () const;  ; void Delete (Option_t *opt="""") override;  Delete all entries stored in the TExMap. ;  ; void Expand (Int_t newsize);  Expand the TExMap. ;  ; Int_t GetSize () const;  ; Long64_t GetValue (Long64_t key);  ; Long64_t GetValue (ULong64_t hash, Long64_t key);  Return the value belonging to specified key and hash value. ;  ; Long64_t GetValue (ULong64_t hash, Long64_t key, UInt_t &slot);  Return the value belonging to specified key and hash value. ;  ; TClass * IsA () const override;  ; Long64_t & operator() (Long64_t key);  ; Long64_t & operator() (ULong64_t hash, Long64_t key);  Return a reference to the value belonging to the key with the specified hash value. ;  ; TExMap & operator= (const TExMap &);  Assignment operator. ;  ; void Remove (Long64_t key);  ; void Remove (ULong64_t hash, Long64_t key);  Remove entry with specified key from the TExMap. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:1643,hash,hash,1643,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,2,['hash'],['hash']
Security,"onst TExMap & ; map). Copy constructor. ; Definition at line 53 of file TExMap.cxx. ◆ ~TExMap(). TExMap::~TExMap ; (; ). Delete TExMap. ; Definition at line 80 of file TExMap.cxx. Member Function Documentation. ◆ Add() [1/2]. void TExMap::Add ; (; Long64_t ; key, . Long64_t ; value . ). inline . Definition at line 66 of file TExMap.h. ◆ Add() [2/2]. void TExMap::Add ; (; ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. The key should be unique. ; Definition at line 88 of file TExMap.cxx. ◆ AddAt(). void TExMap::AddAt ; (; UInt_t ; slot, . ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. ; The key should be unique. If the 'slot' is open, use it to store the value, otherwise revert to Add(hash,key,value) This is usually used in conjunction with GetValue with 3 parameters: if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {; ...; } else {; fMap->AddAt(slot,hash,key,value);; }; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Definition at line 117 of file TExMap.cxx. ◆ Capacity(). Int_t TExMap::Capacity ; (; ); const. inline . Definition at line 69 of file TExMap.h. ◆ Class(). static TClass * TExMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TExMap::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TExMap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TExMap.h. ◆ DeclFileName(). static const char * TExMap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file TExMap.h. ◆ Delete(). void TExMap::Delete ; (; Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:12962,hash,hash,12962,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"onst TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules( const TString &source, Int_t version ) const; 329{; 330 TObject* obj;; 331 TObjArrayIter it( fAllRules );; 332 TMatches arr;; 333 // arr->SetOwner( kFALSE );; 334 ; 335 while( (obj = it.Next()) ) {; 336 TSchemaRule* rule = (TSchemaRule*)obj;; 337 if( rule->GetSourceClass() == source && rule->TestVersion( version ) ); 338 arr.push_back( rule );; 339 }; 340 ; 341 return arr;; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Return all the rules that applies to the specified checksum of the given 'source' class.; 346/// User has to delete the returned array; 347 ; 348const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules( const TString &source, UInt_t checksum ) const; 349{; 350 TObject* obj;; 351 TObjArrayIter it( fAllRules );; 352 TMatches arr;; 353 // arr->SetOwner( kFALSE );; 354 ; 355 while( (obj = it.Next()) ) {; 356 TSchemaRule* rule = (TSchemaRule*)obj;; 357 if( rule->GetSourceClass() == source && rule->TestChecksum( checksum ) ); 358 arr.push_back( rule );; 359 }; 360 ; 361 return arr;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Return all the rules that applies to the specified version OR checksum of the given 'source' class.; 366/// User has to delete the returned array; 367 ; 368const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules( const TString &source, Int_t version, UInt_t checksum ) const; 369{; 370 TObject* obj;; 371 TObjArrayIter it( fAllRules );; 372 TMatches arr;; 373 // arr->SetOwner( kFALSE );; 374 ; 375 while( (obj = it.Next()) ) {; 376 TSchemaRule* rule = (TSchemaRule*)obj;; 377 if( rule->GetSourceClass() == source && ( rule->TestVersion( version ) || rule->TestChecksum( checksum ) ) ); 378 arr.push_back( rule );; 379 }; 380 ; 381 return arr;; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385 ; 386TClass* TSchemaRuleSet:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html:13155,checksum,checksum,13155,doc/master/TSchemaRuleSet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html,1,['checksum'],['checksum']
Security,"onst char * TSessionServerFrame::GetAddress ; (; ); const. inline . Definition at line 202 of file TSessionViewer.h. ◆ GetConfigText(). const char * TSessionServerFrame::GetConfigText ; (; ); const. inline . Definition at line 205 of file TSessionViewer.h. ◆ GetLogLevel(). Int_t TSessionServerFrame::GetLogLevel ; (; ); const. inline . Definition at line 204 of file TSessionViewer.h. ◆ GetName(). const char * TSessionServerFrame::GetName ; (; ); const. inlineoverridevirtual . Return unique name, used in SavePrimitive methods. ; Reimplemented from TGWindow.; Definition at line 201 of file TSessionViewer.h. ◆ GetPortNumber(). Int_t TSessionServerFrame::GetPortNumber ; (; ); const. inline . Definition at line 203 of file TSessionViewer.h. ◆ GetUserName(). const char * TSessionServerFrame::GetUserName ; (; ); const. inline . Definition at line 206 of file TSessionViewer.h. ◆ HandleExpose(). Bool_t TSessionServerFrame::HandleExpose ; (; Event_t * ; event). overridevirtual . Handle expose event in server frame. ; Reimplemented from TGWindow.; Definition at line 352 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionServerFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 233 of file TSessionViewer.h. ◆ IsSync(). Bool_t TSessionServerFrame::IsSync ; (; ); const. inline . Definition at line 207 of file TSessionViewer.h. ◆ OnBtnAddClicked(). void TSessionServerFrame::OnBtnAddClicked ; (; ). Add newly created session configuration in the list of sessions. ; Definition at line 684 of file TSessionViewer.cxx. ◆ OnBtnConnectClicked(). void TSessionServerFrame::OnBtnConnectClicked ; (; ). Connect to selected server. ; Definition at line 432 of file TSessionViewer.cxx. ◆ OnBtnDeleteClicked(). void TSessionServerFrame::OnBtnDeleteClicked ; (; ). Delete selected session configuration (remove it from the list). ; Definition at line 377 of file TSessionViewer.cxx. ◆ OnBtnNewServerClicked",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionServerFrame.html:34190,expose,expose,34190,doc/master/classTSessionServerFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionServerFrame.html,1,['expose'],['expose']
Security,"onst char *name = nullptr, const char *title = nullptr, const char *dims = nullptr) : TNamed(name,title), fDimensions(dims) {}; 28 const char *GetDimensions() { return fDimensions; }; 29 ; 30 ClassDefOverride(TSources,2);; 31 };; 32 ; 33 typedef enum; 34 {; 35 kReadRule = 0,; 36 kReadRawRule = 1,; 37 kNone = 99999; 38 } RuleType_t;; 39 ; 40 typedef void (*ReadFuncPtr_t)( char*, TVirtualObject* );; 41 typedef void (*ReadRawFuncPtr_t)( char*, TBuffer&);; 42 ; 43 TSchemaRule();; 44 virtual ~TSchemaRule();; 45 ; 46 TSchemaRule( const TSchemaRule& rhs );; 47 TSchemaRule& operator = ( const TSchemaRule& rhs );; 48 Bool_t operator == ( const TSchemaRule& rhs ) const;; 49 ; 50 ; 51 void Clear(Option_t * /*option*/ ="""") override;; 52 Bool_t SetFromRule( const char *rule );; 53 ; 54 const char *GetVersion( ) const;; 55 Bool_t SetVersion( const TString& version );; 56 Bool_t TestVersion( Int_t version ) const;; 57 Bool_t SetChecksum( const TString& checksum );; 58 Bool_t TestChecksum( UInt_t checksum ) const;; 59 void SetSourceClass( const TString& classname );; 60 const char *GetSourceClass() const;; 61 void SetTargetClass( const TString& classname );; 62 const char *GetTargetClass() const;; 63 void SetTarget( const TString& target );; 64 const TObjArray* GetTarget() const;; 65 const char *GetTargetString() const;; 66 void SetSource( const TString& source );; 67 const TObjArray* GetSource() const;; 68 void SetEmbed( Bool_t embed );; 69 Bool_t GetEmbed() const;; 70 Bool_t IsAliasRule() const;; 71 Bool_t IsRenameRule() const;; 72 Bool_t IsValid() const;; 73 void SetCode( const TString& code );; 74 const char *GetCode() const;; 75 void SetAttributes( const TString& attributes );; 76 const char *GetAttributes() const;; 77 Bool_t HasTarget( const TString& target ) const;; 78 ; 79 Bool_t HasSource( const TString& source ) const;; 80 void SetReadFunctionPointer( ReadFuncPtr_t ptr );; 81 ReadFuncPtr_t GetReadFunctionPointer() const;; 82 void SetReadRawFunctionPointer( ReadRawFuncPtr_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8h_source.html:1662,checksum,checksum,1662,doc/master/TSchemaRule_8h_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8h_source.html,1,['checksum'],['checksum']
Security,"onst char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReadStringstatic TString * ReadString(TBuffer &b, const TClass *clReq)Read TString object from buffer.Definition TString.cxx:1362; TString::EqualToBool_t EqualTo(const char *cs, ECaseCompare cmp=kExact) constDefinition TString.h:645; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ChopTString & Chop()Definition TString.h:691; TString::MaybeRegexpBool_t MaybeRegexp() constReturns true if string contains one of the regexp characters ""^$.[]*+?"".Definition TString.cxx:952; TString::ResizeIncrementstatic Ssiz_t ResizeIncrement(Ssiz_t ri=16)Set default resize increment for all TStrings. Default is 16.Definition TString.cxx:1602; TString::HashCaseUInt_t HashCase() constReturn a case-sensitive hash value (endian independent).Definition TString.cxx:633; TString::IsOctBool_t IsOct() constReturns true if all characters in string are octal digits (0-7).Definition TString.cxx:1924; TString::~TStringvirtual ~TString()Delete a TString.Definition TString.cxx:251; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::GetMaxWastestatic Ssiz_t GetMaxWaste()Definition TString.cxx:1584; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8h_source.html:47029,hash,hash,47029,doc/master/TString_8h_source.html,https://root.cern,https://root.cern/doc/master/TString_8h_source.html,1,['hash'],['hash']
Security,"onst char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ←; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUri.html:8467,password,password,8467,root/html602/TUri.html,https://root.cern,https://root.cern/root/html602/TUri.html,2,['password'],['password']
Security,"onst char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TS3HTTPRequest&operator=(const TS3HTTPRequest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TS3HTTPRequest&SetAccessKey(const TString& accessKey); TS3HTTPRequest&SetAuthKeys(const TString& accessKey, const TString& secretKey); TS3HTTPRequest&SetAuthType(TS3HTTPRequest::EAuthType authType); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); TS3HTTPRequest&SetBucket(const TString& bucket); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TS3HTTPRequest&SetHost(const TString& host); TS3HTTPRequest&SetObjectKey(const TString& objectKey); static voidTObject::SetObjectStat(Bool_t stat); TS3HTTPRequest&SetSecretKey(const TString& secretKey); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:5223,access,accessKey,5223,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidProcessRequest(THttpCallArg* arg); static Bool_tVerifyFilePath(const char* fname). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListfCallArgs! submitted arguments; TStringfDefaultPage! file name for default page name; TStringfDefaultPageCont! content of the file content; TStringfDrawPage! file name for drawing of single element; TStringfDrawPageCont! content of draw page; TListfEngines! engines which runs http server; TStringfJSROOT! location of external JSROOT files; TStringfJSROOTSYS! location of local JSROOT files; TListfLocations! list of local directories, which could be accessed via server; Long_tfMainThrdId! id of the main ROOT process; TMutexfMutex! mutex to protect list with arguments; TStringTNamed::fNameobject identifier; TRootSniffer*fSniffer! sniffer provides access to ROOT objects hierarchy; THttpTimer*fTimer! timer used to access main thread; TStringTNamed::fTitleobject title; TStringfTopName! name of top folder, default - ""ROOT"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpServer(const char* engine = ""civetweb:8080""); constructor. ~THttpServer(); destructor; delete all http engines and sniffer. void SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:8482,access,accessed,8482,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,3,['access'],"['access', 'accessed']"
Security,"onst char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7048,password,password,7048,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security,"onst override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const override;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void Rehash (Int_t newCapacity, Bool_t checkObjValidity=kTRUE);  Rehash the hashtable. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the hashtable. ;  ; TObject * RemoveSlow (TObject *obj);  Remove object from the hashtable without using the hash value. ;  ; void SetRehashLevel (Int_t rehash);  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TCollection; virtual ~TCollection ();  TNamed destructor. ;  ; void AddVector (TObject *obj1,...);  Add all arguments to the collection. ;  ; Bool_t AssertClass (TClass *cl) const;  Make sure all objects in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:3259,hash,hashtable,3259,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,2,['hash'],['hashtable']
Security,"onst std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); constructors dictated by subclassing off of MethodBase. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodANNBase.html:24716,access,accessors,24716,root/html604/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,"onst std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. MethodANNBase(const TString& jobName, TMVA::Types::EMVA methodType, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir); constructors dictated by subclassing off of MethodBase. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:24708,access,accessors,24708,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,"onst. inline . Definition at line 525 of file RFieldBase.hxx. ◆ GetStructure(). ENTupleStructure ROOT::Experimental::RFieldBase::GetStructure ; (; ); const. inline . Definition at line 516 of file RFieldBase.hxx. ◆ GetSubFields() [1/2]. std::vector< ROOT::Experimental::RFieldBase * > ROOT::Experimental::RFieldBase::GetSubFields ; (; ). Definition at line 1004 of file RField.cxx. ◆ GetSubFields() [2/2]. std::vector< const ROOT::Experimental::RFieldBase * > ROOT::Experimental::RFieldBase::GetSubFields ; (; ); const. Definition at line 1014 of file RField.cxx. ◆ GetTraits(). int ROOT::Experimental::RFieldBase::GetTraits ; (; ); const. inline . Definition at line 508 of file RFieldBase.hxx. ◆ GetTypeAlias(). const std::string & ROOT::Experimental::RFieldBase::GetTypeAlias ; (; ); const. inline . Definition at line 515 of file RFieldBase.hxx. ◆ GetTypeChecksum(). virtual std::uint32_t ROOT::Experimental::RFieldBase::GetTypeChecksum ; (; ); const. inlinevirtual . Return the current TClass reported checksum of this class. Only valid if kTraitTypeChecksum is set. ; Reimplemented in ROOT::Experimental::RClassField, ROOT::Experimental::RStreamerField, and ROOT::Experimental::RField< TObject >.; Definition at line 544 of file RFieldBase.hxx. ◆ GetTypeName(). const std::string & ROOT::Experimental::RFieldBase::GetTypeName ; (; ); const. inline . Definition at line 514 of file RFieldBase.hxx. ◆ GetTypeVersion(). virtual std::uint32_t ROOT::Experimental::RFieldBase::GetTypeVersion ; (; ); const. inlinevirtual . Indicates an evolution of the C++ type itself. ; Reimplemented in ROOT::Experimental::RClassField, ROOT::Experimental::RStreamerField, and ROOT::Experimental::RField< TObject >.; Definition at line 542 of file RFieldBase.hxx. ◆ GetValueSize(). virtual size_t ROOT::Experimental::RFieldBase::GetValueSize ; (; ); const. pure virtual . The number of bytes taken by a value of the appropriate type. ; Implemented in ROOT::Experimental::Internal::RRDFCardinalityField, ROOT::Experim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:43667,checksum,checksum,43667,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['checksum'],['checksum']
Security,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id: TKSocket.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TKSocket.html:5338,authenticat,authentication,5338,root/html530/TKSocket.html,https://root.cern,https://root.cern/root/html530/TKSocket.html,1,['authenticat'],['authentication']
Security,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id: TKSocket.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKSocket.html:5338,authenticat,authentication,5338,root/html532/TKSocket.html,https://root.cern,https://root.cern/root/html532/TKSocket.html,1,['authenticat'],['authentication']
Security,"onst; Int_tlastIndex() const; const RooNameSet*nameSet1ByIndex(Int_t index) const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<RooAbsCacheElement>&operator=(const RooCacheManager<RooAbsCacheElement>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html:2901,access,accessed,2901,root/html530/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html,2,['access'],['accessed']
Security,"onst; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=( const ForeignVector & v). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8291,access,access,8291,root/html602/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"onst; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; voidPrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; voidPrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; virtual Int_tTObject::Read(const char* name); Int_tReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset); Int_tReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidTVirtualStreamerInfo::SetCanDelete(Bool_t opt = kTRUE); virtual voidSetCheckSum(UInt_t checksum); virtual voidSetClass(TClass* cl); virtual voidSetClassVersion(Int_t vers); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTVirtualStreamerInfo::SetFactory(TVirtualStreamerInfo* factory); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static Bool_tTVirtualStreamerInfo::SetStreamMemberWise(Bool_t enable = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagFile(TFile* fFile); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(const TClass* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStreamerInfo.html:8306,checksum,checksum,8306,root/html530/TStreamerInfo.html,https://root.cern,https://root.cern/root/html530/TStreamerInfo.html,2,['checksum'],['checksum']
Security,"onst;  Dump contents of object on stdout. ;  ; const void * DynamicCast (const TClass *base, const void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; void * DynamicCast (const TClass *base, void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; char * EscapeChars (const char *text) const;  Introduce an escape character (@) in front of a special chars. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const char *onfile_classname, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const TClass *onfile_cl, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindStreamerInfo (UInt_t checksum, Bool_t isTransient=kFALSE) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; TVirtualStreamerInfo * FindStreamerInfoAbstractEmulated (UInt_t checksum) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; void ForceReload (TClass *oldcl);  we found at least one equivalent. ;  ; TClass * GetActualClass (const void *object) const;  Return a pointer to the real class of the object. ;  ; TClass * GetBaseClass (const char *classname);  Return pointer to the base class ""classname"". ;  ; TClass * GetBaseClass (const TClass *base);  Return pointer to the base class ""cl"". ;  ; Int_t GetBaseClassOffset (const TClass *toBase, void *address=nullptr, bool isDerivedObject=true);  ; TClass * GetBaseDataMember (const char *datamember);  Return pointer to (base) class that contains datamember. ;  ; UInt_t GetCheckSum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:9030,checksum,checksum,9030,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,6,['checksum'],['checksum']
Security,"onstDataSet(); }. RooDataHist* GetChainAsDataHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(enum IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if they desire it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by Keys. » Last changed: root/roostats:$Id$ » Last generated: 2015-06-02 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__MCMCInterval.html:19074,expose,exposed,19074,root/html604/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html604/RooStats__MCMCInterval.html,1,['expose'],['exposed']
Security,"onstDataSet(); }. RooDataHist* GetChainAsDataHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(enum IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if they desire it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by Keys. » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__MCMCInterval.html:19074,expose,exposed,19074,root/html602/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__MCMCInterval.html,1,['expose'],['exposed']
Security,"onstructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__SimulatedAnnealing.html:4387,access,accessors,4387,root/html534/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html534/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"onstructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:4772,access,accessors,4772,root/html604/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"onstructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html:4764,access,accessors,4764,root/html602/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"ontaining the class declaration ; Definition at line 102 of file TListOfFunctions.h. ◆ Delete(). void TListOfFunctions::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete all TFunction object files. ; Reimplemented from THashList.; Definition at line 162 of file TListOfFunctions.cxx. ◆ Find(). TFunction * TListOfFunctions::Find ; (; DeclId_t ; id); const. Return the TMethod or TFunction describing the function corresponding to the Decl 'id'. ; Return NULL if not found. ; Definition at line 250 of file TListOfFunctions.cxx. ◆ FindObject() [1/2]. TObject * TListOfFunctions::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a function just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 173 of file TListOfFunctions.cxx. ◆ FindObject() [2/2]. TObject * TListOfFunctions::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 443 of file TListOfFunctions.cxx. ◆ First(). TObject * TListOfFunctions::First ; (; ); const. overridevirtual . Return the first object in the list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 483 of file TListOfFunctions.cxx. ◆ FirstLink(). TObjLink * TListOfFunctions::FirstLink ; (; ); const. overridevirtual . Reimplemented from TList.; Definition at line 491 of file TListOfFunctions.cxx. ◆ Get(). TFunction * TListOfFunctions::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TMethod or TFunction describing the function corresponding to the Decl 'id'. ; Definition at line 262 of file TListOfFunctions.cxx. ◆ GetLast(). Int_t TListOfFunctions::GetLast ; (; ); const. overridevirtual . Returns index of last object in collection. ; Returns -1 when no objects in collection. ; Reimplemented from TSeqCollection.; Definition at line 524 of file TListOfFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:28655,hash,hash,28655,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['hash'],['hash']
Security,"ontents of this histogram. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UseCurrentStyle () override;  Copy current attributes from/to current style. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:30899,hash,hash,30899,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,2,['hash'],['hash']
Security,"ontentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:41387,validat,validate,41387,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['validat'],['validate']
Security,"ontentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_eocachePo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:34408,validat,validate,34408,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,2,['validat'],['validate']
Security,ontrolBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore Counting semaphore class; TSeqCollection Sequenceable collection ABC; TServerSocket This class implements server sockets; TSessionDescription Session description; TSessionFrame Session frame; TSessionInputFrame Input frame; TSessionLogView PROOF progress dialog; TSessionOutputFrame Output frame; TSessionQueryFrame Query frame; TSessionServerFrame Server frame; TSessionViewer Session Viewer; TShape Basic shape; TSignalHandler Signal event handler; TSlave PROOF slave server; TSlaveInfo basic info on slave; TSlaveLite PROOF lite worker server; TSlider A user interface slider.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:117931,authenticat,authentication,117931,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['authenticat'],['authentication']
Security,"onventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 1. Extracting an object from a TFile. File can be local on your disk or remote accessible for instance through http:; root [0] TFile* file = TFile::Open(""http://someserver/somefile.root"");. You can list the objects inside the file using .ls:; root [1] .ls; TFile** hsimple.root Demo ROOT file with histograms; TFile* hsimple.root Demo ROOT file with histograms; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple. You can access objects inside the files by their names, either by using this name as a variable on the prompt:; root [2] hpx->Draw();. In regular code you should use TFile::GetObject():; root [3] TH1* readThis = 0;; root [4] file->GetObject(""hpx"", readThis);. Now let's try this out: get the TTree called ""MyTree"" from a file located at http://root.cern.ch/root/files/tutorials/mockupx.root Note that you don't need to download it with your browser: you just specify the http:// location as an argument to TFile::Open(). Once you have the TTree object, call Print() on it to see its structure.; . ‹ 0. Setting up ROOT; up; 2. Running code in ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/1-extracting-object-tfile.html:2423,access,access,2423,d/1-extracting-object-tfile.html,https://root.cern,https://root.cern/d/1-extracting-object-tfile.html,1,['access'],['access']
Security,"onymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionServerFrame. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h). const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionServerFrame.html:21144,expose,expose,21144,root/html602/TSessionServerFrame.html,https://root.cern,https://root.cern/root/html602/TSessionServerFrame.html,2,['expose'],['expose']
Security,"onymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TExMap.html:7204,hash,hash,7204,root/html602/TExMap.html,https://root.cern,https://root.cern/root/html602/TExMap.html,2,['hash'],['hash']
Security,"onymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches; UChar_t_byteValue! Transient cache for byte values from tree branches; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_t_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:32801,validat,validate,32801,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,4,"['access', 'validat']","['access', 'validate']"
Security,"ooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooListProxy_gamma; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistConstraint.html:41616,access,access,41616,root/html602/RooHistConstraint.html,https://root.cern,https://root.cern/root/html602/RooHistConstraint.html,2,['access'],['access']
Security,"ooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:43745,access,access,43745,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['access'],['access']
Security,"ooArgSet_allDependentsList of generate + prototype dependents; Bool_t_binGenDataBin data between generating and fitting; Bool_t_canAddFitResultsAllow adding of external fit results?; RooAbsGenContext*_constrGenContextGenerator context for constraints p.d.f; RooAbsPdf*_constrPdfConstraints p.d.f; RooArgSet_dependentsList of dependents ; Bool_t_extendedGenAdd poisson term to number of events to generate?; RooArgSet*_fitInitParamsList of initial values of fit parameters; RooAbsPdf*_fitModelFit model ; RooLinkedList_fitOptListFit option command list ; TString_fitOptionsFit options string; RooDataSet*_fitParDataData set of fit parameters of each sample; RooArgSet*_fitParamsList of actual fit parameters; TList_fitResListList of RooFitResult fit output objects; RooAbsGenContext*_genContextGenerator context ; TList_genDataListList of generated data sample; RooArgSet*_genInitParamsList of originalgenerator parameters; RooAbsPdf*_genModelGenerator model ; RooDataSet*_genParDataList of of generated parameters of each sample; RooArgSet*_genParamsList of actual generator parameters; const RooDataSet*_genProtoDataGenerator prototype data set; RooAbsData*_genSampleCurrently generated sample ; list<RooAbsMCStudyModule*>_modListList of additional study modules ;; Double_t_nExpGenNumber of expected events to generate in extended mode; RooRealVar*_ngenVar; RooRealVar*_nllVar; Bool_t_perExptGenParamsDo generation parameter change per event?; RooArgSet_projDepsList of projected dependents in fit; Bool_t_randProtoRandomize order of prototype data access; Bool_t_silenceSilent running mode?; Bool_t_verboseGenVerbose generation?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:11903,access,access,11903,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['access'],['access']
Security,"ooArgSet_allDependentsList of generate + prototype dependents; Bool_t_binGenDataBin data between generating and fitting; Bool_t_canAddFitResultsAllow adding of external fit results?; RooAbsGenContext*_constrGenContextGenerator context for constraints p.d.f; RooAbsPdf*_constrPdfConstraints p.d.f; RooArgSet_dependentsList of dependents ; Bool_t_extendedGenAdd poisson term to number of events to generate?; RooArgSet*_fitInitParamsList of initial values of fit parameters; RooAbsPdf*_fitModelFit model ; RooLinkedList_fitOptListFit option command list ; TString_fitOptionsFit options string; RooDataSet*_fitParDataData set of fit parameters of each sample; RooArgSet*_fitParamsList of actual fit parameters; TList_fitResListList of RooFitResult fit output objects; RooAbsGenContext*_genContextGenerator context ; TList_genDataListList of generated data sample; RooArgSet*_genInitParamsList of originalgenerator parameters; RooAbsPdf*_genModelGenerator model ; RooDataSet*_genParDataList of of generated parameters of each sample; RooArgSet*_genParamsList of actual generator parameters; const RooDataSet*_genProtoDataGenerator prototype data set; RooAbsData*_genSampleCurrently generated sample ; list<RooAbsMCStudyModule*>_modListList of additional study modules ;; Double_t_nExpGenNumber of expected events to generate in extended mode; RooRealVar*_ngenVar; RooRealVar*_nllVar; Bool_t_perExptGenParamsDo generation parameter change per event?; RooArgSet_projDepsList of projected dependents in fit; Bool_t_randProtoRandomize order of prototype data access; Bool_t_silenceSilent running mode?; Bool_t_verboseGenVerbose generation?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCStudy.html:11945,access,access,11945,root/html528/RooMCStudy.html,https://root.cern,https://root.cern/root/html528/RooMCStudy.html,4,['access'],['access']
Security,"ooMCStudy::fitSample ; (; RooAbsData * ; genSample). protected . Internal method. ; Fit given dataset with fit model. If fit converges (TMinuit status code zero) The fit results are appended to the fit results dataset; If the fit option ""r"" is supplied, the RooFitResult objects will always be saved, regardless of the fit status. RooFitResults objects can be retrieved later via fitResult(). ; Definition at line 648 of file RooMCStudy.cxx. ◆ genData(). RooAbsData * RooMCStudy::genData ; (; Int_t ; sampleNum); const. Return the given generated dataset. ; This method will only return datasets if during the run cycle it was indicated that generator data should be saved. ; Definition at line 856 of file RooMCStudy.cxx. ◆ generate(). bool RooMCStudy::generate ; (; Int_t ; nSamples, . Int_t ; nEvtPerSample = 0, . bool ; keepGenData = false, . const char * ; asciiFilePat = nullptr . ). Generate 'nSamples' samples of 'nEvtPerSample' events. ; If keepGenData is set, all generated data sets will be kept in memory and can be accessed later via genData().; Data sets will be written out in ascii form if the pattern string is supplied. The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat"" and should contain one integer field that encodes the sample serial number. ; Definition at line 525 of file RooMCStudy.cxx. ◆ generateAndFit(). bool RooMCStudy::generateAndFit ; (; Int_t ; nSamples, . Int_t ; nEvtPerSample = 0, . bool ; keepGenData = false, . const char * ; asciiFilePat = nullptr . ). Generate and fit 'nSamples' samples of 'nEvtPerSample' events. ; If keepGenData is set, all generated data sets will be kept in memory and can be accessed later via genData().; Data sets will be written out in ascii form if the pattern string is supplied. The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat"" and should contain one integer field that encodes the sample serial number. ; Definition at line 503 of file Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:27208,access,accessed,27208,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['access'],['accessed']
Security,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_se,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:23786,access,access,23786,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['access'],['access']
Security,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; static RooCategorySharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:23599,access,access,23599,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['access'],['access']
Security,"oofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:22965,authenticat,authenticated,22965,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,2,['authenticat'],"['authenticated', 'authentication']"
Security,"ool ROOT::Fit::Fitter::CalculateHessErrors ; (; ). perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the Hessian matrix To be called only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. ; A new FitResult with the Hessian result will be produced ; Definition at line 530 of file Fitter.cxx. ◆ CalculateMinosErrors(). bool ROOT::Fit::Fitter::CalculateMinosErrors ; (; ). perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. ; The result will be appended in the fit result class Optionally a vector of parameter indices can be passed for selecting the parameters to analyse using FitConfig::SetMinosErrors ; Definition at line 593 of file Fitter.cxx. ◆ Config() [1/2]. FitConfig & ROOT::Fit::Fitter::Config ; (; ). inline . access to the configuration (non const method) ; Definition at line 427 of file Fitter.h. ◆ Config() [2/2]. const FitConfig & ROOT::Fit::Fitter::Config ; (; ); const. inline . access to the fit configuration (const method) ; Definition at line 422 of file Fitter.h. ◆ DoBinnedLikelihoodFit(). bool ROOT::Fit::Fitter::DoBinnedLikelihoodFit ; (; bool ; extended = true, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). protected . binned likelihood fit ; Definition at line 360 of file Fitter.cxx. ◆ DoInitMinimizer(). bool ROOT::Fit::Fitter::DoInitMinimizer ; (; ). protected . Definition at line 692 of file Fitter.cxx. ◆ DoLeastSquareFit(). bool ROOT::Fit::Fitter::DoLeastSquareFit ; (; const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential). protected . least square fit ; Definition at line 309 of file Fitter.cxx. ◆ DoLinearFit(). bool ROOT::Fit::Fitter::DoLinearFit ; (; ). protected . linear least square fit ; Definition at line 513 of file Fitter.cxx. ◆ DoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:18398,access,access,18398,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['access'],['access']
Security,"ool flag);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double weight (Int_t index) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:9740,hash,hash,9740,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['hash'],['hash']
Security,"ool range=true);  ; virtual void SetUnsigned ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafB.html:5340,hash,hash,5340,doc/master/classTLeafB.html,https://root.cern,https://root.cern/doc/master/classTLeafB.html,13,['hash'],['hash']
Security,"oolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:34868,access,access,34868,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,2,['access'],['access']
Security,"ool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when ente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:368600,access,access,368600,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"ool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adjust the type according to findings; 4883 type = (localFile) ? kLocal : type;; 4884 } else if (TPMERegexp(""^(http[s]?|s3http[s]?|[a]?s3|gs|gshttp[s]?){1}:"", ""i"").Match(name)) {; 4885 //; 4886 // Web file; 4887 type = kWeb;; 4888 } else if (!strncmp(name, ""file:"", 5)) {; 4889 //; 4890 // 'file' protocol; 4891 type = kFile;; 4892 }; 4893 // We are done; 4894 return type;; 4895}; 4896 ; 4897////////////////////////////////////////////////////////////////////////////////; 4898/// Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:178324,access,access,178324,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['access'],['access']
Security,"ool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:6052,access,accessible,6052,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,2,['access'],['accessible']
Security,"oose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  . Protected Attributes; std::string fMethod;  minimizer method to be used, must be of a type listed in R optim or optimx descriptions ;  ;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . Private Attributes; TMatrixD fCovMatrix;  covariant matrix ;  ; std::vector< double > fErrors;  vector of parameter errors ;  ; TMatrixD fHessMatrix;  Hessian matrix. ;  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Math::BasicMinimizer; bool CheckDimension () const;  ; bool CheckObjFunction () const;  ; MinimTransformFunction * CreateTransformation (std::vector< double > &startValues, const ROOT::Math::IMultiGradFunction *func=nullptr);  ; void SetFinalValues (const double *x, const MinimTransformFunction *func=nullptr);  ; void SetMinValue (double val);  . #include <Math/RMinimizer.h>. Inheritance diagram for ROOT::Math::RMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RMinimizer.html:11075,validat,validated,11075,doc/master/classROOT_1_1Math_1_1RMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RMinimizer.html,1,['validat'],['validated']
Security,"ootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:16572,authoriz,authorization,16572,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authoriz'],['authorization']
Security,opagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_mistag; RooCategoryProxy_mixState; RooRealProxyRooAbsAnaConvPdf::_modelOrigina,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBMixDecay.html:42059,access,access,42059,root/html534/RooBMixDecay.html,https://root.cern,https://root.cern/root/html534/RooBMixDecay.html,1,['access'],['access']
Security,"opeIndep = false . ). A variation of the previous addToCodeBody that takes in a bool value that determines if input is independent. ; This overload exists because there might other ways to determine if a value/collection of values is scope independent. Parameters. inString to add to the squashed code. ; isScopeIndepThe value determining if the input is scope dependent. . Definition at line 123 of file CodeSquashContext.cxx. ◆ addToGlobalScope(). void RooFit::Detail::CodeSquashContext::addToGlobalScope ; (; std::string const & ; str). Adds the given string to the string block that will be emitted at the top of the squashed function. ; Useful for variable declarations. Parameters. strThe string to add to the global scope. . Definition at line 81 of file CodeSquashContext.cxx. ◆ addVecObs(). void RooFit::Detail::CodeSquashContext::addVecObs ; (; const char * ; key, . int ; idx . ). Since the squashed code represents all observables as a single flattened array, it is important to keep track of the start index for a vector valued observable which can later be expanded to access the correct element. ; For example, a vector valued variable x with 10 entries will be squashed to obs[start_idx + i]. Parameters. keyThe name of the node representing the vector valued observable. ; idxThe start index (or relative position of the observable in the set of all observables). . Definition at line 99 of file CodeSquashContext.cxx. ◆ assembleCode(). std::string RooFit::Detail::CodeSquashContext::assembleCode ; (; std::string const & ; returnExpr). Assemble and return the final code with the return expression and global statements. ; Parameters. returnExprThe string representation of what the squashed function should return, usually the head node. . ReturnsThe final body of the function. ; Definition at line 89 of file CodeSquashContext.cxx. ◆ beginLoop(). std::unique_ptr< CodeSquashContext::LoopScope > RooFit::Detail::CodeSquashContext::beginLoop ; (; RooAbsArg const * ; in). Create a R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html:8436,access,access,8436,doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html,1,['access'],['access']
Security,"open operations in ms - 0 corresponds to blocking i/o; static TUrlfgProxyglobally set proxy URL; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TWebFile. ←. TS3WebFile. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:25498,authenticat,authentication,25498,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['authenticat'],['authentication']
Security,"operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidOptimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetCanDelete(Bool_t opt = kTRUE); virtual voidSetCheckSum(UInt_t checksum); virtual voidSetClass(TClass* cl); virtual voidSetClassVersion(Int_t vers); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetFactory(TVirtualStreamerInfo* factory); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static Bool_tSetStreamMemberWise(Bool_t enable = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagFile(TFile* fFile); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(const TClass* oldClass, TClass* newClass); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualStreamerInfo.html:6182,checksum,checksum,6182,root/html530/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html530/TVirtualStreamerInfo.html,2,['checksum'],['checksum']
Security,"operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidOptimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetCanDelete(Bool_t opt = kTRUE); virtual voidSetCheckSum(UInt_t checksum); virtual voidSetClass(TClass* cl); virtual voidSetClassVersion(Int_t vers); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetFactory(TVirtualStreamerInfo* factory); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static Bool_tSetStreamMemberWise(Bool_t enable = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagFile(TFile* fFile); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(const TClass* oldClass, TClass* newClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:6362,checksum,checksum,6362,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,1,['checksum'],['checksum']
Security,"operator=(const TCollection &)=delete; TCollection::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TCollection.h:189; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:18142,access,accessible,18142,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['access'],['accessible']
Security,"operly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printCompactTree(ostream& os, const char* indent, const char* namePat, RooAbsArg* client); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:32458,checksum,checksum,32458,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['checksum'],['checksum']
Security,"opied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPolynomial.html:40270,access,access,40270,root/html534/RooPolynomial.html,https://root.cern,https://root.cern/root/html534/RooPolynomial.html,1,['access'],['access']
Security,"option as ""X=number"", for example ""X=10000"" for 10000 toys. The function returns the probability. (thanks to Ben Kilminster to submit this procedure). Note that this option ""X"" is much slower. The returned function value is the probability of test (much less than one means NOT compatible); Code adapted by Rene Brun from original HBOOK routine HDIFF; NOTE1 A good description of the Kolmogorov test can be seen at: http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; NOTE2 see also alternative function TH1::Chi2Test The Kolmogorov test is assumed to give better results than Chi2Test in case of histograms with low statistics.; NOTE3 (Jan Conrad, Fred James) ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform distributions of 500 events in 100 bins, the values of PROB,; instead of being exactly uniformly distributed between zero and one, have; a mean value of about 0.56. We can apply a useful; rule: As long as the bin width is small compared with any significant; physical effect (for example the experimental resolution) then the binning; cannot have an important effect. Therefore, we believe that for all; practical purposes, the probability value PROB is calculated correctly; provided the user is aware that:. 1. The value of PROB should not be expected to have exactly the correct; distribution for binned data.; 2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:185165,access,access,185165,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security,"options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:20772,authenticat,authentication,20772,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authentication']
Security,"opy constructor (disabled, class is not copyable) ;  ;  Fitter (const std::shared_ptr< FitResult > &result);  Constructor from a result. ;  ; virtual ~Fitter ();  Destructor. ;  ; bool ApplyWeightCorrection (const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false);  apply correction in the error matrix for the weights for likelihood fits This method can be called only after a fit. ;  ; bool CalculateHessErrors ();  perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the Hessian matrix To be called only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. ;  ; bool CalculateMinosErrors ();  perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. ;  ; FitConfig & Config ();  access to the configuration (non const method) ;  ; const FitConfig & Config () const;  access to the fit configuration (const method) ;  ; bool EvalFCN ();  Perform a simple FCN evaluation. ;  ; bool Fit (const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  Fit a binned data set using a least square fit. ;  ; template<class Data , class Function , class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value || std::is_same<Function, int>::value), Function>::type> ; bool Fit (const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  fit a data set using any generic model function If data set is binned a least square fit is performed If data set is unbinned a maximum likelihood fit (not extended) is done Pre-requisite on the function: it must implement the 1D or multidimensional parametric function interface. ;  ; bool Fit (const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:2998,access,access,2998,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,2,['access'],['access']
Security,"or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THostAuth.html:9801,authenticat,authentication,9801,root/html528/THostAuth.html,https://root.cern,https://root.cern/root/html528/THostAuth.html,6,['authenticat'],['authentication']
Security,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:8768,access,access,8768,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['access'],['access']
Security,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:8996,access,access,8996,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['access'],['access']
Security,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:9073,access,access,9073,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['access'],['access']
Security,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:9020,access,access,9020,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['access'],['access']
Security,"or CI function of the cell content.; 2795/// if the cell content is N, the color CI used will be the color number; 2796/// in colors[N],etc. If the maximum cell content is > ncolors, all; 2797/// cell contents are scaled to ncolors.; 2798///; 2799/// `if ncolors <= 0` a default palette (see below) of 50 colors is; 2800/// defined. The colors defined in this palette are OK for coloring pads, labels.; 2801///; 2802/// ~~~ {.cpp}; 2803/// index 0->9 : grey colors from light to dark grey; 2804/// index 10->19 : ""brown"" colors; 2805/// index 20->29 : ""blueish"" colors; 2806/// index 30->39 : ""redish"" colors; 2807/// index 40->49 : basic colors; 2808/// ~~~; 2809///; 2810/// `if ncolors == 1 && colors == 0`, a Rainbow Color map is created; 2811/// with 50 colors. It is kept for backward compatibility. Better palettes like; 2812/// kBird are recommended.; 2813///; 2814/// High quality predefined palettes with 255 colors are available when `colors == 0`.; 2815/// The following value of `ncolors` give access to:; 2816///; 2817/// ~~~ {.cpp}; 2818/// if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2819/// if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2820/// if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2821/// if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); 2822/// if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2823/// if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; 2824/// if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; 2825/// if ncolors = 58 and colors=0, a Cubehelix palette is used; 2826/// (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); 2827/// if ncolors = 59 and colors=0, a Green Red Violet palette is used.; 2828/// if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; 2829/// if ncolors = 61 and colors=0, an Ocean palette is u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:102940,access,access,102940,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['access']
Security,"or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);. returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3.; Alphanumeric Bin Labels; By default, an histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See example in $ROOTSYS/tutorials/graphs/labels1.C, labels2.C; call to a Fill function with one of the arguments being a string, e.g. hist1->Fill(somename, weigth);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);. See example in $ROOTSYS/tutorials/hist/hlabels1.C, hlabels2.C; via TTree::Draw.; see for example $ROOTSYS/tutorials/tree/cernstaff.C. tree.Draw(""Nation::Division"");. where ""Nation"" and ""Division"" are two br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:4918,access,access,4918,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['access'],['access']
Security,"or bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. » Author: Asen Christov, Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss , Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: PDF.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDF.html:13247,access,accessors,13247,root/html530/TMVA__PDF.html,https://root.cern,https://root.cern/root/html530/TMVA__PDF.html,1,['access'],['accessors']
Security,"or bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. » Author: Asen Christov, Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss , Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: PDF.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__PDF.html:13247,access,accessors,13247,root/html532/TMVA__PDF.html,https://root.cern,https://root.cern/root/html532/TMVA__PDF.html,1,['access'],['accessors']
Security,"or bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. » Author: Asen Christov, Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: PDF.h 33928 2010-06-15 16:19:31Z stelzer $ » Last generated: 2010-12-13 17:53; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDF.html:12542,access,accessors,12542,root/html528/TMVA__PDF.html,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html,1,['access'],['accessors']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html:6414,access,access,6414,root/html528/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html:6416,access,access,6416,root/html530/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html:6416,access,access,6416,root/html532/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const Double32_t* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html:6456,access,access,6456,root/html534/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html:5894,access,access,5894,root/html528/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html:5896,access,access,5896,root/html530/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_double_2_.html:5896,access,access,5896,root/html532/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:5932,access,access,5932,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,26,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:5764,access,access,5764,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html:5766,access,access,5766,root/html530/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html:5766,access,access,5766,root/html532/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html:5801,access,access,5801,root/html534/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html,18,['access'],['access']
Security,"or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:83376,access,access,83376,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['access']
Security,"or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:353; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:83204,access,access,83204,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html:6324,access,access,6324,root/html528/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html:6326,access,access,6326,root/html530/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html:6326,access,access,6326,root/html532/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const Double32_t* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html:6366,access,access,6366,root/html534/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html:5804,access,access,5804,root/html528/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html:5806,access,access,5806,root/html530/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_double_2_.html:5806,access,access,5806,root/html532/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:5842,access,access,5842,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,26,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:5674,access,access,5674,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html:5676,access,access,5676,root/html530/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html:5676,access,access,5676,root/html532/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html:5711,access,access,5711,root/html534/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html,18,['access'],['access']
Security,"or storage backend ;  CTChainA chain is a collection of files containing TTree objects ;  CTChainElementA TChainElement describes a component of a TChain ;  ►CTChainIndexA Chain Index ;  CTChainIndexEntryHolds a description of indices of trees in the chain ;  CTChair;  CTChirpFileRead and write data via a Chirp server ;  CTChirpSystem;  CTCivetweb;  CTCL;  ►CTClassThe ROOT global object gROOT contains a list of all defined classes ;  CInsertTClassInRegistryRAII;  CTDeclNameRegistry;  CTNameMapNode;  CTClassDocInfo;  CTClassDocOutput;  CTClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized way to create the TClass objects ;  CTClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe ;  CTClassRefTClassRef is used to implement a permanent reference to a TClass object ;  CTClassStreamer;  CTClassTableThis class registers for all classes their name, id and dictionary function in a hash table ;  CTClassTreeDraw inheritance tree and their relations for a list of classes ;  CTClonesArrayAn array of clone (identical) objects ;  CTCollectionCollection abstract base class ;  CTCollectionClassStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTCollectionMemberStreamerClass streamer object to implement TMemberStreamer functionality for I/O emulation ;  CTCollectionMethodBrowsableTCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing all methods of the collection itself ;  CTCollectionPropertyBrowsableA tiny browser helper object (and its generator) for adding a virtual (as in ""not actually part of the class"", not in C++ virtual) ""@size()"" method to a collection ;  CTCollectionProxyFactoryTCollectionProxyFactory Interface to collection proxy and streamer generator ;  CTCollectionStreamerClass streamer object to implement TClassStreamer functionality for I/O emulation ;  CTColorThe color creation and management c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:131672,hash,hash,131672,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['hash'],['hash']
Security,"or(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48188,access,access,48188,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['access'],['access']
Security,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TKSocket.html:5357,authenticat,authentication,5357,root/html534/TKSocket.html,https://root.cern,https://root.cern/root/html534/TKSocket.html,1,['authenticat'],['authentication']
Security,"or, Deconvolution for 2-D histograms; TSpectrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrum2Painter TSpectrum 3d graphics package; TSpectrum2Transform Spectrum2 Transformer, it calculates classic orthogonal 2D transforms; TSpectrum3 Peak Finder, Background estimator, Markov smoothing and Deconvolution for 3-D histograms; TSpectrumFit Spectrum Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrumTransform Spectrum Transformer, it calculates classic orthogonal 1D transforms; TSpider Helper class to draw spider; TSpiderEditor GUI for editing the spider plot attributes.; TSpline Spline base class; TSpline3 Class to create third natural splines; TSpline5 Class to create quintic natural splines; TSplinePoly Spline polynomial terms; TSplinePoly3 Third spline polynomial terms; TSplinePoly5 Quintic spline polynomial terms; TStatus Status class; TStdExceptionHandler C++ exception handler; TStopwatch A stopwatch which times real and cpu time; TStorage Storage manager class; TStreamerArtificial StreamerElement injected by a TSchemaRule. Transient only to preverse forward compatibility.; TStreamerBase Streamer element of type base class; TStreamerBasicPointer Streamer element for a pointer to a basic type; TStreamerBasicType Streamer element for a basic type; TStreamerElement Base class for one element (data member) to be Streamed; TStreamerInfo Streamer information for one class version; TStreamerInfoActions ; TStreamerInfoActions::TActionSequence ; TStreamerInfoActions::TConfiguration ; TStreamerInfoActions::TConfiguredAction A configured action; TStreamerLoop Streamer element for a pointer to an array of objects; TStreamerObject Streamer element of type object; TStreamerObjectAny Streamer element of type object other than TObject; TStreamerObjectAnyPointer Streamer element of type poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:125860,inject,injected,125860,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['inject'],['injected']
Security,"or, Deconvolution for 2-D histograms; TSpectrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrum2Painter TSpectrum 3d graphics package; TSpectrum2Transform Spectrum2 Transformer, it calculates classic orthogonal 2D transforms; TSpectrum3 Peak Finder, Background estimator, Markov smoothing and Deconvolution for 3-D histograms; TSpectrumFit Spectrum Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrumTransform Spectrum Transformer, it calculates classic orthogonal 1D transforms; TSpider Helper class to draw spider; TSpiderEditor GUI for editing the spider plot attributes.; TSpline Spline base class; TSpline3 Class to create third natural splines; TSpline5 Class to create quintic natural splines; TSplinePoly Spline polynomial terms; TSplinePoly3 Third spline polynomial terms; TSplinePoly5 Quintic spline polynomial terms; TStatus Status class; TStdExceptionHandler C++ exception handler; TStopwatch A stopwatch which times real and cpu time; TStorage Storage manager class; TStreamerArtificial StreamerElement injected by a TSchemaRule. Transient only to preverse forward compatibility.; TStreamerBase Streamer element of type base class; TStreamerBasicPointer Streamer element for a pointer to a basic type; TStreamerBasicType Streamer element for a basic type; TStreamerElement Base class for one element (data member) to be Streamed; TStreamerInfo Streamer information for one class version; TStreamerLoop Streamer element for a pointer to an array of objects; TStreamerObject Streamer element of type object; TStreamerObjectAny Streamer element of type object other than TObject; TStreamerObjectAnyPointer Streamer element of type pointer to a non TObject; TStreamerObjectPointer Streamer element of type pointer to a TObject; TStreamerSTL Streamer element of type STL container; TStreamerSTLstring",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:118891,inject,injected,118891,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['inject'],['injected']
Security,"or. Deletes all list that might have been created. ; Definition at line 1660 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 494 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Definition at line 511 of file TClass.cxx. ◆ AddImplFile(). void TClass::AddImplFile ; (; const char * ; filename, . int ; line . ). Definition at line 1952 of file TClass.cxx. ◆ AddInstance(). void TClass::AddInstance ; (; Bool_t ; heap = kFALSE). inline . Definition at line 381 of file TClass.h. ◆ AddRule(). Bool_t TClass::AddRule ; (; const char * ; rule). static . Add a schema evolution customization rule. ; The syntax of the rule can be either the short form: [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:53094,checksum,checksum,53094,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"or. Deletes all list that might have been created. ; Definition at line 1727 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 555 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Definition at line 576 of file TClass.cxx. ◆ AddImplFile(). void TClass::AddImplFile ; (; const char * ; filename, . int ; line . ). Definition at line 2019 of file TClass.cxx. ◆ AddInstance(). void TClass::AddInstance ; (; Bool_t ; heap = kFALSE). inline . Definition at line 381 of file TClass.h. ◆ AddRule(). Bool_t TClass::AddRule ; (; const char * ; rule). static . Add a schema evolution customization rule. ; The syntax of the rule can be either the short form: [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:53095,checksum,checksum,53095,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"or; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:20894,authenticat,authenticated,20894,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authenticated']
Security,"or< std::string > &output, int &nestedLoc, EModType mode=TClassEdit::kNone);  Stores in output (after emptying it) the split type. ;  ; bool GetStdArrayProperties (const char *typeName, std::string &typeNameBuf, std::array< int, 5 > &maxIndices, int &ndim);  ; std::string GetUniquePtrType (std::string_view name);  ; const char * GetUnqualifiedName (const char *name);  Return the start of the unqualified name include in 'original'. ;  ; void Init (TClassEdit::TInterpreterLookupHelper *helper);  ; std::string InsertStd (const char *tname);  ; bool IsArtificial (std::string_view name);  ; bool IsDefAlloc (const char *alloc, const char *classname);  return whether or not 'allocname' is the STL default allocator for type 'classname' ;  ; bool IsDefAlloc (const char *alloc, const char *keyclassname, const char *valueclassname);  return whether or not 'allocname' is the STL default allocator for a key of type 'keyclassname' and a value of type 'valueclassname' ;  ; bool IsDefComp (const char *comp, const char *classname);  return whether or not 'compare' is the STL default comparator for type 'classname' ;  ; bool IsDefHash (const char *hashname, const char *classname);  return whether or not 'hashname' is the STL default hash for type 'classname' ;  ; bool IsDefPred (const char *predname, const char *classname);  return whether or not 'predname' is the STL default predicate for type 'classname' ;  ; bool IsInterpreterDetail (const char *type);  Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t etc..) ;  ; bool IsStdArray (std::string_view name);  ; bool IsStdClass (const char *type);  return true if the class belongs to the std namespace ;  ; bool IsStdPair (std::string_view name);  ; bool IsStdPairBase (std::string_view name);  ; bool IsSTLBitset (const char *type);  Return true is the name is std::bitset<number> or bitset<number> ;  ; int IsSTLCont (const char *type, int testAlloc);  type : type name: vector<list<classA,a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTClassEdit.html:3777,hash,hashname,3777,doc/master/namespaceTClassEdit.html,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html,3,['hash'],"['hash', 'hashname']"
Security,"or==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:5846,access,access,5846,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html:5848,access,access,5848,root/html530/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"or==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html:5848,access,access,5848,root/html532/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"orDefinition TROOT.cxx:304; ROOT::Internal::TROOTAllocator::TROOTAllocatorTROOTAllocator()Definition TROOT.cxx:341; ROOT::Internal::TROOTAllocator::fHolderchar fHolder[sizeof(TROOT)]Definition TROOT.cxx:338; ROOT::Internal::TROOTAllocator::fObjTROOT fObjDefinition TROOT.cxx:337; ROOT::Internal::TROOTAllocator::~TROOTAllocator~TROOTAllocator()Definition TROOT.cxx:344; ROOT::TVirtualRWMutexDefinition TVirtualRWMutex.h:39; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1975; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::SetRefreshFlagvoid SetRefreshFlag(Bool_t flag)Definition TBrowser.h:100; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:585; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetDeclFileNameconst char * GetDeclFileName() constR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:130709,hash,hash,130709,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['hash'],['hash']
Security,"orIdMap_t::const_iterator const_iteratorDefinition TClass.cxx:372; ROOT::TMapTypeToTClass::key_typeIdMap_t::key_type key_typeDefinition TClass.cxx:371; TClassTable::NormalizeThenLockDefinition TClassTable.cxx:70; TClassTable::NormalizeThenLock::GetNormalizedNameconst std::string & GetNormalizedName() constDefinition TClassTable.cxx:98; TClassTable::NormalizeThenLock::fNormalizedNamestd::string fNormalizedNameDefinition TClassTable.cxx:71; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(const NormalizeThenLock &)=delete; TClassTable::NormalizeThenLock::~NormalizeThenLock~NormalizeThenLock()Definition TClassTable.cxx:94; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(const char *cname)Definition TClassTable.cxx:80; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(NormalizeThenLock &&)=delete; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock()=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(const NormalizeThenLock &)=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(NormalizeThenLock &&)=delete; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTable::PrintTablestatic void PrintTable()Print the class table.Definition TClassTable.cxx:823; TClassTable::GetPragmaBitsstatic Int_t GetPragmaBits(const char *name)Returns the pragma bits as specified in the LinkDef.h file.Definition TClassTable.cxx:660; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetIDstatic Version_t GetID(const char *cname)Returns the ID of a class.Definition TClassTable.cxx:647; TClassTable::IdMap_tROOT::TMapTypeToClassRec IdMap_tDefinition TClassTable.h:43; TClassTable::SortTablestatic void SortTable()Sort the class table by ascending c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:41260,hash,hash,41260,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['hash'],['hash']
Security,"orObject() [2/2]. const TList * THashList::GetListForObject ; (; const TObject * ; obj); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 294 of file THashList.cxx. ◆ IsA(). TClass * THashList::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 72 of file THashList.h. ◆ operator=(). THashList & THashList::operator= ; (; const THashList & ; ). privatedelete . ◆ RecursiveRemove(). void THashList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 310 of file THashList.cxx. ◆ Rehash(). void THashList::Rehash ; (; Int_t ; newCapacity). Rehash the hashlist. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. ; Definition at line 368 of file THashList.cxx. ◆ Remove() [1/2]. TObject * THashList::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Implements TCollection.; Reimplemented in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:31545,hash,hash,31545,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,2,['hash'],['hash']
Security,"ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Helper function for resolving MANY.; Specify the ONLY volume that overlaps with the; specified MANY and has to be substracted.; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the volume specified by; the volumeName. Int_t VolId(const char* volName) const; Return the medium parameters for the volume specified by the; volumeName.; functions for drawing; virtual void DrawOneSpec(const char* name) = 0;; virtual void Gsatt(const char* name, const char* att, Int_t val) = 0;; virtual void Gdraw(const char*,Double_t theta = 30, Double_t phi = 30,; Double_t psi = 0, Double_t u0 = 10, Double_t v0 = 10,; Double_t ul = 0.01, Double_t vl = 0.01) = 0;; Euclid; virtual void WriteEuclid(const char*, const char*, Int_t, Int_t) = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:14413,access,access,14413,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,6,['access'],['access']
Security,"ordinates are compacted to use as few bits as possible; e.g. a histogram with 10 bins in x and 20 bins in y will only use 4 bits for the x representation and 5 bits for the y representation. This is handled by the internal class THnSparseCompactBinCoord. Bin data (content and coordinates) are allocated in chunks of size fChunkSize; this parameter can be set when constructing a THnSparse. Each chunk is represented by an object of class THnSparseArrayChunk.; Translation from an n-dimensional bin coordinate to the linear index within the chunks is done by GetBin(). It creates a hash from the compacted bin coordinates (the hash of a bin coordinate is the compacted coordinate itself if it takes less than 8 bytes, the size of a Long64_t. This hash is used to lookup the linear index in the TExMap member fBins; the coordinates of the entry fBins points to is compared to the coordinates passed to GetBin(). If they do not match, these two coordinates have the same hash - which is extremely unlikely but (for the case where the compact bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to GetBin() will retrieve the matching bin. ; Definition at line 37 of file THnSparse.h. Public Member Functions;  ~THnSparse () override;  Destruct a THnSparse. ;  ; void AddBinContent (const Int_t *idx, Double_t v=1.);  Forwards to THnBase::AddBinContent(). ;  ; void AddBinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:4478,hash,hash,4478,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['hash'],['hash']
Security,"ores objects in a file-system-li...Definition TFile.h:53; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; mTMarker mDefinition textangle.C:8. Definition at line 31 of file TMacro.h. Public Member Functions;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual Longptr_t Exec (const char *params=nullptr, Int_t *error=nullptr);  Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save macro source on stream out. ;  ; virtual void SaveSource (const char *filename);  Save macro source in filename. ;  ; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:2503,checksum,checksum,2503,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['checksum'],['checksum']
Security,"ormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::IsEmptybool IsEmpty() constTrue if a fit result does not exist (even invalid) with parameter values.Definition FitResult.h:108; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::Parametersconst std::vector< double > & Parameters() constparameter values (return std::vector)Definition FitResult.h:167; ROOT::Fit::FitResult::Ndfunsigned int Ndf() constNumber of degree of freedom.Definition FitResult.h:156; ROOT::Fit::FitResult::Chi2double Chi2() constReturn the Chi2 value after fitting In case of unbinned fits (or not defined one, see the documentati...Definition FitResult.h:153; ROOT::Fit::FitResult::Printvoid Print(std::ostr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:47316,access,access,47316,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['access'],['access']
Security,"ormance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:10752,access,access,10752,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['access'],['access']
Security,"ormat::kNEAAnyNumber);; TGNumberEntryField is a plain vanilla entry field, whereas TGNumberEntry adds two small buttons to increase and decrease the numerical value in the field. The number entry widgets also support using the up and down cursor keys to change the numerical values. The step size can be selected with control and shift keys:. –small step (1 unit/factor of 3); Shift medium step (10 units/factor of 10); Controllarge step (100 units/factor of 30); Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set when the entry field is created, but it can be changed by pressing the alt key at the same time.; 25.8.4 Menus; Menus provide a list of commands or options helping the user to select and to perform a task. The menu system classes are TGMenuBar, TGMenuTitle, TGPopupMenu, and TGMenuEntry.; The TGMenuBar class implements a menu bar widget. It is used to specify and provide access to common and frequently used application actions described in menu titles, implemented by TGMenuTitle class. The menu bar is the highest-level of the menu system and it is a starting point for all interactions. Also, it is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame).; The menu bar is as a container for its menus - objects of the type TGPopupMenu. Popup menus can appear in a menu bar. They can be a sub-menu of another popup menu (cascading menus) or can be standalone (as a context menu). They are made of one or more menu items choices. When displayed, the menu items are arranged in a vertical list. Usually they correspond to actions (e.g. Open). These items can be labeled with text, graphics or a combination of both. Each of them should have a character defined as its unique key for access. Grouped logically by their func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1189654,access,access,1189654,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"orrectly.Definition TTreeReaderValue.h:84; ROOT::Internal::TTreeReaderValueBase::GetDerivedTypeNamevirtual const char * GetDerivedTypeName() const =0; ROOT::Internal::TTreeReaderValueBase::fBranchNameTString fBranchNameName of the branch to read data from.Definition TTreeReaderValue.h:128; ROOT::Internal::TTreeReaderValueBase::ProxyReadTemplateROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate()Try to read the value from the TBranchProxy, returns the status of the read.Definition TTreeReaderValue.cxx:145; ROOT::Internal::TTreeReaderValueBase::fTreeReaderTTreeReader * fTreeReaderTree reader we belong to.Definition TTreeReaderValue.h:130; ROOT::Internal::TTreeReaderValueBase::fDictTDictionary * fDictType that the branch should contain.Definition TTreeReaderValue.h:131; ROOT::Internal::TTreeReaderValueBase::operator=TTreeReaderValueBase & operator=(const TTreeReaderValueBase &)Copy-assign.Definition TTreeReaderValue.cxx:93; ROOT::Internal::TTreeReaderValueBase::fReadStatusEReadStatus fReadStatusRead status of this data access.Definition TTreeReaderValue.h:126; ROOT::Internal::TTreeReaderValueBase::GetBranchNameconst char * GetBranchName() constDefinition TTreeReaderValue.h:95; ROOT::Internal::TTreeReaderValueBase::ErrorAboutMissingProxyIfNeededvoid ErrorAboutMissingProxyIfNeeded()Definition TTreeReaderValue.cxx:817; ROOT::Internal::TTreeReaderValueBase::GetLeafTLeaf * GetLeaf()If we are reading a leaf, return the corresponding TLeaf.Definition TTreeReaderValue.h:91; ROOT::Internal::TTreeReaderValueBase::ProxyReadEReadStatus ProxyRead()Definition TTreeReaderValue.h:74; ROOT::Internal::TTreeReaderValueBase::~TTreeReaderValueBasevirtual ~TTreeReaderValueBase()Unregister from tree reader, cleanup.Definition TTreeReaderValue.cxx:118; ROOT::Internal::TTreeReaderValueBase::BranchProxyRead_tbool(ROOT::Detail::TBranchProxy::* BranchProxyRead_t)()Definition TTreeReaderValue.h:78; ROOT::Internal::TTreeReaderValueBase::ProxyReadDefaultImplEReadStatus ProxyReadDefa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:16734,access,access,16734,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['access'],['access']
Security,"orresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stack index; gGeoManager->PopPath(Int_t index);; TGeoManager::PopPointBool_t PopPoint()Definition TGeoManager.h:595; TGeoManager::PushPointInt_t PushPoint(Int_t startlevel=0)Definition TGeoManager.h:594; TGeoManager::PushPathInt_t PushPath(Int_t startlevel=0)Definition TGeoManager.h:591; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:79327,access,access,79327,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['access']
Security,"ors=0, a Copper palette is used.; if ncolors = 111 and colors=0, a Gist Earth palette is used.; if ncolors = 112 and colors=0, a Viridis palette is used.; if ncolors = 113 and colors=0, a Cividis palette is used.; a#define a(i)Definition RSha256.hxx:99; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; These palettes can also be accessed by names: kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; kBird=57, kCubehelix=58, kGreenRedViolet=59,; kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; kAlpine=63, kAquamarine=64, kArmy=65,; kAtlantic=66, kAurora=67, kAvocado=68,; kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; kBrownCyan=72, kCMYK=73, kCandy=74,; kCherry=75, kCoffee=76, kDarkRainBow=77,; kDarkTerrain=78, kFall=79, kFruitPunch=80,; kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; kGreenPink=84, kIsland=85, kLake=86,; kLightTemperature=87, kLightTerrain=88, kMint=89,; kNeon=90, kPastel=91, kPearl=92,; kPigeon=93, kPlum=94, kRedBlue=95,; kRose=96, kRust=97, kSandyTerrain=98,; kSienna=99, kSolar=100, kSouthWest=101,; kStarryNight=102, kSunset=103, kTemperatureMap=104,; kThermometer=105, kValentine=106, kVisibleSpectrum=107,; kWaterMelon=108, kCool=109, kCopper=110,; kGistEarth=111 kViridis=112, kCividis=113; For example: gStyle->SetPalette(kBird);; Set the current palette as ""Bird"" (number 57).; The color numbers specified in the palette can be viewed by selecting the item ""colors"" in the ""VIEW"" menu of the canvas toolbar. The color parameters can be changed via TColor::SetRGB.; Note that when drawing a 2D histogram h2 with the option ""COL"" or ""COLZ"" or with any ""CONT"" options using the color map, the number of colors used is defined by the number of contours n specified with: h2->SetContour(n) ; Definition at line 2921 of file TColor.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:72440,access,accessed,72440,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['access'],['accessed']
Security,"ory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Types::kFDA@ kFDADefinition Types.h:92; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMVA::Types::kPDEFoam@ kPDEFoamDefinition Types.h:94; TMVA::Types::kMLP@ kMLPDefinition Types.h:90; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::TMVAMultiClassGuivoid TMVAMultiClassGui(const char *fName=""TMVAMulticlass.root"", TString dataset=""""); Factory.h; AuthorAndreas Hoecker ; Definition in file TMVAMulticlass.C. tutorialstmvaTMVAMulticlass.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:41500,access,access,41500,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,2,['access'],['access']
Security,"ost member functions defined in this base class are in general overridden by the derived classes. ; Definition at line 29 of file TNamed.h. Public Member Functions;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTNamed.html:1503,hash,hash,1503,doc/v632/classTNamed.html,https://root.cern,https://root.cern/doc/v632/classTNamed.html,2,['hash'],['hash']
Security,"ost' header to include in the HTTP request. ; Definition at line 189 of file TS3HTTPRequest.cxx. ◆ MakeRequestLine(). TString TS3HTTPRequest::MakeRequestLine ; (; TS3HTTPRequest::EHTTPVerb ; httpVerb); const. protected . Returns the first line of a HTTP request for this object. ; Note that since we don't use the virtual host syntax which is supported by Amazon, we must include the bucket name in thr resource. For example, we don't use http://mybucket.s3.amazonaws.com/path/to/my/file but instead http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1"" Also note that the path must include the leading '/'. ; Definition at line 178 of file TS3HTTPRequest.cxx. ◆ MakeTokenHeader(). TString TS3HTTPRequest::MakeTokenHeader ; (; ); const. protected . Returns the session security token header for this HTTP request. ; Definition at line 205 of file TS3HTTPRequest.cxx. ◆ SetAccessKey(). TS3HTTPRequest & TS3HTTPRequest::SetAccessKey ; (; const TString & ; accessKey). inline . Definition at line 145 of file TS3HTTPRequest.h. ◆ SetAuthKeys(). TS3HTTPRequest & TS3HTTPRequest::SetAuthKeys ; (; const TString & ; accessKey, . const TString & ; secretKey . ). inline . Definition at line 132 of file TS3HTTPRequest.h. ◆ SetAuthType(). TS3HTTPRequest & TS3HTTPRequest::SetAuthType ; (; TS3HTTPRequest::EAuthType ; authType). inline . Definition at line 139 of file TS3HTTPRequest.h. ◆ SetBucket(). TS3HTTPRequest & TS3HTTPRequest::SetBucket ; (; const TString & ; bucket). inline . Definition at line 120 of file TS3HTTPRequest.h. ◆ SetHost(). TS3HTTPRequest & TS3HTTPRequest::SetHost ; (; const TString & ; host). inline . Definition at line 114 of file TS3HTTPRequest.h. ◆ SetObjectKey(). TS3HTTPRequest & TS3HTTPRequest::SetObjectKey ; (; const TString & ; objectKey). inline . Definition at line 126 of file TS3HTTPRequest.h. ◆ SetSecretKey(). TS3HTTPRequest & TS3HTTPRequest::SetSecretKey ; (; const TString & ; secretKey). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:17928,access,accessKey,17928,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,1,['access'],['accessKey']
Security,"ostream &o, const TString &prefix) const;  write options to output stream (e.g. in writing the MVA weight files ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html:5106,hash,hash,5106,doc/master/classTMVA_1_1VariableImportance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html,1,['hash'],['hash']
Security,"ostream &o, const TString &prefix) const;  write options to output stream (e.g. in writing the MVA weight files ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Configurable.html:3136,hash,hash,3136,doc/master/classTMVA_1_1Configurable.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Configurable.html,52,['hash'],['hash']
Security,"ot contains relative path below current directory. ;  . Protected Attributes; std::queue< std::shared_ptr< THttpCallArg > > fArgs;  ! submitted arguments ;  ; std::string fCors;  ! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses ;  ; std::string fCorsCredentials;  ! CORS: add Access-Control-Allow-Credentials: true response header ;  ; std::string fDefaultPage;  ! file name for default page name ;  ; std::string fDefaultPageCont;  ! content of default html page ;  ; std::string fDrawPage;  ! file name for drawing of single element ;  ; std::string fDrawPageCont;  ! content of draw html page ;  ; TList fEngines;  ! engines which runs http server ;  ; TString fJSROOT;  ! location of external JSROOT files ;  ; TString fJSROOTSYS;  ! location of local JSROOT files ;  ; std::map< std::string, std::string > fLocations;  ! list of local directories, which could be accessed via server ;  ; Long_t fMainThrdId {0};  ! id of the thread for processing requests ;  ; std::mutex fMutex;  ! mutex to protect list with arguments ;  ; Bool_t fOwnThread {kFALSE};  ! true when specialized thread allocated for processing requests ;  ; Long_t fProcessingThrdId {0};  ! id of the thread where events are recently processing ;  ; std::unique_ptr< TRootSniffer > fSniffer;  ! sniffer provides access to ROOT objects hierarchy ;  ; Bool_t fTerminated {kFALSE};  ! termination flag, disables all requests processing ;  ; std::thread fThrd;  ! own thread ;  ; std::unique_ptr< THttpTimer > fTimer;  ! timer used to access main thread ;  ; TString fTopName {""ROOT""};  ! name of top folder, default - ""ROOT"" ;  ; std::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers;  ! list of WS handlers ;  ; std::mutex fWSMutex;  ! mutex to protect WS handler lists ;  ; Bool_t fWSOnly {kFALSE};  ! when true, handle only websockets / longpoll engine ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:17764,access,accessed,17764,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,3,['access'],"['access', 'accessed']"
Security,"ot program that ignores the original classes. This interesting possibility allows to send the class structure of an application to a colleague who does not have your classes.; Example: TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; You can send at this point the file myClass.root to a colleague who can run the following Root basic session TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; ttauto * ttDefinition textangle.C:16; At this point, one has still access to all the classes present in the original session and select any combination of these classes to be displayed. ; Definition at line 22 of file TClassTree.h. Public Member Functions;  TClassTree ();  TClassTree default constructor. ;  ;  TClassTree (const char *name, const char *classes="""");  TClassTree constructor. ;  ;  ~TClassTree () override;  TClassTree default destructor. ;  ; void Draw (const char *classes="""") override;  Draw the inheritance tree and relations for the list of classes see this class header for the syntax and examples. ;  ; virtual Int_t FindClass (const char *classname);  Find class number corresponding to classname in list of local classes. ;  ; const char * GetClasses () const;  ; virtual const char * GetSourceDir () const;  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  list classes names and titles ;  ; void Paint (Option_t *option="""") override;  Draw the current class setting in fClasses and fStatus. ;  ; void SaveAs (const char *filename="""", Option_t *opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:4917,access,access,4917,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['access'],['access']
Security,"ot"" or ""roots"". The following are valid TNetFile URL's:; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root of the remote file tree is the user's home directory. Therefore an absolute pathname requires a // after the host or port specifier (see last example). Further the expansion of the standard shell characters, like ~, $, .., are handled as expected. TNetFile (actually TUrl) uses 1094 as default port for rootd.; Connecting to a rootd requires the remote user id and password. TNetFile allows three ways for you to provide your login: Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and TAuthenticate::SetGlobalPasswd(); Getting it from the ~/.netrc file (same file as used by ftp); Command line prompt The different methods will be tried in the order given above. On machines with AFS rootd will authenticate using AFS (if it was compiled with AFS support). If the protocol is specified as ""rootk"" kerberos5 will be used for authentication.; The rootd daemon lives in the directory $ROOTSYS/bin. It can be started either via inetd or by hand from the command line (no need to be super user). ; Definition at line 34 of file TNetFile.h. Public Member Functions;  TNetFile ();  ;  TNetFile (const char *url, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create a TNetFile object. ;  ; virtual ~TNetFile ();  TNetFile dtor. Send close message and close socket. ;  ; void Close (Option_t *option="""") override;  Close remote file. ;  ; void Flush () override;  Flush file to disk. ;  ; const TUrl * GetEndpointUrl () const override;  ; Int_t GetErrorCode () const;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  Retruns kTRUE if file is open, kFALSE otherwise. ;  ; Bool_t Matches (const char *url) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:1541,authenticat,authenticate,1541,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['authenticat'],['authenticate']
Security,"otMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:42811,access,access,42811,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['access'],['access']
Security,"otPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Bool_tRooAbsReal::_globalSelectCompGlobal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealSumPdf.html:38173,validat,validate,38173,root/html532/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html532/RooRealSumPdf.html,1,['validat'],['validate']
Security,"otPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_extendedAllow use as extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TIterator*_funcIter! Iterator over FUNC list; RooListProxy_funcListList of component FUNCs; static Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealSumPdf.html:36173,validat,validate,36173,root/html526/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html526/RooRealSumPdf.html,3,['validat'],['validate']
Security,"ote: the size on the screen is defined by the size of the pad. The original image is not modified by this function. If width or height is larger than the original image they are reduced to the width and height of the image. If the off values are too large (off + width > image width) than the off values are decreased. For example: offX = image width - width Note: the parameters are always relative to the original image not to the size of an already zoomed image. ; Reimplemented from TImage.; Definition at line 2027 of file TASImage.cxx. Member Data Documentation. ◆ fEditable. Bool_t TASImage::fEditable. protected . ! kTRUE image can be resized, moved by resizing/moving gPad ; Definition at line 66 of file TASImage.h. ◆ fgInit. Bool_t TASImage::fgInit = kFALSE. staticprotected . global flag to init afterimage only once ; Definition at line 73 of file TASImage.h. ◆ fgPlugList. THashTable * TASImage::fgPlugList = new THashTable(50). staticprotected . ! hash table containing loaded plugins ; Definition at line 70 of file TASImage.h. ◆ fGrayImage. ASImage* TASImage::fGrayImage. protected . ! gray image ; Definition at line 68 of file TASImage.h. ◆ fgVisual. ASVisual * TASImage::fgVisual = nullptr. staticprotected . pointer to visual structure ; Definition at line 72 of file TASImage.h. ◆ fImage. ASImage* TASImage::fImage. protected . ! pointer to image structure of original image ; Definition at line 57 of file TASImage.h. ◆ fIsGray. Bool_t TASImage::fIsGray. protected . ! kTRUE if image is gray ; Definition at line 69 of file TASImage.h. ◆ fMaxValue. Double_t TASImage::fMaxValue. protected . ! max value in image ; Definition at line 59 of file TASImage.h. ◆ fMinValue. Double_t TASImage::fMinValue. protected . ! min value in image ; Definition at line 60 of file TASImage.h. ◆ fPaintMode. Int_t TASImage::fPaintMode. protected . ! 1 - fast mode, 0 - low memory slow mode ; Definition at line 67 of file TASImage.h. ◆ fScaledImage. TASImage* TASImage::fScaledImage. protected . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:82541,hash,hash,82541,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['hash'],['hash']
Security,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRint.html:12667,access,access,12667,root/html528/TRint.html,https://root.cern,https://root.cern/root/html528/TRint.html,4,['access'],['access']
Security,"otected Member Functions |; Protected Attributes |; Private Attributes |; List of all members ; ROOT::Experimental::Internal::RPageSource Class ReferenceabstractNTuple-related classes. ; Abstract interface to read data from an ntuple. ; The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the corresponding physical columns. Pages from the columns of interest can then be mapped into memory. The page source also gives access to the ntuple's meta-data. ; Definition at line 549 of file RPageStorage.hxx. Classes; class  RActivePhysicalColumns;  Keeps track of the requested physical column IDs. More...;  ; struct  RClusterInfo;  Summarizes cluster-level information that are necessary to load a certain page. More...;  ; struct  RCounters;  Default I/O performance counters that get registered in fMetrics More...;  ; struct  REntryRange;  Used in SetEntryRange / GetEntryRange. More...;  ; class  RExclDescriptorGuard;  An RAII wrapper used for the writable access to RPageSource::fDescriptor. See GetSharedDescriptorGuard(). More...;  ; class  RSharedDescriptorGuard;  An RAII wrapper used for the read-only access to RPageSource::fDescriptor. See GetExclDescriptorGuard()`. More...;  . Public Member Functions;  RPageSource (const RPageSource &)=delete;  ;  RPageSource (RPageSource &&)=delete;  ;  RPageSource (std::string_view ntupleName, const RNTupleReadOptions &fOptions);  ;  ~RPageSource () override;  ; ColumnHandle_t AddColumn (DescriptorId_t fieldId, RColumn &column) override;  Register a new column. ;  ; void Attach ();  Open the physical storage container and deserialize header and footer. ;  ; std::unique_ptr< RPageSource > Clone () const;  Open the same storage multiple time, e.g. ;  ; void DropColumn (ColumnHandle_t columnHandle) override;  Unregisters a column. ;  ; REntryRange GetEntryRange () const;  ; NTupleSize_t GetNElements (ColumnHandle_t columnHandle);  ; NTupleSize_t GetNEntries ();  ; const RNTupleRead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:1264,access,access,1264,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['access'],['access']
Security,"ouble step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableInitialRange(unsigned int, double, double); virtual boolSetVariableLimits(unsigned int ivar, double lower, double upper); virtual boolSetVariableLowerLimit(unsigned int ivar, double lower); virtual boolSetVariableStepSize(unsigned int ivar, double value); virtual boolSetVariableUpperLimit(unsigned int ivar, double upper); virtual boolSetVariableValue(unsigned int ivar, double value); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsfOptionsminimizer options; intfStatusstatus of minimizer ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a new free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a new lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower, double upper). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:4995,validat,validated,4995,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,1,['validat'],['validated']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_2_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_2_.html,2,['access'],['access']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_3_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_3_.html,2,['access'],['access']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_4_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_4_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_4_.html,2,['access'],['access']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_5_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_5_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_5_.html,2,['access'],['access']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_6_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_6_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_6_.html,2,['access'],['access']
Security,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_double_7_.html:4610,access,access,4610,root/html602/ROOT__Math__SVector_double_7_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_double_7_.html,2,['access'],['access']
Security,"ouble>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:9641,access,access,9641,root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,9,['access'],['access']
Security,"ouble_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:350526,hash,hashlist,350526,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['hash'],['hashlist']
Security,"ouble_t);  ; void SetShared (Bool_t flag=kTRUE);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:7463,hash,hash,7463,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,2,['hash'],['hash']
Security,"ould be able to access the contents of buf as they; 1443/// are with:; 1444///; 1445/// ~~~{.cpp}; 1446/// static_cast<T*>(buf.GetCurrent()); 1447/// ~~~; 1448///; 1449/// where T is the type stored on this branch.; 1450///; 1451/// When `count_buf` points to a valid TBuffer and the branch has a branch count,; 1452/// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; 1453/// from the branchCount. After deserialization those value can be used to calculate; 1454/// the number of elements corresponding to each entries.; 1455///; 1456/// For each entry the number of elements is the multiplication of; 1457/// ; 1458/// ~~~{.cpp}; 1459/// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; 1460/// auto len = leaf->GetLen();; 1461/// ~~~; 1462///; 1463/// and the value in the BranchCount corresponding to that entry (can be obtained; 1464/// from `branch->GetBranchCount()`).; 1465///; 1466/// \note This interface is not meant to be exposed to end users, but rather it should; 1467/// be wrapped by higher-level interfaces.; 1468///; 1469/// \note See TBranch::GetEntriesSerialized() for an alternative that does not; 1470/// perform byte swapping (useful to save one pass over data in some cases).; 1471///; 1472Int_t TBranch::GetBulkEntries(Long64_t entry, TBuffer &user_buf); 1473{; 1474 // TODO: eventually support multiple leaves.; 1475 if (R__unlikely(fNleaves != 1)) return -1;; 1476 TLeaf *leaf = static_cast<TLeaf*>(fLeaves.UncheckedAt(0));; 1477 if (R__unlikely(leaf->GetDeserializeType() == TLeaf::DeserializeType::kExternal)) {; 1478 return -1;; 1479 }; 1480 ; 1481 // Remember which entry we are reading.; 1482 fReadEntry = entry;; 1483 ; 1484 bool enabled = !TestBit(kDoNotProcess);; 1485 if (R__unlikely(!enabled)) return -1;; 1486 TBasket *basket = nullptr;; 1487 Long64_t first;; 1488 Int_t result = GetBasketAndFirst(basket, first, &user_buf);; 1489 if (R__unlikely(result < 0)) return -1;; 1490 // Only support reading from full c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:52579,expose,exposed,52579,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['expose'],['exposed']
Security,"ound when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:10951,access,accessing,10951,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,1,['access'],['accessing']
Security,"outine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:43257,hash,hash,43257,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['hash'],['hash']
Security,"outine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 520 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:42982,hash,hash,42982,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['hash'],['hash']
Security,"oved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:55313,access,access,55313,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"override . dtor ; Definition at line 65 of file TASPluginGS.cxx. Member Function Documentation. ◆ Class(). static TClass * TASPluginGS::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TASPluginGS::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TASPluginGS::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 38 of file TASPluginGS.h. ◆ DeclFileName(). static const char * TASPluginGS::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 38 of file TASPluginGS.h. ◆ File2ASImage(). ASImage * TASPluginGS::File2ASImage ; (; const char * ; filename). overridevirtual . read PS/EPS/PDF file and convert it to ASImage ; Reimplemented from TASImagePlugin.; Definition at line 76 of file TASPluginGS.cxx. ◆ Hash(). ULong_t TASPluginGS::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASPluginGS::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASPluginGS.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPluginGS.html:12766,hash,hash,12766,doc/master/classTASPluginGS.html,https://root.cern,https://root.cern/doc/master/classTASPluginGS.html,1,['hash'],['hash']
Security,"override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBrowserObject.html:1679,hash,hash,1679,doc/master/classTBrowserObject.html,https://root.cern,https://root.cern/doc/master/classTBrowserObject.html,1,['hash'],['hash']
Security,"ow they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7018,access,access,7018,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['access'],['access']
Security,"owHandler * ; h). Add handler for unknown (i.e. unregistered) windows. ; Definition at line 552 of file TGClient.cxx. ◆ CancelRedraw(). void TGClient::CancelRedraw ; (; TGWindow * ; w). Definition at line 386 of file TGClient.cxx. ◆ Class(). static TClass * TGClient::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGClient::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGClient::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 153 of file TGClient.h. ◆ DeclFileName(). static const char * TGClient::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 153 of file TGClient.h. ◆ DoRedraw(). Bool_t TGClient::DoRedraw ; (; ). protected . Redraw all windows that need redrawing. ; Returns kFALSE if no redraw was needed, kTRUE otherwise. Only redraw the application's windows when the event queue does not contain expose event anymore. ; Definition at line 795 of file TGClient.cxx. ◆ ForceRedraw(). void TGClient::ForceRedraw ; (; ). inline . Definition at line 98 of file TGClient.h. ◆ FreeColor(). void TGClient::FreeColor ; (; Pixel_t ; color); const. Free color. ; Definition at line 504 of file TGClient.cxx. ◆ FreeFont(). void TGClient::FreeFont ; (; const TGFont * ; font). Free a font. ; Definition at line 364 of file TGClient.cxx. ◆ FreeGC() [1/2]. void TGClient::FreeGC ; (; const TGGC * ; gc). Free a graphics context. ; Definition at line 328 of file TGClient.cxx. ◆ FreeGC() [2/2]. void TGClient::FreeGC ; (; GContext_t ; gc). Free a graphics context. ; Definition at line 336 of file TGClient.cxx. ◆ FreePicture(). void TGClient::FreePicture ; (; const TGPicture * ; pic). Free picture resource. ; Definition at line 308 of file TGClient.cxx. ◆ GetColorByName(). Bool_t TGClient::GetColorByName ; (; const char * ; name, . Pixel_t & ; pixel . ); const. Get a color by na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGClient.html:23149,expose,expose,23149,doc/master/classTGClient.html,https://root.cern,https://root.cern/doc/master/classTGClient.html,1,['expose'],['expose']
Security,"ow_lwb..row_upb][col_lwb..col_upb] ; Implements TMatrixTBase< Element >.; Definition at line 569 of file TMatrixTSym.cxx. ◆ GetSub() [3/3]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::GetSub ; (; Int_t ; row_lwb, . Int_t ; row_upb, . TMatrixTSym< Element > & ; target, . Option_t * ; option = ""S"" . ); const. Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the returned matrix depends on the argument option: ; option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default) else : return [row_lwb..row_upb][row_lwb..row_upb] ; Definition at line 503 of file TMatrixTSym.cxx. ◆ Invert(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Invert ; (; Double_t * ; det = nullptr). Invert the matrix and calculate its determinant Notice that the LU decomposition is used instead of Bunch-Kaufman Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU . ; The user can access Bunch-Kaufman through the TDecompBK class . ; Definition at line 961 of file TMatrixTSym.cxx. ◆ InvertFast(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::InvertFast ; (; Double_t * ; det = nullptr). Invert the matrix and calculate its determinant. ; Definition at line 979 of file TMatrixTSym.cxx. ◆ IsA(). template<class Element > . TClass * TMatrixTSym< Element >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TMatrixTBase< Element >.; Definition at line 180 of file TMatrixTSym.h. ◆ IsSymmetric(). template<class Element > . Bool_t TMatrixTSym< Element >::IsSymmetric ; (; ); const. inlineoverridevirtual . Check whether matrix is symmetric. ; Reimplemented from TMatrixTBase< Element >.; Definition at line 99 of file TMatrixTSym.h. ◆ Memcpy_m(). template<class Element > . Int_t TMatrixTSym< Element >::Memcpy_m ; (; Element * ; newp, . const Element * ; oldp, . Int_t ; copySize, . Int_t ; newSize, . Int_t ; oldS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:32883,access,access,32883,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['access'],['access']
Security,"owsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:20503,authenticat,authenticated,20503,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authenticated']
Security,"oxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmulatedProxystatic TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)Generate emulated collection proxy for a given class.Definition TCollectionProxyFactory.cxx:63; TCollectionProxyFactory::GenEmul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255403,checksum,checksum,255403,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"p () const;  ; Int_t TrackingCode () const;  ; Double_t Width () const;  ; Int_t X () const;  ; Int_t Y () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParticlePDG.html:3881,hash,hash,3881,doc/master/classTParticlePDG.html,https://root.cern,https://root.cern/doc/master/classTParticlePDG.html,1,['hash'],['hash']
Security,"p is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:44728,checksum,checksum,44728,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,2,['checksum'],['checksum']
Security,"p over all entries on the TTree.; while (subscriptionManager.Next()) {; // Now myTribuneDeGeneve has loaded its data and we can access it.; // TTreeReaderValue behaves like an iterator; you need to use ""->"" on; // it to access the data it refers to.; myTribuneDeGeneve->read();; ...; }. Summary; As you saw, TTree is about. Chunking up similar, disconnected entries of which typically only one needs to be available, just like newspaper issues or data from High Energy Physics collisions, also known as the entries of a TTree; Selecting which data the TTree should provide, i.e. subscribing to certain branches only. Branches can be nested, so depending on the tree you could even subscribe to only the sports section or even only an article, reducing data transfer. A precedure like this is actually what most physicists do to analyze data from a series of TTrees. So let's try it in practice!; . ‹ Using TTree::Draw() to access a TTree; up; Using a Macro to Read a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:4530,access,access,4530,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['access'],['access']
Security,"p the entry, otherwise discard it. |; 109| Range() | Filter rows based on entry number (single-thread only). |; 110| Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; 111| RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; 112| RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; 113| Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |; 114 ; 115 ; 116### Actions; 117Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 118 ; 119In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 120 ; 121Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 122produce many different results in one event loop. Instant actions trigger the event loop instantly.; 123 ; 124 ; 125| **Lazy action** | **Description** |; 126|------------------|-----------------|; 127| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 128| Book() | Book execution of a custom action using a user-defined helper object. |; 129| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 130| Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; 131| Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; 132| Fill() | Fill a user-defined object with the val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:7411,access,accessed,7411,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"p(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Autho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:246955,authoriz,authorization,246955,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,4,['authoriz'],['authorization']
Security,"p(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Autho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:246987,authoriz,authorization,246987,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,4,['authoriz'],['authorization']
Security,"p->Find(info.name());; 708 if (r); 709 return r->fDict;; 710 return nullptr;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Given the normalized class name returns the Dictionary() function of a class; 715/// (uses hash of name).; 716 ; 717DictFuncPtr_t TClassTable::GetDictNorm(const char *cname); 718{; 719 if (!CheckClassTableInit()); 720 return nullptr;; 721 ; 722 if (gDebug > 9); 723 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 724 ; 725 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 726 ; 727 if (gDebug > 9) {; 728 ::Info(""GetDict"", ""searches for %s"", cname);; 729 fgIdMap->Print();; 730 }; 731 ; 732 TClassRec *r = FindElement(cname, kFALSE);; 733 if (r); 734 return r->fDict;; 735 return nullptr;; 736}; 737 ; 738////////////////////////////////////////////////////////////////////////////////; 739/// Given the class name returns the TClassProto object for the class.; 740/// (uses hash of name).; 741 ; 742TProtoClass *TClassTable::GetProto(const char *cname); 743{; 744 if (gDebug > 9) {; 745 ::Info(""GetDict"", ""searches for %s"", cname);; 746 }; 747 ; 748 if (!CheckClassTableInit()); 749 return nullptr;; 750 ; 751 NormalizeThenLock guard(cname);; 752 ; 753 if (gDebug > 9) {; 754 // Because of the early call to Info, gROOT is already initialized; 755 // and thus this will not cause a recursive call to TClassTable.; 756 ::Info(""GetDict"", ""searches for %s"", cname);; 757 fgIdMap->Print();; 758 }; 759 ; 760 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 761 if (r); 762 return r->fProto;; 763 return nullptr;; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Given the class normalized name returns the TClassProto object for the class.; 768/// (uses hash of name).; 769 ; 770TProtoClass *TClassTable::GetProtoNorm(const char *cname); 771{; 772 if (gDebug > 9) {; 773 ::Info(""GetDict"", ""searches f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:24096,hash,hash,24096,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['hash'],['hash']
Security,"p; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if succesfull. Bool_t Commit(); subm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLServer.html:7993,password,password,7993,root/html528/TSQLServer.html,https://root.cern,https://root.cern/root/html528/TSQLServer.html,3,['password'],['password']
Security,"p; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); subm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLServer.html:8369,password,password,8369,root/html534/TSQLServer.html,https://root.cern,https://root.cern/root/html534/TSQLServer.html,1,['password'],['password']
Security,"pDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetSystem.html:19104,access,access,19104,root/html534/TNetSystem.html,https://root.cern,https://root.cern/root/html534/TNetSystem.html,3,['access'],['access']
Security,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,2,['access'],"['access', 'accessing']"
Security,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,2,['access'],"['access', 'accessing']"
Security,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,2,['access'],"['access', 'accessing']"
Security,"pSym<float,5> >(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,5> >(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,2,['access'],"['access', 'accessing']"
Security,"pSym<float,6> >(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SVector<float,6*(6+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,6> >(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SVector<float,6*(6+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,2,['access'],"['access', 'accessing']"
Security,"pSym<float,7> >(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SVector<float,7*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:4877,access,access,4877,root/html528/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,8,['access'],"['access', 'accessing']"
Security,"pSym<float,7> >(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SVector<float,7*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:4877,access,access,4877,root/html526/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,2,['access'],"['access', 'accessing']"
Security,"pVerb) const; Returns this request's signature. TString HTTPVerbToTString(TS3HTTPRequest::EHTTPVerb httpVerb) const. TS3HTTPRequest& SetTimeStamp(); Sets this request's time stamp according to:; http://code.google.com/apis/storage/docs/reference-headers.html#date. TString MakeRequestLine(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the first line of a HTTP request for this object. Note that since; we don't use the virtual host syntax which is supported by Amazon, we; must include the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:9151,authenticat,authentication,9151,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,3,['authenticat'],['authentication']
Security,"package taking an option const char * Return -1 on error, 0 otherwise. ;  ; Int_t Load (const char *pack, TList *optls=0);  Method to load a package taking an option list Return -1 on error, 0 otherwise. ;  ; TMD5 * ReadMD5 (const char *pack);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ; Int_t Remove (const char *pack=0, Bool_t dolock=kTRUE);  Remove package 'pack' If 'pack' is null or empty all packages are cleared. ;  ; void SetLogger (TPackMgrLog_t logger);  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetPrefix (const char *pfx);  ; void Show (const char *title=0);  Show available packages. ;  ; void ShowEnabled (const char *title=0);  Show enabled packages. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unload (const char *pack);  Method to unload a package. ;  ; Int_t Unpack (const char *pack, TMD5 *sum=0);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:4407,checksum,checksum,4407,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['checksum'],['checksum']
Security,"parent);  Set parent in key buffer. ;  ; Int_t Sizeof () const override;  Return the size in bytes of the key header structure. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKeySQL.html:6545,hash,hash,6545,doc/master/classTKeySQL.html,https://root.cern,https://root.cern/doc/master/classTKeySQL.html,2,['hash'],['hash']
Security,"parse the contents, instead of a file. ;  ; Int_t ParseFile (const char *filename) override;  It creates the parse context of the xml file, where the xml file name is filename. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TXMLParser;  TXMLParser ();  Initializes parser variables. ;  ;  ~TXMLParser () override;  Cleanup. ;  ; Int_t GetParseCode () const;  ; const char * GetParseCodeMessage (Int_t parseCode) const;  Returns the parse code message. ;  ; Bool_t GetReplaceEntities () const;  ; Bool_t GetStopOnError () const;  ; Bool_t GetValidate () const;  ; const char * GetValidateError () const;  ; const char * GetValidateWarning () const;  ; TClass * IsA () const override;  ; void SetReplaceEntities (Bool_t val=kTRUE);  The parser will replace/expand entities. ;  ; void SetStopOnError (Bool_t stop=kTRUE);  Set parser stops in case of error: ;  ; void SetValidate (Bool_t val=kTRUE);  The parser will validate the xml file if val = true. ;  ; virtual void StopParser ();  Stops parsing. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSAXParser.html:3482,validat,validate,3482,doc/master/classTSAXParser.html,https://root.cern,https://root.cern/doc/master/classTSAXParser.html,1,['validat'],['validate']
Security,"parseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THnT<Long64_t> multi-dimensional histogram with templated storage; THnT<ULong64_t> multi-dimensional histogram with templated storage; THnT<char> multi-dimensional histogram with templated storage; THnT<double> multi-dimensional histogram with templated storage; THnT<float> multi-dimensional histogram with templated storage; THnT<int> multi-dimensional histogram with templated storage; THnT<long> multi-dimensional histogram with templated storage; THnT<short> multi-dimensional histogram with templated storage; THnT<unsigned int> multi-dimensional histogram with templated storage; THnT<unsigned long> multi-dimensional histogram with templated storage; THnT<unsigned short> multi-dimensional histogram with templated storage; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; THttpCallArg Arguments for single HTTP call; THttpEngine abstract class which should provide http-based protocol for server; THttpServer HTTP server for ROOT analysis; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:100856,authenticat,authentication,100856,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['authenticat'],['authentication']
Security,"parser, a DOM style tree interface and a SAX style event based interface. TXMLParser is parent class of TSAXParser and TDOMParser, which are a SAX interface and DOM interface of libxml. ; Definition at line 24 of file TXMLParser.h. Public Member Functions;  TXMLParser ();  Initializes parser variables. ;  ;  ~TXMLParser () override;  Cleanup. ;  ; Int_t GetParseCode () const;  ; const char * GetParseCodeMessage (Int_t parseCode) const;  Returns the parse code message. ;  ; Bool_t GetReplaceEntities () const;  ; Bool_t GetStopOnError () const;  ; Bool_t GetValidate () const;  ; const char * GetValidateError () const;  ; const char * GetValidateWarning () const;  ; TClass * IsA () const override;  ; virtual Int_t ParseBuffer (const char *contents, Int_t len)=0;  ; virtual Int_t ParseFile (const char *filename)=0;  ; void SetReplaceEntities (Bool_t val=kTRUE);  The parser will replace/expand entities. ;  ; void SetStopOnError (Bool_t stop=kTRUE);  Set parser stops in case of error: ;  ; void SetValidate (Bool_t val=kTRUE);  The parser will validate the xml file if val = true. ;  ; virtual void StopParser ();  Stops parsing. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:1604,validat,validate,1604,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['validat'],['validate']
Security,"patible URI ;  CTUrlThis class represents a WWW compatible URL ;  ►CTUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier) ;  Cuuid_time_t;  CTVector2;  CTVector3;  CTVectorT;  CTVersionCheck;  CTViewSee TView3D ;  CTView3DThe 3D view class ;  CTViewer3DPadProvides 3D viewer interface (TVirtualViewer3D) support on a pad ;  CTViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data members in a class and all its base classes without caching any of the TDictionary pointers ;  CTViewPubDataMembersIterIterator of over the view's content ;  CTViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods in a class and all its base classes without caching any of the TFunction pointers ;  CTViewPubFunctionsIterIterator of over the view's content ;  CTViewTimer;  CTVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  CTVirtualAuth;  CTVirtualBranchBrowsableTVirtualBranchBrowsable is a base class (not really abstract, but useless by itself) for helper objects that extend TBranch's browsing support ;  CTVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators ;  ►CTVirtualCollectionProxy;  CTPushPop;  ►CTVirtualCollectionPtrIterators;  CTInternalIterator;  CTVirtualDragManager;  CTVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms ;  CTVirtualFitterAbstract Base Class for Fitting ;  CTVirtualGeoPainter;  CTVirtualGeoTrack;  CTVirtualGLManip;  CTVirtualGLPainter;  CTVirtualGraphPainterAbstract interface to a histogram painter ;  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndexAbstract interface for Tree Index ;  CTVirtualIsAProxy;  CTVirtualMagField;  CTVirtualMC;  CTVirtualMCApplication;  CTVirtualMCDecayer;  CTVirtualMCGeometry; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:163038,access,access,163038,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"patible; 2201 * sizes. */; 2202mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2203 == (NUM_OPTIONS + 1),; 2204 ""config_options and enum not sync"");; 2205 ; 2206 ; 2207enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2208 ; 2209 ; 2210struct mg_handler_info {; 2211 /* Name/Pattern of the URI. */; 2212 char *uri;; 2213 size_t uri_len;; 2214 ; 2215 /* handler type */; 2216 int handler_type;; 2217 ; 2218 /* Handler for http/https or authorization requests. */; 2219 mg_request_handler handler;; 2220 unsigned int refcount;; 2221 int removing;; 2222 ; 2223 /* Handler for ws/wss (websocket) requests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:69131,authoriz,authorization,69131,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"patible; 2202 * sizes. */; 2203mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2204 == (NUM_OPTIONS + 1),; 2205 ""config_options and enum not sync"");; 2206 ; 2207 ; 2208enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2209 ; 2210 ; 2211struct mg_handler_info {; 2212 /* Name/Pattern of the URI. */; 2213 char *uri;; 2214 size_t uri_len;; 2215 ; 2216 /* handler type */; 2217 int handler_type;; 2218 ; 2219 /* Handler for http/https or authorization requests. */; 2220 mg_request_handler handler;; 2221 unsigned int refcount;; 2222 int removing;; 2223 ; 2224 /* Handler for ws/wss (websocket) requests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:69163,authoriz,authorization,69163,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authoriz'],['authorization']
Security,"pe=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:24297,hash,hash,24297,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['hash'],['hash']
Security,"pecified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2);; 305 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2);; 306 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2);; 307 }; 308 ; 309 /**; 310 Get components into a linear algebra matrix of size at least 3x3,; 311 which must support operator()(i,j) for write access to elements; 312 (0,0) thru (2,2).; 313 */; 314 template<class ForeignMatrix>; 315 void; 316 GetRotationMatrix (ForeignMatrix & m) const {; 317 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ];; 318 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ];; 319 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ];; 320 }; 321 ; 322 /**; 323 Set the components from nine scalars -- UNCHECKED for orthonormaility; 324 */; 325 void; 326 SetComponents (Scalar xx, Scalar xy, Scalar xz,; 327 Scalar yx, Scalar yy, Scalar yz,; 328 Scalar zx, Scalar zy, Scalar zz) {; 329 fM[kXX]=xx; fM[kXY]=xy; fM[kXZ]=xz;; 330 fM[kYX]=yx; fM[kYY]=yy; fM[kYZ]=yz;; 331 fM[kZX]=zx; fM[kZY]=zy; fM[kZZ]=zz;; 332 }; 333 ; 334 /**; 335 Get the nine components into nine scalars; 336 */; 337 void; 338 GetComponents (Scalar &xx, Scalar &xy, Scalar &xz,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:9914,access,access,9914,doc/master/GenVector_2Rotation3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html,1,['access'],['access']
Security,"pect to each other, the maximum height can be influenced by SetBarWidth(). Deactivated, the height of the bin with the maximum content of each individual violin is set to a constant value using SetBarWidth(). The static function will affect all violin-charts in the running program. Default is true. Scaling between multiple violin-charts (using ""same"" or THStack) is not supported, yet.; The zero indicator line; Typical for violin charts is a line in the background over the whole histogram indicating the bins with zero entries. The zero indicator line can be activated with z=1. The line color will always be the same as the fill-color of the histogram.; The Mean; The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then the whiskers will be forced to be solid (usually hashed); Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses better whisker definition (w=2) and outliers (p=1).; Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot including a box-plot.; How to use the violin-plots drawing option; There are two predefined violin-plot representations:; ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution, zero indicator line); ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or hashed style).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:70423,hash,hashed,70423,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['hash'],['hashed']
Security,pedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ fSecContexts. TSeqCollection* TROOT::fSecContexts. protected . List of security contexts (TSecContext) ; Definition at line 161 of file TROOT.h. ◆ fSelectPad. TVirtualPad* TROOT::fSelectPad. protected . Currently selected pad. ; Definition at line 139 of file TROOT.h. ◆ fSockets. TSeqCollection* TROOT::fSockets. protected . List of network sockets. ; Definition at line 148 of file TROOT.h. ◆ fSpecials. TSeqCollection* TROOT::fSpecials. protected . List of special objects. ; Definition at line 156 of file TROOT.h. ◆ fStreamerInfo. TSeqCollection* TROOT::fStreamerInfo. protected . List of active StreamerInfo classes. ; Definition at line 159 of file TROOT.h. ◆ fStyles. TSeqCollection* TROOT::fStyles. protected . List of styles. ; Definition at line 150 of file TROOT.h. ◆ fTasks. TSeqCollection* TROOT::fTasks. protected . List of tasks. ; Definition at line 152 of file TROOT.h. ◆ fTimer. Int_t TROOT::fTimer. protected . Timer flag. ; Definition at line 123 of file TROOT.h. ◆ fTypes. TCollection* TROOT::fTypes. protected . List of data types definition. ; Definition at line 141 of file TRO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:86602,secur,security,86602,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['secur'],['security']
Security,"pendency graph for TString.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define BIG_CONSTANT(x)   (x##LLU);  ; #define ROTL64(x, y)   rotl64(x,y);  . Functions; char * Compress (const char *str);  Remove all blanks from the string str. ;  ; int EscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar);  Escape specchars in src with escchar and copy to dst. ;  ; char * Form (const char *fmt,...);  Formats a string in a circular formatting buffer. ;  ; static char * Format (const char *format, va_list ap);  Format a string in a circular formatting buffer (using a printf style format descriptor). ;  ; UInt_t Hash (const char *str);  Return a case-sensitive hash value (endian independent). ;  ; static void Mash (UInt_t &hash, UInt_t chars);  Utility used by Hash(). ;  ; static int MemIsEqual (const char *p, const char *q, Ssiz_t n);  Returns false if strings are not equal. ;  ; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string. ;  ; TString operator+ (const TString &s, const char *cs);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s1, const TString &s2);  Use the special concatenation constructor. ;  ; TBuffer & operator<< (TBuffer &buf, const TString *s);  Write TString or derived to TBuffer. ;  ; Bool_t operator== (const TString &s1, const char *s2);  Compare TString with a char *. ;  ; Bool_t operator== (const TSubString &s1, const TSubString &s2);  Compare two sub-strings. ;  ; Bool_t operator== (const TSubString &ss, const char *cs);  Compare sub-string to char *. ;  ; Bool_t ope",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx.html:1621,hash,hash,1621,doc/master/TString_8cxx.html,https://root.cern,https://root.cern/doc/master/TString_8cxx.html,1,['hash'],['hash']
Security,"perations required by ROOT analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:146; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:11165,access,access,11165,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"perations required by ROOT analyses; at the same time, users can just as easily specify custom code that will be executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:11554,access,access,11554,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"permission to use the GNU C Library in; non-free programs enables many more people to use the whole GNU; operating system, as well as its variant, the GNU/Linux operating; system. Although the Lesser General Public License is Less protective of the; users' freedom, it does ensure that the user of a program that is; linked with the Library has the freedom and the wherewithal to run; that program using a modified version of the Library. The precise terms and conditions for copying, distribution and; modification follow. Pay close attention to the difference between a; ""work based on the library"" and a ""work that uses the library"". The; former contains code derived from the library, whereas the latter must; be combined with the library in order to run.; ; GNU LESSER GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License Agreement applies to any software library or other; program which contains a notice placed by the copyright holder or; other authorized party saying it may be distributed under the terms of; this Lesser General Public License (also called ""this License"").; Each licensee is addressed as ""you"". A ""library"" means a collection of software functions and/or data; prepared so as to be conveniently linked with application programs; (which use some of those functions and data) to form executables. The ""Library"", below, refers to any such software library or work; which has been distributed under these terms. A ""work based on the; Library"" means either the Library or any derivative work under; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:8570,authoriz,authorized,8570,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['authoriz'],['authorized']
Security,"plate arguments of the; 8858/// function template described by ft_info.; 8859 ; 8860UInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const; 8861{; 8862 if (!ft_info) return 0;; 8863 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8864 return ft->getTemplateParameters()->getMinRequiredArguments();; 8865}; 8866 ; 8867////////////////////////////////////////////////////////////////////////////////; 8868/// Return the property of the function template.; 8869 ; 8870Long_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const; 8871{; 8872 if (!ft_info) return 0;; 8873 ; 8874 long property = 0L;; 8875 property |= kIsCompiled;; 8876 ; 8877 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8878 ; 8879 switch (ft->getAccess()) {; 8880 case clang::AS_public:; 8881 property |= kIsPublic;; 8882 break;; 8883 case clang::AS_protected:; 8884 property |= kIsProtected;; 8885 break;; 8886 case clang::AS_private:; 8887 property |= kIsPrivate;; 8888 break;; 8889 case clang::AS_none:; 8890 if (ft->getDeclContext()->isNamespace()); 8891 property |= kIsPublic;; 8892 break;; 8893 default:; 8894 // IMPOSSIBLE; 8895 assert(false && ""Unexpected value for the access property value in Clang"");; 8896 break;; 8897 }; 8898 ; 8899 const clang::FunctionDecl *fd = ft->getTemplatedDecl();; 8900 if (const clang::CXXMethodDecl *md =; 8901 llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {; 8902 if (md->getMethodQualifiers().hasConst()) {; 8903 property |= kIsConstant | kIsConstMethod;; 8904 }; 8905 if (md->isVirtual()) {; 8906 property |= kIsVirtual;; 8907 }; 8908 if (md->isPureVirtual()) {; 8909 property |= kIsPureVirtual;; 8910 }; 8911 if (const clang::CXXConstructorDecl *cd =; 8912 llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {; 8913 if (cd->isExplicit()) {; 8914 property |= kIsExplicit;; 8915 }; 8916 }; 8917 else if (const clang::CXXConversionDecl *cd =; 8918 llvm::dyn_cast<clang::CXXConversionDecl>(md)) {; 8919 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:345874,access,access,345874,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"plate<typename Proxied , typename DataSource = void> . template<typename F , typename std::enable_if_t<!std::is_convertible< F, std::string >::value, int > = 0> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Define ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function. . Returnsthe first node of the computation graph for which the new quantity is defined.; Define a column that will be visible from all subsequent nodes of the functional chain. The expression is only evaluated for entries that pass all the preceding filters. A new variable is created called name, accessible as if it was contained in the dataset from subsequent transformations/actions.; Use cases include:; caching the results of complex calculations for easy and efficient multiple access; extraction of quantities of interest from complex objects. An exception is thrown if the name of the new column is already in use in this branch of the computation graph. Example usage:; // assuming a function with signature:; double myComplexCalculation(const RVec<float> &muon_pts);; // we can pass it directly to Define; auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; // alternatively, we can pass the body of the function as a string, as in Filter:; auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; NoteIf the body of the string expression contains an explicit return statement (even if it is in a nested scope), RDataFrame will not add another one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:49886,access,accessible,49886,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['access'],['accessible']
Security,"ple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root of the remote file tree is the user's home directory. Therefore an absolute pathname requires a // after the host or port specifier (see last example). Further the expansion of the standard shell characters, like ~, $, .., are handled as expected. TNetFile (actually TUrl) uses 1094 as default port for rootd.; Connecting to a rootd requires the remote user id and password. TNetFile allows three ways for you to provide your login: Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and TAuthenticate::SetGlobalPasswd(); Getting it from the ~/.netrc file (same file as used by ftp); Command line prompt The different methods will be tried in the order given above. On machines with AFS rootd will authenticate using AFS (if it was compiled with AFS support). If the protocol is specified as ""rootk"" kerberos5 will be used for authentication.; The rootd daemon lives in the directory $ROOTSYS/bin. It can be started either via inetd or by hand from the command line (no need to be super user). ; Definition at line 34 of file TNetFile.h. Public Member Functions;  TNetFile ();  ;  TNetFile (const char *url, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Create a TNetFile object. ;  ; virtual ~TNetFile ();  TNetFile dtor. Send close message and close socket. ;  ; void Close (Option_t *option="""") override;  Close remote file. ;  ; void Flush () override;  Flush file to disk. ;  ; const TUrl * GetEndpointUrl () const override;  ; Int_t GetErrorCode () const;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  Retruns kTRUE if file is open, kFALSE otherwise. ;  ; Bool_t Matches (const char *url) override;  Return kTRUE if 'url' matches the coordinates of this file. ;  ; Bool_t ReadBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:1670,authenticat,authentication,1670,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['authenticat'],['authentication']
Security,"pleCompressor > fCompressor;  Helper to zip pages and header/footer; includes a 16MB (kMAXZIPBUF) zip buffer. ;  ; std::unique_ptr< RNTupleWriteOptions > fOptions;  ;  Protected Attributes inherited from ROOT::Experimental::Internal::RPageStorage; Detail::RNTupleMetrics fMetrics;  ; std::string fNTupleName;  ; std::unique_ptr< RPageAllocator > fPageAllocator;  For the time being, we will use the heap allocator for all sources and sinks. This may change in the future. ;  ; RTaskScheduler * fTaskScheduler = nullptr;  . Private Attributes; bool fIsInitialized = false;  Flag if sink was initialized. ;  ; std::vector< Callback_t > fOnDatasetCommitCallbacks;  ; std::vector< unsigned char > fSealPageBuffer;  Used as destination buffer in the simple SealPage overload. ;  ; RWritePageMemoryManager fWritePageMemoryManager;  Used in ReservePage to maintain the page buffer budget. ;  . Additional Inherited Members;  Static Public Attributes inherited from ROOT::Experimental::Internal::RPageStorage; static constexpr std::size_t kNBytesPageChecksum = sizeof(std::uint64_t);  The page checksum is a 64bit xxhash3. ;  . #include <ROOT/RPageStorage.hxx>. Inheritance diagram for ROOT::Experimental::Internal::RPageSink:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Callback_t. using ROOT::Experimental::Internal::RPageSink::Callback_t = std::function<void(RPageSink &)>. Definition at line 258 of file RPageStorage.hxx. Constructor & Destructor Documentation. ◆ RPageSink() [1/3]. ROOT::Experimental::Internal::RPageSink::RPageSink ; (; std::string_view ; ntupleName, . const RNTupleWriteOptions & ; options . ). Definition at line 611 of file RPageStorage.cxx. ◆ RPageSink() [2/3]. ROOT::Experimental::Internal::RPageSink::RPageSink ; (; const RPageSink & ; ). delete . ◆ RPageSink() [3/3]. ROOT::Experimental::Internal::RPageSink::RPageSink ; (; RPageSink && ; ). default . ◆ ~RPageSink(). ROOT::Experimental::Inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html:7003,checksum,checksum,7003,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,1,['checksum'],['checksum']
Security,"plemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTNamed.html:19399,hash,hash,19399,doc/v632/classTNamed.html,https://root.cern,https://root.cern/doc/v632/classTNamed.html,1,['hash'],['hash']
Security,"plemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNamed.html:19322,hash,hash,19322,doc/master/classTNamed.html,https://root.cern,https://root.cern/doc/master/classTNamed.html,1,['hash'],['hash']
Security,"pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitely specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.ps",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:27039,access,accessed,27039,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,3,['access'],['accessed']
Security,"pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:28032,access,accessed,28032,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,3,['access'],['accessed']
Security,"ppear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every application success and depends of three main factors:. number of presented items in the menu; how often the menu is used; how often the menu contents may change. 25.8.5 Toolbar. A toolbar (TGToolBar) is a composite frame that contains TGPictureButtonobjects. It provides an easy and fast access to most frequently used commands or options across multiple application screens. Also, it invokes easily a sub application within an application. All its functions can be obtained by application menus. It is located horizontally at the top of the main window just below the menu bar. All other subtask and sub-feature bars are positioned along sides of window.; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",; 0; };; // toolbar tool tip text; const char *tips[] = {; ""X Settings"",; ""Y Settings"",; ""Z Settings"",; 0; };; // toolbar button separator; int separator = 5;. // structure containing toolbar button information; ToolBarData_t t[3];. // creation of a toolbar object as a child of main frame; TGToolBar *tb = new TGToolBar(fMain,520,80);. for (int i = 0; i < 3; i++) {; // filling the ToolBarData_t with information; t[i].fPixmap = xpms[i]; // icon file; t[i].fTipText = tips[i]; // tool tip text; t[i].fStayDown = kFALSE; // button behavior if clicked; t[i].fId = i+1; // bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1194901,access,access,1194901,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"pped on screen, kFALSE otherwise. ;  ; virtual Bool_t IsMapSubwindows () const;  ; virtual void LowerWindow ();  lower window ;  ; virtual Int_t MustCleanup () const;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetEditDisabled (UInt_t on=kEditDisable);  ; virtual void SetMapSubwindows (Bool_t);  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGButton.html:11134,hash,hash,11134,doc/master/classTGButton.html,https://root.cern,https://root.cern/doc/master/classTGButton.html,65,['hash'],['hash']
Security,"pper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Fri Nov 26 14:26:55 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__CCTreeWrapper.html:1617,validat,validationSample,1617,root/html528/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html528/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"pper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Jun 30 15:15:18 2015 » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__CCTreeWrapper.html:1617,validat,validationSample,1617,root/html602/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html602/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"pplied to the item full_item_name should have full path to the item. ; Returns:. -1 - object invisible, cannot be accessed or listed; 0 - no explicit restrictions, use default; 1 - read-only access; 2 - full access . Definition at line 546 of file TRootSniffer.cxx. ◆ Class(). static TClass * TRootSniffer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRootSniffer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRootSniffer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 249 of file TRootSniffer.h. ◆ CreateItem(). Bool_t TRootSniffer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item element. ; Definition at line 1691 of file TRootSniffer.cxx. ◆ CreateOwnTopFolder(). void TRootSniffer::CreateOwnTopFolder ; (; ). Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffer instances At the same time such sniffer lost access to all global lists and folders. ; Definition at line 913 of file TRootSniffer.cxx. ◆ DeclFileName(). static const char * TRootSniffer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 249 of file TRootSniffer.h. ◆ DecodeUrlOptionValue(). TString TRootSniffer::DecodeUrlOptionValue ; (; const char * ; value, . Bool_t ; remove_quotes = kTRUE . ). protected . Method replaces all kind of special symbols, which could appear in URL options. ; Definition at line 1282 of file TRootSniffer.cxx. ◆ ExecuteCmd(). Bool_t TRootSniffer::ExecuteCmd ; (; const std::string & ; path, . const std::string & ; options, . std::string & ; res . ). protectedvirtual . Execute command marked as _kind=='Command'. ; Definition at line 1164 of file TRootSniffer.cxx. ◆ FindInHierarchy(). void * TRootSniffer::FindInHierarchy ; (; const char * ; path, . TClass ** ; cl = nullptr, . TDataMember ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:23174,access,access,23174,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['access'],['access']
Security,"pply (std::unique_ptr< StateDelta > &&delta);  Re-apply a delta. ;  ; std::unique_ptr< State > GetStateBefore ();  Get the lock state before the most recent write lock was taken. ;  ; TVirtualRWMutex::Hint_t * ReadLock ();  Acquire the lock in read mode. ;  ; void ReadUnLock (TVirtualRWMutex::Hint_t *);  Release the lock in read mode. ;  ; std::unique_ptr< StateDelta > Rewind (const State &earlierState);  Rewind to an earlier mutex state, returning the delta. ;  ; TVirtualRWMutex::Hint_t * WriteLock ();  Acquire the lock in write mode. ;  ; void WriteUnLock (TVirtualRWMutex::Hint_t *);  Release the lock in write mode. ;  . Private Member Functions; void AssertReadCountLocIsFromCurrentThread (const size_t *presumedLocalReadersCount);  Assert that presumedLocalReadersCount really matches the local read count. ;  . Private Attributes; std::condition_variable_any fCond;  ! RWlock internal condition variable ;  ; MutexT fMutex;  ! RWlock internal mutex ;  ; std::atomic< int > fReaderReservation;  ! A reader wants access ;  ; std::atomic< int > fReaders;  ! Number of readers ;  ; RecurseCountsT fRecurseCounts;  ! Trackers for re-entry in the lock by the same thread. ;  ; std::atomic< bool > fWriter;  ! Is there a writer? ;  ; std::atomic< int > fWriterReservation;  ! A writer wants access ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/thread/src/TReentrantRWLock.hxx>; Member Typedef Documentation. ◆ State. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::State = TVirtualRWMutex::State. Definition at line 299 of file TReentrantRWLock.hxx. ◆ StateDelta. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::StateDelta = TVirtualRWMutex::StateDelta. Definition at line 300 of file TReentrantRWLock.hxx. Constructor & Destructor Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TReentrantRWLock.html:1795,access,access,1795,doc/master/classROOT_1_1TReentrantRWLock.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TReentrantRWLock.html,1,['access'],['access']
Security,"pply (std::unique_ptr< StateDelta > &&delta);  Re-apply a delta. ;  ; std::unique_ptr< State > GetStateBefore ();  Get the lock state before the most recent write lock was taken. ;  ; TVirtualRWMutex::Hint_t * ReadLock ();  Acquire the lock in read mode. ;  ; void ReadUnLock (TVirtualRWMutex::Hint_t *);  Release the lock in read mode. ;  ; std::unique_ptr< StateDelta > Rewind (const State &earlierState);  Rewind to an earlier mutex state, returning the delta. ;  ; TVirtualRWMutex::Hint_t * WriteLock ();  Acquire the lock in write mode. ;  ; void WriteUnLock (TVirtualRWMutex::Hint_t *);  Release the lock in write mode. ;  . Private Member Functions; void AssertReadCountLocIsFromCurrentThread (const size_t *presumedLocalReadersCount);  Assert that presumedLocalReadersCount really matches the local read count. ;  . Private Attributes; std::condition_variable_any fCond;  ! RWlock internal condition variable ;  ; MutexT fMutex;  ! RWlock internal mutex ;  ; std::atomic< int > fReaderReservation;  ! A reader wants access ;  ; std::atomic< int > fReaders;  ! Number of readers ;  ; RecurseCountsT fRecurseCounts;  ! Trackers for re-entry in the lock by the same thread. ;  ; std::atomic< bool > fWriter;  ! Is there a writer? ;  ; std::atomic< int > fWriterReservation;  ! A writer wants access ;  . #include </home/sftnight/build/workspace/root-makedoc-v632/rootspi/rdoc/src/v6-32-00-patches/core/thread/src/TReentrantRWLock.hxx>; Member Typedef Documentation. ◆ State. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::State = TVirtualRWMutex::State. Definition at line 299 of file TReentrantRWLock.hxx. ◆ StateDelta. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::StateDelta = TVirtualRWMutex::StateDelta. Definition at line 300 of file TReentrantRWLock.hxx. Constructor & Destr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html:1794,access,access,1794,doc/v632/classROOT_1_1TReentrantRWLock.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html,1,['access'],['access']
Security,"pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Tue Jun 2 15:36:16 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooTreeDataStore.html:19611,access,access,19611,root/html604/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html604/RooTreeDataStore.html,1,['access'],['access']
Security,"preter::kRecoverable@ kRecoverableDefinition TInterpreter.h:74; TInterpreter::kDangerous@ kDangerousDefinition TInterpreter.h:75; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:470970,access,access,470970,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:15869,checksum,checksum,15869,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,12,['checksum'],['checksum']
Security,"private . Definition at line 114 of file TSchemaRule.h. ◆ fInclude. TString ROOT::TSchemaRule::fInclude. private . Source data member vector (for searching purposes) ; Definition at line 111 of file TSchemaRule.h. ◆ fIncludeVect. TObjArray* ROOT::TSchemaRule::fIncludeVect. mutableprivate . Definition at line 112 of file TSchemaRule.h. ◆ fReadFuncPtr. ReadFuncPtr_t ROOT::TSchemaRule::fReadFuncPtr. private . Definition at line 115 of file TSchemaRule.h. ◆ fReadRawFuncPtr. ReadRawFuncPtr_t ROOT::TSchemaRule::fReadRawFuncPtr. private . Conversion function pointer for read rule. ; Definition at line 116 of file TSchemaRule.h. ◆ fRuleType. RuleType_t ROOT::TSchemaRule::fRuleType. private . Conversion function pointer for readraw rule. ; Definition at line 117 of file TSchemaRule.h. ◆ fSource. TString ROOT::TSchemaRule::fSource. private . Target data member vector (for searching purposes) ; Definition at line 109 of file TSchemaRule.h. ◆ fSourceClass. TString ROOT::TSchemaRule::fSourceClass. private . Source checksum vector (for searching purposes) ; Definition at line 105 of file TSchemaRule.h. ◆ fSourceVect. TObjArray* ROOT::TSchemaRule::fSourceVect. mutableprivate . Definition at line 110 of file TSchemaRule.h. ◆ fTarget. TString ROOT::TSchemaRule::fTarget. private . Definition at line 107 of file TSchemaRule.h. ◆ fTargetClass. TString ROOT::TSchemaRule::fTargetClass. private . Definition at line 106 of file TSchemaRule.h. ◆ fTargetVect. TObjArray* ROOT::TSchemaRule::fTargetVect. mutableprivate . Definition at line 108 of file TSchemaRule.h. ◆ fVersion. TString ROOT::TSchemaRule::fVersion. private . Definition at line 101 of file TSchemaRule.h. ◆ fVersionVect. std::vector<std::pair<Int_t, Int_t> >* ROOT::TSchemaRule::fVersionVect. mutableprivate . Definition at line 102 of file TSchemaRule.h. core/meta/inc/TSchemaRule.h; core/meta/src/TSchemaRule.cxx. ROOTTSchemaRule. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:37 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:28992,checksum,checksum,28992,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,1,['checksum'],['checksum']
Security,prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore Counting semaphore class; TSeqCollection Sequenceable collection ABC; TServerSocket This class implements server sockets; TSessionDescription Session description; TSessionFrame Session frame; TSessionInputFrame Input frame; TSessionLogView PROOF progress dialog; TSessionOutputFrame Output frame; TSessionQueryFrame Query frame; TSessionServerFrame Server frame; TSessionViewer Session Viewer; TShape Basic shape; TSignalHandler Signal event handler; TSlave PROOF slave server; TSlaveInfo basic info on workers; TSlaveLite PROOF lite worker server; TSlider A user interface slider.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:120883,authenticat,authentication,120883,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['authenticat'],['authentication']
Security,"protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooAbsData::ErrorType_etypeError type store in associated RooDataHist; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooChi2Var::FuncMode_funcModeFunction, P.d.f. or ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:32821,validat,validate,32821,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,3,['validat'],['validate']
Security,"pt to view them here. . ; Download . ; Download ROOT . ; All Releases . ; Documentation . ; Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Using TTree::Draw() to access a TTree. Now close the browser, quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. For this exercise, you will probably need the TTree::Draw() documentation. Now, display the ""fPosY"" leaf values, without the browser, just by using the TTree::Draw() function. As the TTree is called EventTree, you need to call something like EventTree->Draw(""X""), which would draw the distribution of X values. Of course you don't want to draw the value of X but of fPosY...the value of X but of fPosY... Figure 4: Distribution of ""fPosY"" values; Still the same ""fPosY"" leaf values, but now apply a cut in the momentum, meaning draw only the fPosY value of events with a momentum higher than 50.0. Check the documentation of TTree::Draw() - you will be using the method overload taking a const char* as selection. Figure 5: Distribution of ""fP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-ttreedraw-access-ttree.html:1946,access,access,1946,d/using-ttreedraw-access-ttree.html,https://root.cern,https://root.cern/d/using-ttreedraw-access-ttree.html,1,['access'],['access']
Security,"ption = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TExMap.html:4301,hash,hash,4301,root/html530/TExMap.html,https://root.cern,https://root.cern/root/html530/TExMap.html,2,['hash'],['hash']
Security,"ption = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TExMap.html:4301,hash,hash,4301,root/html534/TExMap.html,https://root.cern,https://root.cern/root/html534/TExMap.html,1,['hash'],['hash']
Security,"ption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_ser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:20828,access,access,20828,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,1,['access'],['access']
Security,"ption_t* = """"). Bool_t SetFromRule(const char* rule). const char * GetVersion() const. Bool_t SetVersion(const TString& version). Bool_t TestVersion(Int_t version) const. Bool_t SetChecksum(const TString& checksum). Bool_t TestChecksum(UInt_t checksum) const. void SetSourceClass(const TString& classname). const char * GetSourceClass() const. void SetTargetClass(const TString& classname). const char * GetTargetClass() const. void SetTarget(const TString& target). const TObjArray* GetTarget() const. const char * GetTargetString() const. void SetSource(const TString& source). const TObjArray* GetSource() const. void SetEmbed(Bool_t embed). Bool_t GetEmbed() const. Bool_t IsAliasRule() const. Bool_t IsRenameRule() const. Bool_t IsValid() const. void SetCode(const TString& code). const char * GetCode() const. void SetAttributes(const TString& attributes). const char * GetAttributes() const. Bool_t HasTarget(const TString& target) const. Bool_t HasSource(const TString& source) const. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr). ReadFuncPtr_t GetReadFunctionPointer() const. void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr). ReadRawFuncPtr_t GetReadRawFunctionPointer() const. void SetInclude(const TString& include). const TObjArray* GetInclude() const. void SetRuleType(ROOT::TSchemaRule::RuleType_t type). RuleType_t GetRuleType() const. Bool_t Conflicts(const ROOT::TSchemaRule* rule) const. void AsString(TString& out, const char* options = """") const. void ls(Option_t* option = """") const. Bool_t ProcessVersion(const TString& version) const. Bool_t ProcessChecksum(const TString& checksum) const. void ProcessList(TObjArray* array, const TString& list). void ProcessDeclaration(TObjArray* array, const TString& list). » Last changed: root/core:$Id$ » Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__TSchemaRule.html:10534,checksum,checksum,10534,root/html604/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html604/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"ption_t* = """"). Bool_t SetFromRule(const char* rule). const char * GetVersion() const. Bool_t SetVersion(const TString& version). Bool_t TestVersion(Int_t version) const. Bool_t SetChecksum(const TString& checksum). Bool_t TestChecksum(UInt_t checksum) const. void SetSourceClass(const TString& classname). const char * GetSourceClass() const. void SetTargetClass(const TString& classname). const char * GetTargetClass() const. void SetTarget(const TString& target). const TObjArray* GetTarget() const. const char * GetTargetString() const. void SetSource(const TString& source). const TObjArray* GetSource() const. void SetEmbed(Bool_t embed). Bool_t GetEmbed() const. Bool_t IsAliasRule() const. Bool_t IsRenameRule() const. Bool_t IsValid() const. void SetCode(const TString& code). const char * GetCode() const. void SetAttributes(const TString& attributes). const char * GetAttributes() const. Bool_t HasTarget(const TString& target) const. Bool_t HasSource(const TString& source) const. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr). ReadFuncPtr_t GetReadFunctionPointer() const. void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr). ReadRawFuncPtr_t GetReadRawFunctionPointer() const. void SetInclude(const TString& include). const TObjArray* GetInclude() const. void SetRuleType(ROOT::TSchemaRule::RuleType_t type). RuleType_t GetRuleType() const. Bool_t Conflicts(const ROOT::TSchemaRule* rule) const. void AsString(TString& out, const char* options = """") const. void ls(Option_t* option = """") const. Bool_t ProcessVersion(const TString& version) const. Bool_t ProcessChecksum(const TString& checksum) const. void ProcessList(TObjArray* array, const TString& list). void ProcessDeclaration(TObjArray* array, const TString& list). » Last changed: root/core:$Id$ » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:10534,checksum,checksum,10534,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"ption_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; 348 /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; 349 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 350 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 351 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 352 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 353 template <class T> TBranch *Branch(const char* name, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 354 {; 355 return BranchImpRef(name, TClass::GetClass<T>(), TDataType::GetType(typeid(T)), obj, bufsize, splitlevel);; 356 }; 357 ; 358 /// Add a new branch, and infer the data type from the array `addobj` being passed.; 359 ///; 360 /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; 361 /// possible, unless e.g. type conversions are needed.; 362 ///; 363 /// \param[in] name Name of the branch to be created.; 364 /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:16947,access,accessed,16947,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['access'],['accessed']
Security,"ptional argument info may be specified to give an; alternative StreamerInfo instead of using the default StreamerInfo; automatically built from the class definition.; For more information, see class TStreamerInfo. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:44673,hash,hashtable,44673,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['hash'],['hashtable']
Security,"ptions(). void Reset(); reset the Method --> As if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(const TMVA::Event*const ev); regression response. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBase.html:34073,access,accessors,34073,root/html602/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBase.html,2,['access'],['accessors']
Security,"ptr),fClassGenerators(nullptr),fSecContexts(nullptr),; 616 fProofs(nullptr),fClipboard(nullptr),fDataSets(nullptr),fUUIDs(nullptr),fRootFolder(nullptr),fBrowsables(nullptr),; 617 fPluginManager(nullptr); 618{; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Initialize the ROOT system. The creation of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via such a function).; 638 ; 639TROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc); 640 : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),; 641 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 642 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 643 fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),; 644 fFromPopUp(kTRUE),fMustClean(kTRUE),fForceStyle(kFALSE),; 645 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:24685,access,accessed,24685,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['accessed']
Security,"ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); Bool_toperator==(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::Test",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TSchemaRule.html:4767,checksum,checksum,4767,root/html530/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); Bool_toperator==(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TSchemaRule.html:4767,checksum,checksum,4767,root/html534/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html534/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,ptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once so merge the training and testing trees from the MVA factory first: ; Implements TMVA::MethodBase.; Definition at line 260 of file MethodTMlpANN.cxx. Member Data Documentation. ◆ fHiddenLayer. TString TMVA::MethodTMlpANN::fHiddenLayer. private . string containing the hidden layer structure ; Definition at line 111 of file MethodTMlpANN.h. ◆ fLayerSpec. TString TMVA::MethodTMlpANN::fLayerSpec. private . Layer specification option. ; Definition at line 106 of file MethodTMlpANN.h. ◆ fLearningMethod. TString TMVA::MethodTMlpANN::fLearningMethod. private . the learning method (given via option string) ; Definition at line 116 of file MethodTMlpANN.h. ◆ fLocalTrainingTree. TTree* TMVA::MethodTMlpANN::fLocalTrainingTree. private . local copy of training tree ; Definition at line 109 of file MethodTMlpANN.h. ◆ fMLP. TMultiLayerPerceptron* TMVA::MethodTMlpANN::fMLP. private . the TMLP ; Definition at line 108 of file MethodTMlpANN.h. ◆ fMLPBuildOptions. TString TMVA::MethodTMlpANN::fMLPBuildOptions. private . option string to build the mlp ; Definition at line 114 of file MethodTMlpANN.h. ◆ fNcycles. Int_t TMVA::MethodTMlpANN::fNcycles. private . number of training cycles ; Definition at line 112 of file MethodTMlpANN.h. ◆ fValidationFraction. Double_t TMVA::MethodTMlpANN::fValidationFraction. private . fraction of events in training tree used for cross validation ; Definition at line 113 of file MethodTMlpANN.h. Libraries for TMVA::MethodTMlpANN:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/MethodTMlpANN.h; tmva/tmva/src/MethodTMlpANN.cxx. TMVAMethodTMlpANN. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:38 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html:37098,validat,validation,37098,doc/master/classTMVA_1_1MethodTMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html,1,['validat'],['validation']
Security,"put (bool flag);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooDataSet * summaryData ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ToyMCStudy.html:2756,hash,hash,2756,doc/master/classRooStats_1_1ToyMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ToyMCStudy.html,1,['hash'],['hash']
Security,"put (bool flag);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooDataSet * summaryData ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenFitStudy.html:3197,hash,hash,3197,doc/master/classRooGenFitStudy.html,https://root.cern,https://root.cern/doc/master/classRooGenFitStudy.html,1,['hash'],['hash']
Security,"put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 1180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:340572,access,access,340572,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 1180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:340605,access,access,340605,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101512,access,access,101512,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101544,access,access,101544,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"pwindowsize=-1);  Create a parallel server socket object for a named service. ;  ;  TPServerSocket (Int_t port, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a parallel server socket object on a specified port. ;  ; virtual ~TPServerSocket ();  ; TPSocket * Accept (UChar_t Opt=kSrvNoAuth) override;  Accept a connection on a parallel server socket. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TServerSocket;  TServerSocket (const char *service, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object for a named service. ;  ;  TServerSocket (Int_t port, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object on a specified port. ;  ; virtual ~TServerSocket ();  Destructor: cleanup authentication stuff (if any) and close. ;  ; TInetAddress GetLocalInetAddress () override;  Return internet address of host to which the server socket is bound, i.e. ;  ; Int_t GetLocalPort () override;  Get port # to which server socket is bound. In case of error returns -1. ;  ; TClass * IsA () const override;  ; Int_t Recv (char *, Int_t) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *, Int_t, Int_t &) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &, Int_t &) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *, Int_t, ESendRecvOptions=kDefault) override;  Receive a raw buffer of specified length bytes. ;  ; Int_t Send (const char *, Int_t=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Send (const TMessage &) override;  Send a TMessage object. ;  ; Int_t Send (Int_t) override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:1489,authenticat,authentication,1489,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,1,['authenticat'],['authentication']
Security,"q.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1290 of file TSocket.cxx. ◆ CreateAuthSocket() [2/2]. TSocket * TSocket::CreateAuthSocket ; (; const char * ; user, . const char * ; url, . Int_t ; port, . Int_t ; size = 0, . Int_t ; tcpwindowsize = -1, . TSocket * ; opensock = nullptr, . Int_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [options] = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1432 of file TSocket.cxx. ◆ DeclFileName(). static const char * TSocket::DeclFileName ; (; ). inlinestatic . ReturnsName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:25438,authenticat,authentication,25438,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authentication']
Security,"qfloat * qDefinition THbookFile.cxx:89; TMD5.h; TObjArray.h; TObjString.h; kHashShiftconst UInt_t kHashShiftDefinition TString.cxx:68; rotl64uint64_t rotl64(uint64_t x, int8_t r)Definition TString.cxx:720; ToLowerTString ToLower(const TString &str)Return a lower-case version of str.Definition TString.cxx:1497; operator+TString operator+(const TString &s, const char *cs)Use the special concatenation constructor.Definition TString.cxx:1525; ROTL64#define ROTL64(x, y)Definition TString.cxx:725; MemIsEqualstatic int MemIsEqual(const char *p, const char *q, Ssiz_t n)Returns false if strings are not equal.Definition TString.cxx:885; operator>>TBuffer & operator>>(TBuffer &buf, TString *&s)Read string from TBuffer. Function declared in ClassDef.Definition TString.cxx:1461; BIG_CONSTANT#define BIG_CONSTANT(x)Definition TString.cxx:726; operator==Bool_t operator==(const TString &s1, const char *s2)Compare TString with a char *.Definition TString.cxx:1482; HashUInt_t Hash(const char *str)Return a case-sensitive hash value (endian independent).Definition TString.cxx:576; SlowFormatstatic char * SlowFormat(const char *format, va_list ap, int hint)Format a string in a formatting buffer (using a printf style format descriptor).Definition TString.cxx:2394; ToUpperTString ToUpper(const TString &str)Return an upper-case version of str.Definition TString.cxx:1511; SwapIntstatic UInt_t SwapInt(UInt_t x)Definition TString.cxx:556; Mashstatic void Mash(UInt_t &hash, UInt_t chars)Utility used by Hash().Definition TString.cxx:566; TString.h; Compresschar * Compress(const char *str)Remove all blanks from the string str.Definition TString.cxx:2572; UnEscCharint UnEscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Un-escape specchars in src from escchar and copy to dst.Definition TString.cxx:2617; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:92576,hash,hash,92576,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['hash'],['hash']
Security,"qual to fgBufferSize (default value=1000).; fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; The axis limits will be automatically computed when the buffer will; be full or when the function BufferEmpty is called.; Filling histograms; An histogram is typically filled with statements like:. h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w). or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent.; To access the bin content of a given bin, do:. Double_t binContent = h->GetBinContent(bin);. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via. h->SetBit(TH1::kCanRebin);. then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:8437,access,access,8437,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['access'],['access']
Security,"qual to fgBufferSize (default value=1000).; fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; The axis limits will be automatically computed when the buffer will; be full or when the function BufferEmpty is called.; Filling histograms; An histogram is typically filled with statements like:. h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w). or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent.; To access the bin content of a given bin, do:. Double_t binContent = h->GetBinContent(bin);. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via. h->SetCanExtend(kAllAxes);. then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:8436,access,access,8436,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['access'],['access']
Security,"que_ptr<RFieldBase> field, FieldMappingFunc_t mapping);; 360 ; 361 void Freeze();; 362 void Unfreeze();; 363 bool IsFrozen() const { return fIsFrozen; }; 364 bool IsBare() const { return !fDefaultEntry; }; 365 std::uint64_t GetModelId() const { return fModelId; }; 366 std::uint64_t GetSchemaId() const { return fSchemaId; }; 367 ; 368 std::unique_ptr<REntry> CreateEntry() const;; 369 /// In a bare entry, all values point to nullptr. The resulting entry shall use BindValue() in order; 370 /// set memory addresses to be serialized / deserialized; 371 std::unique_ptr<REntry> CreateBareEntry() const;; 372 /// Creates a token to be used in REntry methods to address a field present in the entry; 373 REntry::RFieldToken GetToken(std::string_view fieldName) const;; 374 /// Calls the given field's CreateBulk() method. Throws an exception if no field with the given name exists.; 375 RFieldBase::RBulk CreateBulk(std::string_view fieldName) const;; 376 ; 377 REntry &GetDefaultEntry();; 378 const REntry &GetDefaultEntry() const;; 379 ; 380 /// Mutable access to the root field is used to make adjustments to the fields.; 381 RFieldZero &GetMutableFieldZero();; 382 const RFieldZero &GetConstFieldZero() const { return *fFieldZero; }; 383 RFieldBase &GetMutableField(std::string_view fieldName);; 384 const RFieldBase &GetConstField(std::string_view fieldName) const;; 385 ; 386 const std::string &GetDescription() const { return fDescription; }; 387 void SetDescription(std::string_view description);; 388 ; 389 /// Get the (qualified) names of subfields that have been registered to be included in entries from this model.; 390 const std::unordered_set<std::string> &GetRegisteredSubfields() const { return fRegisteredSubfields; }; 391 ; 392 /// Estimate the memory usage for this model during writing; 393 ///; 394 /// This will return an estimate in bytes for the internal page and compression buffers. The value should be; 395 /// understood per sequential RNTupleWriter or per RNTupleFillConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:17920,access,access,17920,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['access'],['access']
Security,"quest. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TS3HTTPRequest. class TS3HTTPRequest: public TObject. TS3HTTPRequest. An object of this class represents an HTTP request extended to be; compatible with Amazon's S3 protocol.; Specifically, such a request contains an 'Authorization' header with; information used by the S3 server for authenticating this request.; The authentication information is computed based on a pair of access; key and secret key which are both provided to the user by the S3; service provider (e.g. Amazon, Google, etc.).; The secret key is used to compute a signature of selected fields in; the request. The algorithm for computing the signature is documented; in:. Google storage:; http://code.google.com/apis/storage/docs/reference/v1/developer-guidev1.html#authentication. Amazon:; http://docs.aws.amazon.com/AmazonS3/latest/dev/S3_Authentication2.html. Function Members (Methods); public:. virtual~TS3HTTPRequest(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:1006,authenticat,authentication,1006,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,2,['authenticat'],['authentication']
Security,"quired, kZoomOps - other ops in action, kNoZoom - no zooming or ops ;  ; UInt_t fZoomWidth;  ! width of zoomed image in image pixels ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttImage; Bool_t fConstRatio {kFALSE};  keep aspect ratio of image on the screen ;  ; UInt_t fImageCompression {0};  compression [0 .. 100] 0: no compression ;  ; EImageQuality fImageQuality {kImgDefault};  OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")} ;  ; TImagePalette fPalette;  color palette for value -> color conversion ;  ; TPaletteEditor * fPaletteEditor {nullptr};  ! GUI to edit the color palette ;  ; Bool_t fPaletteEnabled {kFALSE};  ! kTRUE - palette is drawn on the image ;  . Static Protected Attributes; static Bool_t fgInit = kFALSE;  global flag to init afterimage only once ;  ; static THashTable * fgPlugList = new THashTable(50);  ! hash table containing loaded plugins ;  ; static ASVisual * fgVisual = nullptr;  pointer to visual structure ;  . Private Types; enum  { kNoZoom = 0; , kZoom = 1; , kZoomOps = -1; };  ; enum  { kReadWritePNG; , kReadWriteVector; };  . Private Member Functions; void CreateThumbnail ();  Create image thumbnail. ;  ; void DestroyImage ();  Destroy image. ;  ; void DrawDashHLine (UInt_t y, UInt_t x1, UInt_t x2, UInt_t nDash, const char *pDash, UInt_t col, UInt_t thick);  Draw a dashed horizontal line. ;  ; void DrawDashVLine (UInt_t x, UInt_t y1, UInt_t y2, UInt_t nDash, const char *pDash, UInt_t col, UInt_t thick);  Draw a dashed vertical line. ;  ; void DrawDashZLine (UInt_t x1, UInt_t y1, UInt_t x2, UInt_t y2, UInt_t nDash, const char *pDash, UInt_t col);  Draw a dashed line with one pixel width. ;  ; void DrawDashZTLine (UInt_t x1, UInt_t y1, UInt_t x2, UInt_t y2, UInt_t nDash, const char *pDash, UInt_t col, UInt_t thick);  Draw a dashed line with thick pixel w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:28977,hash,hash,28977,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['hash'],['hash']
Security,"r (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorList.html:2822,hash,hashlist,2822,doc/master/classTSelectorList.html,https://root.cern,https://root.cern/doc/master/classTSelectorList.html,1,['hash'],['hashlist']
Security,"r (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:3152,hash,hashlist,3152,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashlist']
Security,"r (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.3,ConvergenceSteps=20,BatchSize=50,TestRepetitions=1,WeightDecay=0.0,Regularization=None,Optimizer=Adam"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [datasetreg] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mBDTG␛[0m; : ; <WARNING> : Value for option maxdepth was previously set to 3; : the option NegWeightTreatment=InverseBoostNegWeights does not exist for BoostType=Grad; : --> change to new default NegWeightTreatment=Pray; Factory : ␛[1mTrain all methods␛[0m; Factory : [datasetreg] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : --------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:4579,validat,validation,4579,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['validat'],['validation']
Security,"r *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:8619,access,access,8619,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['access'],['access']
Security,"r *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:14262,authenticat,authenticates,14262,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['authenticat'],['authenticates']
Security,"r *uri);  Checks if the indicated dataset exits. ;  ; virtual Long64_t GetAvgFileSize () const;  ; virtual TFileCollection * GetDataSet (const char *uri, const char *server=0);  Utility function used in various methods for user dataset upload. ;  ; virtual TMap * GetDataSets (const char *uri, UInt_t=TDataSetManager::kExport);  Returns all datasets for the <group> and <user> specified by <uri>. ;  ; virtual Long64_t GetGroupQuota (const char *group);  returns the quota a group is allowed to have ;  ; virtual TMap * GetGroupQuotaMap ();  ; virtual Long64_t GetGroupUsed (const char *group);  Returns the used space of that group. ;  ; virtual TMap * GetSubDataSets (const char *uri, const char *excludeservers);  Partition dataset 'ds' accordingly to the servers. ;  ; TClass * IsA () const override;  ; virtual void MonitorUsedSpace (TVirtualMonitoringWriter *monitoring);  Log info to the monitoring server. ;  ; virtual Int_t NotifyUpdate (const char *group=0, const char *user=0, const char *dspath=0, Long_t mtime=0, const char *checksum=0);  Save into the <datasetdir>/dataset.list file the name of the last updated or created or modified dataset Returns 0 on success, -1 on error. ;  ; virtual void ParseInitOpts (const char *opts);  Parse the opts string and set the init bits accordingly Available options: Cq: set kCheckQuota Ar: set kAllowRegister Av: set kAllowVerify Ti: set kTrustInfo Sb: set kIsSandbox Ca: set kUseCache or kDoNotUseCache The opts string may also contain additional unrelated info: in such a case the field delimited by the prefix ""opt:"" is analyzed, e.g. ;  ; Bool_t ParseUri (const char *uri, TString *dsGroup=0, TString *dsUser=0, TString *dsName=0, TString *dsTree=0, Bool_t onlyCurrent=kFALSE, Bool_t wildcards=kFALSE);  Parses a (relative) URI that describes a DataSet on the cluster. ;  ; virtual Int_t RegisterDataSet (const char *uri, TFileCollection *dataSet, const char *opt);  Register a dataset, perfoming quota checkings, if needed. ;  ; virtual Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:3302,checksum,checksum,3302,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['checksum'],['checksum']
Security,"r * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void Create (const char *url, TSocket *sock=nullptr);  Create a TNetSystem object. ;  ; void InitRemoteEntity (const char *url);  Parse and save coordinates of the remote entity (user, host, port, ...) ;  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fIsLocal;  ; TString fLocalPrefix;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:30471,access,access,30471,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,1,['access'],['access']
Security,"r * GetMssUrl (Bool_t=kFALSE);  ; virtual TProofDesc * GetProofDesc (Int_t id);  Get TProofDesc instance corresponding to 'id'. ;  ; virtual TProofDesc * GetProofDesc (TProof *p);  Get TProofDesc instance corresponding to TProof object 'p'. ;  ; virtual Int_t GetRemoteProtocol () const;  ; virtual TProofLog * GetSessionLogs (Int_t=0, const char *=0, const char *=""-v \""| SvcMsg\"""", Bool_t=kFALSE);  ; virtual const char * GetUrl ();  ; virtual void Grep (const char *, const char *=0, const char *=0);  ; TClass * IsA () const override;  ; virtual Bool_t IsLite () const;  ; virtual Bool_t IsProofd () const;  ; virtual Bool_t IsValid () const;  ; virtual void Ls (const char *=""~/"", const char *=0, const char *=0);  ; virtual Bool_t MatchUrl (const char *url);  Checks if 'url' refers to the same user@host:port entity as the URL in memory. ;  ; virtual Int_t Md5sum (const char *, TString &, const char *=0);  ; virtual void More (const char *, const char *=0, const char *=0);  ; virtual Int_t PutFile (const char *, const char *, const char *=0);  ; virtual TList * QuerySessions (Option_t *opt=""S"");  Get list of sessions accessible to this manager. ;  ; virtual TObjString * ReadBuffer (const char *, const char *);  ; virtual TObjString * ReadBuffer (const char *, Long64_t, Int_t);  ; virtual Int_t Reset (Bool_t hard=kFALSE, const char *usr=0);  Send a cleanup request for the sessions associated with the current user. ;  ; virtual Int_t Rm (const char *, const char *=0, const char *=0);  Run 'rm' on 'what'. Locally it is just a call to TSystem::Unlink . ;  ; virtual Int_t SendMsgToUsers (const char *, const char *=0);  Send a message to connected users. ;  ; virtual void SetAlias (const char *alias="""");  ; virtual void SetInvalid ();  ; virtual void SetMssUrl (const char *mss);  ; virtual Int_t SetROOTVersion (const char *);  ; virtual void ShowROOTVersions ();  ; virtual void ShowWorkers ();  Show available workers. ;  ; virtual void ShutdownSession (Int_t id);  ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:3745,access,accessible,3745,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,1,['access'],['accessible']
Security,"r Functions |; Private Attributes |; Friends |; List of all members ; ROOT::RDF::RResultPtr< T > Class Template ReferenceDataframe. ; template<typename T>; class ROOT::RDF::RResultPtr< T >Smart pointer for the return type of actions. ; A wrapper around the result of RDataFrame actions able to trigger calculations lazily. Template Parameters. TType of the action result. A smart pointer which allows to access the result of a RDataFrame action. The methods of the encapsulated object can be accessed via the arrow operator. Upon invocation of the arrow operator or dereferencing (operator*), the loop on the events and calculations of all scheduled actions are executed if needed. It is possible to iterate on the result proxy if the proxied object is a collection. for (auto& myItem : myResultProxy) { ... };; If iteration is not supported by the type of the proxied object, a compilation error is thrown. ; Definition at line 119 of file RResultPtr.hxx. Public Types; using Value_t = T;  Convenience alias to simplify access to proxied type. ;  . Public Member Functions;  RResultPtr ()=default;  ;  RResultPtr (const RResultPtr &)=default;  ; template<typename T2 , std::enable_if_t< std::is_constructible< std::shared_ptr< T >, std::shared_ptr< T2 > >::value, int > = 0> ;  RResultPtr (const RResultPtr< T2 > &r);  Convert a RResultPtr<T2> to a RResultPtr<T>. ;  ;  RResultPtr (RResultPtr &&)=default;  ; RIterationHelper< T >::Iterator_t begin ();  Return an iterator to the beginning of the contained object if this makes sense, throw a compilation error otherwise. ;  ; RIterationHelper< T >::Iterator_t end ();  Return an iterator to the end of the contained object if this makes sense, throw a compilation error otherwise. ;  ; T * GetPtr ();  Get the pointer to the encapsulated object. ;  ; const T & GetValue ();  Get a const reference to the encapsulated object. ;  ; bool IsReady () const;  Check whether the result has already been computed. ;  ; RResultPtr< T > & OnPartialResult (UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:1287,access,access,1287,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['access'],['access']
Security,"r NSUM parsing; 880 ; 881// Defines the formula that a given term uses, if not already defined,; 882// and appends ""sanitized"" formula to `fullFormula` string; 883void TF1::DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula,; 884 int termStart, int termEnd, Double_t xmin, Double_t xmax); 885{; 886 TString originalTerm = formula(termStart, termEnd-termStart);; 887 int coeffLength = TermCoeffLength(originalTerm);; 888 if (coeffLength != -1); 889 termStart += coeffLength + 1;; 890 ; 891 // `originalFunc` is the real formula and `cleanedFunc` is the; 892 // sanitized version that will not confuse the TF1NormSum; 893 // constructor; 894 TString originalFunc = formula(termStart, termEnd-termStart);; 895 TString cleanedFunc = TString(formula(termStart, termEnd-termStart)); 896 .ReplaceAll('+', ""<plus>""); 897 .ReplaceAll('*',""<times>"");; 898 ; 899 // define function (if necessary); 900 if (!gROOT->GetListOfFunctions()->FindObject(cleanedFunc)); 901 newFuncs->Add(new TF1(cleanedFunc, originalFunc, xmin, xmax));; 902 ; 903 // append sanitized term to `fullFormula`; 904 if (fullFormula.Length() != 0); 905 fullFormula.Append('+');; 906 ; 907 // include numerical coefficient; 908 if (coeffLength != -1 && originalTerm[0] != '['); 909 fullFormula.Append(originalTerm(0, coeffLength+1));; 910 ; 911 // add coefficient name; 912 if (coeffLength != -1 && originalTerm[0] == '['); 913 coeffNames->Add(new TObjString(TString(originalTerm(1,coeffLength-2))));; 914 else; 915 coeffNames->Add(nullptr);; 916 ; 917 fullFormula.Append(cleanedFunc);; 918}; 919 ; 920 ; 921// Returns length of coeff at beginning of a given term, not counting the '*'; 922// Returns -1 if no coeff found; 923// Coeff can be either a number or parameter name; 924int TF1::TermCoeffLength(TString &term) {; 925 int firstAsterisk = term.First('*');; 926 if (firstAsterisk == -1) // no asterisk found; 927 return -1;; 928 ; 929 if (TString(term(0,firstAsterisk)).IsFloat()); 930 re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:32545,sanitiz,sanitized,32545,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['sanitiz'],['sanitized']
Security,"r NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Reader.html:15990,access,accessors,15990,root/html604/TMVA__Reader.html,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html,1,['access'],['accessors']
Security,"r NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Reader.html:15982,access,accessors,15982,root/html602/TMVA__Reader.html,https://root.cern,https://root.cern/root/html602/TMVA__Reader.html,1,['access'],['accessors']
Security,"r RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. return getVal(nset). » Last changed: Mon Jul 4 15:21:23 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsHiddenReal.html:34003,access,accessor,34003,root/html530/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html,1,['access'],['accessor']
Security,"r RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. return getVal(nset). » Last changed: Thu Nov 3 20:06:43 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsHiddenReal.html:34382,access,accessor,34382,root/html532/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html532/RooAbsHiddenReal.html,1,['access'],['accessor']
Security,"r a TGeoTrd1 ;  CTGeoTrd2A trapezoid with both x and y lengths varying with z ;  CTGeoTrd2EditorEditor for a TGeoTrd2 ;  CTGeoTreeDialog;  CTGeoTubeCylindrical tube class ;  CTGeoTubeEditorEditor for a TGeoTube ;  CTGeoTubeSegA phi segment of a tube ;  CTGeoTubeSegEditorEditor for a TGeoTubeSeg ;  CTGeoUniformMagFieldImplementation for uniform magnetic field ;  CTGeoUnion;  CTGeoVGConverterGeometry converter to VecGeom ;  CTGeoVGShapeBridge class for using a VecGeom solid as TGeoShape ;  CTGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes ;  ►CTGeoVolumeAssemblyVolume assemblies ;  CThreadData_t;  CTGeoVolumeDialog;  CTGeoVolumeEditorEditor for geometry volumes and assemblies of volumes ;  CTGeoVolumeMultiVolume families ;  CTGeoVoxelFinderFinder class handling voxels ;  ►CTGeoXtruAn extrusion with fixed outline shape in x-y and a sequence of z extents (segments) ;  CThreadData_t;  CTGEventHandler;  CTGFALFileRead and write data via the underlying Grid access mechanism ;  CTGFALSystemDirectory handler for GFAL ;  CTGFileBrowser;  CTGFileContainer;  CTGFileDialog;  CTGFileInfo;  CTGFileItem;  CTGFont;  ►CTGFontDialog;  CFontProp_t;  CTGFontPool;  CTGFontTypeComboBox;  CTGFrame;  CTGFrameElement;  CTGFrameElementPack;  CTGFSComboBox;  CTGGC;  CTGGCPool;  CTGGotoDialog;  CTGGroupFrame;  CTGHButtonGroup;  CTGHeaderFrame;  CTGHorizontal3DLine;  CTGHorizontalFrame;  CTGHorizontalLayout;  CTGHotString;  CTGHProgressBar;  CTGHScrollBar;  CTGHSlider;  CTGHSplitter;  CTGHtml;  CTGHtmlAnchor;  CTGHtmlBlock;  CTGHtmlBrowser;  CTGHtmlCell;  CTGHtmlElement;  CTGHtmlForm;  CTGHtmlHr;  CTGHtmlImage;  CTGHtmlImageMarkup;  CTGHtmlInput;  CTGHtmlLayoutContext;  CTGHtmlLi;  CTGHtmlListStart;  CTGHtmlMapArea;  CTGHtmlMarkupElement;  CTGHtmlRef;  CTGHtmlScript;  CTGHtmlSpaceElement;  CTGHtmlTable;  CTGHtmlTextElement;  CTGHtmlUri;  CTGIcon;  CTGIconLBEntry;  CTGIdleHandler;  CTGImageMap;  CTGInputDialog;  CTGInsets;  CTGItemContextEmpty object used as context",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:164322,access,access,164322,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['access'],['access']
Security,"r a range and return an instance of a KahanSum. ; See Add(Iterator,Iterator) for details. Parameters. [in]beginBeginning of a range. ; [in]endEnd of the range. ; [in]initialValueOptional initial value. . Definition at line 211 of file Util.h. ◆ Add() [1/3]. template<typename T = double, unsigned int N = 1> . template<class Container_t > . void ROOT::Math::KahanSum< T, N >::Add ; (; const Container_t & ; inputs). inline . Fill from a container that supports index access. ; Parameters. [in]inputsContainer with index access such as std::vector or array. . Definition at line 195 of file Util.h. ◆ Add() [2/3]. template<typename T = double, unsigned int N = 1> . template<class Iterator > . void ROOT::Math::KahanSum< T, N >::Add ; (; Iterator ; begin, . Iterator ; end . ). inline . Accumulate from a range denoted by iterators. ; This function will auto-vectorise with random-access iterators. Parameters. [in]beginBeginning of a range. Needs to be a random access iterator for automatic vectorisation, because a contiguous block of memory needs to be read. ; [in]endEnd of the range. . Definition at line 180 of file Util.h. ◆ Add() [3/3]. template<typename T = double, unsigned int N = 1> . void ROOT::Math::KahanSum< T, N >::Add ; (; T ; x). inline . Single-element accumulation. Will not vectorise. ; Definition at line 165 of file Util.h. ◆ AddIndexed(). template<typename T = double, unsigned int N = 1> . void ROOT::Math::KahanSum< T, N >::AddIndexed ; (; T ; input, . std::size_t ; index . ). inline . Add input to the sum. ; Particularly helpful when filling from a for loop. This function can be inlined and auto-vectorised if the index parameter is used to enumerate consecutive fills. Use Add() or Accumulate() when no index is available. Parameters. [in]inputValue to accumulate. ; [in]indexIndex of the value. Determines internal accumulator that this value is added to. Make sure that consecutive fills have consecutive indices to make a loop auto-vectorisable. The actual value of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html:8761,access,access,8761,doc/master/classROOT_1_1Math_1_1KahanSum.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html,1,['access'],['access']
Security,r all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNotifyLinkLinks multiple listeners to be notified on TChain file changes ;  CTNotifyLinkBase;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class generates packets to be processed on PROOF worker servers ;  CTPacketizerAdaptiveThis packetizer is based on TPacketizer but uses different load-balancing algorithms and data structures ;  CTPacketizerFileThis packetizer generates packets which contain a single file pat,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:197484,hash,hash,197484,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['hash'],['hash']
Security,"r at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 1 */); 2076{; 2077 TClass* cl = TClass::GetClass(classname);; 2078 if (!cl) {; 2079 Error(""BranchOld"", ""Cannot find class: '%s'"", classname);; 2080 return nullptr;; 2081 }; 2082 if (!cl->IsTObject()) {; 2083 if (fgBranchStyle == 0) {; 2084 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2085 ""\tfgBranchStyle is set to zero requesting by default to use BranchOld.\n""; 2086 ""\tIf this is intentional use Bronch instead of Branch or BranchOld."", classname);; 2087 } else {; 2088 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2089 ""\tYou can not use BranchOld to store objects of this type."",classname);; 2090 }; 2091 return nullptr;; 2092 }; 2093 TBranch* branch = new TBranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:82728,access,access,82728,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"r at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2388/// ~~~; 2389/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2390/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2391///; 2392/// bufsize is the buffer size in bytes for this branch; 2393/// The default value is 32000 bytes and should be ok for most cases.; 2394/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2395/// and each entry is large (Megabytes); 2396/// A small value for bufsize is optimum if you intend to access; 2397/// the entries in the Tree randomly and your Tree is in split mode.; 2398///; 2399/// Use splitlevel < 0 instead of splitlevel=0 when the class; 2400/// has a custom Streamer; 2401///; 2402/// Note: if the split level is set to the default (99), TTree::Branch will; 2403/// not issue a warning if the class can not be split.; 2404 ; 2405TBranch* TTree::Bronch(const char* name, const char* classname, void* addr, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2406{; 2407 return BronchExec(name, classname, addr, true, bufsize, splitlevel);; 2408}; 2409 ; 2410////////////////////////////////////////////////////////////////////////////////; 2411/// Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);; 2412 ; 2413TBranch* TTree::BronchExec(const char* name, const char* classname, void* addr, bool isptrptr, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2414{; 2415 TClass* cl = TClass::GetClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:95324,access,access,95324,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"r authentication to rootd or proofd. ; User is asked to type user name. Returns user name (which must be deleted by caller) or 0. If non-interactive run (eg ProofServ) returns default user. ; Definition at line 1102 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [1/2]. Int_t TAuthenticate::ProofAuthSetup ; (; ). private . Authentication related stuff setup in TProofServ. ; This is the place where the buffer send by the client / master is decoded. It contains also password information, if the case requires. Return 0 on success, -1 on failure. ; Definition at line 3699 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [2/2]. Int_t TAuthenticate::ProofAuthSetup ; (; TSocket * ; sock, . Bool_t ; client . ). staticprivate . Setup of authetication related stuff in PROOF run after a successful authentication. ; Return 0 on success, -1 on failure. ; Definition at line 3820 of file TAuthenticate.cxx. ◆ ReadRootAuthrc(). Int_t TAuthenticate::ReadRootAuthrc ; (; ). static . Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ; Files are read only if they changed since last reading If 'proofconf' is defined, check also file proofconf for directives ; Definition at line 3212 of file TAuthenticate.cxx. ◆ RemoveHostAuth(). void TAuthenticate::RemoveHostAuth ; (; THostAuth * ; ha, . Option_t * ; opt = """" . ). static . Remove THostAuth instance from the list. ; Definition at line 2203 of file TAuthenticate.cxx. ◆ RemoveSecContext(). void TAuthenticate::RemoveSecContext ; (; TRootSecContext * ; ctx). staticprivate . Tool for removing SecContext ctx from THostAuth listed in fgAuthInfo or fgProofAuthInfo. ; Definition at line 3661 of file TAuthenticate.cxx. ◆ RfioAuth(). Int_t TAuthenticate::RfioAuth ; (; TString & ; user). private . RFIO authentication (no longer supported) ; Definition at line 1498 of file TAuthenticate.cxx. ◆ SecureRecv(). Int_t TAuthenticate::SecureRecv ; (; TSocket * ; sock, . Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:35400,authenticat,authentication,35400,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"r class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* indpar = 0); Set the result from the fit; parameter values, errors, chi2, etc...; Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; By default it is assume that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:62049,access,accessed,62049,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['access'],['accessed']
Security,"r converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:11114,hash,hashtable,11114,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,6,['hash'],['hashtable']
Security,"r correlation matrix as a TMatrixDSym object. In addition TFitResult derives from TNamed and can be conveniently stored in a file.; When fitting an histogram ( a TH1 object) or a graph (a TGraph object) it is possible to return a TFitResult via the TFitResultPtr object, which behaves as a smart pointer to a TFitResult. TFitResultPtr is the return object by TH1::Fit or TGraph::Fit. By default the TFitResultPtr contains only the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer.; If the fit option S is instead used, TFitResultPtr contains the TFitResult and behaves as a smart pointer to it. This is an example:; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; 5.8 The Minimization packages; As explained before various minimization packages can be used when fitting in ROOT. We have seen before how to configure the Fitter class to use different minimization packages and different minimization options. When using the Fit method the minimization package (and its options) can be selected using the static methods of the ROOT::Math::MinimizerOptions class. For example to select Minuit2 instead of Minuit for fitting an histogram do:; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:212487,access,access,212487,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"r delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRule.html:4409,checksum,checksum,4409,root/html526/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"r delete[] for an array. ;  ; void Destructor (ObjectPtr obj, Bool_t dtorOnly=kFALSE);  Explicitly call destructor for object. ;  ; void Destructor (void *obj, Bool_t dtorOnly=kFALSE);  Explicitly call destructor for object. ;  ; void Draw (Option_t *option="""") override;  Draw detailed class inheritance structure. ;  ; void Dump () const override;  Dump contents of object on stdout. ;  ; void Dump (const void *obj, Bool_t noAddr=kFALSE) const;  Dump contents of object on stdout. ;  ; const void * DynamicCast (const TClass *base, const void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; void * DynamicCast (const TClass *base, void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; char * EscapeChars (const char *text) const;  Introduce an escape character (@) in front of a special chars. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const char *onfile_classname, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const TClass *onfile_cl, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindStreamerInfo (UInt_t checksum, Bool_t isTransient=kFALSE) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; TVirtualStreamerInfo * FindStreamerInfoAbstractEmulated (UInt_t checksum) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; void ForceReload (TClass *oldcl);  we found at least one equivalent. ;  ; TClass * GetActualClass (const void *object) const;  Return a pointer to the real class of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:8599,checksum,checksum,8599,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,6,['checksum'],['checksum']
Security,"r even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8505read_auth_file(struct mg_file *filep,; 8506 struct read_auth_file_struct *workdata,; 8507 int depth); 8508{; 8509 int is_authorized = 0;; 8510 struct mg_file fp;; 8511 size_t l;; 8512 ; 8513 if (!filep || !workdata || (0 == depth)) {; 8514 return 0;; 8515 }; 8516 ; 8517 /* Loop over passwords file */; 8518 while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep) != NULL) {; 8519 l = strlen(workdata->buf);; 8520 while (l > 0) {; 8521 if (isspace((unsigned char)workdata->buf[l - 1]); 8522 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8523 l--;; 8524 workdata->buf[l] = 0;; 8525 } else; 8526 break;; 8527 }; 8528 if (l < 1) {; 8529 continue;; 8530 }; 8531 ; 8532 workdata->f_user = workdata->buf;; 8533 ; 8534 if (workdata->f_user[0] == ':') {; 8535 /* user names may not contain a ':' and may not be empty,; 8536 * so lines starting with ':' may be used for a special purpose; 8537 */; 8538 if (workdata->f_user[1] == '#') {; 8539 /* :# is a comment */; 8540 continue;; 8541 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:245666,password,passwords,245666,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['password'],['passwords']
Security,"r even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8506read_auth_file(struct mg_file *filep,; 8507 struct read_auth_file_struct *workdata,; 8508 int depth); 8509{; 8510 int is_authorized = 0;; 8511 struct mg_file fp;; 8512 size_t l;; 8513 ; 8514 if (!filep || !workdata || (0 == depth)) {; 8515 return 0;; 8516 }; 8517 ; 8518 /* Loop over passwords file */; 8519 while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep) != NULL) {; 8520 l = strlen(workdata->buf);; 8521 while (l > 0) {; 8522 if (isspace((unsigned char)workdata->buf[l - 1]); 8523 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8524 l--;; 8525 workdata->buf[l] = 0;; 8526 } else; 8527 break;; 8528 }; 8529 if (l < 1) {; 8530 continue;; 8531 }; 8532 ; 8533 workdata->f_user = workdata->buf;; 8534 ; 8535 if (workdata->f_user[0] == ':') {; 8536 /* user names may not contain a ':' and may not be empty,; 8537 * so lines starting with ':' may be used for a special purpose; 8538 */; 8539 if (workdata->f_user[1] == '#') {; 8540 /* :# is a comment */; 8541 continue;; 8542 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:245698,password,passwords,245698,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['password'],['passwords']
Security,"r example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). 13.12.1.8 Compatibility with CLHEP Vector Classes. For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessorsx(), y(), and z() (and t() for the 4D).; We provide vector member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). 13.12.1.9 Connection to Linear Algebra Package; In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:726538,access,accessorsx,726538,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessorsx']
Security,"r for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRFIOFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a RFIO file object. A RFIO file is the same as a TFile; except that it is being accessed via a rfiod server. The url; argument must be of the form: rfio:/path/file.root (where file.root; is a symlink of type /shift/aaa/bbb/ccc) or rfio:server:/path/file.root.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TRFIOFile; object. Use IsZombie() to see if the file is accessable.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). ~TRFIOFile(); RFIO file dtor. Close and flush directory structure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it; in a single buffer. Returns kTRUE in case of error. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRFIOFile.html:23278,access,accessable,23278,root/html530/TRFIOFile.html,https://root.cern,https://root.cern/root/html530/TRFIOFile.html,2,['access'],['accessable']
Security,"r function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:457; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TROOTROOT top level object description.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:24020,access,access,24020,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['access'],['access']
Security,"r function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TROOTROOT top level object description.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:24019,access,access,24019,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['access'],['access']
Security,r interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summur,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:124862,authenticat,authentication,124862,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['authenticat'],['authentication']
Security,"r matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:43568,access,access,43568,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['access'],['access']
Security,"r names and parameter types. Do not write values instead of types in that place. It is possible to pass a parameter by value to a slot method in the following way:; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""SetMaximum(=123) "");; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""Draw(=\""LEGO\"")"");; As you see the parameter’s value is preceded by the equation symbol (=). Please note that this method of passing arguments by value works only if the signal has less arguments than the slot. If the signal method has the same number of arguments, then the slot argument will be overwritten with the signal argument. In the example below, the Draw option would be overwritten in the first line by the emitted signal argument. The second line would be ok, the argument passed by value would not be overwritten.; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(=\""x\"")"");; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(const char*, =\"" y==1 \"")"");; In addition, if the signal and slot arguments differ in argument type, passing arguments by value leads to undefined behaviour and illegal memory access, as the signal argument will be casted to another data type. In the example below, if Selected emits Int_t = 1, then ChangeText will try to read a TString at address 0x1.; Connect(myComboBox, ""Selected(Int_t)"", ""TGTextButton"", myButton, ""ChangeText(=\""Hello\"")"");; You have the possibility to destroy a signal/slot connection by using Disconnect() methods. There are three ways to do this:; 1/ to destroy all connections to an object’s signals;; 2/ to destroy all connections to a particular object’s signal; 3/ to detach an object from a specific receiver:; Disconnect(myObgect); // case 1; Disconnect(myObgect, ""mySignal""); // case 2; Disconnect(myObgect,0,myReceiver,0); // case 3; Three parameters of these methods could be replaced by 0. The meaning in these cases would be “any signal”, “any receiving object”, “any slot of the receiving object”, i.e. 0 is u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1172154,access,access,1172154,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"r not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen.GetHeaders().size() == 1;; 3983 // We may have an umbrella and forgot to add the flag. Downgrade the; 3984 // warning into an informat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160379,integrity,integrity,160379,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['integrity'],['integrity']
Security,"r of added elements. ; If called from a TBranch::Browse overload, ""branch"" should be set to the calling TBranch, otherwise ""parent"" should be set to the TVirtualBranchBrowsable being browsed. ; Definition at line 501 of file TBranchBrowsable.cxx. ◆ GetIconName(). const char * TMethodBrowsable::GetIconName ; (; ); const. inlineoverridevirtual . return our special icons ; Reimplemented from TObject.; Definition at line 111 of file TBranchBrowsable.h. ◆ IsA(). TClass * TMethodBrowsable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TBranchBrowsable.h. ◆ IsMethodBrowsable(). bool TMethodBrowsable::IsMethodBrowsable ; (; const TMethod * ; m). static . A TMethod is browsable if it is const, public and not pure virtual, if does not have any parameter without default value, and if it has a (non-void) return value. ; A method called *, Get*, or get* will not be browsable if there is a persistent data member called f*, _*, or m*, as data member access is faster than method access. Examples: if one of fX, _X, or mX is a persistent data member, the methods GetX(), getX(), and X() will not be browsable. ; Definition at line 530 of file TBranchBrowsable.cxx. ◆ Register(). void TMethodBrowsable::Register ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigned different addr to the same method, depending on what translation unit you're in... ; Definition at line 585 of file TBranchBrowsable.cxx. ◆ Streamer(). void TMethodBrowsable::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMethodBrowsable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TBranchBrowsable.h. ◆ Unregister(). void TMethodBrowsable::Unregister ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodBrowsable.html:19011,access,access,19011,doc/master/classTMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTMethodBrowsable.html,2,['access'],['access']
Security,"r of nodes). void FillTree(TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:10664,validat,validationSample,10664,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,3,['validat'],['validationSample']
Security,"r of under- and overflow bins left to account for, after the current dimension. More...;  ; struct  RComputeLocalBins< 0, NDIMS, AXES >;  ; struct  RComputeLocalBinsInitialisation;  Recursively compute some quantities needed for ComputeLocalBins, namely the total number of bins per hyperplane (overflow and regular) and the number of regular bins per hyperplane on the hyperplanes that have them. More...;  ; struct  RComputeLocalBinsInitialisation< 0, NDIMS, AXES >;  ; struct  RComputeLocalBinsRaw;  Recursively computes zero-based local bin indices, given... More...;  ; struct  RComputeLocalBinsRaw<-1, NDIMS, BINS, AXES, BINTYPE >;  ; class  RDaosContainer;  A RDaosContainer provides read/write access to objects in a given container. More...;  ; struct  RDaosEventQueue;  ; class  RDaosNTupleAnchor;  Entry point for an RNTuple in a DAOS container. More...;  ; class  RDaosObject;  Provides low-level access to DAOS objects in a container. More...;  ; class  RDaosPool;  A RDaosPool provides access to containers in a specific DAOS pool. More...;  ; class  RDirectoryEntry;  ; class  RExtraTypeInfoDescriptorBuilder;  A helper class for piece-wise construction of an RExtraTypeInfoDescriptor. More...;  ; class  RFieldDescriptorBuilder;  A helper class for piece-wise construction of an RFieldDescriptor. More...;  ; struct  RFieldRepresentationModifier;  ; class  RFileSharedPtrCtor;  ; class  RFileStorageInterface;  Base class for RFile storage backends. More...;  ; struct  RFillIterRange;  Recursively fills the ranges of all axes, excluding under- and overflow. More...;  ; struct  RFillIterRange<-1, AXES >;  ; struct  RFindLocalBins;  Find the per-axis local bin indices associated with a certain set of coordinates. More...;  ; struct  RFindLocalBins<-1, NDIMS, BINS, COORD, AXES >;  ; struct  RGetNBinsCount;  Recursively gets the total number of bins in whole hist, including under- and overflow. More...;  ; struct  RGetNBinsCount< 0, AXES >;  ; struct  RGetNBinsNoOverCount;  Rec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:3176,access,access,3176,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['access'],['access']
Security,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6851,access,access,6851,root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,106,['access'],['access']
Security,"r when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:70989,access,access,70989,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:102265,access,access,102265,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['access'],['access']
Security,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:47291,access,access,47291,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['access'],['access']
Security,"r'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [options] = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1432 of file TSocket.cxx. ◆ DeclFileName(). static const char * TSocket::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TSocket.h. ◆ GetBytesRecv(). UInt_t TSocket::GetBytesRecv ; (; ); const. inline . Definition at line 120 of file TSocket.h. ◆ GetBytesSent(). UInt_t TSocket::GetBytesSent ; (; ); const. inline . Definition at line 119 of file TSocket.h. ◆ GetClientProtocol(). Int_t TSocket::GetClientProtocol ; (; ). static . Static method returning supported client protocol. ; Definition at line 1469 of file TSocket.cxx. ◆ GetCompressionAlgorithm(). Int_t TSocket::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 175 of file TSocket.h. ◆ GetCompressionLevel(). Int_t TSocket::GetCompressionLevel ; (; ); const. inline . Definition at line 181 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:26165,authenticat,authenticated,26165,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,2,['authenticat'],"['authenticated', 'authentication']"
Security,"r(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24906,access,access,24906,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security,"r(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. ROOT::Fit::Fitter* GetFitter() const; Give direct access to the underlying fitter class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:14862,access,access,14862,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,2,['access'],['access']
Security,"r(int level, const char* location, const char* fmt, va_list va) const; voidTDirectory::FillFullPath(TString& buf) const; Bool_tTFile::FlushWriteCache(); virtual TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(); virtual Int_tTWebFile::GetFromWeb(char* buf, Int_t len, const TString& msg); virtual Int_tTWebFile::GetFromWeb10(char* buf, Int_t len, const TString& msg); virtual Int_tGetHead(); virtual Int_tTWebFile::GetHunk(TSocket* s, char* hunk, Int_t maxsize); virtual Int_tTWebFile::GetLine(TSocket* s, char* line, Int_t maxsize); virtual const char*TWebFile::HttpTerminator(const char* start, const char* peeked, Int_t peeklen); virtual voidTWebFile::Init(Bool_t readHeadOnly); Int_tTFile::MakeProjectParMake(const char* packname, const char* filename); Int_tTFile::MakeProjectParProofInf(const char* packname, const char* proofinfdir); voidTObject::MakeZombie(); voidTDirectory::operator=(const TDirectory&); virtual voidProcessHttpHeader(const TString& headerLine); virtual Bool_tTWebFile::ReadBuffer10(char* buf, Int_t len); virtual Bool_tTWebFile::ReadBuffers10(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); voidSetAccessKey(const TString& accessKey); virtual voidSetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); voidSetSecretKey(const TString& secretKey); virtual Int_tTFile::SysClose(Int_t fd); virtual Int_tTFile::SysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:18992,access,accessKey,18992,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['access'],['accessKey']
Security,"r) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:10524,access,accessors,10524,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security,"r); Determine default authentication details for method 'sec' and user 'usr'.; Checks .rootrc family files. Returned string must be deleted by the user. void RemoveHostAuth(THostAuth* ha, Option_t* opt = """"); Remove THostAuth instance from the list. void Show(Option_t* opt = ""S""); Print info about the authentication sector.; If 'opt' contains 's' or 'S' prints information about established TSecContext,; else prints information about THostAuth (if 'opt' is 'p' or 'P', prints; Proof related information). Int_t AuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); Check if we have a valid established sec context in memory; Retrieves relevant info and negotiates with server.; options = ""Opt,strlen(username),username.Data()""; message = kROOTD_USER, ... void InitRandom(); Initialize random machine using seed from /dev/urandom; (or current time if /dev/urandom not available). Int_t GenRSAKeys(); Generate a valid pair of private/public RSA keys to protect for; authentication token exchange. char * GetRandString(Int_t Opt, Int_t Len); Allocates and fills a 0 terminated buffer of length len+1 with; len random characters.; Returns pointer to the buffer (to be deleted by the caller); opt = 0 any non dangerous char; 1 letters and numbers (upper and lower case); 2 hex characters (upper and lower case). Int_t SecureSend(TSocket* Socket, Int_t enc, Int_t KeyType, const char* In); Encode null terminated str using the session private key indicated by enc; and sends it over the network; Returns number of bytes sent, or -1 in case of error.; enc = 1 for private encoding, enc = 2 for public encoding. Int_t SecureRecv(TSocket* Socket, Int_t dec, Int_t KeyType, char** Out); Receive str from sock and decode it using key indicated by key type; Return number of received bytes or -1 in case of error.; dec = 1 for private decoding, dec = 2 for public decoding. Int_t DecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:19507,authenticat,authentication,19507,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,r* f); set request file name. void SetUserName(const char* n); set name of authenticated user. void SetQuery(const char* q); set request query. void SetRequestHeader(const char* h); set full set of request header. Int_t NumRequestHeader() const; returns number of fields in request header. TString GetRequestHeaderName(Int_t number) const; returns field name in request header. TString GetRequestHeader(const char* name); get named field from request header. const char * GetTopName() const; returns engine-specific top-name. const char * GetMethod() const; returns request method like GET or POST. Bool_t IsPostMethod() const; returns kTRUE if post method is used. void* GetPostData() const; return pointer on posted with request data. Long_t GetPostDataLength() const; return length of posted with request data. const char * GetPathName() const; returns path name from request URL. const char * GetFileName() const; returns file name from request URL. const char * GetUserName() const; return authenticated user name (0 - when no authentication). const char * GetQuery() const; returns request query (string after ? in request URL). void SetContentType(const char* typ); these methods used in THttpServer to set results of request processing. void Set404(); mark reply as 404 error - page/request not exists. void SetFile(const char* filename = 0); indicate that http request should response with file content. void SetXml(); set content type as JSON. void SetJson(); set content type as JSON. Int_t NumHeader() const; returns number of fields in header. TString GetHeaderName(Int_t number) const; returns field name in header. void SetEncoding(const char* typ); Set Content-Encoding header like gzip. void SetContent(const char* c); Set content directly. void SetZipping(Int_t kind); Set kind of content zipping; 0 - none; 1 - only when supported in request header; 2 - if supported and content size bigger than 10K; 3 - always. Int_t GetZipping() const; return kind of content zipping. void SetExt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpCallArg.html:10482,authenticat,authenticated,10482,root/html534/THttpCallArg.html,https://root.cern,https://root.cern/root/html534/THttpCallArg.html,4,['authenticat'],"['authenticated', 'authentication']"
Security,"r* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TParticleClassPDG(const TParticleClassPDG& pcp); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TParticleClassPDG&operator=(const TParticleClassPDG& pcp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfParticleslist of (non-owned) particles; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticleClassPDG(const char* name = 0); default constructor. ~TParticleClassPDG(); destructor, class doesn't own its particles... void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. void Browse(TBrowser* b); browse this particle class. TParticleClassPDG(const TParticleClassPDG& pcp); { }. TParticleClassPDG& operator=(const TParticleClassPDG& pcp). Int_t GetNParticles(); ****** access methods. TParticlePDG* GetParticle(Int_t i). TObjArray* GetListOfParticles(); { return fListOfParticles; }. void AddParticle(TObject* p); ****** modifiers. { fListOfParticles->Add(p); }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Pasha Murat 12/02/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TParticleClassPDG.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TParticleClassPDG.html:6137,access,access,6137,root/html528/TParticleClassPDG.html,https://root.cern,https://root.cern/root/html528/TParticleClassPDG.html,1,['access'],['access']
Security,"r* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TParticleClassPDG(const TParticleClassPDG& pcp); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TParticleClassPDG&operator=(const TParticleClassPDG& pcp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfParticleslist of (non-owned) particles; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticleClassPDG(const char* name = 0); default constructor. ~TParticleClassPDG(); destructor, class doesn't own its particles... void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. void Browse(TBrowser* b); browse this particle class. TParticleClassPDG(const TParticleClassPDG& pcp); { }. TParticleClassPDG& operator=(const TParticleClassPDG& pcp). Int_t GetNParticles(); ****** access methods. TParticlePDG* GetParticle(Int_t i). TObjArray* GetListOfParticles(); { return fListOfParticles; }. void AddParticle(TObject* p); ****** modifiers. { fListOfParticles->Add(p); }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Pasha Murat 12/02/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TParticleClassPDG.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParticleClassPDG.html:6206,access,access,6206,root/html530/TParticleClassPDG.html,https://root.cern,https://root.cern/root/html530/TParticleClassPDG.html,1,['access'],['access']
Security,"r* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TParticleClassPDG(const TParticleClassPDG& pcp); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TParticleClassPDG&operator=(const TParticleClassPDG& pcp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfParticleslist of (non-owned) particles; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticleClassPDG(const char* name = 0); default constructor. ~TParticleClassPDG(); destructor, class doesn't own its particles... void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. void Browse(TBrowser* b); browse this particle class. TParticleClassPDG(const TParticleClassPDG& pcp); { }. TParticleClassPDG& operator=(const TParticleClassPDG& pcp). Int_t GetNParticles(); ****** access methods. TParticlePDG* GetParticle(Int_t i). TObjArray* GetListOfParticles(); { return fListOfParticles; }. void AddParticle(TObject* p); ****** modifiers. { fListOfParticles->Add(p); }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Pasha Murat 12/02/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TParticleClassPDG.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParticleClassPDG.html:6206,access,access,6206,root/html532/TParticleClassPDG.html,https://root.cern,https://root.cern/root/html532/TParticleClassPDG.html,1,['access'],['access']
Security,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); RooLinkedListElem*createElement(TObject* obj, RooLinkedListElem* elem = 0); voiddeleteElement(RooLinkedListElem*); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; Bool_t_useNptr!. private:. static RooLinkedListImplDetails::Pool*_pool!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinkedList.html:6305,hash,hashing,6305,root/html534/RooLinkedList.html,https://root.cern,https://root.cern/root/html534/RooLinkedList.html,1,['hash'],['hashing']
Security,"r* sniffer = 0); virtual TClass*IsA() const; Bool_tIsReadOnly(Bool_t dflt = kTRUE); Bool_tIsReadyForResult() const; voidMakeItemName(const char* objname, TString& itemname); Bool_tScanOnlyFields() const; voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetFoundResult(void* obj, TClass* cl, TDataMember* member = 0); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum { kScan; kExpand; kSearch; kCheckChilds; kOnlyFields; kActions; };. protected:. Bool_tfHasMore! indicates that potentially there are more items can be found; TStringfItemName! name of current item; TListfItemsNames! list of created items names, need to avoid duplication; Int_tfLevel! current level of hierarchy; UInt_tfMask! defines operation kind; Bool_tfNodeStarted! indicate if node was started; Int_tfNumChilds! number of childs; Int_tfNumFields! number of fields; TRootSnifferScanRec*fParent! pointer on parent record; Int_tfRestriction! restriction 0 - default, 1 - read-only, 2 - full access; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(). virtual ~TRootSnifferScanRec(). void CloseNode(). Bool_t CanSetFields() const; return true when fields could be set to the hierarchy item . Bool_t ScanOnlyFields() const. void CreateNode(const char* _node_name); Starts new node, must be closed at the end . void BeforeNextChild(). void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Set item field only when creating is specified . void SetRootClass(TClass* cl); Mark item with ROOT class and correspondent streamer info . Bool_t CanExpandItem(); Returns true when item can be expanded . Bool_t IsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSnifferScanRec.html:1925,access,access,1925,root/html534/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html534/TRootSnifferScanRec.html,1,['access'],['access']
Security,"r* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TNetFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:22593,access,access,22593,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,3,['access'],['access']
Security,"r* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TNetFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetSystem.html:22721,access,access,22721,root/html530/TNetSystem.html,https://root.cern,https://root.cern/root/html530/TNetSystem.html,3,['access'],['access']
Security,"r* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TNetFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetSystem.html:22814,access,access,22814,root/html532/TNetSystem.html,https://root.cern,https://root.cern/root/html532/TNetSystem.html,3,['access'],['access']
Security,"r, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:596654,password,password,596654,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['password'],['password']
Security,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:596687,password,password,596687,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['password'],['password']
Security,"r. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; Return value of parameter number ipar. Double_t GetParameter(const char* name) const; Return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter. Int_t GetParNumber(const char* name) const; Return parameter number by name. Bool_t IsString(Int_t oper) const; Return true if the expression at the index 'oper' has to be treated as a string. void Print(Option_t* option = """") const; Dump this formula with its attributes. void ProcessLinear(TString& replaceformula); If the formula is for linear fitting, change the title to; normal and fill the LinearParts array. void SetName(const char* name); Set the name of the formula. We need to allow the list of function to; properly handle the hashes. void SetParameter(const char* name, Double_t parvalue); Initialize parameter number ipar. void SetParameter(Int_t ipar, Double_t parvalue); Initialize parameter number ipar. void SetParameters(const Double_t* params); Initialize array of all parameters.; See also the next function with the same name. void SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0); Initialize up to 11 parameters; All arguments except THE FIRST TWO are optional; In case of a function with only one parameter, call this function with p1=0.; Minimum two arguments are required to differentiate this function; from the SetParameters(cont Double_t *params). void SetParName(Int_t ipar, const char* name); Set name of parameter number ipar. void SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFormula.html:28909,hash,hashes,28909,root/html602/TFormula.html,https://root.cern,https://root.cern/root/html602/TFormula.html,1,['hash'],['hashes']
Security,"r. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to be noted here:; 48# - The @pythonization decorator has one argument that specifies our target; 49# class is `MyClass`.; 50# - The pythonizor function `pythonizor_of_myclass` provides and injects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new instance of that class. At this moment, the pythonizor will; 61# execute and modify the class - pythonizors are always lazily run when a given; 62# class is used for the first time from a Python script.; 63my_object = ROOT.MyClass(); 64 ; 65# Since the pythonizor already executed, we should now see the new behaviour.; 66# For that purpose, let's print `my_object` (should show ""This is a MyClass; 67# object"").; 68print(my_object); 69 ; 70# The previous example is just a simple one, but there are many ways i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:2499,inject,injects,2499,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['inject'],['injects']
Security,"r.Definition TH2.cxx:352; TH2::SetShowProjectionXYvirtual void SetShowProjectionXY(Int_t nbinsY=1, Int_t nbinsX=1)When the mouse is moved in a pad containing a 2-d view of this histogram two canvases show the projec...Definition TH2.cxx:2667; TH2::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH2.cxx:1317; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TH2::RebinYvirtual TH2 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin2D.Definition TH2.cxx:1652; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TMatrixTBaseTMatrixTBase.Definition TMatrixTBase.h:84; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Expandvirtual void Expand(Int_t newSize)Expand or shrink the array to newSize elements.Definition TObjArray.cxx:387; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't wan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:193824,hash,hash,193824,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['hash'],['hash']
Security,"r3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11550,access,access,11550,root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"r::DataMemberInfo_MaxIndexvirtual int DataMemberInfo_MaxIndex(DataMemberInfo_t *, Int_t) constDefinition TInterpreter.h:461; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::ClassInfo_HasDefaultConstructorvirtual Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t *, Bool_t=kFALSE) constDefinition TInterpreter.h:412; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::ClassInfo_GetBaseOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:356401,access,access,356401,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"r::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:143819,hash,hash,143819,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,2,['hash'],['hash']
Security,"r; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. map<Int_t,Int_t>_binMap; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooDataHist_dataSet; RooListProxy_dataVarsThe RooRealVars; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooObjCacheManager_normIntMgrThe integration cach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:31337,validat,validate,31337,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,2,"['access', 'validat']","['access', 'validate']"
Security,"r;  CVectorHelper;  CVectorHelper< char >;  CVectorHelper< double >;  CVectorHelper< float >;  CVectorHelper< int >;  CVectorHelper< m128i >;  CVectorHelper< m256 >;  CVectorHelper< m256d >;  CVectorHelper< m256i >;  CVectorHelper< sfloat >;  CVectorHelper< signed short >;  CVectorHelper< unsigned char >;  CVectorHelper< unsigned int >;  CVectorHelper< unsigned short >;  CVectorHelperSize;  CVectorTypeHelper;  CVectorTypeHelper< char >;  CVectorTypeHelper< double >;  CVectorTypeHelper< float >;  CVectorTypeHelper< int >;  CVectorTypeHelper< sfloat >;  CVectorTypeHelper< short >;  CVectorTypeHelper< unsigned char >;  CVectorTypeHelper< unsigned int >;  CVectorTypeHelper< unsigned short >;  CWriteMaskedVector;  ►NCommon;  ►NInternal;  CCopyConst;  CCopyConst< const A, B >;  CEnableInterleaves;  CAliasingEntryHelper;  CInterleavedMemoryAccess;  CInterleavedMemoryAccessBase;  CInterleavedMemoryReadAccess;  CInterleavedMemoryWrapperWraps a pointer to memory with convenience functions to access it via vectors ;  CLogImpl;  CTypenameForLdexp;  CTypenameForLdexp< Vc::sfloat >;  CVectorMemoryUnion;  CVectorTuple;  CVectorTuple< 2, const V >;  CVectorTuple< 2, V >;  ►NError;  Cinvalid_operands_of_types;  ►NInternal;  CFlagObject;  CFlagObject< AlignedFlag >;  CFlagObject< StreamingAndAlignedFlag >;  CFlagObject< StreamingAndUnalignedFlag >;  CFlagObject< UnalignedFlag >;  CHelperImpl;  CHelperImpl< SSE3Impl >;  CHelperImpl< SSE41Impl >;  CHelperImpl< SSE42Impl >;  CHelperImpl< SSSE3Impl >;  CHelperImpl< Vc::AVXImpl >;  CHelperImpl< Vc::ScalarImpl >;  CHelperImpl< Vc::SSE2Impl >;  CMapImpl;  CMapImpl< Vc::SSE42Impl >;  ►NMem;  CScaleForBlend;  ►NScalar;  CForeachHelper;  CMask;  CSwizzledVector;  CVector;  CVectorAlignedBaseT;  CWriteMaskedVector;  ►NSSE;  Cc_general;  Cc_log;  Cc_log< double >;  Cc_trig;  CConst;  CCtorTypeHelper;  CCtorTypeHelper< float >;  CCtorTypeHelper< short >;  CCtorTypeHelper< unsigned short >;  CDebugStream;  CDetermineGatherMask;  CDetermineGatherMas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:64556,access,access,64556,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"r< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[] (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & operator() (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction with another vector ;  ; template<class A > ; SVector< T, D > & operator+= (const VecExpr< A, T, D > &rhs);  self addition with a vector expression ;  ; template<class A > ; SVector< T, D > & operator-= (const VecExpr< A, T, D > &rhs);  self subtraction with a vector expression ;  ; — Expert functions —; SVector< T, D > & Unit ();  transform vector into a vector of length 1 ;  ; template<unsigned int D2> ; SVector< T, D > & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:5297,access,access,5297,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"r< T, D > &rhs) const;  element wise comparison ;  ; bool operator!= (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator== (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator!= (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[] (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & operator() (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:4890,access,access,4890,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"r<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6018,access,access,6018,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,4,['access'],['access']
Security,"r<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:6018,access,access,6018,root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,4,['access'],['access']
Security,"r<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:6018,access,access,6018,root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,4,['access'],['access']
Security,"r<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:6018,access,access,6018,root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,4,['access'],['access']
Security,"r<T> MakeField(const NameWithDescription_t &fieldNameDesc, ArgsT &&...args); 296 {; 297 EnsureNotFrozen();; 298 EnsureValidFieldName(fieldNameDesc.fName);; 299 auto field = std::make_unique<RField<T>>(fieldNameDesc.fName);; 300 field->SetDescription(fieldNameDesc.fDescription);; 301 std::shared_ptr<T> ptr;; 302 if (fDefaultEntry); 303 ptr = fDefaultEntry->AddValue<T>(*field, std::forward<ArgsT>(args)...);; 304 fFieldNames.insert(field->GetFieldName());; 305 fFieldZero->Attach(std::move(field));; 306 return ptr;; 307 }; 308 ; 309 /// Adds a field whose type is not known at compile time. Thus there is no shared pointer returned.; 310 ///; 311 /// Throws an exception if the field is null.; 312 void AddField(std::unique_ptr<RFieldBase> field);; 313 ; 314 /// Register a subfield so it can be accessed directly from entries belonging to the model. Because registering a; 315 /// subfield does not fundamentally change the model, previously created entries will not be invalidated, nor; 316 /// modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any; 317 /// entries created afterwards.; 318 ///; 319 /// Using models with registered subfields for writing is not allowed. Attempting to do so will result in an; 320 /// exception.; 321 ///; 322 /// Throws an exception if the provided subfield could not be found in the model.; 323 void RegisterSubfield(std::string_view qualifiedFieldName);; 324 ; 325 /// Adds a top-level field based on existing fields.; 326 ///; 327 /// The mapping function takes one argument, which is a string containing the name of the projected field. The return; 328 /// value of the mapping function should be the name of the (existing) field onto which the projection is made.; 329 /// **Example**; 330 /// ~~~ {.cpp}; 331 /// auto model = RNTupleModel::Create();; 332 /// model->MakeField<float>(""met"");; 333 /// auto metProjection = RFieldBase::Create(""missingE"", ""float"").Unwrap();; 334 /// model->AddProject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:14702,access,accessor,14702,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['access'],['accessor']
Security,"rClassName() const; virtual voidTXMLParser::InitializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TDOMParser(const TDOMParser&); TDOMParser&operator=(const TDOMParser&); Int_tParseContext(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TXMLDocument*fTXMLDocxmlDoc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDOMParser(); TDOMParser constructor. ~TDOMParser(); TDOMParser destructor, it calls ReleaseUnderlying(). void ReleaseUnderlying(); Release any existing document. Int_t ParseFile(const char* filename); Parse the XML file where filename is the XML file name.; It will create a TXMLDocument if the file is parsed without; any error. It returns parse code error in case of parse error,; see TXMLParser. Int_t ParseBuffer(const char* buffer, Int_t len); It parses a buffer, much like ParseFile(). Int_t ParseContext(); Creates a XML docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDOMParser.html:10054,validat,validate,10054,root/html526/TDOMParser.html,https://root.cern,https://root.cern/root/html526/TDOMParser.html,5,['validat'],['validate']
Security,"rCoeff (Int_t ivar, Double_t coeff);  set fisher coefficients ;  ; virtual void SetLeft (Node *l);  ; void SetNBkgEvents (Float_t b);  set the sum of the backgr weights in the node, if traininfo defined ;  ; void SetNBkgEvents_unboosted (Float_t b);  set the sum of the unboosted backgr events in the node, if traininfo defined ;  ; void SetNBkgEvents_unweighted (Float_t b);  set the sum of the unweighted backgr events in the node, if traininfo defined ;  ; void SetNBValidation (Double_t b);  set number of background events from the pruning validation sample, if traininfo defined ;  ; void SetNEvents (Float_t nev);  set the number of events that entered the node (during training), if traininfo defined ;  ; void SetNEvents_unboosted (Float_t nev);  set the number of unboosted events that entered the node (during training), if traininfo defined ;  ; void SetNEvents_unweighted (Float_t nev);  set the number of unweighted events that entered the node (during training), if traininfo defined ;  ; void SetNFisherCoeff (Int_t nvars);  ; void SetNodeR (Double_t r);  set the node resubstitution estimate, R(t), for Cost Complexity pruning, if traininfo defined ;  ; void SetNodeType (Int_t t);  set node type: 1 signal node, -1 bkg leave, 0 intermediate Node ;  ; void SetNSigEvents (Float_t s);  set the sum of the signal weights in the node, if traininfo defined ;  ; void SetNSigEvents_unboosted (Float_t s);  set the sum of the unboosted signal events in the node, if traininfo defined ;  ; void SetNSigEvents_unweighted (Float_t s);  set the sum of the unweighted signal events in the node, if traininfo defined ;  ; void SetNSValidation (Double_t s);  set number of signal events from the pruning validation sample, if traininfo defined ;  ; void SetNTerminal (Int_t n);  set number of terminal nodes in the subtree rooted here, if traininfo defined ;  ; virtual void SetParent (Node *p);  ; void SetPurity (void);  return the S/(S+B) (purity) for the node REM: even if nodes with purity 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:9484,validat,validation,9484,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security,"rExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:339569,access,accessor,339569,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"rExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6855; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6881; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6912; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:7012; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4154; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4350; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:342207,access,accessor,342207,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"rForward); virtual~THashTableIter(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator& aIter) const; booloperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTableIter.html:1520,hash,hashtable,1520,root/html528/THashTableIter.html,https://root.cern,https://root.cern/root/html528/THashTableIter.html,3,['hash'],['hashtable']
Security,"rInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 ///////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:276708,checksum,checksum,276708,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"rInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7259 ; 7260TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7261{; 7262 TClass *cl = TClass::GetClass( classname );; 7263 if( !cl ); 7264 return nullptr;; 7265 return FindConversionStreamerInfo( cl, checksum );; 7266}; 7267 ; 7268////////////////////////////////////////////////////////////////////////////////; 7269/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7270 ; 7271TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7272{; 7273 //---------------------------------------------------------------------------; 7274 // Check if the classname was specified correctly; 7275 /////////////////////////////////////////////////////////////////////////////; 7276 ; 7277 if( !cl ); 7278 return nullptr;; 7279 ; 7280 if( cl == this ); 7281 return FindStreamerInfo( checksum );; 7282 ; 7283 //----------------------------------------------------------------------------; 7284 // Check if we already have it; 7285 /////////////////////////////////////////////////////////////////////////////; 7286 ; 7287 TObjArray* arr = nullptr;; 7288 TVirtualStreamerInfo* info = nullptr;; 7289 if (fConversionStreamerInfo.load()) {; 7290 std::map<std::string, TObjArray*>::iterator it;; 7291 ; 7292 R__LOCKGUARD(gInterpreterMutex);; 7293 ; 7294 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7295 ; 7296 if( it != (*fConversionStreamerInfo).end() ) {; 7297 arr = it->second;; 7298 }; 7299 if (arr) {; 7300 info = FindStreamerInfo( arr, checksum );; 7301 }; 7302 }; 7303 ; 7304 if( info ); 7305 return info;; 7306 ; 7307 R__LOCKGUARD(gInterpreterMutex);; 7308 ; 7309 //----------------------------------------------------------------------------; 7310 // Get it from the foreign class; 7311 ///////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:279459,checksum,checksum,279459,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"rLimit(unsigned int ivar, double lower); virtual boolROOT::Math::Minimizer::SetVariableStepSize(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. TMVA::IFitterTarget*fFitness; doublefMinValue; ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; ROOT::Math::GeneticMinimizerParametersfParameters; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int i = 0). ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step); It does nothing! As there is no variable if it has no limits!. bool SetFixedVariable(unsigned int ivar, const string& name, double val); set a fixed variable. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). ROOT::Math::MinimizerOptions Options() const. void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const; get the genetic options of the class and return them in the M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GeneticMinimizer.html:5435,validat,validated,5435,root/html602/ROOT__Math__GeneticMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GeneticMinimizer.html,2,['validat'],['validated']
Security,"rMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. private:. Connection*fConnconnection to Oracle server; Environment*fEnvenvironment of Oracle access; TStringfInfoinfo string with Oracle version information; static const char*fgDatimeFormat! format for converting date and time stamps into string . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleServer(const char* db, const char* uid, const char* pw); Open a connection to a Oracle DB server. The db arguments should be; of the form ""oracle://connection_identifier[/<database>]"", e.g.:; ""oracle://cmscald.fnal.gov/test"". The uid is the username and pw; the password that should be used for the connection. ~TOracleServer(); Close connection to Oracle DB server. void Close(Option_t* opt = """"); Close connection to Oracle DB server. TSQLStatement * Statement(const char* sql, Int_t niter = 100). TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise. Bool_t Exec(const char* sql); Execute sql command wich does not produce any result set.; Return kTRUE if succesfull. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list all tables starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TList* GetTablesList(const char* wild = 0). TSQLTableInfo * GetTableInfo(const char* tablename); Produces SQL table info; Object must be deleted by user. TSQLResult * GetColumns(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:9660,password,password,9660,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['password'],['password']
Security,"rNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfBranchingRatiobranching ratio ( < 1); TArrayIfDaughtersPDG codes of the daughters; Int_tfMatrixElementCodematrix element for this decay mode; Int_tfNumberchannel number. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecayChannel(); default constructor. TDecayChannel(Int_t Number, Int_t MatrixElementCode, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); constructor. ~TDecayChannel(). TDecayChannel(); ****** constructors and destructor. Int_t Number(); ****** accessors. { return fNumber; }. Int_t MatrixElementCode(); { return fMatrixElementCode; }. Int_t NDaughters(); { return fDaughters.fN; }. Double_t BranchingRatio(); { return fBranchingRatio; }. Int_t DaughterPdgCode(Int_t i); { return fDaughters.fArray[i]; }. » Author: P.Murat 15/02/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDecayChannel.html:5944,access,accessors,5944,root/html534/TDecayChannel.html,https://root.cern,https://root.cern/root/html534/TDecayChannel.html,1,['access'],['accessors']
Security,"rStoreUsed!; RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; list<std::pair<Int_t,RooLinkedListElem*> >_storeList!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:7251,hash,hash,7251,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,1,['hash'],['hash']
Security,"rStrconst char * GetErrorStr() constDefinition TSystem.h:350; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:62562,access,access,62562,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['access'],['access']
Security,"rTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:11465,validat,validation,11465,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['validat'],['validation']
Security,"rValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:1473,access,access,1473,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,2,['access'],['access']
Security,"r_start(conn, conn->status_code);; 11718 send_no_cache_header(conn);; 11719 send_additional_header(conn);; 11720 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose fail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:339914,access,access,339914,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"r_start(conn, conn->status_code);; 11719 send_no_cache_header(conn);; 11720 send_additional_header(conn);; 11721 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose fail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:339947,access,access,339947,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"r_t ptr);  Set the pointer to the function to be run for the rule (if it is a read rule). ;  ; void SetReadRawFunctionPointer (ReadRawFuncPtr_t ptr);  Set the pointer to the function to be run for the rule (if it is a raw read rule). ;  ; void SetRuleType (RuleType_t type);  Set the type of the rule. ;  ; void SetSource (const TString &source);  Set the list of source members. ;  ; void SetSourceClass (const TString &classname);  Set the source class of this rule (i.e. the onfile class). ;  ; void SetTarget (const TString &target);  Set the target member of this rule (i.e. the in memory data member). ;  ; void SetTargetClass (const TString &classname);  Set the target class of this rule (i.e. the in memory class). ;  ; Bool_t SetVersion (const TString &version);  Set the version string - returns kFALSE if the format is incorrect. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t TestChecksum (UInt_t checksum) const;  Check if given checksum is defined in this rule. ;  ; Bool_t TestVersion (Int_t version) const;  Check if given version number is defined in this rule. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:5792,checksum,checksum,5792,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,4,['checksum'],['checksum']
Security,"r_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:41636,access,access,41636,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['access'],['access']
Security,"r_traits<char> >& out, Option_t* option = """"); voidTEveElement::SaveVizParams(ostream& out, const TString& tag, const TString& var); virtual voidTEveElement::SelectElement(Bool_t state); voidSetAutoLighting(Bool_t isOn); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTEveElement::SetCompound(TEveCompound* c); voidTEveElement::SetCSCBits(UChar_t f); voidTEveElement::SetDestroyOnZeroRefCnt(Bool_t d); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTEveElement::SetEditMainColor(Bool_t x); voidTEveElement::SetEditMainTransparency(Bool_t x); virtual voidTEveElement::SetElementName(const char* name); virtual voidTEveElement::SetElementNameTitle(const char* name, const char* title); virtual voidTEveElement::SetElementTitle(const char* title); voidSetExtrude(Float_t x); voidSetFontFile(Int_t file); voidSetFontFile(const char* name); voidSetFontMode(Int_t mode); voidSetFontSize(Int_t size, Bool_t validate = kTRUE); voidSetLighting(Bool_t isOn); voidTEveElement::SetMainAlpha(Float_t alpha); virtual voidTEveElement::SetMainColor(Color_t color); voidTEveElement::SetMainColorPixel(Pixel_t pixel); voidTEveElement::SetMainColorPtr(Color_t* color); voidTEveElement::SetMainColorRGB(UChar_t r, UChar_t g, UChar_t b); voidTEveElement::SetMainColorRGB(Float_t r, Float_t g, Float_t b); virtual voidTEveElement::SetMainTransparency(Char_t t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTEveElement::SetPickable(Bool_t p); voidSetPolygonOffset(Float_t factor, Float_t units); virtual Bool_tTEveElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetText(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveText.html:13004,validat,validate,13004,root/html528/TEveText.html,https://root.cern,https://root.cern/root/html528/TEveText.html,1,['validat'],['validate']
Security,"rack = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:2969,access,access,2969,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['access'],['access']
Security,"ractive){; 471 delete fInteractive;; 472 fInteractive = nullptr;; 473 }; 474 return fExitFromTraining;; 475 }; 476 ; 477 // get fIPyMaxIter; 478 inline UInt_t GetMaxIter(){ return fIPyMaxIter; }; 479 ; 480 // get fIPyCurrentIter; 481 inline UInt_t GetCurrentIter(){ return fIPyCurrentIter; }; 482 ; 483 protected:; 484 ; 485 // ---------- protected accessors -------------------------------------------; 486 ; 487 //TDirectory* LocalTDir() const { return Data().LocalRootDir(); }; 488 ; 489 // weight file name and directory (given by global config variable); 490 void SetWeightFileName( TString );; 491 ; 492 const TString& GetWeightFileDir() const { return fFileDir; }; 493 void SetWeightFileDir( TString fileDir );; 494 ; 495 // are input variables normalised ?; 496 Bool_t IsNormalised() const { return fNormalise; }; 497 void SetNormalised( Bool_t norm ) { fNormalise = norm; }; 498 ; 499 // set number of input variables (only used by MethodCuts, could perhaps be removed); 500 // void SetNvar( Int_t n ) { fNvar = n; }; 501 ; 502 // verbose and help flags; 503 Bool_t Verbose() const { return fVerbose; }; 504 Bool_t Help () const { return fHelp; }; 505 ; 506 // ---------- protected event and tree accessors -----------------------------; 507 ; 508 // names of input variables (if the original names are expressions, they are; 509 // transformed into regexps); 510 const TString& GetInternalVarName( Int_t ivar ) const { return (*fInputVars)[ivar]; }; 511 const TString& GetOriginalVarName( Int_t ivar ) const { return DataInfo().GetVariableInfo(ivar).GetExpression(); }; 512 ; 513 Bool_t HasTrainingTree() const { return Data()->GetNTrainingEvents() != 0; }; 514 ; 515 // ---------- protected auxiliary methods ------------------------------------; 516 ; 517 protected:; 518 ; 519 // make ROOT-independent C++ class for classifier response (classifier-specific implementation); 520 virtual void MakeClassSpecific( std::ostream&, const TString& = """" ) const {}; 521 ; 522 // header and auxili",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:22124,access,accessors,22124,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['access'],['accessors']
Security,"ral but NOT vice-versa; 206 */; 207 template <class M>; 208 SMatrix<T,D1,D2,R>& operator=(const M& rhs);; 209 ; 210 SMatrix<T,D1,D2,R>& operator=(const SMatrix<T,D1,D2,R>& rhs);; 211 ; 212 /**; 213 Assign from a matrix expression; 214 */; 215 template <class A, class R2>; 216 SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs);; 217 ; 218 /**; 219 Assign from an identity matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:7784,access,access,7784,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,2,['access'],"['access', 'accessing']"
Security,"ram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeStamp.AsDouble()"");; 4175/// ~~~; 4176/// In addition, when the object is a type TString or std::string, TTree::Draw; 4177/// will call respectively `TString::Data` and `std::string::c_str()`; 4178///; 4179/// If the object is a TBits, the histogram will contain the index of the bit; 4180/// that are turned on.; 4181///; 4182/// ### Retrieving information about the tree itself.; 4183///; 4184/// You can refer to the tree (or chain) containing the data by using the; 4185/// string 'This'.; 4186/// You can then could any TTree methods. For example:; 4187/// ~~~ {.cpp}; 4188/// tree->Draw(""This->GetReadEntry()"");; 4189/// ~~~; 4190/// will display the local entry numbers be read.; 4191/// ~~~ {.cpp}; 4192/// tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; 4193/// ~~~; 4194/// will display the name of the first 'user info' object.; 4195///; 4196/// ### Special functions and variables; 4197///; 4198/// `Entry$`: A TTree::Draw formula can use the special variable `Entry$`; 4199/// to access the entry number being read. For example to draw every; 4200/// other entry use:; 4201/// ~~~ {.cpp}; 4202/// tree.Draw(""myvar"",""Entry$%2==0"");; 4203/// ~~~; 4204/// - `Entry$` : return the current entry number (`== TTree::GetReadEntry()`); 4205/// - `LocalEntry$` : return the current entry number in the current tree of a; 4206/// chain (`== GetTree()->GetReadEntry()`); 4207/// - `Entries$` : return the total number of entries (== TTree::GetEntries()); 4208/// - `LocalEntries$` : return the total number of entries in the current tree; 4209/// of a chain (== GetTree()->TTree::GetEntries()); 4210/// - `Length$` : return the total number of element of this formula for this; 4211/// entry (`==TTreeFormula::GetNdata()`); 4212/// - `Iteration$` : return the current iteration over this formula for this; 4213/// entry (i.e. varies from 0 to `Length$`).; 4214/// - `Length$(formula )` : return the total number of element of the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:168034,access,access,168034,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"rameters) contains the chi2 distribution of; 991/// the fits.; 992///; 993/// If arr is NULL, the generated histograms are added to the list of objects; 994/// in the current directory. It is the user's responsibility to delete; 995/// these histograms.; 996///; 997/// Example: Assume a 2-d histogram h2; 998/// ~~~ {.cpp}; 999/// Root > h2->FitSlicesX(); produces 4 TH1D histograms; 1000/// with h2_0 containing parameter 0(Constant) for a Gaus fit; 1001/// of each bin in Y projected along X; 1002/// with h2_1 containing parameter 1(Mean) for a gaus fit; 1003/// with h2_2 containing parameter 2(StdDev) for a gaus fit; 1004/// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 1005///; 1006/// Root > h2->FitSlicesX(0,15,22,10);; 1007/// same as above, but only for bins 15 to 22 along Y; 1008/// and only for bins in Y for which the corresponding projection; 1009/// along X has more than cut bins filled.; 1010/// ~~~; 1011/// NOTE: To access the generated histograms in the current directory, do eg:; 1012/// ~~~ {.cpp}; 1013/// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; 1014/// ~~~; 1015 ; 1016void TH2::FitSlicesX(TF1 *f1, Int_t firstybin, Int_t lastybin, Int_t cut, Option_t *option, TObjArray* arr); 1017{; 1018 DoFitSlices(true, f1, firstybin, lastybin, cut, option, arr);; 1019 ; 1020}; 1021 ; 1022 ; 1023////////////////////////////////////////////////////////////////////////////////; 1024/// Project slices along Y in case of a 2-D histogram, then fit each slice; 1025/// with function f1 and make a histogram for each fit parameter; 1026/// Only bins along X between firstxbin and lastxbin are considered.; 1027/// By default (firstxbin == 0, lastxbin == -1), all bins in x including; 1028/// over- and underflows are taken into account.; 1029/// If f1=0, a gaussian is assumed; 1030/// Before invoking this function, one can set a subrange to be fitted along Y; 1031/// via f1->SetRange(ymin,ymax); 1032/// The argument option (default=""QNR"") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:40060,access,access,40060,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['access'],['access']
Security,"ramework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtils;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statistics ;  CTHistImpl;  CTHistImplBaseInterface class for THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistIm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:10997,access,accesses,10997,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accesses']
Security,"rams a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:1745,access,access,1745,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,2,['access'],['access']
Security,"ranch.; Definition at line 661 of file TBranchSTL.cxx. ◆ Streamer(). void TBranchSTL::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TBranch. ◆ StreamerNVirtual(). void TBranchSTL::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 42 of file TBranchSTL.h. Member Data Documentation. ◆ fBranchMap. BranchMap_t TBranchSTL::fBranchMap. private . ! Branch map ; Definition at line 64 of file TBranchSTL.h. ◆ fBranchVector. std::vector<ElementBranchHelper_t> TBranchSTL::fBranchVector. private . ! Branch vector ; Definition at line 65 of file TBranchSTL.h. ◆ fClassName. TString TBranchSTL::fClassName. private . Name of the parent class, if we're the data member. ; Definition at line 72 of file TBranchSTL.h. ◆ fClassVersion. Int_t TBranchSTL::fClassVersion. mutableprivate . Version number of the class. ; Definition at line 73 of file TBranchSTL.h. ◆ fClCheckSum. UInt_t TBranchSTL::fClCheckSum. private . Class checksum. ; Definition at line 74 of file TBranchSTL.h. ◆ fCollProxy. TVirtualCollectionProxy* TBranchSTL::fCollProxy. private . ! Collection proxy ; Definition at line 67 of file TBranchSTL.h. ◆ fContName. TString TBranchSTL::fContName. private . Class name of referenced object. ; Definition at line 71 of file TBranchSTL.h. ◆ fID. Int_t TBranchSTL::fID. private . Element serial number in the streamer info. ; Definition at line 77 of file TBranchSTL.h. ◆ fInd. TIndArray TBranchSTL::fInd. private . ! Indices ; Definition at line 70 of file TBranchSTL.h. ◆ fIndArrayCl. TClass* TBranchSTL::fIndArrayCl. private . ! Class of the ind array ; Definition at line 69 of file TBranchSTL.h. ◆ fInfo. TStreamerInfo* TBranchSTL::fInfo. mutableprivate . ! The streamer info ; Definition at line 75 of file TBranchSTL.h. ◆ fObject. char* TBranchSTL::fObject. private . ! Pointer to object at address or the ; Definition at line 76 of file TBranchSTL.h. ◆ fParent. TBranch* TBranchSTL::fParent. private . ! Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchSTL.html:33183,checksum,checksum,33183,doc/master/classTBranchSTL.html,https://root.cern,https://root.cern/doc/master/classTBranchSTL.html,1,['checksum'],['checksum']
Security,"range, converted to unit cube. ;  ; Double_t V3 (UInt_t ind) const;  V3 from sub-range, converted to unit cube. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGL5DDataSet.html:2758,hash,hash,2758,doc/master/classTGL5DDataSet.html,https://root.cern,https://root.cern/doc/master/classTGL5DDataSet.html,1,['hash'],['hash']
Security,"ransient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:40894,access,access,40894,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,1,['access'],['access']
Security,"ras::GetKerasBackendName ; (; ). Definition at line 832 of file MethodPyKeras.cxx. ◆ GetMulticlassValues(). std::vector< Float_t > & MethodPyKeras::GetMulticlassValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 772 of file MethodPyKeras.cxx. ◆ GetMvaValue(). Double_t MethodPyKeras::GetMvaValue ; (; Double_t * ; errLower, . Double_t * ; errUpper . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 657 of file MethodPyKeras.cxx. ◆ GetMvaValues(). std::vector< Double_t > MethodPyKeras::GetMvaValues ; (; Long64_t ; firstEvt, . Long64_t ; lastEvt, . Bool_t ; logProgress . ). virtual . get all the MVA values for the events of the current Data type ; Implements TMVA::PyMethodBase.; Definition at line 679 of file MethodPyKeras.cxx. ◆ GetNumValidationSamples(). UInt_t TMVA::MethodPyKeras::GetNumValidationSamples ; (; ). private . Validation of the ValidationSize option. ; Allowed formats are 20%, 0.2 and 100 etc.; 20% and 0.2 selects 20% of the training set as validation data.; 100 selects 100 events as the validation data. Returnsnumber of samples in validation set ; Definition at line 111 of file MethodPyKeras.cxx. ◆ GetRegressionValues(). std::vector< Float_t > & MethodPyKeras::GetRegressionValues ; (; ). virtual . Reimplemented from TMVA::MethodBase.; Definition at line 740 of file MethodPyKeras.cxx. ◆ HasAnalysisType(). Bool_t MethodPyKeras::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Implements TMVA::PyMethodBase.; Definition at line 70 of file MethodPyKeras.cxx. ◆ Init(). void MethodPyKeras::Init ; (; void ; ). virtual . Initialization function called from MethodBase::SetupMethod() Note that option string are not yet filled with their values. ; This is done before ProcessOption method or after reading from XML file ; Implements TMVA::PyMethodBase.; Definition at line 414 of file MethodPyKeras.cxx. ◆ InitKeras(). void MethodPyKeras::InitKeras ; (; ). private . Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html:33677,validat,validation,33677,doc/master/classTMVA_1_1MethodPyKeras.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html,1,['validat'],['validation']
Security,"ras@ kPyKerasDefinition Types.h:103; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kDL@ kDLDefinition Types.h:99; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::VecOps::cosRVec< PromoteType< T > > cos(const RVec< T > &v)Definition RVec.hxx:1852; ROOT::VecOps::sinRVec< PromoteType< T > > sin(const RVec< T > &v)Definition RVec.hxx:1851; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA_RNN_ClassificationDefinition TMVA_RNN_Classificati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:77474,access,access,77474,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['access'],['access']
Security,"rately year, month, day, hour, minutes and seconds. Different SQL databases has different treatement of date/time types.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps.; Therefore, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from 'DATE' column in Oracle, one should use GetDatime() method. The only difference of timestamp from date/time, that it has fractional; seconds part. Be aware, that fractional part can has different meaning; (actual value) in different SQL plugins. 5. Binary data. Most of modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; Current implementation supposed, that complete content of the; column must be retrieved at once. Therefore very big data of; gigabytes size may cause a problem. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLStatement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:8431,access,access,8431,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,3,['access'],['access']
Security,"ration ; Definition at line 39 of file TImagePlugin.h. ◆ Hash(). ULong_t TImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TImagePlugin.h:37; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 37 of file TImagePlugin.h. ◆ IsA(). TClass * TImagePlugin::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 39 of file TImagePlugin.h. ◆ ReadFile(). virtual unsigned char * TImagePlugin::ReadFile ; (; const char * ; filename, . UInt_t & ; w, . UInt_t & ; h . ). pure virtual . Implemented in TASImagePlugin. ◆ Streamer(). void TImagePlugin::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePlugin.html:12092,hash,hash,12092,doc/master/classTImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTImagePlugin.html,1,['hash'],['hash']
Security,"ration. ; After releasing it, the parameter can vary freely in the fit. The parameter limits are reset to 0,0. ; Definition at line 3151 of file TF1.cxx. ◆ Save(). void TF1::Save ; (; Double_t ; xmin, . Double_t ; xmax, . Double_t ; ymin, . Double_t ; ymax, . Double_t ; zmin, . Double_t ; zmax . ). virtual . Save values of function in array fSave. ; Reimplemented in TF2, and TF3.; Definition at line 3161 of file TF1.cxx. ◆ SavePrimitive(). void TF1::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save primitive as a C++ statement(s) on output stream out. ; Reimplemented from TObject.; Reimplemented in TF12, TF2, and TF3.; Definition at line 3218 of file TF1.cxx. ◆ SetChisquare(). virtual void TF1::SetChisquare ; (; Double_t ; chi2). inlinevirtual . Definition at line 640 of file TF1.h. ◆ SetCurrent(). void TF1::SetCurrent ; (; TF1 * ; f1). static . Static function setting the current function. ; the current function may be accessed in static C-like functions when fitting or painting a function. ; Definition at line 3343 of file TF1.cxx. ◆ SetFitResult(). void TF1::SetFitResult ; (; const ROOT::Fit::FitResult & ; result, . const Int_t * ; indpar = nullptr . ). virtual . Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed This is useful in the case of a combined fit with different functions, and the FitResult contains the global result By default it is assume that indpar = {0,1,2,....,fNpar-1}. ; Definition at line 3355 of file TF1.cxx. ◆ SetFunction() [1/2]. template<typename Func > . void TF1::SetFunction ; (; Func ; f). Definition at line 888 of file TF1.h. ◆ SetFunction() [2/2]. template<class PtrObj , typename MemFn > . void TF1::SetFunction ; (; PtrObj & ; p, . MemFn ; memFn . ). Definition at line 895 of file TF1.h. ◆ SetMaximum(). void TF1::SetMaximum ; (; Double_t ; maximum = -1111). virtual . Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:108991,access,accessed,108991,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['access'],['accessed']
Security,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheSystem.html:16663,access,access,16663,root/html528/TDCacheSystem.html,https://root.cern,https://root.cern/root/html528/TDCacheSystem.html,11,['access'],['access']
Security,"rator= (const ConfInterval &other);  operator= ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html:9124,hash,hash,9124,doc/master/classRooStats_1_1HypoTestInverterResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html,5,['hash'],['hash']
Security,"rator=(char s); Assign character c to TString. TString& operator=(const char* s); Assign string cs to TString. TString& operator=(const std::string &s); Assign std::string s to TString. TString& operator=(const TString& s); Assignment operator. TString& operator=(const TSubString& s); Assign a TSubString substr to TString. TString& Append(char c, Ssiz_t rep = 1); Append character c rep times to string. Ssiz_t Capacity(Ssiz_t n); Return string capacity. If nc != current capacity Clone() the string; in a string with the desired capacity. int CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; Compare a string to char *cs2. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TString.html:9700,hash,hash,9700,root/html528/TString.html,https://root.cern,https://root.cern/root/html528/TString.html,1,['hash'],['hash']
Security,"raw (Option_t *option="""") override;  Draw detailed class inheritance structure. ;  ; void Dump () const override;  Dump contents of object on stdout. ;  ; void Dump (const void *obj, Bool_t noAddr=kFALSE) const;  Dump contents of object on stdout. ;  ; const void * DynamicCast (const TClass *base, const void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; void * DynamicCast (const TClass *base, void *obj, Bool_t up=kTRUE);  Cast obj of this class type up to baseclass cl if up is true. ;  ; char * EscapeChars (const char *text) const;  Introduce an escape character (@) in front of a special chars. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const char *onfile_classname, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindConversionStreamerInfo (const TClass *onfile_cl, UInt_t checksum) const;  Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ;  ; TVirtualStreamerInfo * FindStreamerInfo (UInt_t checksum, Bool_t isTransient=kFALSE) const;  Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ;  ; TVirtualStreamerInfo * FindStreamerInfoAbstractEmulated (UInt_t checksum) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; void ForceReload (TClass *oldcl);  we found at least one equivalent. ;  ; TClass * GetActualClass (const void *object) const;  Return a pointer to the real class of the object. ;  ; TClass * GetBaseClass (const char *classname);  Return pointer to the base class ""classname"". ;  ; TClass * GetBaseClass (const TClass *base);  Return pointer to the base class ""cl"". ;  ; Int_t GetBaseClassOffset (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:8829,checksum,checksum,8829,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,6,['checksum'],['checksum']
Security,"ray for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimiza",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:9981,access,accessors,9981,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['access'],['accessors']
Security,"ray than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; Entry$ : return the current entry number (TTree::GetReadEntry()); Entries$ : return the total number of entries (TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry; Iteration$: return the current iteration over this formula for this entry (i.e. varies from 0 to Length$). tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");. TRef and TRefArray are automatically deferenced and this shows the value of the fPx of the track referenced by fLastTrack. To access the TRef object itself use the ‘@’ notation (see next example). This auto dereferencing can be extended (via an implementation of TVirtualRefProxy) to any reference type. tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");. Will cast the return value of GetObject() (which happens to be TObject* in this case) before requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘user info’ object:; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");. tree->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:607391,access,access,607391,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:189183,checksum,checksum,189183,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,4,['checksum'],['checksum']
Security,"rbkDELETE; static TS3HTTPRequest::EHTTPVerbkGET; static TS3HTTPRequest::EAuthTypekGoogle; static TS3HTTPRequest::EHTTPVerbkHEAD; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TS3HTTPRequest::EAuthTypekNoAuth; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TS3HTTPRequest::EHTTPVerbkPOST; static TS3HTTPRequest::EHTTPVerbkPUT; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfAccessKeyAccess key (for authentication); TS3HTTPRequest::EAuthTypefAuthTypeAuthentication type; TStringfBucketBucket name; TStringfHostHost name; TStringfObjectKeyObject key; TStringfSecretKeySecret key (for authentication); TStringfTimeStampRequest time stamp; TS3HTTPRequest::EHTTPVerbfVerbHTTP Verb. Class Charts. Inheritance Chart:. TObject. ←; TS3HTTPRequest. Function documentation; TS3HTTPRequest(). TS3HTTPRequest(TS3HTTPRequest::EHTTPVerb httpVerb, const TString& host, const TString& bucket, const TString& objectKey, TS3HTTPRequest::EAuthType authType, const TString& accessKey, const TString& secretKey); Default constructor. TS3HTTPRequest(const TS3HTTPRequest& m); Copy constructor. TString ComputeSignature(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns this request's signature. TString HTTPVerbToTString(TS3HTTPRequest::EHTTPVerb httpVerb) const. TS3HTTPRequest& SetTimeStamp(); Sets this request's time stamp according to:; http://code.google.com/apis/storage/docs/reference-headers.html#date. TString MakeRequestLine(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the first line of a HTTP request for this object. Note ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:8138,authenticat,authentication,8138,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,4,['authenticat'],['authentication']
Security,"rchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton will then be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:176097,access,access,176097,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"rd 'event'. ; Reimplemented from TGEventHandler.; Definition at line 746 of file TGLEventHandler.cxx. ◆ HandleMotion(). Bool_t TGLEventHandler::HandleMotion ; (; Event_t * ; event). overridevirtual . Handle mouse motion 'event'. ; Reimplemented from TGEventHandler.; Definition at line 890 of file TGLEventHandler.cxx. ◆ HandleTimer(). Bool_t TGLEventHandler::HandleTimer ; (; TTimer * ; t). overridevirtual . If mouse delay timer times out emit signal. ; Reimplemented from TObject.; Definition at line 990 of file TGLEventHandler.cxx. ◆ PopupContextMenu(). void TGLEventHandler::PopupContextMenu ; (; TGLPhysicalShape * ; pshp, . Event_t * ; event, . Int_t ; gx, . Int_t ; gy . ). virtual . Popup context menu. ; Definition at line 1063 of file TGLEventHandler.cxx. ◆ RemoveTooltip(). void TGLEventHandler::RemoveTooltip ; (; ). virtual . Hide the tooltip. ; Definition at line 1117 of file TGLEventHandler.cxx. ◆ Repaint(). void TGLEventHandler::Repaint ; (; ). overridevirtual . Handle window expose 'event' - show. ; Reimplemented from TGEventHandler.; Definition at line 1048 of file TGLEventHandler.cxx. ◆ Rotate(). Bool_t TGLEventHandler::Rotate ; (; Int_t ; xDelta, . Int_t ; yDelta, . Bool_t ; mod1, . Bool_t ; mod2 . ). protectedvirtual . Method to handle action TGLViewer::kDragCameraRotate. ; Reimplemented in TEveLegoEventHandler.; Definition at line 980 of file TGLEventHandler.cxx. ◆ SelectForClicked(). void TGLEventHandler::SelectForClicked ; (; Event_t * ; event). protectedvirtual . Run selection (optionally with on secondary selection) and emit corresponding Clicked() signals. ; Protected method. ; Definition at line 127 of file TGLEventHandler.cxx. ◆ SelectForMouseOver(). void TGLEventHandler::SelectForMouseOver ; (; ). protectedvirtual . Run selection (optionally with on secondary selection) and emit corresponding MouseOver() signals. ; Protected method. ; Definition at line 169 of file TGLEventHandler.cxx. ◆ SetArcBall(). void TGLEventHandler::SetArcBall ; (; Bool_t ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEventHandler.html:25403,expose,expose,25403,doc/master/classTGLEventHandler.html,https://root.cern,https://root.cern/doc/master/classTGLEventHandler.html,1,['expose'],['expose']
Security,rd; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCou,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:22786,access,access,22786,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['access'],['access']
Security,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:13303,access,access,13303,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,5,['access'],['access']
Security,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:17634,access,access,17634,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"rdinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12888,access,access,12888,root/html526/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"rding the histogram bin contents.; This function checks if the bins integral exists. If not, the integral; is evaluated, normalized to one.; The integral is automatically recomputed if the number of entries; is not the same then when the integral was computed.; NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise.; If the histogram has a bin with negative content a NaN is returned. Double_t GetBinContent(Int_t bin) const; -*-*-*-*-*Return content of bin number bin. Implemented in TH1C,S,F,D. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful; to access the bin information independently of the dimension. Double_t GetBinContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only; see convention for numbering bins in TH1::GetBin. Double_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return content of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only; see convention for numbering bins in TH1::GetBin. Double_t GetBinWithContent(Double_t c, Int_t& binx, Int_t firstx = 0, Int_t lastx = 0, Double_t maxdiff = 0) const; compute first binx in the range [firstx,lastx] for which; diff = abs(bin_content-c) <= maxdiff; In case several bins in the specified range with diff=0 are found; the first bin found is returned in binx.; In case several bins in the specified range satisfy diff <=maxdiff; the bin with the smallest difference is returned in binx.; In all cases the function returns the smallest difference. NOTE1: if firstx <= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:94131,access,access,94131,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['access'],['access']
Security,"re identified in the folder hierarchy by an “UNIX-like” naming convention. The base of all folders is //root. It is visible at the top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the folder.; Here is an example of a folder’s path name:; //root/Event/Hits/TCP; One does not have to specify the full path name. If the partial path name is unique, it will find it; otherwise it will return the first occurrence of the path.; The first diagram shows a system without folders. The objects have pointers to each other to access each other’s data. Pointers are an efficient way to share data between classes. However, a direct pointer creates a direct coupling between classes. This design can become a very tangled web of dependencies in a system with a large number of classes. In the second diagram, a reference to the data is in the folder and the consumers refer to the folder rather than each other to access the data. The naming and search service provided by the ROOT folders hierarchy provides an alternative. It loosely couples the classes and greatly enhances I/O operations. In this way, folders separate the data from the algorithms and greatly improve the modularity of an application by minimizing the class dependencies. In addition, the folder hierarchy creates a picture of the data organization. This is useful when discussing data design issues or when learning the data organization. The example below illustrates this point.; 10.3 How to Use Folders; Using folders means to build a hierarchy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:419515,access,access,419515,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:85; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html:3277,access,access,3277,doc/v632/TIOFeatures_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html,1,['access'],['access']
Security,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TIOFeatures_8hxx_source.html:3278,access,access,3278,doc/master/TIOFeatures_8hxx_source.html,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html,1,['access'],['access']
Security,"re-allocated */; 18880 thread_index = (int)(conn - ctx->worker_connections);; 18881 if ((thread_index < 0); 18882 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18883 mg_cry_ctx_internal(ctx,; 18884 ""Internal error: Invalid worker index %i"",; 18885 thread_index);; 18886 return;; 18887 }; 18888 ; 18889 /* Request buffers are not pre-allocated. They are private to the; 18890 * request and do not contain any state information that might be; 18891 * of interest to anyone observing a server status. */; 18892 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18893 if (conn->buf == NULL) {; 18894 mg_cry_ctx_internal(; 18895 ctx,; 18896 ""Out of memory: Cannot allocate buffer for worker %i"",; 18897 thread_index);; 18898 return;; 18899 }; 18900 conn->buf_size = (int)ctx->max_request_size;; 18901 ; 18902 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18903 ; 18904 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18905 ; 18906 conn->request_info.user_data = ctx->user_data;; 18907 /* Allocate a mutex for this connection to allow communication both; 18908 * within the request handler and from elsewhere in the application; 18909 */; 18910 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18911 mg_free(conn->buf);; 18912 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18913 return;; 18914 }; 18915 ; 18916#if defined(USE_SERVER_STATS); 18917 conn->conn_state = 1; /* not consumed */; 18918#endif; 18919 ; 18920 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18921 * signal sq_empty condvar to wake up the master waiting in; 18922 * produce_socket() */; 18923 while (consume_socket(ctx, &conn->client, thread_index)) {; 18924 ; 18925 /* New connections must start with new protocol negotiation */; 18926 tls.alpn_proto = NULL;; 18927 ; 18928#if defined(USE_SERVER_STATS); 18929 conn->conn_close_time = 0;; 18930#endif; 18931 conn->conn_birth_time = time(NULL);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:562209,access,access,562209,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"re-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, thread_index)) {; 18925 ; 18926 /* New connections must start with new protocol negotiation */; 18927 tls.alpn_proto = NULL;; 18928 ; 18929#if defined(USE_SERVER_STATS); 18930 conn->conn_close_time = 0;; 18931#endif; 18932 conn->conn_birth_time = time(NULL);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:562242,access,access,562242,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Tue Jun 30 14:37:48 2015 » Last generated: 2015-06-30 14:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeDataStore.html:19611,access,access,19611,root/html602/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html602/RooTreeDataStore.html,1,['access'],['access']
Security,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Tue Mar 10 17:21:02 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:18620,access,access,18620,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,1,['access'],['access']
Security,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Fri Dec 2 14:27:15 2011 » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:18434,access,access,18434,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,1,['access'],['access']
Security,"re_t::PrintTensor(deepNet.GetLayerAt(nlayers-1)->GetOutput(),""output tensor last layer"" );; 1510 ; 1511 deepNet.Backward(my_batch.GetInput(), my_batch.GetOutput(), my_batch.GetWeights());; 1512 ; 1513 if (debugFirstEpoch); 1514 std::cout << ""- doing optimizer update \n"";; 1515 ; 1516 // increment optimizer step that is used in some algorithms (e.g. ADAM); 1517 optimizer->IncrementGlobalStep();; 1518 optimizer->Step();; 1519 ; 1520#ifdef DEBUG; 1521 std::cout << ""minmimizer step - momentum "" << settings.momentum << "" learning rate "" << optimizer->GetLearningRate() << std::endl;; 1522 for (size_t l = 0; l < nlayers; ++l) {; 1523 if (deepNet.GetLayerAt(l)->GetWeights().size() > 0) {; 1524 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightsAt(0),TString::Format(""weights after step layer %d"",l).Data());; 1525 Architecture_t::PrintTensor(deepNet.GetLayerAt(l)->GetWeightGradientsAt(0),""weight gradients"");; 1526 }; 1527 }; 1528#endif; 1529 ; 1530 }; 1531 ; 1532 if (debugFirstEpoch) std::cout << ""\n End batch loop - compute validation loss \n"";; 1533 //}; 1534 debugFirstEpoch = false;; 1535 if ((nTrainEpochs % settings.testInterval) == 0) {; 1536 ; 1537 std::chrono::time_point<std::chrono::system_clock> t1,t2;; 1538 ; 1539 t1 = std::chrono::system_clock::now();; 1540 ; 1541 // Compute validation error.; 1542 ; 1543 ; 1544 Double_t valError = 0.0;; 1545 bool inTraining = false;; 1546 for (auto batch : validationData) {; 1547 auto inputTensor = batch.GetInput();; 1548 auto outputMatrix = batch.GetOutput();; 1549 auto weights = batch.GetWeights();; 1550 // should we apply droput to the loss ??; 1551 valError += deepNet.Loss(inputTensor, outputMatrix, weights, inTraining, includeRegularization);; 1552 }; 1553 // normalize loss to number of batches and add regularization term; 1554 Double_t regTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1555 valError /= (Double_t)(nValidationSamples / settings.batchSize);; 1556 valError += regTerm;; 1557 ; 1558",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:60910,validat,validation,60910,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['validat'],['validation']
Security,"read for the container in %s\n\tThe size read is %d while the maximum is %d\n\tThe size is reset to 0 for this entry (%lld)"", GetName(), n, fMaximum, GetReadEntry());; 4481 n = 0;; 4482 }; 4483 }; 4484 fNdata = n;; 4485 TClonesArray* clones = (TClonesArray*) fObject;; 4486 if (clones->IsZombie()) {; 4487 return;; 4488 }; 4489 // The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; 4490 // setting to zero of the unused slots), so we no longer need to call Clear explicitly; 4491 // clones->Clear();; 4492 clones->ExpandCreateFast(fNdata);; 4493}; 4494 ; 4495////////////////////////////////////////////////////////////////////////////////; 4496/// Read leaves into i/o buffers for this branch.; 4497/// Case of a data member within a TClonesArray (fType == 31).; 4498 ; 4499void TBranchElement::ReadLeavesClonesMember(TBuffer& b); 4500{; 4501 // No need to validate the address here, if we are a member of a split ClonesArray,; 4502 // fID is positive; 4503 // ValidateAddress();; 4504 ; 4505 if (fObject == nullptr); 4506 {; 4507 // We have nowhere to copy the data (probably because the data member was; 4508 // 'dropped' from the current schema) so let's no copy it in a random place.; 4509 return;; 4510 }; 4511 ; 4512 // TClonesArray sub-branch (contains the elements).; 4513 fNdata = fBranchCount->GetNdata();; 4514 TClonesArray* clones = (TClonesArray*) fObject;; 4515 if (clones->IsZombie()) {; 4516 return;; 4517 }; 4518 TStreamerInfo *info = GetInfoImp();; 4519 if (info==nullptr) return;; 4520 // Since info is not null, fReadActionSequence is not null either.; 4521 ; 4522 // Note, we could (possibly) save some more, by configuring the action; 4523 // based on the value of fOnfileObject rather than pushing in on a stack.; 4524 R__PushCache onfileObject(((TBufferFile&)b),fOnfileObject,fNdata);; 4525 ; 4526 char **arr = (char **)clones->GetObjectRef();; 4527 char **end = arr + fNdata;; 4528 b.ApplySequenceVecPtr(*fReadActionSequence,arr,end);; 4529}; 4530 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:166541,validat,validate,166541,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['validat'],['validate']
Security,"ready existing variable ;  ; virtual bool SetVariableValue (unsigned int ivar, double value);  set the value of an already existing variable ;  ; virtual bool SetVariableValues (const double *x);  set the values of all existing variables (array must be dimensioned to the size of the existing parameters) ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  ; virtual int VariableIndex (const std::string &name) const;  get index of variable given a variable given a name return -1 if variable is not found ;  ; virtual std::string VariableName (unsigned int ivar) const;  get name of variables (override if minimizer support storing of variable names) return an empty string if variable is not found ;  ; virtual const double * X () const =0;  return pointer to X values at the minimum ;  . Protected Attributes; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/Minimizer.h>. Inheritance diagram for ROOT::Math::Minimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Minimizer() [1/3]. ROOT::Math::Minimizer::Minimizer ; (; ). inline . Default constructor. ; Definition at line 124 of file Minimizer.h. ◆ ~Minimizer(). virtual ROOT::Math::Minimizer::~Minimizer ; (; ). inlinevirtual . Destructor (no operations). ; Definition at line 127 of file Minimizer.h. ◆ Minimizer() [2/3]. ROOT::Math::Minimizer::Minimizer ; (; Minimizer const & ; ). delete . ◆ Minimizer() [3/3]. ROOT::Math::Minimizer::Minimizer ; (; Minimizer && ; ). delete . Member Function Documentation. ◆ Clear(). virtual void ROOT::Math::Minimizer::Clear ; (; ). inlinevirtual . reset for consecutive minimization - implement if needed ; Reimplemented in ROOT::Math::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:13535,validat,validated,13535,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['validat'],['validated']
Security,"ream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void ToggleEditor ();  ; void ToggleEventStatus ();  ; void ToggleToolBar ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:20200,hash,hash,20200,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['hash'],['hash']
Security,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2010-09-26 20:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:17795,access,access,17795,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,6,['access'],['access']
Security,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDocParser.html:17864,access,access,17864,root/html530/TDocParser.html,https://root.cern,https://root.cern/root/html530/TDocParser.html,6,['access'],['access']
Security,"ream& out); Given fCurrentClass, look for methods in its header file's; class declaration block, and extract documentation to out,; while beautifying the header file in parallel. Bool_t ProcessComment(); Parse the current line as a comment, handling directives and re-formatting; the comment: remove ""/*"", ""*/"", ""//"", similar characters surrounding lines,; etc. Return kFALSE if the line is not a comment. void RemoveCommentContext(Bool_t cxxcomment); remove the top-most comment context that matches cxxcomment,. Bool_t Strip(TString& s); strips ' ', tabs, and newlines from both sides of str. void WriteClassDoc(ostream& out, Bool_t first = kTRUE); Write the class description depending (among others) on fClassDocState. void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, Bool_t isconst, const char* file, TString& anchor, TString& codeOneLiner); Write a method, forwarding to TClassDocOutput. void WriteSourceLine(ostream& out); Write fLineSource to out.; Adjust relative paths first. const TList* GetMethods(TDocParser::EAccess access) const; { return &fMethods[access]; }. TClass* GetCurrentClass() const; { return fCurrentClass; }. TDocOutput* GetDocOutput() const; { return fDocOutput; }. Long_t GetLineNumber() const; { return fLineNumber; }. const TList* GetDataMembers(TDocParser::EAccess access) const; { return &fDataMembers[access]; }. const TList* GetEnums(TDocParser::EAccess access) const; { return &fDataMembers[access+3]; }. const char* GetSourceInfo(TDocParser::ESourceInfo type) const; { return fSourceInfo[type]; }. void SetCurrentModule(const char* module); { fCurrentModule = module; }. » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TDocParser.h 35685 2010-09-23 17:12:07Z axel $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDocParser.html:17864,access,access,17864,root/html532/TDocParser.html,https://root.cern,https://root.cern/root/html532/TDocParser.html,6,['access'],['access']
Security,"reamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TFunction *func);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:6133,hash,hash,6133,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['hash'],['hash']
Security,"reamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4652 // Note: This is done for STL collections; 4653 // Note: fClassVersion could be -1 here (for an emulated class).; 4654 // This is also the code path take for unversioned classes.; 4655 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4656 }; 4657 ; 4658 if (!sinfo) {; 4659 // We just were not able to find a streamer info, we have to make a new one.; 4660 TMmallocDescTemp setreset;; 4661 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4662 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4663 if (gDebug > 0) {; 4664 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:175954,access,access,175954,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"reamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated class, or -2 if the; 4704 // user requested the emulated streamerInfo for an abstract; 4705 // base class, even though we have a dictionary for it.; 4706 ; 4707 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4708 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4709 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4710 version = fClassVersion;; 4711 }; 4712 ; 4713 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4714 ; 4715 if (!sinfo && (version != fClassVersion)) {; 4716 // When the requested version does not exist we return; 4717 // the TVirtualStreamerInfo for the currently loaded class version.; 4718 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4719 // Note: This is done for STL collections; 4720 // Note: fClassVersion could be -1 here (for an emulated class).; 4721 // This is also the code path take for unversioned classes.; 4722 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4723 }; 4724 ; 4725 if (!sinfo) {; 4726 // We just were not able to find a streamer info, we have to make a new one.; 4727 TMmallocDescTemp setreset;; 4728 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4729 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4730 if (gDebug > 0) {; 4731 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:178705,access,access,178705,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"reamerInfo for class cl.Definition TTree.cxx:2652; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualArray::GetObjectAtchar * GetObjectAt(UInt_t ind) constDefinition TVirtualArray.h:41; TVirtualArray::SetSizevoid SetSize(UInt_t size)Definition TVirtualArray.h:43; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionIterators::CreateIteratorsvoid CreateIterators(void *collection, TVirtualCollectionProxy *proxy)Definition TVirtualCollectionIterators.h:65; TVirtualCollectionIterators::fBeginvoid * fBeginDefinition TVirtualCollectionIterators.h:41; TVirtualCollectionIterators::fEndvoid * fEndDefinition TVirtualCollectionIterators.h:42; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:304001,access,access,304001,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['access'],['access']
Security,"reamerInfo; kShort enum valueTVirtualStreamerInfo; kSingleKey enum valueTObject; kSkip enum valueTVirtualStreamerInfo; kSkipL enum valueTVirtualStreamerInfo; kSkipP enum valueTVirtualStreamerInfo; kSTL enum valueTVirtualStreamerInfo; kSTLp enum valueTVirtualStreamerInfo; kSTLstring enum valueTVirtualStreamerInfo; kStreamer enum valueTVirtualStreamerInfo; kStreamLoop enum valueTVirtualStreamerInfo; kTNamed enum valueTVirtualStreamerInfo; kTObject enum valueTVirtualStreamerInfo; kTString enum valueTVirtualStreamerInfo; kUChar enum valueTVirtualStreamerInfo; kUInt enum valueTVirtualStreamerInfo; kULong enum valueTVirtualStreamerInfo; kULong64 enum valueTVirtualStreamerInfo; kUnset enum valueTVirtualStreamerInfo; kUnsupportedConversion enum valueTVirtualStreamerInfo; kUShort enum valueTVirtualStreamerInfo; kWriteDelete enum valueTObject; kZombie enum valueTObject; ls(Option_t *option="""") const overrideTStreamerInfovirtual; MakeZombie()TObjectinlineprotected; MatchLegacyCheckSum(UInt_t checksum) constTStreamerInfo; MayNotUse(const char *method) constTObject; New(void *obj=nullptr) overrideTStreamerInfovirtual; NewArray(Long_t nElements, void *ary=nullptr) overrideTStreamerInfovirtual; NewInfo(TClass *cl) overrideTStreamerInfoinlinevirtual; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TStreamerInfo &)=deleteTStreamerInfoprivate; TVirtualStreamerInfo::operator=(const TVirtualStreamerInfo &)TVirtualStreamerInfoprotected; TNamed::operator=(const TNamed &rhs)TNamed; TObject::operator=(const TObject &rhs)TObjectinline; Optimize(Bool_t opt=kTRUE)TVirtualStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo-members.html:13284,checksum,checksum,13284,doc/master/classTStreamerInfo-members.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo-members.html,1,['checksum'],['checksum']
Security,"reamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  Public Member Functions inherited from TColorGradient;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UInt_t indx) const;  Return alpha parameter of selected color. ;  ; const Double_t * GetColorPositions () const;  Get color positions. ;  ; const Double_t * GetColors () const;  Get colors. ;  ; ECoordinateMode GetCoordinateMode () const;  Get coordinate mode. ;  ; SizeType_t GetNumberOfSteps () const;  Get number of steps. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Color_t *colorIndices);  Reset color. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Double_t *colorIndices);  Reset color. ;  ; void SetColorAlpha (UInt_t indx, Double_t alpha);  Change alpha parameter of the color. ;  ; void SetCoordinateMode (ECoordinateMode mode);  Set coordinate mode. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TColor;  TColor ();  Default constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearGradient.html:1724,validat,validate,1724,doc/master/classTLinearGradient.html,https://root.cern,https://root.cern/doc/master/classTLinearGradient.html,2,['validat'],['validate']
Security,"reamers; }. 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; to user project and compile them. TXmlFile class implementation can be taken; from http://www-linux.gsi.de/~linev/xmlfile.tar.gz. TXMLPlayer class generates one function per class, which called class streamer.; Name of such function for class TExample will be TExample_streamer. Following data members for streamed classes are supported:; - simple data types (int, double, float); - array of simple types (int[5], double[5][6]); - dynamic array of simple types (int* with comment field // [fSize]); - const char*; - object of any nonROOT class; - pointer on object; - array of objects; - array of pointers on objects; - stl string; - stl vector, list, deque, set, multiset, map, multimap; - allowed arguments for stl containers are: simple data types, string, object, pointer on object; Any other data member can not be (yet) read from xml file and write to xml file. If data member of class is private or protected, it can not be accessed via; member name. Two alternative way is supported. First, if for class member fValue; exists function GetValue(), it will be used to get value from the class, and if; exists SetValue(), it will be used to set apropriate data member. Names of setter; and getter methods can be specified in comments filed like:. int fValue; // *OPTION={GetMethod=""GetV"";SetMethod=""SetV""}. If getter or setter methods does not available, address to data member will be; calculated as predefined offeset to object start address. In that case generated code; should be used only on the same platform (OS + compiler), where it was generated. Generated streamers resolve inheritance tree for given class. This allows to have; array (or vector) of object pointers on some basic class, while objects of derived; class(es) are used. To access data from xml files, user should use TXmlFile class, which is different from; ROOT TXMLFile, but provides very similar functionality. For example, to read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLPlayer.html:2221,access,accessed,2221,root/html528/TXMLPlayer.html,https://root.cern,https://root.cern/root/html528/TXMLPlayer.html,6,['access'],['accessed']
Security,"reating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionAppli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:156215,validat,validation,156215,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['validat'],['validation']
Security,"rebinning.; 326 ; 327 ; 328\anchor filling-histograms; 329## Filling histograms; 330 ; 331 A histogram is typically filled with statements like:; 332~~~ {.cpp}; 333 h1->Fill(x);; 334 h1->Fill(x, w); //fill with weight; 335 h2->Fill(x, y); 336 h2->Fill(x, y, w); 337 h3->Fill(x, y, z); 338 h3->Fill(x, y, z, w); 339~~~; 340 or via one of the Fill functions accepting names described above.; 341 The Fill functions compute the bin number corresponding to the given; 342 x, y or z argument and increment this bin by the given weight.; 343 The Fill functions return the bin number for 1-D histograms or global; 344 bin number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 350 To access the bin content of a given bin, do:; 351~~~ {.cpp}; 352 Double_t binContent = h->GetBinContent(bin);; 353~~~; 354 ; 355 By default, the bin number is computed using the current axis ranges.; 356 If the automatic binning option has been set via; 357~~~ {.cpp}; 358 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:15357,access,access,15357,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['access'],['access']
Security,recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRootSniffer Sniffer of ROOT objects; TRootSnifferScanRec Scan record for objects sniffer; TRootSnifferStore structure for results store of objects sniffer; TRootSnifferStoreJson json results store of objects sniffer; TRootSnifferStoreXml xml results store of objects sniffer; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TS3HTTPRequest Create generic HTTP request for Amazon S3 and Google Storage services; TS3WebFile Read a ROOT file from a S3 server; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class; TSQLColumnData Single SQL column data.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:122914,authenticat,authentication,122914,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['authenticat'],['authentication']
Security,"rectives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THostAuth.html:9968,authenticat,authentication,9968,root/html528/THostAuth.html,https://root.cern,https://root.cern/root/html528/THostAuth.html,6,['authenticat'],['authentication']
Security,"rectory for storing the libraries produced by ACLiC is set by:; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; The additional include directives for ACLiC compilations are set by:; ACLiC.IncludePaths: -I/where/the/includes/are; 28.6.7 PROOF Related Variables; PROOF debug options.; Proof.DebugLevel: 0; Proof.DebugMask:-1; PROOF GDB hooks allows a debugger to be attached early in the startup phase of proofserv:0 - don’t wait; 1 - master proofserv enters wait loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1264217,access,access,1264217,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ree A wrapper class supporting Hbook ntuples (CWN and RWN); THelix A Helix drawn as a PolyLine3D; THilbertMatrixT<double> Template of Hilbert Matrix class; THilbertMatrixT<float> Template of Hilbert Matrix class; THilbertMatrixTSym<double> Template of Symmetric Hilbert Matrix class; THilbertMatrixTSym<float> Template of Symmetric Hilbert Matrix class; THistPainter Helper class to draw histograms; THnSparse Interfaces of sparse n-dimensional histogram; THnSparseArrayChunk chunks of linearized bins; THnSparseT<TArrayC> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayD> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayF> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:90039,authenticat,authentication,90039,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,5,['authenticat'],['authentication']
Security,"ree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooSetProxy_cacheObsVariables to be cached; Bool_t_cacheSourceKeep an attached clone of the source in the cache for fast operation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:36084,access,access,36084,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,2,['access'],['access']
Security,"ref. void OrtoNorm3(); Orto-norm columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& ); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.9, Double_t high = 1.1) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrans.html:16300,access,access,16300,root/html534/TEveTrans.html,https://root.cern,https://root.cern/root/html534/TEveTrans.html,1,['access'],['access']
Security,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:4876,checksum,checksum,4876,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,1,['checksum'],['checksum']
Security,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMD5.html:4876,checksum,checksum,4876,root/html530/TMD5.html,https://root.cern,https://root.cern/root/html530/TMD5.html,1,['checksum'],['checksum']
Security,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMD5.html:4876,checksum,checksum,4876,root/html532/TMD5.html,https://root.cern,https://root.cern/root/html532/TMD5.html,1,['checksum'],['checksum']
Security,"remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:455973,access,access,455973,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:456006,access,access,456006,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"rence Guide ; .  . Loading...; Searching...; No Matches. Files ; Net tutorialsTutorials. ; Examples showing the net classes. . Files; file  authclient.C;  This macro should be run together with authserv.C to test authentication between two remote ROOT sessions. ;  ; file  authserv.C;  This macro should be run together with authclient.C to test authentication between two remote ROOT sessions. ;  ; file  fastMergeServer.C;  This script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block. ;  ; file  hclient.C;  Client program which creates and fills a histogram. ;  ; file  hcons.C;  Histogram consumer script. ;  ; file  hprod.C;  Histogram producer script. ;  ; file  hserv.C;  Server program which waits for two clients to connect. ;  ; file  hserv2.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  parallelMergeServer.C;  This script shows how to make a simple iterative server that can accept connections while handling currently open connections. ;  ; file  parallelMergeTest.C;  ; file  pclient.C;  Client program to test parallel sockets. ;  ; file  pserv.C;  Server program to test parallel sockets. ;  ; file  spy.C;  Client program which allows the snooping of objects from a spyserv process. ;  ; file  spyserv.C;  Server program which allows clients, ""spies"", to connect and snoop objects. ;  ; file  TestAuth.C;  Macro test authentication methods stand alone. ;  ; file  testTUDPSocket.C;  As test echo server use udpserver.c in the same directory. ;  ; file  treeClient.C;  Client program which creates and fills 2 histograms and a TTree. ;  ; file  TUriTest.C;  Rudimentary TUri test macro. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__net.html:1669,authenticat,authentication,1669,doc/master/group__tutorial__net.html,https://root.cern,https://root.cern/doc/master/group__tutorial__net.html,1,['authenticat'],['authentication']
Security,"rence Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:1402,access,access,1402,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,1,['access'],['access']
Security,"rence. ; This class stores a (key,value) pair using an external hash. ; The (key,value) are Long64_t's and therefore can contain object pointers or any longs. The map uses an open addressing hashing method (linear probing). ; Definition at line 33 of file TExMap.h. Classes; struct  Assoc_t;  . Public Member Functions;  TExMap (const TExMap &map);  Copy constructor. ;  ;  TExMap (Int_t mapSize=100);  Create a TExMap. ;  ;  ~TExMap ();  Delete TExMap. ;  ; void Add (Long64_t key, Long64_t value);  ; void Add (ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. The key should be unique. ;  ; void AddAt (UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value);  Add an (key,value) pair to the table. ;  ; Int_t Capacity () const;  ; void Delete (Option_t *opt="""") override;  Delete all entries stored in the TExMap. ;  ; void Expand (Int_t newsize);  Expand the TExMap. ;  ; Int_t GetSize () const;  ; Long64_t GetValue (Long64_t key);  ; Long64_t GetValue (ULong64_t hash, Long64_t key);  Return the value belonging to specified key and hash value. ;  ; Long64_t GetValue (ULong64_t hash, Long64_t key, UInt_t &slot);  Return the value belonging to specified key and hash value. ;  ; TClass * IsA () const override;  ; Long64_t & operator() (Long64_t key);  ; Long64_t & operator() (ULong64_t hash, Long64_t key);  Return a reference to the value belonging to the key with the specified hash value. ;  ; TExMap & operator= (const TExMap &);  Assignment operator. ;  ; void Remove (Long64_t key);  ; void Remove (ULong64_t hash, Long64_t key);  Remove entry with specified key from the TExMap. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:1317,hash,hash,1317,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,2,['hash'],['hash']
Security,"renceCutOrientation = cutOrientation; }. void SetMethodDir(TDirectory* methodDir); { fBaseDir = fMethodBaseDir = methodDir; }. void SetBaseDir(TDirectory* methodDir); { fBaseDir = methodDir; }. void SetMethodBaseDir(TDirectory* methodDir); { fMethodBaseDir = methodDir; }. UInt_t GetTrainingTMVAVersionCode() const; the TMVA version can be obtained and checked using; if (GetTrainingTMVAVersionCode()>TMVA_VERSION(3,7,2)) {...}; or; if (GetTrainingROOTVersionCode()>ROOT_VERSION(5,15,5)) {...}. { return fTMVATrainingVersion; }. UInt_t GetTrainingROOTVersionCode() const; { return fROOTTrainingVersion; }. TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true). const TransformationHandler& GetTransformationHandler(Bool_t takeReroutedIfAvailable = true) const. void RerouteTransformationHandler(TMVA::TransformationHandler* fTargetTransformation); { fTransformationPointer=fTargetTransformation; }. DataSetInfo& DataInfo() const; ---------- event accessors ------------------------------------------------; returns reference to data set. { return fDataSetInfo; }. UInt_t GetNEvents() const; event reference and update. { return Data()->GetNEvents(); }. Bool_t HasMVAPdfs() const; { return fHasMVAPdfs; }. void SetAnalysisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:34549,access,accessors,34549,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,2,['access'],['accessors']
Security,"renced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TColorGradient::ECoordinateModekObjectBoundingMode; static TObject::(anonymous)TObject::kOverwrite; static TColorGradient::ECoordinateModekPadMode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. vector<Double_t>fColorPositions; vector<Double_t>fColorsRGBA values.; TColorGradient::ECoordinateModefCoordinateMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. void ResetColor(UInt_t nPoints, const Double_t* points, const Color_t* colorIndices). void ResetColor(UInt_t nPoints, const Double_t* points, const Double_t* colorIndices). void SetCoordinateMode(TColorGradient::ECoordinateMode mode). const Double_t * GetColorPositions() const. const Double_t * GetColors() const. void RegisterColor(Color_t colorIndex). TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). ECoordinateMode GetCoordinateMode() const. SizeType_t GetNumberOfSteps() const. » Last ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColorGradient.html:10732,validat,validate,10732,root/html602/TColorGradient.html,https://root.cern,https://root.cern/root/html602/TColorGradient.html,2,['validat'],['validate']
Security,"rent object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170973,access,access,170973,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['access'],['access']
Security,"rent object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173161,access,access,173161,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['access'],['access']
Security,replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury infor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:115270,authenticat,authentication,115270,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['authenticat'],['authentication']
Security,"required key is the ""samples"" (at least one sample is needed) and the; 1463required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1464sample in the ""metadata"" key.; 1465 ; 1466A simple example for the formatting of the specification in the JSON file is the following:; 1467 ; 1468~~~{.cpp}; 1469{; 1470 ""samples"": {; 1471 ""sampleA"": {; 1472 ""trees"": [""tree1"", ""tree2""],; 1473 ""files"": [""file1.root"", ""file2.root""],; 1474 ""metadata"": {; 1475 ""lumi"": 10000.0, ; 1476 ""xsec"": 1.0,; 1477 ""sample_category"" = ""data""; 1478 }; 1479 },; 1480 ""sampleB"": {; 1481 ""trees"": [""tree3"", ""tree4""],; 1482 ""files"": [""file3.root"", ""file4.root""],; 1483 ""metadata"": {; 1484 ""lumi"": 0.5, ; 1485 ""xsec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1504~~~; 1505 ; 1506or directly the filename:; 1507 ; 1508~~~{.python}; 1509df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1510~~~; 1511 ; 1512An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1513provides a corresponding exemplary JSON file for the dataset specification.; 1514 ; 1515\anchor progressbar; 1516### Adding a progress bar ; 1517 ; 1518A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1519The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1520and an estimated remaining time (per",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:84821,access,access,84821,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"required key is the ""samples"" (at least one sample is needed) and the; 1503required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; 1504sample in the ""metadata"" key.; 1505 ; 1506A simple example for the formatting of the specification in the JSON file is the following:; 1507 ; 1508~~~{.cpp}; 1509{; 1510 ""samples"": {; 1511 ""sampleA"": {; 1512 ""trees"": [""tree1"", ""tree2""],; 1513 ""files"": [""file1.root"", ""file2.root""],; 1514 ""metadata"": {; 1515 ""lumi"": 10000.0, ; 1516 ""xsec"": 1.0,; 1517 ""sample_category"" = ""data""; 1518 }; 1519 },; 1520 ""sampleB"": {; 1521 ""trees"": [""tree3"", ""tree4""],; 1522 ""files"": [""file3.root"", ""file4.root""],; 1523 ""metadata"": {; 1524 ""lumi"": 0.5, ; 1525 ""xsec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1544~~~; 1545 ; 1546or directly the filename:; 1547 ; 1548~~~{.python}; 1549df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1550~~~; 1551 ; 1552An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1553provides a corresponding exemplary JSON file for the dataset specification.; 1554 ; 1555\anchor progressbar; 1556### Adding a progress bar ; 1557 ; 1558A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1559The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1560and an estimated remaining time (per",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:86501,access,access,86501,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:340001,access,access,340001,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:340034,access,access,340034,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully initialized.; 162 kIndexedFriendNoMatch, ///< A friend with TTreeIndex doesn't have an entry for this index; 163 kMissingBranchWhenSwitchingTree, ///< A branch was not found when switching to the next TTree in the chain; 164 kEntryUnknownError ///< LoadTree return less than -6, likely a 'newer' error code.; 165 };; 166 ; 167 enum ELoadTreeStatus {; 168 kNoTree = 0, ///< default state, no TTree is connected (formerly 'Zombie' state); 169 kLoadTreeNone, ///<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:5311,access,accessing,5311,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['access'],['accessing']
Security,"returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:453810,access,access,453810,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:453843,access,access,453843,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returning the method index (which can be used to find; the method in GetAuthMethod()). Returns -1 in case meth is not found. char * PromptUser(const char* remote); Static method to prompt for the user name to be used for authentication; to rootd or proofd. User is asked to type user name.; Returns user name (which must be deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns default user. char * PromptPasswd(const char* prompt = ""Password: ""); Static method to prompt for the user's passwd to be used for; authentication to rootd or proofd. Uses non-echoing command line; to get passwd. Returns passwd (which must de deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns -1. GlobusAuth_t GetGlobusAuthHook(); Static method returning the globus authorization hook. const char * GetRSAPubExport(Int_t key = 0); Static method returning the RSA public keys. Int_t GetRSAInit(); Static method returning the RSA initialization flag. void SetDefaultRSAKeyType(Int_t key); Static method setting the default type of RSA key. void SetRSAInit(Int_t init = 1); Static method setting RSA initialization flag. TList * GetAuthInfo(); Static method returning the list with authentication details. TList * GetProofAuthInfo(); Static method returning the list with authentication directives; to be sent to proof. void AuthError(const char* where, Int_t error); Print error string depending on error code. void SetGlobalUser(const char* user); Set global user name to be used for authentication to rootd or proofd. void SetGlobalPasswd(const char* passwd); Set global passwd to be used for authentication to rootd or proofd. void SetGlobalPwHash(Bool_t pwhash); Set global passwd hash flag to be used for authentication to rootd or proofd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:14595,authoriz,authorization,14595,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authoriz'],['authorization']
Security,"rg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSpHarmonic.html:34310,access,access,34310,root/html534/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html534/RooSpHarmonic.html,1,['access'],['access']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsAnaConvPdf::forceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:13407,hash,hash,13407,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,18,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsCachedPdf::forceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:13327,hash,hash,13327,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,12,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:12891,hash,hash,12891,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,131,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:13263,hash,hash,13263,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,34,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooSimultaneous::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:13337,hash,hash,13337,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,3,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& arg) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); const RooArgList&funcList() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:13368,hash,hash,13368,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,3,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:13412,hash,hash,13412,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,7,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:15010,hash,hash,15010,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExtendPdf.html:13351,hash,hash,13351,root/html534/RooExtendPdf.html,https://root.cern,https://root.cern/root/html534/RooExtendPdf.html,6,['hash'],['hash']
Security,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype, const RooArgSet* auxProto, Bool_t verbose) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:12998,hash,hash,12998,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,3,['hash'],['hash']
Security,"rg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; The following named arguments are supported. SplitParam(varname, catname) -- Split parameter(s) with given name(s) in category(s) with given names; SplitParam(var, cat) -- Split given parameter(s) in givem category(s); SplitParamConstrained(vname, cname, remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; SplitParamConstrained(var,cat,remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; Restrict(catName,stateNameList) -- Restrict build by only considered listed state names of category with given name. RooSimultaneous* build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; Use the provided BuildConfig or MultiBuildConfig object to configure the build. RooSimultaneous* executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); Internal build driver from validation ObjBuildConfig. std::string makeSplitName(const RooArgSet& splitCatSet); Construct name of composite split. RooSimWSTool(RooWorkspace& ws); Constructors, assignment etc. ObjBuildConfig* validateConfig(RooSimWSTool::BuildConfig& bc). » Last changed: Tue Jun 30 14:35:47 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimWSTool.html:13623,validat,validation,13623,root/html602/RooSimWSTool.html,https://root.cern,https://root.cern/root/html602/RooSimWSTool.html,2,['validat'],"['validateConfig', 'validation']"
Security,"rg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; The following named arguments are supported. SplitParam(varname, catname) -- Split parameter(s) with given name(s) in category(s) with given names; SplitParam(var, cat) -- Split given parameter(s) in givem category(s); SplitParamConstrained(vname, cname, remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; SplitParamConstrained(var,cat,remainder) -- Make constrained split in parameter(s) with given name(s) in category(s) with given names; putting remainder fraction formula in state with name ""remainder""; Restrict(catName,stateNameList) -- Restrict build by only considered listed state names of category with given name. RooSimultaneous* build(const char* simPdfName, RooSimWSTool::BuildConfig& bc, Bool_t verbose = kTRUE); Build a RooSimultaneous p.d.f with name simPdfName from cloning specializations of protytpe p.d.f protoPdfName.; Use the provided BuildConfig or MultiBuildConfig object to configure the build. RooSimultaneous* executeBuild(const char* simPdfName, RooSimWSTool::ObjBuildConfig& obc, Bool_t verbose = kTRUE); Internal build driver from validation ObjBuildConfig. std::string makeSplitName(const RooArgSet& splitCatSet); Construct name of composite split. RooSimWSTool(RooWorkspace& ws); Constructors, assignment etc. ObjBuildConfig* validateConfig(RooSimWSTool::BuildConfig& bc). » Last changed: Tue Mar 10 17:19:09 2015 » Last generated: 2015-03-10 17:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool.html:12617,validat,validation,12617,root/html534/RooSimWSTool.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool.html,2,['validat'],"['validateConfig', 'validation']"
Security,"riable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::CleanCompiledMacrosvirtual void CleanCompiledMacros()Remove the shared libs produced by the CompileMacro() function, together with their rootmaps,...Definition TSystem.cxx:4369; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:167949,access,access,167949,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['access'],['access']
Security,"rials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run the executable by typing root at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.; Here is a short description of the most relevant libraries, the ones marked with a * are only installed when the options specified them. libAsImage is the image manipulation library; libCling is the C++ interpreter (Cling); libCore is the Base classes; libEG is the abstract event generator interface classes; *libEGPythia is the Pythia5 event generator interface; *libEGPythia6 is the Pythia6 event generator interface; libFitPanel contains the GUI used for fitting; libGed contains the GUI used for editing the properties of histograms, graphs, etc.; libGeom is the geometry package (with builder and painter); libGpad is the pad and canvas classes which depend on low level graphics; libGraf is the 2D graphics primitives (can be us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:17633,access,access,17633,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTFnPdfBinding.html:39875,access,access,39875,root/html534/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html,1,['access'],['access']
Security,"ributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TObjArray.h; TVirtualCollectionProxy.h; TVirtualStreamerInfo.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TStreamerBasicTypeDefinition TStreamerElement.h:269; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfo::TCompInfoDefinition TStreamerInfo.h:41; TStreamerInfo::TCompInfo::TCompInfoTCompInfo()Definition TStreamerInfo.h:57; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:20094,access,accessing,20094,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['access'],['accessing']
Security,"ride;  Print the name of the proxy on ostream. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:9175,hash,hash,9175,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['hash'],['hash']
Security,"ride;  Print title of formula. ;  ; void printValue (std::ostream &os) const override;  Print value of formula. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormula.html:4863,hash,hash,4863,doc/master/classRooFormula.html,https://root.cern,https://root.cern/doc/master/classRooFormula.html,1,['hash'],['hash']
Security,"ride;  Stream an object of class RooFitResult. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:7569,hash,hash,7569,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['hash'],['hash']
Security,"riginal PyROOT code by Wim Lavrijsen, LBL; 3//; 4// /*************************************************************************; 5// * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6// * All rights reserved. *; 7// * *; 8// * For the licensing terms see $ROOTSYS/LICENSE. *; 9// * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10// *************************************************************************/; 11 ; 12// Bindings; 13// CPyCppyy.h must be go first, since it includes Python.h, which must be; 14// included before any standard header; 15#include ""CPyCppyy/API.h""; 16#include ""TPython.h""; 17#include ""TPyClassGenerator.h""; 18 ; 19// ROOT; 20#include ""TROOT.h""; 21#include ""TClassRef.h""; 22#include ""TObject.h""; 23 ; 24#include <Riostream.h>; 25 ; 26// Standard; 27#include <mutex>; 28#include <sstream>; 29#include <stdio.h>; 30#include <string>; 31 ; 32/// \class TPython; 33/// Accessing the Python interpreter from C++.; 34///; 35/// The TPython class allows for access to python objects from Cling. The current; 36/// functionality is only basic: ROOT objects and builtin types can freely cross; 37/// the boundary between the two interpreters, python objects can be instantiated; 38/// and their methods can be called. All other cross-coding is based on strings; 39/// that are run on the python interpreter.; 40///; 41/// Examples:; 42///; 43/// ~~~{.cpp}; 44/// $ root -l; 45/// // Execute a string of python code.; 46/// root [0] TPython::Exec( ""print('Hello World!')"" );; 47/// Hello World!; 48///; 49/// // Create a TNamed on the python side, and transfer it back and forth.; 50/// root [1] std::any res1;; 51/// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; 52/// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; 53/// root [4] std::any res2;; 54/// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; 55/// root [6] (&std::any_cast<TNamed&>(res1) == std::a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:1235,access,access,1235,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['access'],['access']
Security,"rimental::RNTupleReader::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleReader.hxx:90; ROOT::Experimental::RNTupleReader::fDisplayReaderstd::unique_ptr< RNTupleReader > fDisplayReaderWe use a dedicated on-demand reader for Show() and Scan().Definition RNTupleReader.hxx:83; ROOT::Experimental::RNTupleReader::EnableMetricsvoid EnableMetrics()Enable performance measurements (decompression time, bytes read from storage, etc....Definition RNTupleReader.hxx:364; ROOT::Experimental::RNTupleReader::GetMetricsconst Detail::RNTupleMetrics & GetMetrics() constDefinition RNTupleReader.hxx:365; ROOT::Experimental::RNTupleReader::beginRIterator begin()Definition RNTupleReader.hxx:342; ROOT::Experimental::RNTupleReader::~RNTupleReader~RNTupleReader(); ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(DescriptorId_t fieldId, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:295; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName)Provides access to an individual field that can contain either a scalar value or a collection,...Definition RNTupleReader.hxx:269; ROOT::Experimental::RNTupleReader::GetViewRNTupleView< T > GetView(std::string_view fieldName, std::shared_ptr< T > objPtr)Definition RNTupleReader.hxx:275; ROOT::Experimental::RNTupleReader::GetDescriptorconst RNTupleDescriptor & GetDescriptor()Returns a cached copy of the page source descriptor.Definition RNTupleReader.cxx:230; ROOT::Experimental::RNTupleReader::GetNEntriesNTupleSize_t GetNEntries() constDefinition RNTupleReader.hxx:175; ROOT::Experimental::RNTupleReader::fCachedDescriptorstd::unique_ptr< RNTupleDescriptor > fCachedDescriptorThe ntuple descriptor in the page source is protected by a read-write lock.Definition RNTupleReader.hxx:89; ROOT::Experimental::RNTupleReader::OpenFriendsstatic std::unique_ptr< RNTupleReader > OpenFriends(std::span< RNTupleOpenSpec > ntuples, const RNTupleReadOptions &options=RNTupleReadOptions())Open RNTuples as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:22021,access,access,22021,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['access'],['access']
Security,"rimer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome About ROOT. ROOT is a framework for data processing, born at CERN, at the heart of the research on high-energy physics. Every day, thousands of physicists use ROOT applications to analyze their data or to perform simulations. With ROOT you can:. Save data You can save your data (and any C++ object) in a compressed binary form in a ROOT file. The object format is also saved in the same file: the ROOT files are self-descriptive. Even in the case the source files describing the data model are not available, the information contained in a ROOT file is be always readable. ROOT provides a data structure, the tree, that is extremely powerful for fast access of huge amounts of data - orders of magnitude faster than accessing a normal file.; Access data Data saved into one or several ROOT files can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Clin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:2497,access,access,2497,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,2,['access'],"['access', 'accessing']"
Security,"rimitive(ostream& out, Option_t* option = """"); voidTEveElement::SaveVizParams(ostream& out, const TString& tag, const TString& var); virtual voidTEveElement::SelectElement(Bool_t state); voidSetAutoLighting(Bool_t isOn); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTEveElement::SetCompound(TEveCompound* c); voidTEveElement::SetCSCBits(UChar_t f); voidTEveElement::SetDestroyOnZeroRefCnt(Bool_t d); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTEveElement::SetEditMainColor(Bool_t x); voidTEveElement::SetEditMainTransparency(Bool_t x); virtual voidTEveElement::SetElementName(const char* name); virtual voidTEveElement::SetElementNameTitle(const char* name, const char* title); virtual voidTEveElement::SetElementTitle(const char* title); voidSetExtrude(Float_t x); voidSetFontFile(Int_t file); voidSetFontFile(const char* name); voidSetFontMode(Int_t mode); voidSetFontSize(Int_t size, Bool_t validate = kTRUE); voidSetLighting(Bool_t isOn); voidTEveElement::SetMainAlpha(Float_t alpha); virtual voidTEveElement::SetMainColor(Color_t color); voidTEveElement::SetMainColorPixel(Pixel_t pixel); voidTEveElement::SetMainColorPtr(Color_t* color); voidTEveElement::SetMainColorRGB(UChar_t r, UChar_t g, UChar_t b); voidTEveElement::SetMainColorRGB(Float_t r, Float_t g, Float_t b); virtual voidTEveElement::SetMainTransparency(Char_t t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTEveElement::SetPickable(Bool_t p); voidSetPolygonOffset(Float_t factor, Float_t units); virtual Bool_tTEveElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetText(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveText.html:13123,validat,validate,13123,root/html530/TEveText.html,https://root.cern,https://root.cern/root/html530/TEveText.html,2,['validat'],['validate']
Security,"rimitive(ostream& out, Option_t* option = """"); voidTEveElement::SaveVizParams(ostream& out, const TString& tag, const TString& var); virtual voidTEveElement::SelectElement(Bool_t state); voidSetAutoLighting(Bool_t isOn); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTEveElement::SetCompound(TEveCompound* c); voidTEveElement::SetCSCBits(UChar_t f); voidTEveElement::SetDestroyOnZeroRefCnt(Bool_t d); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTEveElement::SetEditMainColor(Bool_t x); voidTEveElement::SetEditMainTransparency(Bool_t x); virtual voidTEveElement::SetElementName(const char* name); virtual voidTEveElement::SetElementNameTitle(const char* name, const char* title); virtual voidTEveElement::SetElementTitle(const char* title); voidSetExtrude(Float_t x); voidSetFontFile(Int_t file); voidSetFontFile(const char* name); voidSetFontMode(Int_t mode); voidSetFontSize(Int_t size, Bool_t validate = kTRUE); voidSetLighting(Bool_t isOn); voidTEveElement::SetMainAlpha(Float_t alpha); virtual voidTEveElement::SetMainColor(Color_t color); voidTEveElement::SetMainColorPixel(Pixel_t pixel); voidTEveElement::SetMainColorPtr(Color_t* color); voidTEveElement::SetMainColorRGB(UChar_t r, UChar_t g, UChar_t b); voidTEveElement::SetMainColorRGB(Float_t r, Float_t g, Float_t b); virtual voidTEveElement::SetMainTransparency(Char_t t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTEveElement::SetPickable(Bool_t p); voidTEveElement::SetPickableRecursively(Bool_t p); voidSetPolygonOffset(Float_t factor, Float_t units); virtual Bool_tTEveElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveText.html:13123,validat,validate,13123,root/html534/TEveText.html,https://root.cern,https://root.cern/root/html534/TEveText.html,3,['validat'],['validate']
Security,"ring fDimensions;; 26 public:; 27 TSources(const char *name = nullptr, const char *title = nullptr, const char *dims = nullptr) : TNamed(name,title), fDimensions(dims) {}; 28 const char *GetDimensions() { return fDimensions; }; 29 ; 30 ClassDefOverride(TSources,2);; 31 };; 32 ; 33 typedef enum; 34 {; 35 kReadRule = 0,; 36 kReadRawRule = 1,; 37 kNone = 99999; 38 } RuleType_t;; 39 ; 40 typedef void (*ReadFuncPtr_t)( char*, TVirtualObject* );; 41 typedef void (*ReadRawFuncPtr_t)( char*, TBuffer&);; 42 ; 43 TSchemaRule();; 44 virtual ~TSchemaRule();; 45 ; 46 TSchemaRule( const TSchemaRule& rhs );; 47 TSchemaRule& operator = ( const TSchemaRule& rhs );; 48 Bool_t operator == ( const TSchemaRule& rhs ) const;; 49 ; 50 ; 51 void Clear(Option_t * /*option*/ ="""") override;; 52 Bool_t SetFromRule( const char *rule );; 53 ; 54 const char *GetVersion( ) const;; 55 Bool_t SetVersion( const TString& version );; 56 Bool_t TestVersion( Int_t version ) const;; 57 Bool_t SetChecksum( const TString& checksum );; 58 Bool_t TestChecksum( UInt_t checksum ) const;; 59 void SetSourceClass( const TString& classname );; 60 const char *GetSourceClass() const;; 61 void SetTargetClass( const TString& classname );; 62 const char *GetTargetClass() const;; 63 void SetTarget( const TString& target );; 64 const TObjArray* GetTarget() const;; 65 const char *GetTargetString() const;; 66 void SetSource( const TString& source );; 67 const TObjArray* GetSource() const;; 68 void SetEmbed( Bool_t embed );; 69 Bool_t GetEmbed() const;; 70 Bool_t IsAliasRule() const;; 71 Bool_t IsRenameRule() const;; 72 Bool_t IsValid() const;; 73 void SetCode( const TString& code );; 74 const char *GetCode() const;; 75 void SetAttributes( const TString& attributes );; 76 const char *GetAttributes() const;; 77 Bool_t HasTarget( const TString& target ) const;; 78 ; 79 Bool_t HasSource( const TString& source ) const;; 80 void SetReadFunctionPointer( ReadFuncPtr_t ptr );; 81 ReadFuncPtr_t GetReadFunctionPointer() const;; 82 void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8h_source.html:1618,checksum,checksum,1618,doc/master/TSchemaRule_8h_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8h_source.html,1,['checksum'],['checksum']
Security,"ring theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategoryClass for categorizing the phase space.Definition MethodCategory.h:58; TMVA::MethodCategory::AddMethodTMVA::IMethod * AddMethod(const TCut &, const TString &theVariables, Types::EMVA theMethod, const TString &theTitle, const TString &theOptions)adds sub-classifier for a categoryDefinition MethodCategory.cxx:138; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TMVA::TMVAGuivoid TMVAGui(const char *fName=""TMVA.root"", TString dataset=""""); Factory.h; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategory.C. tutorialstmvaTMVAClassificationCategory.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:37752,access,access,37752,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,2,['access'],['access']
Security,"ring>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; MINIMIZER*_minimizer! Internal minuit instance; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:33842,access,access,33842,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,1,['access'],['access']
Security,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:40652,access,access,40652,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,2,['access'],['access']
Security,"rint (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:15889,access,access,15889,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,3,['access'],['access']
Security,"rint (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:8279,access,access,8279,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['access'],['access']
Security,"rint a stack trace. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual int Symlink (const char *from, const char *to);  Create a symbolic link from file1 to file2. ;  ; virtual void Syslog (ELogLevel level, const char *mess);  Send mess to syslog daemon. ;  ; virtual const char * TempDirectory () const;  Return a user configured or systemwide directory to create temporary files in. ;  ; virtual FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr);  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; virtual int Umask (Int_t mask);  Set the process file creation mode mask. ;  ; virtual const char * UnixPathName (const char *unixpathname);  Convert from a local pathname to a Unix pathname. ;  ; virtual void Unload (const char *module);  Unload a shared library. ;  ; virtual void Unsetenv (const char *name);  Unset environment variable. ;  ; virtual int Utime (const char *file, Long_t modtime, Long_t actime);  Set the a files modification and access times. ;  ; virtual char * Which (const char *search, const char *file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual const char * WorkingDirectory ();  Return working directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:19299,access,access,19299,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,1,['access'],['access']
Security,"rint summary of query. ;  ; void WorkerActivity ();  Measure the worker activity. ;  ; Bool_t WrkInfoOK () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis.html:3854,hash,hash,3854,doc/master/classTProofPerfAnalysis.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis.html,1,['hash'],['hash']
Security,"riteBufferInt_t WriteBuffer(TBuffer &b, char *pointer, Int_t first)General Write.Definition TStreamerInfoWriteBuffer.cxx:863; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::WriteBufferAuxInt_t WriteBufferAux(TBuffer &b, const T &arr, TCompInfo *const *const compinfo, Int_t first, Int_t last, Int_t narr, Int_t eoffset, Int_t mode)The object at pointer is serialized to the buffer b if (arrayMode & 1) ptr is a pointer to array of p...Definition TStreamerInfoWriteBuffer.cxx:114; TStreamerInfo::WriteBufferSTLPtrsInt_t WriteBufferSTLPtrs(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t first, Int_t eoffset)Write for STL container.Definition TStreamerInfoWriteBuffer.cxx:850; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetWriteMemberWiseActionsvirtual TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions()=0; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::GetFunctionDeleteTwoIteratorsvirtual DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read=kTRUE)=0; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:46259,access,access,46259,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['access'],['access']
Security,"riteDelete; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name); Return the object with given name from the table. TObject* find(const TObject* hashArg); Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by method chosen in constructor. » Last changed: Mon Dec 7 13:47:56 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHashTable.html:7044,hash,hash,7044,root/html526/RooHashTable.html,https://root.cern,https://root.cern/root/html526/RooHashTable.html,5,['hash'],"['hash', 'hashArg']"
Security,"rited from TGeoBoolNode; enum  EGeoBoolType { kGeoUnion; , kGeoIntersection; , kGeoSubtraction; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBoolNode; void AssignPoints (Int_t npoints, Double_t *points);  Set fPoints array. ;  ; Bool_t MakeBranch (const char *expr, Bool_t left);  Mutex for thread data access. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBoolNode; TGeoShape * fLeft {nullptr};  ; TGeoMatrix * fLeftMat {nullptr};  ; std::mutex fMutex;  Size for the navigation data array. ;  ; Int_t fNpoints {0};  ; Double_t * fPoints {nullptr};  number of points on the mesh ;  ; TGeoShape * fRight {nullptr};  ; TGeoMatrix * fRightMat {nullptr};  ; std::vector< ThreadData_t * > fThreadData;  array of mesh points ;  ; Int_t fThreadSize {0};  Navigation data per thread. ;  . #include <TGeoBoolNode.h>. Inheritance diagram for TGeoIntersection:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoIntersection() [1/3]. TGeoIntersection::TGeoIntersection ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:13147,access,access,13147,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['access'],['access']
Security,"rited from TGeoBoolNode; enum  EGeoBoolType { kGeoUnion; , kGeoIntersection; , kGeoSubtraction; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBoolNode; void AssignPoints (Int_t npoints, Double_t *points);  Set fPoints array. ;  ; Bool_t MakeBranch (const char *expr, Bool_t left);  Mutex for thread data access. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBoolNode; TGeoShape * fLeft {nullptr};  ; TGeoMatrix * fLeftMat {nullptr};  ; std::mutex fMutex;  Size for the navigation data array. ;  ; Int_t fNpoints {0};  ; Double_t * fPoints {nullptr};  number of points on the mesh ;  ; TGeoShape * fRight {nullptr};  ; TGeoMatrix * fRightMat {nullptr};  ; std::vector< ThreadData_t * > fThreadData;  array of mesh points ;  ; Int_t fThreadSize {0};  Navigation data per thread. ;  . #include <TGeoBoolNode.h>. Inheritance diagram for TGeoSubtraction:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoSubtraction() [1/3]. TGeoSubtraction::TGeoSubtraction ; (; ). De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSubtraction.html:13138,access,access,13138,doc/master/classTGeoSubtraction.html,https://root.cern,https://root.cern/doc/master/classTGeoSubtraction.html,1,['access'],['access']
Security,"rited from TGeoBoolNode; enum  EGeoBoolType { kGeoUnion; , kGeoIntersection; , kGeoSubtraction; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBoolNode; void AssignPoints (Int_t npoints, Double_t *points);  Set fPoints array. ;  ; Bool_t MakeBranch (const char *expr, Bool_t left);  Mutex for thread data access. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBoolNode; TGeoShape * fLeft {nullptr};  ; TGeoMatrix * fLeftMat {nullptr};  ; std::mutex fMutex;  Size for the navigation data array. ;  ; Int_t fNpoints {0};  ; Double_t * fPoints {nullptr};  number of points on the mesh ;  ; TGeoShape * fRight {nullptr};  ; TGeoMatrix * fRightMat {nullptr};  ; std::vector< ThreadData_t * > fThreadData;  array of mesh points ;  ; Int_t fThreadSize {0};  Navigation data per thread. ;  . #include <TGeoBoolNode.h>. Inheritance diagram for TGeoUnion:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoUnion() [1/3]. TGeoUnion::TGeoUnion ; (; ). Default constructor. ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:13089,access,access,13089,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['access'],['access']
Security,rked/selected ;  ; Bool_t fIsMarking;  true if in marking mode ;  ; Bool_t fIsSaved;  true is content is saved ;  ; TGLongPosition fMarkedEnd;  end position of marked text ;  ; Bool_t fMarkedFromX;  true if text is marked from x ;  ; Bool_t fMarkedFromY;  true if text is marker from y ;  ; TGLongPosition fMarkedStart;  start position of marked text ;  ; Int_t fMaxAscent;  maximum ascent in font ;  ; Int_t fMaxDescent;  maximum descent in font ;  ; Int_t fMaxWidth;  maximum width of character in font ;  ; TGGC fNormGC;  graphics context for drawing text ;  ; Bool_t fReadOnly;  text cannot be edited ;  ; TViewTimer * fScrollTimer;  scrollbar timer ;  ; TGGC fSelbackGC;  graphics context for drawing marked background ;  ; TGGC fSelGC;  graphics context for drawing marked text ;  ; TGText * fText;  text buffer ;  ;  Protected Attributes inherited from TGView; TGViewFrame * fCanvas;  frame containing the text ;  ; Atom_t fClipboard;  clipboard property ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TGHScrollBar * fHsb;  horizontal scrollbar ;  ; TGLongPosition fMousePos;  position of mouse ;  ; Int_t fScrolling;  scrolling direction ;  ; TGLongPosition fScrollVal;  scroll value ;  ; TGDimension fVirtualSize;  the current virtual window size ;  ; TGLongPosition fVisible;  position of visible region ;  ; TGVScrollBar * fVsb;  vertical scrollbar ;  ; TGGC fWhiteGC;  graphics context used for scrolling generates GraphicsExposure events ;  ; UInt_t fXMargin;  x margin ;  ; UInt_t fYMargin;  y margin ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDND,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:42489,expose,exposed,42489,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,3,['expose'],['exposed']
Security,"rmation.; 16189 * In order to make wolfSSL work, it is split in two files.; 16190 * One file that contains key and certificate used by the server and; 16191 * an optional chain file for the ssl stack.; 16192 */; 16193 if (chain) {; 16194 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16195 mg_cry_ctx_internal(phys_ctx,; 16196 ""%s: cannot use certificate chain file %s: %s"",; 16197 __func__,; 16198 chain,; 16199 ssl_error());; 16200 return 0;; 16201 }; 16202 }; 16203 return 1;; 16204}; 16205 ; 16206 ; 16207#if defined(OPENSSL_API_1_1); 16208static unsigned long; 16209ssl_get_protocol(int version_id); 16210{; 16211 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16212 if (version_id > 0); 16213 ret |= SSL_OP_NO_SSLv2;; 16214 if (version_id > 1); 16215 ret |= SSL_OP_NO_SSLv3;; 16216 if (version_id > 2); 16217 ret |= SSL_OP_NO_TLSv1;; 16218 if (version_id > 3); 16219 ret |= SSL_OP_NO_TLSv1_1;; 16220 if (version_id > 4); 16221 ret |= SSL_OP_NO_TLSv1_2;; 16222#if defined(SSL_OP_NO_TLSv1_3); 16223 if (version_id > 5); 16224 ret |= SSL_OP_NO_TLSv1_3;; 16225#endif; 16226 return ret;; 16227}; 16228#else; 16229static long; 16230ssl_get_protocol(int version_id); 16231{; 16232 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16233 if (version_id > 0); 16234 ret |= SSL_OP_NO_SSLv2;; 16235 if (version_id > 1); 16236 ret |= SSL_OP_NO_SSLv3;; 16237 if (version_id > 2); 16238 ret |= SSL_OP_NO_TLSv1;; 16239 if (version_id > 3); 16240 ret |= SSL_OP_NO_TLSv1_1;; 16241 if (version_id > 4); 16242 ret |= SSL_OP_NO_TLSv1_2;; 16243#if defined(SSL_OP_NO_TLSv1_3); 16244 if (version_id > 5); 16245 ret |= SSL_OP_NO_TLSv1_3;; 16246#endif; 16247 return (long)ret;; 16248}; 16249#endif /* OPENSSL_API_1_1 */; 16250 ; 16251 ; 16252/* SSL callback documentation:; 16253 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16254 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16255 * https://linux.die.net/man/3/ssl_set_info_callback */; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:478401,certificate,certificate,478401,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,"rmation.; 16190 * In order to make wolfSSL work, it is split in two files.; 16191 * One file that contains key and certificate used by the server and; 16192 * an optional chain file for the ssl stack.; 16193 */; 16194 if (chain) {; 16195 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16196 mg_cry_ctx_internal(phys_ctx,; 16197 ""%s: cannot use certificate chain file %s: %s"",; 16198 __func__,; 16199 chain,; 16200 ssl_error());; 16201 return 0;; 16202 }; 16203 }; 16204 return 1;; 16205}; 16206 ; 16207 ; 16208#if defined(OPENSSL_API_1_1); 16209static unsigned long; 16210ssl_get_protocol(int version_id); 16211{; 16212 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16213 if (version_id > 0); 16214 ret |= SSL_OP_NO_SSLv2;; 16215 if (version_id > 1); 16216 ret |= SSL_OP_NO_SSLv3;; 16217 if (version_id > 2); 16218 ret |= SSL_OP_NO_TLSv1;; 16219 if (version_id > 3); 16220 ret |= SSL_OP_NO_TLSv1_1;; 16221 if (version_id > 4); 16222 ret |= SSL_OP_NO_TLSv1_2;; 16223#if defined(SSL_OP_NO_TLSv1_3); 16224 if (version_id > 5); 16225 ret |= SSL_OP_NO_TLSv1_3;; 16226#endif; 16227 return ret;; 16228}; 16229#else; 16230static long; 16231ssl_get_protocol(int version_id); 16232{; 16233 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16234 if (version_id > 0); 16235 ret |= SSL_OP_NO_SSLv2;; 16236 if (version_id > 1); 16237 ret |= SSL_OP_NO_SSLv3;; 16238 if (version_id > 2); 16239 ret |= SSL_OP_NO_TLSv1;; 16240 if (version_id > 3); 16241 ret |= SSL_OP_NO_TLSv1_1;; 16242 if (version_id > 4); 16243 ret |= SSL_OP_NO_TLSv1_2;; 16244#if defined(SSL_OP_NO_TLSv1_3); 16245 if (version_id > 5); 16246 ret |= SSL_OP_NO_TLSv1_3;; 16247#endif; 16248 return (long)ret;; 16249}; 16250#endif /* OPENSSL_API_1_1 */; 16251 ; 16252 ; 16253/* SSL callback documentation:; 16254 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16255 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16256 * https://linux.die.net/man/3/ssl_set_info_callback */; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:478434,certificate,certificate,478434,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:12455,access,access,12455,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,12,['access'],['access']
Security,"rms when the flag OpenGL.CanvasPreferGL is set to 1 in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; Alternatively, you can call at the top of your script gSytle->SetCanvasPreferGL();. Or if you prefer to activate GL for a single canvas c, then use c->SetSupportGL(true);. Line Width; The line width is expressed in pixel units. The line width of any class inheriting from TAttLine can be changed using the method SetLineWidth and retrieved using the method GetLineWidth. The following picture shows the line widths from 1 to 10 pixels. Line Style; Line styles are identified via integer numbers. The line style of any class inheriting from TAttLine can be changed using the method SetLineStyle and retrieved using the method GetLineStyle.; The first 10 line styles are predefined as shown on the following picture:. Some line styles can be accessed via the following enum:; kSolid = 1; kDashed = 2; kDotted = 3; kDashDotted = 4; kDashed@ kDashedDefinition TAttLine.h:48; kSolid@ kSolidDefinition TAttLine.h:48; kDashDotted@ kDashDottedDefinition TAttLine.h:48; kDotted@ kDottedDefinition TAttLine.h:48; Additional line styles can be defined using TStyle::SetLineStyleString. For example the line style number 11 can be defined as follow: gStyle->SetLineStyleString(11,""400 200"");; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TStyle::SetLineStyleStringvoid SetLineStyleString(Int_t i, const char *text)Set line style string using the PostScript convention.Definition TStyle.cxx:1483; Existing line styles (1 to 10) can be redefined using the same method. ; Definition at line 18 of file TAttLine.h. Public Member Functions;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttLine.html:2206,access,accessed,2206,doc/master/classTAttLine.html,https://root.cern,https://root.cern/doc/master/classTAttLine.html,1,['access'],['accessed']
Security,"rn *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(Scalar[] dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13045,access,access,13045,root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,2,['access'],['access']
Security,"rn 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bool_t RemoveDataSet(const char* group, const char* user, const char* dsName); Removes the indicated dataset. Bool_t ExistsDataSet(const char* group, const char* user, const char* dsName);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:16700,checksum,checksum,16700,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['checksum'],['checksum']
Security,"rn request result for specified objid from normal classtable. ;  ; TSQLResult * GetNormalClassDataAll (Long64_t minobjid, Long64_t maxobjid, TSQLClassInfo *sqlinfo);  Return data for several objects from the range from normal class table. ;  ; InfoListRet GetStreamerInfoListImpl (bool) final;  Read back streamer infos from database List of streamer infos is always stored with key:id 0, which is not shown in normal keys list. ;  ; Bool_t HasTable (const char *name);  Test if table name exists. ;  ; void IncrementModifyCounter ();  Update value of modify counter in config table Modify counter used to indicate that something was changed in database. ;  ; void InitSqlDatabase (Bool_t create);  initialize sql database and correspondent structures identical to TFile::Init() function ;  ; Int_t IsLongStringCode (Long64_t objid, const char *value);  Checks if this is long string code returns 0, if not or string id. ;  ; Bool_t IsReadAccess ();  dummy, in future should check about read access to database ;  ; Bool_t IsTablesExists ();  Checks if main keys table is existing. ;  ; Bool_t IsWriteAccess ();  Checkis, if lock is free in configuration tables. ;  ; Bool_t ProduceClassSelectQuery (TVirtualStreamerInfo *info, TSQLClassInfo *sqlinfo, TString &columns, TString &tables, Int_t &tablecnt);  used by MakeClassSelectQuery method to add columns from table of class, specified by TVirtualStreamerInfo structure ;  ; Bool_t ReadConfigurations ();  read table configurations as special table ;  ; TObject * ReadSpecialObject (Long64_t keyid, TObject *obj=nullptr);  Read data of special kind of objects. ;  ; void ReadSQLClassInfos ();  Read all class infos from IdsTable. ;  ; TSQLClassInfo * RequestSQLClassInfo (const char *clname, Int_t version);  Search in database tables for specified class and return TSQLClassInfo object. ;  ; TSQLClassInfo * RequestSQLClassInfo (const TClass *cl);  Search in database tables for specified class and return TSQLClassInfo object. ;  ; void SaveToData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:44124,access,access,44124,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"rn the set of overloads for this name, collecting all available ones.; Can construct and insert new TFunction-s. TList* GetListForObject(const TObject* obj) const; Return the set of overloads for function obj, collecting all available ones.; Can construct and insert new TFunction-s. TFunction * Find(TListOfFunctions::DeclId_t id) const; Return the TMethod or TFunction describing the function corresponding; to the Decl 'id'. Return NULL if not found. TFunction * Get(TListOfFunctions::DeclId_t id); Return (after creating it if necessary) the TMethod or TFunction; describing the function corresponding to the Decl 'id'. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the functions known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TFunction* func); Mark 'func' as being unloaded.; After the unload, the function can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TObject* FindObject(const TObject* obj) const. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfFunctions.html:14538,hash,hash,14538,root/html604/TListOfFunctions.html,https://root.cern,https://root.cern/root/html604/TListOfFunctions.html,2,['hash'],['hash']
Security,"rn the set of the schema rules if any. ; If create is true, create an empty set ; Definition at line 1941 of file TClass.cxx. ◆ GetSharedLibs(). const char * TClass::GetSharedLibs ; (; ). Get the list of shared libraries containing the code for class cls. ; The first library in the list is the one containing the class, the others are the libraries the first one depends on. Returns 0 in case the library is not found. ; Definition at line 3623 of file TClass.cxx. ◆ GetShowMembersWrapper(). ShowMembersFunc_t TClass::GetShowMembersWrapper ; (; ); const. inline . Definition at line 487 of file TClass.h. ◆ GetState(). EState TClass::GetState ; (; ); const. inline . Definition at line 488 of file TClass.h. ◆ GetStreamer(). TClassStreamer * TClass::GetStreamer ; (; ); const. Return the Streamer Class allowing streaming (if any). ; Definition at line 2914 of file TClass.cxx. ◆ GetStreamerFunc(). ClassStreamerFunc_t TClass::GetStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom streamer (member function). ; Definition at line 2939 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4599 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:91198,access,accessor,91198,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessor']
Security,"rn the set of the schema rules if any. ; If create is true, create an empty set ; Definition at line 2008 of file TClass.cxx. ◆ GetSharedLibs(). const char * TClass::GetSharedLibs ; (; ). Get the list of shared libraries containing the code for class cls. ; The first library in the list is the one containing the class, the others are the libraries the first one depends on. Returns 0 in case the library is not found. ; Definition at line 3690 of file TClass.cxx. ◆ GetShowMembersWrapper(). ShowMembersFunc_t TClass::GetShowMembersWrapper ; (; ); const. inline . Definition at line 487 of file TClass.h. ◆ GetState(). EState TClass::GetState ; (; ); const. inline . Definition at line 488 of file TClass.h. ◆ GetStreamer(). TClassStreamer * TClass::GetStreamer ; (; ); const. Return the Streamer Class allowing streaming (if any). ; Definition at line 2981 of file TClass.cxx. ◆ GetStreamerFunc(). ClassStreamerFunc_t TClass::GetStreamerFunc ; (; ); const. Get a wrapper/accessor function around this class custom streamer (member function). ; Definition at line 3006 of file TClass.cxx. ◆ GetStreamerInfo(). TVirtualStreamerInfo * TClass::GetStreamerInfo ; (; Int_t ; version = 0, . Bool_t ; isTransient = kFALSE . ); const. returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ; Note: There are two special version numbers: - 0: Use the class version from the currently loaded class library.; - -1: Assume no class library loaded (emulated class).; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4666 of file TClass.cxx. ◆ GetStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::GetStreamerInfoAbstractEmulated ; (; Int_t ; version = 0); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:91199,access,accessor,91199,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessor']
Security,"rn true;; 101 }; 102 if (lhs.fReader->GetTree()->GetEntriesFast() == 0 && lhs.fEntry == 0 && !IsValid()) {; 103 return true;; 104 }; 105 return fEntry == lhs.fEntry;; 106 }; 107 ; 108 /// Compare two iterators for inequality.; 109 bool operator!=(const Iterator_t& lhs) const {; 110 return !(*this == lhs);; 111 }; 112 ; 113 /// Increment the iterator (postfix i++).; 114 Iterator_t operator++(int) {; 115 Iterator_t ret = *this;; 116 this->operator++();; 117 return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:4653,access,access,4653,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['access'],['access']
Security,"rn what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPython.html:1816,access,access,1816,root/html528/TPython.html,https://root.cern,https://root.cern/root/html528/TPython.html,1,['access'],['access']
Security,"rn-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample ; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees ; Double_tfErrorFractionntuple var: misclassification error fraction ; vector<Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions"" ; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodDT.html:19328,validat,validation,19328,root/html534/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodDT.html,1,['validat'],['validation']
Security,"rn-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfMinNodeEventsmin number of events in node; Float_tfMinNodeSizemin percentage of training events in node; TStringfMinNodeSizeSstring containing min percentage of training events in node; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostaincient variable, only needed for ""CompatibilityOptions""; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsfUseNvars is used as a poisson mean, and the actual value of useNvars is at each step drawn form that distribution; Bool_tfUseYesNoLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodDT.html:20488,validat,validation,20488,root/html602/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodDT.html,2,['validat'],['validation']
Security,"rnal parameters (after minimization). ~MnUserParameterState(); {}. MnUserParameterState(const MnUserParameterState& state); {}. MnUserParameterState& operator=(const ROOT::Minuit2::MnUserParameterState& state). const MnGlobalCorrelationCoeff& GlobalCC() const; {return fGlobalCC;}. MnUserCovariance Hessian() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html:5719,access,access,5719,root/html530/ROOT__Minuit2__MnUserParameterState.html,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html,1,['access'],['access']
Security,"rned. ; Definition at line 202 of file TGPicture.cxx. ◆ GetPicture() [4/4]. const TGPicture * TGPicturePool::GetPicture ; (; const char * ; name, . UInt_t ; new_width, . UInt_t ; new_height . ). Get picture with specified size from pool (picture will be scaled if necessary). ; Picture must be freed using TGPicturePool::FreePicture(). If picture is not found 0 is returned. ; Definition at line 138 of file TGPicture.cxx. ◆ IsA(). TClass * TGPicturePool::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 113 of file TGPicture.h. ◆ operator=(). TGPicturePool & TGPicturePool::operator= ; (; const TGPicturePool & ; pp). protected . assignment operator ; Definition at line 67 of file TGPicture.cxx. ◆ Print(). void TGPicturePool::Print ; (; Option_t * ; option = """"); const. overridevirtual . List all pictures in the pool. ; Reimplemented from TObject.; Definition at line 307 of file TGPicture.cxx. ◆ Streamer(). void TGPicturePool::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGPicturePool::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 113 of file TGPicture.h. Member Data Documentation. ◆ fClient. const TGClient* TGPicturePool::fClient. protected . client for which we keep icon pool ; Definition at line 92 of file TGPicture.h. ◆ fPath. TString TGPicturePool::fPath. protected . icon search path ; Definition at line 93 of file TGPicture.h. ◆ fPicList. THashTable* TGPicturePool::fPicList. protected . hash table containing the icons ; Definition at line 94 of file TGPicture.h. Libraries for TGPicturePool:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGPicture.h; gui/gui/src/TGPicture.cxx. TGPicturePool. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGPicturePool.html:14943,hash,hash,14943,doc/master/classTGPicturePool.html,https://root.cern,https://root.cern/doc/master/classTGPicturePool.html,1,['hash'],['hash']
Security,"rns 0 in case gc is not found. ;  ; TGGC * FindGC (GContext_t gc);  Find graphics context based on its GContext_t handle. ;  ; void FreeGC (const TGGC *gc);  Delete graphics context if it is not used anymore. ;  ; void FreeGC (GContext_t gc);  Delete graphics context if it is not used anymore. ;  ; TGGC * GetGC (GContext_t gct);  returns graphics context based on its GContext_t handle. ;  ; TGGC * GetGC (GCValues_t *values, Bool_t rw=kFALSE);  Get the best matching graphics context depending on values. ;  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  List all graphics contexts in the pool. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGGCPool.html:1631,hash,hash,1631,doc/master/classTGGCPool.html,https://root.cern,https://root.cern/doc/master/classTGGCPool.html,1,['hash'],['hash']
Security,"rns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:29176,access,access,29176,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['access'],['access']
Security,"rnsName of the file containing the class declaration ; Definition at line 105 of file TS3WebFile.h. ◆ GetAccessKey(). const TString & TS3WebFile::GetAccessKey ; (; ); const. inline . Definition at line 96 of file TS3WebFile.h. ◆ GetBucket(). const TString & TS3WebFile::GetBucket ; (; ); const. inline . Definition at line 98 of file TS3WebFile.h. ◆ GetCredentialsFromEnv(). Bool_t TS3WebFile::GetCredentialsFromEnv ; (; const char * ; accessKeyEnv, . const char * ; secretKeyEnv, . const char * ; tokenEnv, . TString & ; outAccessKey, . TString & ; outSecretKey, . TString & ; outToken . ). private . Sets the access and secret keys from the environmental variables, if they are both set. ; Sets the security session token if it is given. ; Definition at line 366 of file TS3WebFile.cxx. ◆ GetHead(). Int_t TS3WebFile::GetHead ; (; ). overrideprotectedvirtual . Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this file. ; Uses TS3HTTPRequest to generate an HTTP HEAD request which includes the authorization header expected by the S3 server. ; Reimplemented from TWebFile.; Definition at line 287 of file TS3WebFile.cxx. ◆ GetObjectKey(). const TString & TS3WebFile::GetObjectKey ; (; ); const. inline . Definition at line 99 of file TS3WebFile.h. ◆ GetSecretKey(). const TString & TS3WebFile::GetSecretKey ; (; ); const. inline . Definition at line 97 of file TS3WebFile.h. ◆ GetUrl(). const TUrl & TS3WebFile::GetUrl ; (; ); const. inline . Definition at line 100 of file TS3WebFile.h. ◆ IsA(). TClass * TS3WebFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFile.; Definition at line 105 of file TS3WebFile.h. ◆ ParseOptions(). Bool_t TS3WebFile::ParseOptions ; (; Option_t * ; options, . TString & ; accessKey, . TString & ; secretKey, . TString & ; token . ). private . Extracts the S3 authentication key pair (access key and secret key) from the options. ; The authentication credentials can be specified in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:53076,authoriz,authorization,53076,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['authoriz'],['authorization']
Security,"ro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveUtil.html:3363,access,access,3363,root/html528/TEveUtil.html,https://root.cern,https://root.cern/root/html528/TEveUtil.html,4,['access'],['access']
Security,"roduce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); Example to fill a symmetric matrix from an std::vector:; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; 13.13.2.2 Accessing and Setting Methods; The matrix elements can be set using the operator()(irow,icol), where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. Furthermore, all the matrix elements can be set also by using the SetElements function passing a generic iterator. The elements can be accessed by the same methods as well as by using the function ROOT::Math::SMatrix::apply. The apply(i) has exactly the same behavior for general and symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMatrix object in a matrix. If the size of the sub-vector or sub-matrix is larger than the matrix size a static assert (a compilation error) is pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:757861,access,access,757861,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"rofileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Mon Jul 4 15:23:44 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:35417,validat,validateAbsMin,35417,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"rofileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Thu Nov 3 20:09:01 2011 » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:35796,validat,validateAbsMin,35796,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"rols precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCollection.html:19967,hash,hash,19967,root/html532/RooAbsCollection.html,https://root.cern,https://root.cern/root/html532/RooAbsCollection.html,1,['hash'],['hash']
Security,"rols precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCollection.html:19956,hash,hash,19956,root/html534/RooAbsCollection.html,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html,3,['hash'],['hash']
Security,"rom TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(void* obj, TMemberInspector& insp, Int_t isATObject = -1) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; ionterpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:22384,access,access,22384,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['access'],['access']
Security,"rom TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(void* obj, TMemberInspector& insp, char* parent, Int_t isATObject = -1) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the same 'dictionary'.; This effectively creates a hard alias for the class name. void CopyCollectionProxy(const TVirtualCollectionProxy& ); Copy the argument. void Draw(Option_t* option = """"); Draw detailed class inheritance structure.; If a class B inherits from a class A, the description of B is drawn; on the right side of the description of A.; Member functions overridden by B are shown in cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:19362,access,access,19362,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['access'],['access']
Security,"rom the SQL server for an object.; TSQLObjectDataPool XML object keeper class ; TSQLObjectInfo Info (classname, version) about object in database ; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore Counting semaphore class; TSeqCollection Sequenceable collection ABC; TServerSocket This class implements server sockets; TSessionDescription Session description; TSessionFrame Session frame; TSessionInputFrame Input frame; TSessionLogView PROOF progress dialog; TSessionOutputFrame Output frame; TSessionQueryFrame Query frame; TSessionServerFrame Server frame; TSessionViewer Session Viewer; TShape Basic shape; TSignalHandler Signal event handler; TSlave PROOF slave server; TSlaveInfo basic info on workers; TSlaveLite PROOF lite worker server; TSlider A user interface slider.; TSliderBox The moving box of a TSlider; TSocket This class implements client sockets; TSortedList A sorted list; TSpectrum Peak Finder, background estimator, Deconvolution; TSpectrum2 Peak Finder, background estimator, Deconvolution for 2-D histograms; TSpectrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:123400,authenticat,authentication,123400,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['authenticat'],['authentication']
Security,"rom, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:9558,access,accessors,9558,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['access'],['accessors']
Security,"ron;  Small helper to save proxy environment in the event of recursive calls. More...;  ; struct  EnvironBase;  ; class  Insert;  Small helper to encapsulate all necessary data accesses for containers like set, multiset etc. More...;  ; class  Iterators;  Small helper to implement the function to create,access and destroy iterators. More...;  ; struct  Iterators< Cont_t, true >;  ; struct  Iterators< std::vector< T >, false >;  ; class  IteratorValue;  Small helper to encapsulate whether to return the value pointed to by the iterator or its address. More...;  ; struct  IteratorValue< Cont_t, value_ptr * >;  ; class  MapInsert;  Small helper to encapsulate all necessary data accesses for containers like set, multiset etc. More...;  ; struct  PairHolder;  ; class  Pushback;  Small helper to encapsulate all necessary data accesses for containers like vector, list, deque. More...;  ; struct  Pushback< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Pushback< std::vector< Bool_t, A > >;  ; class  Pushfront;  Small helper to encapsulate all necessary data accesses for containers like forward_list. More...;  ; struct  SfinaeHelper;  ; class  Type;  Small helper to encapsulate basic data accesses for all STL continers. More...;  ; struct  Type< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Type< std::vector< Bool_t, A > >;  . Public Member Functions;  TCollectionProxyInfo (const std::type_info &info, size_t iter_size, size_t value_diff, int value_offset, void *(*size_func)(void *), void(*resize_func)(void *, size_t), void *(*clear_func)(void *), void *(*first_func)(void *), void *(*next_func)(void *), void *(*construct_func)(void *, size_t), void(*destruct_func)(void *, size_t), void *(*feed_func)(void *, void *, size_t), void *(*collect_func)(void *, void *), void *(*create_env)(), void(*getIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)=nullptr, void *(*copyIterator)(void *dest, const void *source)=nullptr, voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html:1574,access,accesses,1574,doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,1,['access'],['accesses']
Security,"ronSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< Bool_t, A > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t, A > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CRArgsMenuItem;  CRCheckedMenuItem;  CRHistBinIterIterates over the bins of a RHist or RHistImpl ;  CRHistBinPtrPoints to a histogram bin (or actually a RHistBinRef) ;  CRHistBinRefRepresents a bin reference ;  CRHistBinStatConst view on a bin's statistical data ;  CRHistDataA RHistImplBase's data, provides accessors to all its statistics ;  CRHistImpl;  CRHistImplBaseInterface class f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:17315,access,accesses,17315,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['access'],['accesses']
Security,"roofMonSender.h. Public Member Functions;  TDSetPlet (const char *name, TDSet *ds=0);  ;  ~TDSetPlet () override;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMonSender_1_1TDSetPlet.html:1314,hash,hash,1314,doc/master/classTProofMonSender_1_1TDSetPlet.html,https://root.cern,https://root.cern/doc/master/classTProofMonSender_1_1TDSetPlet.html,1,['hash'],['hash']
Security,"ror (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,MaxEpochs=10,WeightDecay=1e-4,Regularization=None,Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.0"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Will now use the CPU architecture with BLAS and IMT support !; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; Factory : Booking method: ␛[1mPyKeras␛[0m; : ; : ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:7497,validat,validation,7497,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['validat'],['validation']
Security,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. TRecorder & operator=(const TRecGuiEvent& ). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:41; This page has been automatically generated. For comments o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecGuiEvent.html:7972,expose,exposes,7972,root/html534/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html534/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecGuiEvent.html:7884,expose,exposes,7884,root/html528/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRecGuiEvent.html:7953,expose,exposes,7953,root/html530/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html530/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecGuiEvent.html:7953,expose,exposes,7953,root/html532/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html532/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"ross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidation. ; DataSetInfo : [datasetcv] : Added class ""Signal""; : Add Tree of type Signal with 1000 events; DataSetInfo : [datasetcv] : Added class ""Background""; : Add Tree of type Background with 1000 events; <HEADER> Factory : You are running ROOT Version: 6.33.01, Oct 10, 2023; : ; : _/_/_/_/_/ _| _| _| _| _|_| ; : _/ _|_| _|_| _| _| _| _| ; : _/ _| _| _| _| _| _|_|_|_| ; : _/ _| _| _| _| _| _| ; : _/ _| _| _| _| _| ; : ; : ___________TMVA Version 4.2.1, Feb 5, 2015; : ; : Rebuilding Dataset datasetcv; : Building event vectors for type 2 Signal; : Dataset[datasetcv] : create input formulas for tree ; : Building event vectors for type 2 Background; : Dataset[datasetcv] : create input formulas for tree ; <HEADER> DataSetFactory : [datasetcv] : Number of events in input trees; : ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:1830,access,accessed,1830,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['access'],['accessed']
Security,"ross validation where the splitting into k folds is computed deterministically. This ensures that the a given event will always end up in the same fold.; In addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidationRegression. ; DataSetInfo : [datasetcvreg] : Added class ""Regression""; : Add Tree TreeR of type Regression with 10000 events; --- TMVACrossValidationRegression: Using input file: ./files/tmva_reg_example.root; : Dataset[datasetcvreg] : Class index : 0 name : Regression; <HEADER> Factory : You are running ROOT Version: 6.33.01, Oct 10, 2023; : ; : _/_/_/_/_/ _| _| _| _| _|_| ; : _/ _|_| _|_| _| _| _| _| ; : _/ _| _| _| _| _| _|_|_|_| ; : _/ _| _| _| _| _| _| ; : _/ _| _| _| _| _| ; : ; : ___________TMVA Version 4.2.1, Feb 5, 2015; : ; : Rebuilding Dataset datasetcvreg; : Building event vectors for type 2 Regression; : Dataset[datasetcvreg] : create input formulas for tree TreeR; <HEADER> DataSetFactory : [datasetcvreg] : Number of events in input trees; : ; : Number of tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html:1856,access,accessed,1856,doc/master/TMVACrossValidationRegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationRegression_8C.html,1,['access'],['accessed']
Security,"rotected . Definition at line 44 of file BasicFCN.h. Constructor & Destructor Documentation. ◆ BasicFCN(). template<class DerivFunType , class ModelFunType , class DataType > . ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::BasicFCN ; (; const std::shared_ptr< DataType > & ; data, . const std::shared_ptr< IModelFunction > & ; func . ). inlineprotected . Constructor from data set and model function. ; Definition at line 55 of file BasicFCN.h. ◆ ~BasicFCN(). template<class DerivFunType , class ModelFunType , class DataType > . virtual ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::~BasicFCN ; (; ). inlineprotectedvirtual . Destructor (no operations) ; Definition at line 66 of file BasicFCN.h. Member Function Documentation. ◆ Data(). template<class DerivFunType , class ModelFunType , class DataType > . virtual const DataType & ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::Data ; (; ); const. inlinevirtual . access to const reference to the data ; Definition at line 72 of file BasicFCN.h. ◆ DataPtr(). template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr< DataType > ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::DataPtr ; (; ); const. inline . access to data pointer ; Definition at line 75 of file BasicFCN.h. ◆ HasHessian(). template<class DerivFunType , class ModelFunType , class DataType > . virtual bool ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::HasHessian ; (; ); const. inlinevirtual . flag to indicate if can compute Hessian ; Reimplemented from ROOT::Math::BasicFitMethodFunction< DerivFunType >.; Definition at line 84 of file BasicFCN.h. ◆ ModelFunction(). template<class DerivFunType , class ModelFunType , class DataType > . virtual const IModelFunction & ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::ModelFunction ; (; ); const. inlinevirtual . access to const reference to the model function ; Definition at line 78 of file BasicFCN.h. ◆ ModelFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html:6293,access,access,6293,doc/master/classROOT_1_1Fit_1_1BasicFCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html,1,['access'],['access']
Security,"rotected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:146731,access,accessible,146731,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['accessible']
Security,"rotected methods.; 3911 ; 3912const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3913{; 3914 R__LOCKGUARD(gInterpreterMutex);; 3915 ; 3916 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3917 if (load) {; 3918 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3919 fAllPubMethod->Load();; 3920 }; 3921 return fAllPubMethod;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Returns a list of all public data members of this class and its base; 3926/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3927/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3928 ; 3929TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3930{; 3931 R__LOCKGUARD(gInterpreterMutex);; 3932 ; 3933 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3934 if (load) fAllPubData->Load();; 3935 return fAllPubData;; 3936}; 3937 ; 3938////////////////////////////////////////////////////////////////////////////////; 3939/// Returns list of methods accessible by context menu.; 3940 ; 3941void TClass::GetMenuItems(TList *list); 3942{; 3943 if (!HasInterpreterInfo()) return;; 3944 ; 3945 // get the base class; 3946 TIter nextBase(GetListOfBases(), kIterBackward);; 3947 TBaseClass *baseClass;; 3948 while ((baseClass = (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClass->GetClassPointer();; 3950 if (base) base->GetMenuItems(list);; 3951 }; 3952 ; 3953 // remove methods redefined in this class with no menu; 3954 TMethod *method, *m;; 3955 TIter next(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:149482,access,accessible,149482,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['accessible']
Security,"rotected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooDataHist_dh; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:32712,validat,validate,32712,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,2,"['access', 'validat']","['access', 'validate']"
Security,"routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPad::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPad.h:267; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 267 of file TPad.h. ◆ HasViewer3D(). Bool_t TPad::HasViewer3D ; (; ); const. inlineoverridevirtual . Implements TVirtualPad.; Definition at line 401 of file TPad.h. ◆ HideToolTip(). void TPad::HideToolTip ; (; Int_t ; event). protectedvirtual . Hide tool tip depending on the event type. ; Typically tool tips are hidden when event is not a kMouseEnter and not a kMouseMotion event. ; Definition at line 2847 of file TPad.cxx. ◆ HighLight(). void TPad::HighLight ; (; Color_t ; color = kRed, . Bool_t ; set = kTRUE . ). overridevirtual . Highlight pad. ; do not highlight when printing on Postscript ; Implements TVirtualPad.; Definition at line 3055 of file TPad.cxx. ◆ IncrementPaletteColor(). Int_t TPad::IncrementPaletteColor ; (; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:87591,hash,hash,87591,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['hash'],['hash']
Security,"routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPair::HashULong_t Hash() const overrideReturn hash value for this object.Definition TMap.h:118; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 118 of file TMap.h. ◆ IsA(). TClass * TPair::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 124 of file TMap.h. ◆ IsEqual(). Bool_t TPair::IsEqual ; (; const TObject * ; obj); const. inlineoverridevirtual . Default equal comparison (objects are equal if they have the same address in memory). ; More complicated classes might want to override this function. ; Reimplemented from TObject.; Definition at line 119 of file TMap.h. ◆ IsFolder(). Bool_t TPair::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPair.html:13078,hash,hash,13078,doc/master/classTPair.html,https://root.cern,https://root.cern/doc/master/classTPair.html,1,['hash'],['hash']
Security,"routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPave::HashULong_t Hash() const overrideReturn hash value for this object.Definition TPave.h:63; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 63 of file TPave.h. ◆ IsA(). TClass * TPave::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBox.; Reimplemented in TPaveClass, TPaveLabel, TPaveStats, TPavesText, and TPaveText.; Definition at line 91 of file TPave.h. ◆ IsSortable(). Bool_t TPave::IsSortable ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 64 of file TPave.h. ◆ ls(). void TPave::ls ; (; Option_t * ; option = """"); const. overridevirtual . List this pave with its attributes. ; Reimplemented from TBox.; Definition at line 279 of file TPave.cxx. ◆ operator=(). TPave & TPave::operator= ; (; const TPave & ; src). Assignment operator. ; Definition at line 129 of file TPave.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPave.html:24858,hash,hash,24858,doc/master/classTPave.html,https://root.cern,https://root.cern/doc/master/classTPave.html,1,['hash'],['hash']
Security,"roviders in the same program/macro, where the environemntal variables solution is not convenient (see below).; To use AWS temporary security credentials you need to specify the session token. This can be added to the options argument with a string of the form TOKEN=mySessionToken. The temporary access and secret keys must also be available, either via the AUTH option or by environmental variable.; If you need to specify more than one option separate them by ' ' (blank), for instance: ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+""; Examples: TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f3 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""TOKEN=AQoDYXdzEM///////////wEa8AHEYmCinjD+TsGEjtgKSMAT6wnY"");; If there is no authentication information in the 'options' argument (i.e. not AUTH=""...."") the values of the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain the access key id and the secret access key, respectively. You have been provided with these credentials by your S3 service provider.; If neither the AUTH information is provided in the 'options' argument nor the environmental variables are set, we try to open the file without providing any authentication information to the server. This is useful when the file is set an access control that allows for any unidentified user to read the file. ; Definition at line 152 of file TS3WebFile.cxx. ◆ ~TS3WebFile(). virtual TS3WebFile::~TS3WebFile ; (; ). inlinevirtual . Definition at line 93 of file TS3WebFile.h. Member Function Documentation. ◆ Class(). static TClass * TS3WebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TS3WebFile::Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:50764,authenticat,authentication,50764,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['authenticat'],['authentication']
Security,"rowser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:316; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:124; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:196",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:44064,access,access,44064,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"roxiedPtr, fColRegister, columns);; 398 return RInterface<F_t, DS_t>(std::move(filterPtr), *fLoopManager, fColRegister);; 399 }; 400 ; 401 // clang-format off; 402 ////////////////////////////////////////////////////////////////////////////; 403 /// \brief Define a new column.; 404 /// \param[in] name The name of the defined column.; 405 /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; 406 /// \param[in] columns Names of the columns/branches in input to the producer function.; 407 /// \return the first node of the computation graph for which the new quantity is defined.; 408 ///; 409 /// Define a column that will be visible from all subsequent nodes; 410 /// of the functional chain. The `expression` is only evaluated for entries that pass; 411 /// all the preceding filters.; 412 /// A new variable is created called `name`, accessible as if it was contained; 413 /// in the dataset from subsequent transformations/actions.; 414 ///; 415 /// Use cases include:; 416 /// * caching the results of complex calculations for easy and efficient multiple access; 417 /// * extraction of quantities of interest from complex objects; 418 ///; 419 /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; 420 ///; 421 /// ### Example usage:; 422 /// ~~~{.cpp}; 423 /// // assuming a function with signature:; 424 /// double myComplexCalculation(const RVec<float> &muon_pts);; 425 /// // we can pass it directly to Define; 426 /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; 427 /// // alternatively, we can pass the body of the function as a string, as in Filter:; 428 /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; 429 /// ~~~; 430 ///; 431 /// \note If the body of the string expression contains an explicit `return` statement (even if it is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:20218,access,accessible,20218,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['access'],['accessible']
Security,"roxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(UInt_t nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedMapProxy.html:4712,access,accessors,4712,root/html534/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedMapProxy.html,2,['access'],['accessors']
Security,"rptr);  ; template<typename T1 > ; RResultPtr< T1 > RDFDetail::MakeResultPtr (const std::shared_ptr< T1 > &, ::ROOT::Detail::RDF::RLoopManager &, std::shared_ptr< RDFInternal::RActionBase >);  ; ROOT::Internal::RDF::SnapshotPtr_t ROOT::Internal::RDF::CloneResultAndAction (const ROOT::Internal::RDF::SnapshotPtr_t &inptr, const std::string &outputFileName);  ; RResultPtr< T > ROOT::Internal::RDF::CloneResultAndAction (const RResultPtr< T > &inptr);  ; class ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper;  ; template<typename T1 > ; ROOT::RDF::Experimental::RResultMap< T1 > ROOT::RDF::Experimental::VariationsFor (RResultPtr< T1 > resPtr);  ; class RResultHandle;  . #include <ROOT/RResultPtr.hxx>; Member Typedef Documentation. ◆ SPT_t. template<typename T > . using ROOT::RDF::RResultPtr< T >::SPT_t = std::shared_ptr<T>. private . Definition at line 121 of file RResultPtr.hxx. ◆ Value_t. template<typename T > . using ROOT::RDF::RResultPtr< T >::Value_t = T. Convenience alias to simplify access to proxied type. ; Definition at line 206 of file RResultPtr.hxx. Constructor & Destructor Documentation. ◆ RResultPtr() [1/5]. template<typename T > . ROOT::RDF::RResultPtr< T >::RResultPtr ; (; std::shared_ptr< T > ; objPtr, . RDFDetail::RLoopManager * ; lm, . std::shared_ptr< RDFInternal::RActionBase > ; actionPtr . ). inlineprivate . Definition at line 199 of file RResultPtr.hxx. ◆ RResultPtr() [2/5]. template<typename T > . ROOT::RDF::RResultPtr< T >::RResultPtr ; (; ). default . ◆ RResultPtr() [3/5]. template<typename T > . ROOT::RDF::RResultPtr< T >::RResultPtr ; (; const RResultPtr< T > & ; ). default . ◆ RResultPtr() [4/5]. template<typename T > . ROOT::RDF::RResultPtr< T >::RResultPtr ; (; RResultPtr< T > && ; ). default . ◆ RResultPtr() [5/5]. template<typename T > . template<typename T2 , std::enable_if_t< std::is_constructible< std::shared_ptr< T >, std::shared_ptr< T2 > >::value, int > = 0> . ROOT::RDF::RResultPtr< T >::RResultPtr ; (; const RResultPtr< T2 > & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:5524,access,access,5524,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['access'],['access']
Security,"rray(const ULong_t *l, Int_t n)=0; TBuffer::ReadClassEmulatedvirtual Int_t ReadClassEmulated(const TClass *cl, void *object, const TClass *onfile_class=nullptr)=0; TBuffer::Bufferchar * Buffer() constDefinition TBuffer.h:96; TBuffer::ReadArrayvirtual Int_t ReadArray(Char_t *&c)=0; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TMemberStreamerDefinition TMemberStreamer.h:26; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TRefTableA TRefTable maintains the association between a referenced object and the parent object supporting th...Definition TRefTable.h:35; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TStreamerInfoActionsDefinition TBuffer.h:39; lTLine lDefinition textangle.C:4. corebaseincTBuffer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8h_source.html:46774,access,access,46774,doc/master/TBuffer_8h_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html,1,['access'],['access']
Security,"rrently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 11801 if (!mg_stat(conn, path, &de.file)) {; 11802 /* mg_stat returns 0 if the file does not exist */; 11803 mg_send_http_error(conn,; 11804 404,; 11805 ""Error: Cannot delete file\nFile %s not found"",; 11806 path);; 11807 return;; 11808 }; 11809 ; 11810 if (de.file.is_directory) {; 11811 if (remove_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:340852,access,access,340852,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"rrently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 11802 if (!mg_stat(conn, path, &de.file)) {; 11803 /* mg_stat returns 0 if the file does not exist */; 11804 mg_send_http_error(conn,; 11805 404,; 11806 ""Error: Cannot delete file\nFile %s not found"",; 11807 path);; 11808 return;; 11809 }; 11810 ; 11811 if (de.file.is_directory) {; 11812 if (remove_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:340885,access,access,340885,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"rride;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditHist.html:7455,access,accessible,7455,doc/master/classTGTextEditHist.html,https://root.cern,https://root.cern/doc/master/classTGTextEditHist.html,1,['access'],['accessible']
Security,"rride;  Make a clone of an object using the Streamer facility. ;  ; void Delete (Option_t *o=nullptr) override;  Remove all elements in collection and delete all elements NB: Collection does not own elements, this function should be used judiciously by caller. ;  ; bool empty () const;  ; RooLinkedListIterImpl end () const;  ; TObject * find (const char *name) const;  Return pointer to object with given name in collection. ;  ; RooAbsArg * findArg (const RooAbsArg *) const;  Return pointer to object with given name in collection. ;  ; TObject * FindObject (const char *name) const override;  Return pointer to object with given name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object in list. ;  ; TObject * First () const;  ; RooFIter fwdIterator () const;  Create a one-time-use forward iterator for this list. ;  ; Int_t getHashTableSize () const;  ; const char * GetName () const override;  Returns name of object. ;  ; Int_t GetSize () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Int_t IndexOf (const char *name) const;  Return position of given object in list. ;  ; Int_t IndexOf (const TObject *arg) const;  Return position of given object in list. ;  ; TClass * IsA () const override;  ; RooLinkedListIter iterator (bool forward=true) const;  Create an iterator for this list. ;  ; TIterator * MakeIterator (bool forward=true) const;  Create a TIterator for this list. ;  ; RooLinkedList & operator= (const RooLinkedList &other);  Assignment operator, copy contents from 'other'. ;  ; void Print (const char *opt) const override;  Print contents of list, defers to Print() function of contained objects. ;  ; RooLinkedListIterImpl rbegin () const;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; virtual bool Remove (TObject *arg);  Remove object from collection. ;  ; RooLinkedListIterImpl rend () const;  ; bool Replace (const TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:2294,hash,hash,2294,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash']
Security,"rride;  Set the title of the TNamed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystemDirectory.html:4600,hash,hash,4600,doc/master/classTSystemDirectory.html,https://root.cern,https://root.cern/doc/master/classTSystemDirectory.html,2,['hash'],['hash']
Security,"rrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of typedef, e,g.: ""class TDirectory*"".Definition TDataType.cxx:175; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsOptInt_t GetNargsOpt() constNumber of function optional (default) arguments.Definition TFunction.cxx:184; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:40458,hash,hash,40458,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['hash'],['hash']
Security,"rror message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  THashTable (const THashTable &)=delete;  ; void AddImpl (Int_t slot, TObject *object);  Helper function doing the actual add to the table give a slot and object. ;  ; Int_t GetCheckedHashValue (TObject *obj) const;  ; Int_t GetHashValue (const char *str) const;  ; Int_t GetHashValue (const TObject *obj) const;  ; Int_t GetHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:12956,access,accessible,12956,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['access'],['accessible']
Security,"rror message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EStatusBits { kIsOwnerValue = (1ULL << ( 15 )); };  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void PrintCollectionEntry (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:14585,access,accessible,14585,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['access'],['accessible']
Security,"rrorPruning =0; , kCostComplexityPruning; , kNoPruning; };  ; typedef std::vector< const TMVA::Event * > EventConstList;  ; typedef std::vector< TMVA::Event * > EventList;  . Public Member Functions;  DecisionTree (const DecisionTree &d);  copy constructor that creates a true copy, i.e. ;  ;  DecisionTree (SeparationBase *sepType, Float_t minSize, Int_t nCuts, DataSetInfo *=nullptr, UInt_t cls=0, Bool_t randomisedTree=kFALSE, Int_t useNvars=0, Bool_t usePoissonNvars=kFALSE, UInt_t nMaxDepth=9999999, Int_t iSeed=fgRandomSeed, Float_t purityLimit=0.5, Int_t treeID=0);  constructor specifying the separation type, the min number of events in a no that is still subjected to further splitting, the number of bins in the grid used in applying the cut for the node splitting. ;  ;  DecisionTree (void);  default constructor using the GiniIndex as separation criterion, no restrictions on minium number of events in a leave note or the separation gain in the node splitting ;  ; virtual ~DecisionTree (void);  destructor ;  ; void ApplyValidationSample (const EventConstList *validationSample) const;  run the validation sample through the (pruned) tree and fill in the nodes the variables NSValidation and NBValidadtion (i.e. ;  ; UInt_t BuildTree (const EventConstList &eventSample, DecisionTreeNode *node=nullptr);  building the decision tree by recursively calling the splitting of one (root-) node into two daughter nodes (returns the number of nodes) ;  ; Double_t CheckEvent (const TMVA::Event *, Bool_t UseYesNoLeaf=kFALSE) const;  the event e is put into the decision tree (starting at the root node) and the output is NodeType (signal) or (background) of the final node (basket) in which the given events ends up. ;  ; void CheckEventWithPrunedTree (const TMVA::Event *) const;  pass a single validation event through a pruned decision tree on the way down the tree, fill in all the ""intermediate"" information that would normally be there from training. ;  ; virtual const char * ClassName ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:2938,validat,validationSample,2938,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,2,['validat'],"['validation', 'validationSample']"
Security,"rrorStrategy == ""SUMOFSQUARES"") {; 531 fNet.SetLossFunction(ELossFunction::kMeanSquaredError);; 532 }; 533 if (fErrorStrategy == ""CROSSENTROPY"") {; 534 fNet.SetLossFunction(ELossFunction::kCrossEntropy);; 535 }; 536 if (fErrorStrategy == ""MUTUALEXCLUSIVE"") {; 537 fNet.SetLossFunction(ELossFunction::kSoftmaxCrossEntropy);; 538 }; 539 fOutputFunction = EOutputFunction::kSoftmax;; 540 }; 541 ; 542 //; 543 // Initialization; 544 //; 545 ; 546 if (fWeightInitializationString == ""XAVIER"") {; 547 fWeightInitialization = DNN::EInitialization::kGauss;; 548 }; 549 else if (fWeightInitializationString == ""XAVIERUNIFORM"") {; 550 fWeightInitialization = DNN::EInitialization::kUniform;; 551 }; 552 else {; 553 fWeightInitialization = DNN::EInitialization::kGauss;; 554 }; 555 ; 556 //; 557 // Training settings.; 558 //; 559 ; 560 // Force validation of the ValidationSize option; 561 GetNumValidationSamples();; 562 ; 563 KeyValueVector_t strategyKeyValues = ParseKeyValueString(fTrainingStrategyString,; 564 TString (""|""),; 565 TString ("",""));; 566 ; 567 std::cout << ""Parsed Training DNN string "" << fTrainingStrategyString << std::endl;; 568 std::cout << ""STring has size "" << strategyKeyValues.size() << std::endl;; 569 for (auto& block : strategyKeyValues) {; 570 TTrainingSettings settings;; 571 ; 572 settings.convergenceSteps = fetchValue(block, ""ConvergenceSteps"", 100);; 573 settings.batchSize = fetchValue(block, ""BatchSize"", 30);; 574 settings.testInterval = fetchValue(block, ""TestRepetitions"", 7);; 575 settings.weightDecay = fetchValue(block, ""WeightDecay"", 0.0);; 576 settings.learningRate = fetchValue(block, ""LearningRate"", 1e-5);; 577 settings.momentum = fetchValue(block, ""Momentum"", 0.3);; 578 settings.dropoutProbabilities = fetchValue(block, ""DropConfig"",; 579 std::vector<Double_t>());; 580 ; 581 TString regularization = fetchValue(block, ""Regularization"",; 582 TString (""NONE""));; 583 if (regularization == ""L1"") {; 584 settings.regularization = DNN::ERegularization::kL1;; 585 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:19068,validat,validation,19068,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"rrors; Any serious inconsistency results in an error. ; Definition at line 27 of file TFractionFitter.h. Public Member Functions;  TFractionFitter ();  TFractionFitter default constructor. ;  ;  TFractionFitter (TH1 *data, TObjArray *MCs, Option_t *option="""");  TFractionFitter constructor. ;  ;  ~TFractionFitter () override;  TFractionFitter default destructor. ;  ; void Constrain (Int_t parm, Double_t low, Double_t high);  Constrain the values of parameter number <parm> (the parameter numbering follows that of the input template vector). ;  ; void ErrorAnalysis (Double_t UP);  Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. ;  ; Double_t EvaluateFCN (const Double_t *par);  ; void ExcludeBin (Int_t bin);  Exclude the given bin from the fit. ;  ; TFitResultPtr Fit ();  Perform the fit with the default UP value. ;  ; Double_t GetChisquare () const;  Return the likelihood ratio Chi-squared (chi2) for the fit. ;  ; ROOT::Fit::Fitter * GetFitter () const;  Give direct access to the underlying fitter class. ;  ; TH1 * GetMCPrediction (Int_t parm) const;  Return the adjusted MC template (Aji) for template (parm). ;  ; Int_t GetNDF () const;  return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ;  ; TH1 * GetPlot ();  Return the ""template prediction"" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account). ;  ; Double_t GetProb () const;  return the fit probability ;  ; void GetResult (Int_t parm, Double_t &value, Double_t &error) const;  Obtain the fit result for parameter <parm> (the parameter numbering follows that of the input template vector). ;  ; void IncludeBin (Int_t bin);  Include the given bin in the fit, if it was excluded before using ExcludeBin(). ;  ; TClass * IsA () const override;  ; void ReleaseRangeX ();  Release restrictions on the X range of the histogram to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:7407,access,access,7407,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['access'],['access']
Security,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const Double32_t* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the interm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html:6538,access,access,6538,root/html534/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:6014,access,access,6014,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,26,['access'],['access']
Security,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html:5883,access,access,5883,root/html534/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html,18,['access'],['access']
Security,"rs ;  CTVirtualGeoPainterAbstract class for geometry painters ;  CTVirtualGeoTrackBase class for user-defined tracks attached to a geometry ;  CTVirtualGLManip;  CTVirtualGLPainter;  CTVirtualGraphPainterAbstract interface to a histogram painter ;  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndexAbstract interface for Tree Index ;  CTVirtualIsAProxy;  CTVirtualMagFieldAbstract class for magnetic field ;  CTVirtualMCAbstract Monte Carlo interface ;  CTVirtualMCApplicationInterface to a user Monte Carlo application ;  CTVirtualMCDecayerAbstract base class for particle decays ;  CTVirtualMCGeometryInterface to Monte Carlo geometry construction ;  CTVirtualMCSensitiveDetectorInterface to a user defined sensitive detector ;  CTVirtualMCStackInterface to a user defined particles stack ;  CTVirtualMonitoringReader;  CTVirtualMonitoringWriter;  CTVirtualMutexThis class implements a mutex interface ;  CTVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  ►CTVirtualPacketizerThe packetizer is a load balancing object created for each query ;  CTVirtualSlaveStat;  CTVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes ;  CTVirtualPadEditorAbstract base class used by ROOT graphics editor ;  CTVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas ;  CTVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTVirtualProofPlayerAbstract interface for the PROOF player ;  CTVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG ;  CTVirtualQConnectionMediates the link between the signal and the slot ;  CTVirtualRefProxy;  CTVirtualStreamerInfoAbstract Interface class describing Streamer information for one class ;  CTVirtualTableInterface;  CTVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:219203,access,access,219203,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,2,['access'],['access']
Security,"rs(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward). private:. Int_tNextSlot(); THashTableIter(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THashTableIter.html:1965,hash,hashtable,1965,root/html604/THashTableIter.html,https://root.cern,https://root.cern/root/html604/THashTableIter.html,1,['hash'],['hashtable']
Security,"rs(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward). private:. Int_tNextSlot(); THashTableIter(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTableIter.html:1965,hash,hashtable,1965,root/html602/THashTableIter.html,https://root.cern,https://root.cern/root/html602/THashTableIter.html,1,['hash'],['hashtable']
Security,"rs, directories, files and collections. Can locate objects (or its data member) per name. Can be extended to application-specific classes.; Normally TRootSnifferFull class is used which able to access data from trees, canvases, histograms. ; Definition at line 115 of file TRootSniffer.h. Public Member Functions;  TRootSniffer (const char *name=""sniff"", const char *objpath=""Objects"");  constructor ;  ; virtual ~TRootSniffer ();  destructor ;  ; Bool_t CanDrawItem (const char *path);  Method verifies if object can be drawn. ;  ; Bool_t CanExploreItem (const char *path);  Method returns true when object has childs or one could try to expand item. ;  ; Int_t CheckRestriction (const char *item_name);  Checked if restriction is applied to the item full_item_name should have full path to the item. ;  ; Bool_t CreateItem (const char *fullname, const char *title);  Create item element. ;  ; void CreateOwnTopFolder ();  Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffer instances At the same time such sniffer lost access to all global lists and folders. ;  ; virtual void * FindInHierarchy (const char *path, TClass **cl=nullptr, TDataMember **member=nullptr, Int_t *chld=nullptr);  Search element with specified path Returns pointer on element Optionally one could obtain element class, member description and number of childs. ;  ; TObject * FindTObjectInHierarchy (const char *path);  Search element in hierarchy, derived from TObject. ;  ; const char * GetAutoLoad () const;  return name of configured autoload scripts (or 0) ;  ; const char * GetItemField (const char *fullname, const char *name);  Return field for specified item. ;  ; virtual ULong_t GetItemHash (const char *itemname);  Get hash function for specified item used to detect any changes in the specified object. ;  ; virtual ULong_t GetStreamerInfoHash ();  ; TFolder * GetTopFolder (Bool_t force=kFALSE);  Returns top TFolder instance for the sniffer. ;  ; Bool_t HasRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:1525,access,access,1525,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['access'],['access']
Security,"rs.cxx:542; TListOfDataMembers::GetTDictionary * Get(DeclId_t id)Return (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:216; TListOfDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection.Definition TListOfDataMembers.cxx:399; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctions.cxx:162; TListOfFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctions.cxx:374; TListOfFunctions::Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfFunctions.cxx:409; TListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information.Definition TListOfTypes.h:31; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:139311,access,access,139311,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['access'],['access']
Security,"rsion embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of MethodDL supporting both CNN and RNN; Add possibility to customize all relevant minimizer parameters used for training in MethodDL; Add support in MethodDL for the Cudnn version 8 when using the Cuda implementation for CNN and RNN Minuit2; Implement the missing support for MethodCategory for multiclass classifiers.; Add possibility to retrieve a ROC curve made with the training dataset instead of the default test dataset. RooFit Libraries. Extension / updates of the doxygen reference guide.; Allow for removing RooPlot from global directory management, see RooPlot::AddDirectory and RooPlot::SetDirectory; Hash-assisted finding of elements in RooWorkspace. Large RooWorkspace objects were slow in finding elements. This was improved using a hash map.; Stabilise RooStats::HypoTestInverter. It can now tolerate a few failed fits when conducting hypothesis tests. This is relevant when a few points in a parameter scan don’t converge due to numerical or model instabilities. These points will be skipped, and HypoTestInverter can continue.; Tweak pull / residual plots. ROOT automatically zoomed out a bit when a pull / residual plot is created. Now, the axis range of the original plot is transferred to the residual plot, so the pulls can be drawn below the main plot.; Improve plotting of RooBinSamplingPdf; Print a Warning message when the RooAddPdf is evaluated without passing a normalization set and the class has not a normalization set defined. Without a normalization set the RooAddPdf is not properly defined and its shape will be different depending on which normalization range is used. Massive speed up of RooFit’s BatchMode on CPUs with vector extensions; RooFit’s BatchMode has been around since ROOT 6.20, but to full",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:16605,hash,hash,16605,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['hash'],['hash']
Security,"rsion(). static constexpr Version_t TClassTable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 101 of file TClassTable.h. ◆ Classes(). int TClassTable::Classes ; (; ). Definition at line 388 of file TClassTable.cxx. ◆ DeclFileName(). static const char * TClassTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 101 of file TClassTable.h. ◆ FindElement(). TClassRec * TClassTable::FindElement ; (; const char * ; cname, . Bool_t ; insert . ). staticprivate . Find a class by name in the class table (using hash of name). ; Returns 0 if the class is not in the table. Unless arguments insert is true in which case a new entry is created and returned. cname must be the normalized name of the class. ; Definition at line 625 of file TClassTable.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClassTable::GetDict ; (; const char * ; cname). static . Given the class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 674 of file TClassTable.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClassTable::GetDict ; (; const std::type_info & ; info). static . Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ; Definition at line 692 of file TClassTable.cxx. ◆ GetDictNorm(). DictFuncPtr_t TClassTable::GetDictNorm ; (; const char * ; cname). static . Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 717 of file TClassTable.cxx. ◆ GetID(). Version_t TClassTable::GetID ; (; const char * ; cname). static . Returns the ID of a class. ; Definition at line 647 of file TClassTable.cxx. ◆ GetPragmaBits(). Int_t TClassTable::GetPragmaBits ; (; const char * ; name). static . Returns the pragma bits as specified in the LinkDef.h file. ; Definition at line 660 of file TClassTable.cxx. ◆ GetProto(). TProtoClass * TClassTable::GetProto ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:16987,hash,hash,16987,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"rsionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash; static ROOT::TMapTypeToTClass*fgIdMapMap from typeid to TClass pointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:16499,access,access,16499,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,2,['access'],['access']
Security,"rspective(). virtual Bool_t TGLCamera::IsPerspective ; (; ); const. inlinevirtual . Reimplemented in TGLPerspectiveCamera.; Definition at line 119 of file TGLCamera.h. ◆ OfInterest(). Bool_t TGLCamera::OfInterest ; (; const TGLBoundingBox & ; box, . Bool_t ; ignoreSize . ); const. Calculate if the an object defined by world frame bounding box is 'of interest' to the camera. ; This is defined as box:. intersecting completely or partially (kInside/kPartial) with cameras interest box (fInterestBox); having significant length OR volume ratio compared to this interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See TGLCamera::UpdateInterest() for more details of camera interest box.; Note: Length/volume ratios NOT dependent on the projected size of box at current camera configuration as we do not want continual changes. This is used when (re) populating the scene with objects from external client.; TODO: Might be more logical to move this test out to client - and have accessor for fInterestBox instead? ; Definition at line 578 of file TGLCamera.cxx. ◆ operator=(). TGLCamera & TGLCamera::operator= ; (; const TGLCamera & ; ). privatedelete . ◆ RefCamBase(). TGLMatrix & TGLCamera::RefCamBase ; (; ). inline . Definition at line 169 of file TGLCamera.h. ◆ RefCamTrans(). TGLMatrix & TGLCamera::RefCamTrans ; (; ). inline . Definition at line 170 of file TGLCamera.h. ◆ RefLastNoPickProjM(). TGLMatrix & TGLCamera::RefLastNoPickProjM ; (; ); const. inline . Definition at line 174 of file TGLCamera.h. ◆ RefModelViewMatrix(). const TGLMatrix & TGLCamera::RefModelViewMatrix ; (; ); const. inline . Definition at line 121 of file TGLCamera.h. ◆ RefViewport() [1/2]. TGLRect & TGLCamera::RefViewport ; (; ). inline . Definition at line 128 of file TGLCamera.h. ◆ RefViewport() [2/2]. const TGLRect & TGLCamera::RefViewport ; (; ); const. inline . Definition at line 129 of file TGLCamera.h. ◆ Reset(). virtual void TGLCamera::Reset ; (; ). pure virtual . Implemented in TGLO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:28257,access,accessor,28257,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['access'],['accessor']
Security,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:16803,hash,hash,16803,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,5,['hash'],['hash']
Security,"rt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:70539,access,access,70539,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"rt, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of byt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:23682,authenticat,authenticated,23682,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authenticated']
Security,"rtual Bool_tTClass::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTClass::InterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTClass::IsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); Bool_tTClass::MatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:12286,checksum,checksum,12286,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,1,['checksum'],['checksum']
Security,"rtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHashTable&operator=(const RooHashTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tremove(TObject* arg, TObject* hashArg = 0); Bool_treplace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHashTable.html:4189,hash,hashArg,4189,root/html528/RooHashTable.html,https://root.cern,https://root.cern/root/html528/RooHashTable.html,1,['hash'],['hashArg']
Security,"rtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooHashTable&operator=(const RooHashTable&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tremove(TObject* arg, TObject* hashArg = 0); Bool_treplace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp, char* parent); Int_tsize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHashTable.html:4189,hash,hashArg,4189,root/html526/RooHashTable.html,https://root.cern,https://root.cern/root/html526/RooHashTable.html,1,['hash'],['hashArg']
Security,"rtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * GetInstance(); Static getter that does not create the object. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}. » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGlobalMagField.html:7065,access,access,7065,root/html534/TGeoGlobalMagField.html,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html,1,['access'],['access']
Security,"rtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::CurrentFilestatic TFile *& CurrentFile()Return the current ROOT file if any.Definition TFile.cxx:1067; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::Deletevoid Delete(Option_t *option="""") overrideDelete an object from the file.Definition TKey.cxx:539; TKey::GetSeekKeyvirtual Long64_t GetSeekKey() constDefinition TKey.h:89; TKey::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the key header structure.Definition TKey.cxx:1342; TKey::GetKeylenInt_t GetKeylen() constDefinition TKey.h:84; TKey::GetObjlenInt_t GetObjlen() constDefinition TKey.h:87; TKey::GetNbytesInt_t GetNbytes() constDefinition TKey.h:86; TKey::GetKeepShort_t GetKeep() constReturns the ""KEEP"" status.Definition TKey.cxx:594; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TKey::ReadFilevirtual Bool_t ReadFile()Read the key structure from the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:97461,hash,hash,97461,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['hash'],['hash']
Security,"rtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearMinimizer.html:4656,validat,validated,4656,root/html528/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html528/TLinearMinimizer.html,3,['validat'],['validated']
Security,"rtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; static const char*str(const TNamed* ptr); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooNameReg(Int_t hashSize = 31); RooNameReg(const RooNameReg& other); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum { kRenamedArg; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooHashTable_htableRepository of registered names; static RooNameReg*_instance; RooLinkedList_list; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNameReg(Int_t hashSize = 31); {}. ~RooNameReg(); Destructor. RooNameReg(const RooNameReg& other); Copy constructor. RooNameReg& instance(); Return reference to singleton instance. void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete global objects on heap at end of program. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNameReg.html:5433,hash,hashSize,5433,root/html534/RooNameReg.html,https://root.cern,https://root.cern/root/html534/RooNameReg.html,1,['hash'],['hashSize']
Security,"rtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:6485,hash,hash,6485,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['hash'],['hash']
Security,"rtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added.; if (htsize>0) {; cout << ""RooLinkedList::ctor htsize="" << htsize << endl ;; }. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object '",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:6554,hash,hash,6554,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['hash'],['hash']
Security,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool_tTestVersion(Int_t version) const; ROOT::TSchemaRuleTSchemaRule(); ROOT::TSchemaRuleTSchemaRule(const ROOT::TSchemaRule& rhs); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TSchemaRule.html:5820,checksum,checksum,5820,root/html530/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"rtual_b);  ; virtual Int_t WritePDGTable (const char *filename);  write contents of the particle DB into a file ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatabasePDG.html:4101,hash,hash,4101,doc/master/classTDatabasePDG.html,https://root.cern,https://root.cern/doc/master/classTDatabasePDG.html,1,['hash'],['hash']
Security,"rtyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:80065,access,accessing,80065,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['access'],['accessing']
Security,"ructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; TIterator*_catIter! Iterator over set of input categories; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:23158,access,access,23158,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,1,['access'],['access']
Security,"runeStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Jun 30 15:15:17 2015 » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__CCPruner.html:1890,validat,validationSample,1890,root/html602/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html602/TMVA__CCPruner.html,4,['validat'],"['validation', 'validationSample']"
Security,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClassTree.html:4482,access,access,4482,root/html526/TClassTree.html,https://root.cern,https://root.cern/root/html526/TClassTree.html,5,['access'],['access']
Security,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassTree.html:4482,access,access,4482,root/html602/TClassTree.html,https://root.cern,https://root.cern/root/html602/TClassTree.html,2,['access'],['access']
Security,"ry associated with this file are automatically deleted. Labelling axes; Axis titles can be specified in the title argument of the constructor. They must be separated by "";"": TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; The histogram title and the axis titles can be any TLatex string, and are persisted if a histogram is written to a file.; Any title can be omitted: TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; The method SetTitle() has the same syntax: h->SetTitle(""Histogram title;Another X title Axis"");; Alternatively, the title of each axis can be set directly: h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; For bin labels see binning. Binning. Fix or variable bin size; All histogram types support either fix or variable bin sizes. 2-D histograms may have fix size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw or access histograms are identical in both cases.; Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis. To access the axis parameters, use: TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; See class TAxis for a description of all the access functions. The axis range is always stored internally in double precision. Convention for numbering bins; For all histogram types: nbins, xlow, xup bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with (binx, biny, binz), the function Int_t gbin = h->GetBin(binx, biny, binz);; int; returns a global/lineari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:6721,access,access,6721,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security,"ry in the user_buffer will be shared with the returned TBasket. ; Definition at line 1226 of file TBranch.cxx. ◆ GetBasketSeek(). Long64_t TBranch::GetBasketSeek ; (; Int_t ; basket); const. virtual . Return address of basket in the file. ; Definition at line 1302 of file TBranch.cxx. ◆ GetBasketSize(). virtual Int_t TBranch::GetBasketSize ; (; ); const. inlinevirtual . Definition at line 217 of file TBranch.h. ◆ GetBrowsables(). TList * TBranch::GetBrowsables ; (; ). virtual . Returns (and, if 0, creates) browsable objects for this branch See TVirtualBranchBrowsable::FillListOfBrowsables. ; Definition at line 1312 of file TBranch.cxx. ◆ GetBulkEntries(). Int_t TBranch::GetBulkEntries ; (; Long64_t ; entry, . TBuffer & ; user_buf . ). private . Read a basket of events into the given buffer with byte swapping. ; ReturnsOn success, the number of events of the type held by this branch that have been read into the buffer. -1 on failure.; On success, the caller should be able to access the contents of buf as they are with:; static_cast<T*>(buf.GetCurrent()); where T is the type stored on this branch.; When count_buf points to a valid TBuffer and the branch has a branch count, count_buf will be filled (via a call to GetEntriesSerialized) with the data from the branchCount. After deserialization those value can be used to calculate the number of elements corresponding to each entries.; For each entry the number of elements is the multiplication of; TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; auto len = leaf->GetLen();; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:42730,access,access,42730,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['access'],['access']
Security,"ry inheritance); by many other classes (graphics, histograms). It holds all the markers; attributes.; Marker attributes; The marker attributes are:. Marker color.; Marker style.; Marker size. Marker color; The marker color is a color index (integer) pointing in the ROOT color; table.; The marker color of any class inheriting from TAttMarker can; be changed using the method SetMarkerColor and retrieved using the; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kOpenStar; 30 open star kFullStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TAttMarker.html:1388,access,accessed,1388,root/html530/TAttMarker.html,https://root.cern,https://root.cern/root/html530/TAttMarker.html,2,['access'],['accessed']
Security,"ry.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:348988,hash,hash,348988,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['hash'],['hash']
Security,"ry.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:621; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:641; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:624; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:622; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:351626,hash,hash,351626,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['hash'],['hash']
Security,"s (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:41947,access,access,41947,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,2,['access'],['access']
Security,"s * in the first field (in the case 'href' is a name, ie not IP address) Returns kTRUE if the two matches. ; Definition at line 1440 of file TAuthenticate.cxx. ◆ CheckNetrc() [1/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; For more info see the version with 4 arguments. This version is maintained for backward compatability reasons. ; Definition at line 878 of file TAuthenticate.cxx. ◆ CheckNetrc() [2/2]. Bool_t TAuthenticate::CheckNetrc ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwhash, . Bool_t ; srppwd . ). Try to get user name and passwd from the ~/.rootnetrc or ~/.netrc files. ; First ~/.rootnetrc is tried, after that ~/.netrc. These files will only be used when their access masks are 0600. Returns kTRUE if user and passwd were found for the machine specified in the URL. If kFALSE, user and passwd are """". The boolean pwhash is set to kTRUE if the returned passwd is to be understood as password hash, i.e. if the 'password-hash' keyword is found in the 'machine' lines; not implemented for 'secure' and the .netrc file. The format of these files are:. this is a comment line; machine <machine fqdn> login <user> password <passwd> machine <machine fqdn> login <user> password-hash <passwd>; and in addition ~/.rootnetrc also supports:; secure <machine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthentic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:23574,password,password,23574,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['hash', 'password']","['hash', 'password']"
Security,s ; Definition at line 153 of file Event.h. ◆ ClearDynamicVariables(). static void TMVA::Event::ClearDynamicVariables ; (; ). inlinestatic . Definition at line 122 of file Event.h. ◆ CopyVarValues(). void TMVA::Event::CopyVarValues ; (; const Event & ; other). copies only the variable values ; Definition at line 203 of file Event.cxx. ◆ DeclFileName(). static const char * TMVA::Event::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 153 of file Event.h. ◆ GetBoostWeight(). Double_t TMVA::Event::GetBoostWeight ; (; ); const. inline . Definition at line 85 of file Event.h. ◆ GetClass(). UInt_t TMVA::Event::GetClass ; (; ); const. inline . Definition at line 86 of file Event.h. ◆ GetNSpectators(). UInt_t TMVA::Event::GetNSpectators ; (; ); const. accessor to the number of spectators ; Definition at line 335 of file Event.cxx. ◆ GetNTargets(). UInt_t TMVA::Event::GetNTargets ; (; ); const. accessor to the number of targets ; Definition at line 327 of file Event.cxx. ◆ GetNVariables(). UInt_t TMVA::Event::GetNVariables ; (; ); const. accessor to the number of variables ; Definition at line 316 of file Event.cxx. ◆ GetOriginalWeight(). Double_t TMVA::Event::GetOriginalWeight ; (; ); const. inline . Definition at line 84 of file Event.h. ◆ GetSpectator(). Float_t TMVA::Event::GetSpectator ; (; UInt_t ; ivar); const. return spectator content ; Definition at line 261 of file Event.cxx. ◆ GetSpectators() [1/2]. std::vector< Float_t > & TMVA::Event::GetSpectators ; (; ). inline . Definition at line 107 of file Event.h. ◆ GetSpectators() [2/2]. const std::vector< Float_t > & TMVA::Event::GetSpectators ; (; ); const. inline . Definition at line 108 of file Event.h. ◆ GetTarget(). Float_t TMVA::Event::GetTarget ; (; UInt_t ; itgt); const. inline . Definition at line 102 of file Event.h. ◆ GetTargets() [1/2]. std::vector< Float_t > & TMVA::Event::GetTargets ; (; ). inline . Definition at line 103 of file Event.h. ◆ G,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Event.html:17026,access,accessor,17026,doc/master/classTMVA_1_1Event.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Event.html,1,['access'],['accessor']
Security,"s a callable that takes N arguments of type T, passes them down to function func as an initializer list {t1, t2, t3,..., tN} and returns whatever f({t1, t2, t3, ..., tN}) returns.; Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T. Example usage together with RDataFrame (""varX"" columns must all be float variables): bool myVecFunc(std::vector<float> args);; df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});. Definition at line 103 of file RDFHelpers.hxx. ◆ RunGraphs(). unsigned int ROOT::RDF::RunGraphs ; (; std::vector< RResultHandle > ; handles). Trigger the event loop of multiple RDataFrames concurrently. ; Parameters. [in]handlesA vector of RResultHandles . ReturnsThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:13832,access,accessing,13832,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['access'],['accessing']
Security,"s about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. . Fill() Fill a user-defined object with the values of the specified columns, as if by calling Obj.Fill(col1, col2, ...). . Graph() Fills a TGraph with the two columns provi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:4822,access,accessed,4822,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['accessed']
Security,"s and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:7452,access,accessed,7452,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['access'],['accessed']
Security,"s are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:7203,access,accessible-color-cycles,7203,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['access'],['accessible-color-cycles']
Security,"s branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchSTL.html:13239,checksum,checksum,13239,root/html532/TBranchSTL.html,https://root.cern,https://root.cern/root/html532/TBranchSTL.html,2,['checksum'],['checksum']
Security,"s branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. TStreamerInfo* GetInfo() const. Check if we don't have the stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchSTL.html:12316,checksum,checksum,12316,root/html528/TBranchSTL.html,https://root.cern,https://root.cern/root/html528/TBranchSTL.html,2,['checksum'],['checksum']
Security,"s browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TWebFile() [1/3]. TWebFile::TWebFile ; (; ). inlineprivate . Definition at line 39 of file TWebFile.h. ◆ TWebFile() [2/3]. TWebFile::TWebFile ; (; const char * ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. The url argument must be of the form: http://host.dom.ain/file.root. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 146 of file TWebFile.cxx. ◆ TWebFile() [3/3]. TWebFile::TWebFile ; (; TUrl ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:44439,access,accessible,44439,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['accessible']
Security,"s can be specified:. numfaces - approximate maximal number of faces in three.js model (default 100000); numnodes - approximate maximal number of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default - off); dflt_colors - assign default ROOT colors for the volumes. When transparent volumes appeared in the model, one could use produceRenderOrder() function to correctly set rendering order. It should be used as:; import { produceRenderOrder } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; produceRenderOrder(scene, camera.position, 'box');; Following methods can be applied: “box”, “pnt”, “size”, “ray” and “dflt”. See more info in draw options description for TGeo classes.; Here is running example and source code.; 1.11.7 Custom user class; There is code example how custom user class can be implemented. It shows usage of different draw options for the class and ability to access sub-elements of the object using specialized expand function.; 1.11.8 Use with Node.js; To install latest JSROOT release, just do:; [shell] npm install jsroot; To use in the Node.js scripts, one should add following line:; import { httpRequest, makeSVG } from 'jsroot';; Using JSROOT functionality, one can open binary ROOT files (local and remote), parse ROOT JSON, create SVG output. For example, to create SVG image with lego plot, one should do:; import { openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let svg = await makeSVG({ object: obj, option: ""lego2"", width: 1200, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:31853,access,access,31853,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security,"s changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no sha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:143905,validat,validate,143905,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['validat'],['validate']
Security,"s class ; Definition at line 76 of file TSchemaRuleSet.h. ◆ DeclFileName(). static const char * ROOT::Detail::TSchemaRuleSet::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 76 of file TSchemaRuleSet.h. ◆ FindRules() [1/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source); const. Return all the rules that are about the given 'source' class. ; User has to delete the returned array ; Definition at line 289 of file TSchemaRuleSet.cxx. ◆ FindRules() [2/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version . ); const. Return all the rules that applies to the specified version of the given 'source' class. ; User has to delete the returned array ; Definition at line 328 of file TSchemaRuleSet.cxx. ◆ FindRules() [3/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . Int_t ; version, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified version OR checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 368 of file TSchemaRuleSet.cxx. ◆ FindRules() [4/4]. const TSchemaRuleSet::TMatches TSchemaRuleSet::FindRules ; (; const TString & ; source, . UInt_t ; checksum . ); const. Return all the rules that applies to the specified checksum of the given 'source' class. ; User has to delete the returned array ; Definition at line 348 of file TSchemaRuleSet.cxx. ◆ GetClass(). TClass * TSchemaRuleSet::GetClass ; (; ). Definition at line 386 of file TSchemaRuleSet.cxx. ◆ GetClassCheckSum(). UInt_t TSchemaRuleSet::GetClassCheckSum ; (; ); const. Definition at line 393 of file TSchemaRuleSet.cxx. ◆ GetClassName(). TString TSchemaRuleSet::GetClassName ; (; ); const. Definition at line 403 of file TSchemaRuleSet.cxx. ◆ GetClassVersion(). Int_t TSchemaRuleSet::GetClassVersion ; (; ); const. Definition at line 410 of file TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html:15561,checksum,checksum,15561,doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"s collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const override;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:2160,hash,hash,2160,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"s contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis. To access the axis parameters, use: TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; See class TAxis for a description of all the access functions. The axis range is always stored internally in double precision. Convention for numbering bins; For all histogram types: nbins, xlow, xup bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined. For example, assuming a 3-D histogram with (binx, biny, binz), the function Int_t gbin = h->GetBin(binx, biny, binz);; int; returns a global/linearized gbin number. This global gbin is useful to access the bin content/error information independently of the dimension. Note that to access the information other than bin content and errors one should use the TAxis object directly with e.g.: Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; double; returns the center along z of bin number 27 (not the global bin) in the 3-D histogram h3. Alphanumeric Bin Labels; By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead with:. call TAxis::SetBinLabel(bin, label); This can always be done before or after filling. When the histogram is drawn, bin labels will be automatically drawn. See examples labels1.C and labels2.C; call to a Fill function with one of the arguments being a string, e.g. hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; See examples hlabels1.C and hlabels2.C; via",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:7769,access,access,7769,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['access'],['access']
Security,"s create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedObject.hxx. ◆ fgMaxSlots. template<class T > . constexpr const TNumSlots ROOT::TThreadedObject< T >::fgMaxSlots {64}. staticconstexpr . The initial number of empty processing slots that a TThreadedObject is constructed with by default. ; Deprecated: TThreadedObject grows as more slots are required. ; Definition at line 155 of file TThreadedObject.hxx. ◆ fIsMerged. template<class T > . bool ROOT::TThreadedObject< T >::fIsMerged. private . Remember if the objects have been merged already. ; Definition at line 335 of file TThreadedObject.hxx. ◆ fModel. template<class T > . std::unique_ptr<T> ROOT::TThreadedObject< T >::fModel. private . Use to store a ""model"" of the object. ; Definition at line 327 of file TThreadedObject.hxx. ◆ fObjPointers. template<class T > . std::deque<std::shared_ptr<T> > ROOT::TThreadedObject< T >::fObjPointers. private . An object pointer per slot. ; Definition at line 329 of file TThreadedObject.hxx. ◆ fSpinMutex. template<class T > . ROOT::TSpinMutex ROOT::TThreadedObject< T >::fSpinMutex. mutableprivate . Protects concurrent access to fThrIDSlotMap, fObjPointers. ; Definition at line 334 of file TThreadedObject.hxx. ◆ fThrIDSlotMap. template<class T > . std::map<std::thread::id, unsigned> ROOT::TThreadedObject< T >::fThrIDSlotMap. private . A mapping between the thread IDs and the slots. ; Definition at line 333 of file TThreadedObject.hxx. core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTThreadedObject. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TThreadedObject.html:10690,access,access,10690,doc/master/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TThreadedObject.html,1,['access'],['access']
Security,"s does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can report; 5231/// compilation and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance these interfaces so that we can report; 5255/// compilation and runtime errors properly.; 5256 ; 5257void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5258 const char* params, Bool_t objectIsConst, int* error); 5259{; 5260 R__LOCKGUARD_CLING(gInterpreterMutex);; 5261 if (error) {; 5262 *error = TInterpreter::kNoError;; 5263 }; 5264 // If the actual class of this object inherits 2nd (or more) from TObject,; 5265 // 'obj' is unlikely to be the start of the object (as described by IsA()),; 5266 // hence gInterpreter->Execute will improperly correct the offset.; 5267 void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);; 5268 Longptr_t offset = 0L;; 5269 TClingCallFunc func(GetInterpreterImpl());; 5270 func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);; 5271 void* address = (void*)((Longptr_t)addr + offset);; 5272 func.Exec(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:204337,secur,security,204337,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['secur'],['security']
Security,"s drawn with one of the 2D histogram drawing option,; 115an intermediate 2D histogram is filled using the Delaunay triangles; 116to interpolate the data set. The 2D histogram has equidistant bins along the X; 117and Y directions. The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:5418,access,accessed,5418,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['access'],['accessed']
Security,"s fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' and user 'usr'.; Checks .rootrc family files. Returned string must be deleted by the user. void RemoveHostAuth(THostAuth* ha, Option_t* opt = """"); Remove THostAuth instance from the list. void Show(Option_t* opt = ""S""); Print info about the authentication sector.; If 'opt' contains 's' or 'S' prints information about established TSecContext,; else prints information about THostAuth (if 'opt' is 'p' or 'P', prints; Proof related information). Int_t AuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); Check if we have a valid established sec context in memory; Retrieves relevant info and negotiates with server.; options = ""Opt,strlen(username),username.Data()""; message = kROOTD_USER, ... void InitRandom(); Initialize random machine using seed from /dev/urandom; (or current time if /dev/urandom not available). Int_t GenRSAKeys(); Generate a valid pair of private/public RSA keys to protect for; authentication token exchange. char * GetRandString(Int_t Opt, Int_t Len); Allocates and fills a 0 terminated buffer of length len+1 with; len random characters.; Returns pointer to the buffer (to be deleted by the caller); opt = 0 any non dangerous char; 1 l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:18782,authenticat,authentication,18782,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"s for different locations; Bool_tfScanGlobalDir! when enabled (default), scan gROOT for histograms, canvases, open files; TList*fSinfo! last produced streamer info; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSniffer(const char* name, const char* objpath = ""Objects""); constructor. ~TRootSniffer(); destructor. void SetCurrentCallArg(THttpCallArg* arg); set current http arguments, which then used in different process methods; For instance, if user authorized with some user name,; depending from restrictions some objects will be invisible; or user get full access to the element. void SetAutoLoad(const char* scripts = """"); When specified, _autoload attribute will be always add; to top element of h.json/h.hml requests; Used to instruct browser automatically load special code. const char* GetAutoLoad() const; return name of configured autoload scripts (or 0). void Restrict(const char* path, const char* options); Restrict access to the specified location. Hides or provides read-only access to different parts of the hierarchy; Restriction done base on user-name specified with http requests; Options can be specified in URL style (separated with &); Following parameters can be specified:; visible = [all|user(s)] - make item visible for all users or only specified user; hidden = [all|user(s)] - make item hidden from all users or only specified user; readonly = [all|user(s)] - make item read-only for all users or only specified user; allow = [all|user(s)] - make full access for all users or only specified user; allow_method = method(s) - allow method(s) execution even when readonly flag specified for the object; Like make command seen by all but can be executed only by admin; sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account; sniff->Restrict(""/CmdRebin"",""hidden=guest"");. Bool_t HasRestriction(const char* item_name); Made fast check if item with specified nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSniffer.html:10391,access,access,10391,root/html534/TRootSniffer.html,https://root.cern,https://root.cern/root/html534/TRootSniffer.html,1,['access'],['access']
Security,"s for source info elements (copyright, last changed, author); static set<string>fgKeywordsC++ keywords; static TDocParser::(anonymous)kClassDoc_Ignore; static TDocParser::(anonymous)kClassDoc_LookingHaveSomething; static TDocParser::(anonymous)kClassDoc_LookingNothingFound; static TDocParser::(anonymous)kClassDoc_NumStates; static TDocParser::(anonymous)kClassDoc_Uninitialized; static TDocParser::(anonymous)kClassDoc_Written; static TDocParser::EDocContextkDocClass; static TDocParser::EDocContextkDocFunc; static TDocParser::EDocContextkIgnore; static TDocParser::EDocContextkNumDocContexts. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocParser.html:12497,access,accessible,12497,root/html602/TDocParser.html,https://root.cern,https://root.cern/root/html602/TDocParser.html,2,['access'],['accessible']
Security,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←. TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:11851,access,access,11851,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,1,['access'],['access']
Security,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:11827,access,access,11827,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,1,['access'],['access']
Security,"s generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Tue Jun 30 14:33:01 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:21179,access,accessor,21179,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,1,['access'],['accessor']
Security,"s generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Tue Mar 10 17:16:49 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormula.html:16392,access,accessor,16392,root/html534/RooFormula.html,https://root.cern,https://root.cern/root/html534/RooFormula.html,1,['access'],['accessor']
Security,s how to run items of work asynchronously with a TTaskGroup ;  mt302_TTaskGroupNested.C Calculate Fibonacci numbers exploiting nested parallelism through TTaskGroup ;  mt303_AsyncSimple.C Shows how to run items of work asynchronously with Async ;  mt304_AsyncNested.C Calculate Fibonacci numbers exploiting nested parallelism through Async ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mt305_TFuture.C Shows how to use the Future class of ROOT as a wrapper of std::future ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallel,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:136205,authenticat,authentication,136205,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['authenticat'],['authentication']
Security,"s if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(); regression response. const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. Bool_t MonitorBoost(TMVA::MethodBoost* ); perfrom extra actions during the boosting at different stages. {return kFALSE;}. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:30122,access,accessors,30122,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,3,['access'],['accessors']
Security,"s in different namespaces, we can; 152# stack multiple @pythonization decorators. For example, if we define these; 153# classes:; 154ROOT.gInterpreter.Declare('''; 155class FirstClass {};; 156namespace NS {; 157 class SecondClass {};; 158}; 159'''); 160 ; 161# We can pythonize both of them with a single pythonizor function like so:; 162@pythonization('FirstClass'); 163@pythonization('SecondClass', ns='NS'); 164def pythonizor_for_first_and_second(klass, name):; 165 print('Executed for class ' + name); 166 ; 167# If we now access both classes, we should see that the pythonizor runs twice.; 168f = ROOT.FirstClass(); 169s = ROOT.NS.SecondClass(); 170 ; 171# So far we have seen how pythonizations can be registered for classes that; 172# have not been used yet. We have discussed how, in that case, the pythonizor; 173# functions are executed lazily when their target class/es are used for the; 174# first time in the application.; 175# However, it can also happen that our target class/es have already been; 176# accessed by the time we register a pythonization. In such a scenario, the; 177# pythonizor is applied immediately (at registration time) to the target; 178# class/es.; 179 ; 180# Let's see an example of what was just explained. We will define a new class; 181# and immediately create an object of that class. We can check how the object; 182# still does not have a new attribute `pythonized` that we are going to inject; 183# in the next step.; 184ROOT.gInterpreter.Declare('''; 185class MyClass2 {};; 186'''); 187o = ROOT.MyClass2(); 188try:; 189 print(o.pythonized); 190except AttributeError:; 191 print(""Object has not been pythonized yet!""); 192 ; 193# After that, we will register a pythonization for `MyClass2`. Since the class; 194# has already been used, the pythonization will happen right away.; 195@pythonization('MyClass2'); 196def pythonizor_for_myclass2(klass):; 197 klass.pythonized = True; 198 ; 199# Now our object does have the `pythonized` attribute:; 200print(o.p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:8788,access,accessed,8788,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['access'],['accessed']
Security,"s in this branch. ; Reimplemented in THbookBranch.; Definition at line 2838 of file TBranch.cxx. ◆ SetEntryOffsetLen(). void TBranch::SetEntryOffsetLen ; (; Int_t ; len, . bool ; updateSubBranches = false . ). virtual . Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ; Definition at line 2821 of file TBranch.cxx. ◆ SetFile() [1/2]. void TBranch::SetFile ; (; const char * ; fname). virtual . Set file where this branch writes/reads its buffers. ; By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch files to a different location in the file system and still access the branch files. The ROOT file will be connected only when necessary. If called by TBranch::Fill (via TBasket::WriteFile), the file will be created with the option ""recreate"". If called by TBranch::GetEntry (via TBranch::GetBasket), the file will be opened in read mode. To open a file in ""update"" mode or with a certain compression level, use TBranch::SetFile(TFile *file). ; Definition at line 2908 of file TBranch.cxx. ◆ SetFile() [2/2]. void TBranch::SetFile ; (; TFile * ; file = nullptr). virtual . Set file where this branch writes/reads its buffers. ; By default the branch buffers reside in the file where the Tree was created. If the file name where the tree was created is an absolute path name or an URL (e.g. or root://host/...) and if the fname is not an absolute path name or an URL then the path of the tree file is prepended to fname to make the branch file relative to the tree file. In this case one can move the tree + all branch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:64225,access,access,64225,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['access'],['access']
Security,"s in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; virtual Int_t GetEntries () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQConnectionList.html:6286,hash,hash,6286,doc/master/classTQConnectionList.html,https://root.cern,https://root.cern/doc/master/classTQConnectionList.html,1,['hash'],['hash']
Security,"s in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; virtual Int_t GetEntries () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofOutputList.html:6837,hash,hash,6837,doc/master/classTProofOutputList.html,https://root.cern,https://root.cern/doc/master/classTProofOutputList.html,1,['hash'],['hash']
Security,"s in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; virtual Int_t GetEntries () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGridJobStatusList.html:6157,hash,hash,6157,doc/master/classTGridJobStatusList.html,https://root.cern,https://root.cern/doc/master/classTGridJobStatusList.html,11,['hash'],['hash']
Security,"s in this collection inherit from class cl. ;  ; TIter begin () const;  ; void Browse (TBrowser *b) override;  Browse this collection (called by TBrowser). ;  ; Int_t Capacity () const;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an collection using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TCollection objects. ;  ; Bool_t Contains (const char *name) const;  ; Bool_t Contains (const TObject *obj) const;  ; void Draw (Option_t *option="""") override;  Draw all objects in this collection. ;  ; void Dump () const override;  Dump all objects in this collection. ;  ; TIter end () const;  ; virtual Int_t GetEntries () const;  ; const char * GetName () const override;  Return name of this collection. ;  ; virtual Int_t GetSize () const;  Return the capacity of the collection, i.e. ;  ; virtual Int_t GrowBy (Int_t delta) const;  Increase the collection's capacity by delta slots. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsArgNull (const char *where, const TObject *obj) const;  Returns true if object is a null pointer. ;  ; virtual Bool_t IsEmpty () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsOwner () const;  ; Bool_t IsSortable () const override;  ; R__ALWAYS_INLINE Bool_t IsUsingRWLock () const;  ; void ls (Option_t *option="""") const override;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditHist.html:5947,hash,hash,5947,doc/master/classTGTextEditHist.html,https://root.cern,https://root.cern/doc/master/classTGTextEditHist.html,1,['hash'],['hash']
Security,"s in this file. ;  ; void FillBuffer (char *&) final;  Encode file output buffer. ;  ; void Flush () final;  Synchronize a file's in-memory and on-disk states. ;  ; Int_t GetArrayLimit () const;  ; const char * GetDataBaseName () const;  Return name of data base on the host For Oracle always return 0. ;  ; Long64_t GetEND () const final;  ; Int_t GetErrno () const final;  Method returning errno. ;  ; Int_t GetIOVersion () const;  ; Int_t GetNbytesFree () const final;  ; Int_t GetNbytesInfo () const final;  ; Int_t GetNfree () const final;  ; Int_t GetQuerisCounter () const;  ; Long64_t GetSeekFree () const final;  ; Long64_t GetSeekInfo () const final;  ; Long64_t GetSize () const final;  Returns the current file size. ;  ; const char * GetTablesType () const;  ; Int_t GetUseIndexes () const;  ; Bool_t GetUseSuffixes () const;  ; Int_t GetUseTransactions () const;  ; TClass * IsA () const override;  ; Bool_t IsMySQL () const;  checks, if MySQL database ;  ; Bool_t IsODBC () const;  checks, if ODBC driver used for database connection ;  ; Bool_t IsOpen () const final;  return kTRUE if file is opened and can be accessed ;  ; Bool_t IsOracle () const;  checks, if Oracle database ;  ; void MakeFree (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; TString MakeSelectQuery (TClass *cl);  Produce SELECT statement which can be used to get all data of class cl in one SELECT statement. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:11914,access,accessed,11914,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['accessed']
Security,"s inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:10035,access,accessors,10035,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,6,['access'],['accessors']
Security,"s may cause an annoying but harmless compiler warning:; Myclass.cxx:98: warning:; converting from ""void (Myclass::*)(void *)""to ""void *"" ); Strictly speaking, Thread0 must be a static member function to be called from a thread. Some compilers, for example gcc version 2.95.2, may not allow the (void(*) (void*))s cast and just stop if Thread0 is not static. On the other hand, if Thread0 is static, no compiler warnings are generated at all. Because the 'this' pointer is passed in 'arg' in the call to Thread0(void *arg), you have access to the instance of the class even if Thread0 is static. Using the 'this' pointer, non static members can still be read and written from Thread0, as long as you have provided Getter and Setter methods for these members. For example:; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; Second, the pointer to the current instance of Myclass, i.e. (void*) this, has to be passed as first argument of the threaded function Thread0 (C++ member functions internally expect this pointer as first argument to have access to class members of the same instance). pthreads are made for simple C functions and do not know about Thread0 being a member function of a class. Thus, you have to pass this information by hand, if you want to access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1115612,access,access,1115612,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"s needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. Int_t DeleteVariable(const char* name); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:23405,access,accessed,23405,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['access'],['accessed']
Security,"s never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an object-oriented program that pointer names rarely reflect the fact - you have to be careful that you know if you are dealing with an object or its pointer! Fortunately, the compiler won’t tolerate an attempt to do something like:; root[] my_objptr.Solve();; As we have seen, heap objects have to be accessed via pointers, whereas stack objects can be accessed directly. They can also be accessed via pointers:; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; Here we have a Quad pointer that has been initialized with the address of a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit wise complement, and hence has destruction overtones! We declare it in the .h file and define i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:252526,access,accessed,252526,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedCollectionProxy.h>. Inheritance diagram for TEmulatedCollectionProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Cont_t. typedef std::vector<char> TEmulatedCollectionProxy::Cont_t. Definition at line 25 of file TEmulatedCollectionProxy.h. ◆ PCont_t. typedef Cont_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:12759,access,accessors,12759,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . #include <TEmulatedMapProxy.h>. Inheritance diagram for TEmulatedMapProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEmulatedMapProxy() [1/2]. TEmulatedMapProxy::TEmulatedMapProxy ; (; const TEmulatedMapProxy & ; copy). Definition at line 39 of file TEmulatedMapProxy.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedMapProxy.html:12897,access,accessors,12897,doc/master/classTEmulatedMapProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedMapProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenBitsetProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenBitsetProxy(). TGenBitsetProxy::TGenBitsetProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 138 of file TGenCollectionProxy.cxx. ◆ ~TGenBitsetProxy(). TGenBitsetPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:10913,access,accessors,10913,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenListProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenListProxy(). TGenListProxy::TGenListProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 193 of file TGenCollectionProxy.cxx. ◆ ~TGenListProxy(). TGenListProxy::~TGenLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenListProxy.html:11051,access,accessors,11051,doc/master/classTGenListProxy.html,https://root.cern,https://root.cern/doc/master/classTGenListProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenMapProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenMapProxy(). TGenMapProxy::TGenMapProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 280 of file TGenCollectionProxy.cxx. ◆ ~TGenMapProxy(). TGenMapProxy::~TGenMapProxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenMapProxy.html:11485,access,accessors,11485,doc/master/classTGenMapProxy.html,https://root.cern,https://root.cern/doc/master/classTGenMapProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenSetProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenSetProxy(). TGenSetProxy::TGenSetProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 235 of file TGenCollectionProxy.cxx. ◆ ~TGenSetProxy(). TGenSetProxy::~TGenSetProxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenSetProxy.html:11246,access,accessors,11246,doc/master/classTGenSetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenSetProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorBoolProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenVectorBoolProxy(). TGenVectorBoolProxy::TGenVectorBoolProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 92 of file TGenCollectionProxy.cxx. ◆ ~TGenVectorBoolPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorBoolProxy.html:11108,access,accessors,11108,doc/master/classTGenVectorBoolProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorBoolProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Inheritance diagram for TGenVectorProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGenVectorProxy(). TGenVectorProxy::TGenVectorProxy ; (; const TGenCollectionProxy & ; c). inline . Definition at line 42 of file TGenCollectionProxy.cxx. ◆ ~TGenVectorProxy(). TGenVectorPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenVectorProxy.html:11028,access,accessors,11028,doc/master/classTGenVectorProxy.html,https://root.cern,https://root.cern/doc/master/classTGenVectorProxy.html,1,['access'],['accessors']
Security,"s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions; TGenCollectionStreamer & operator= (const TGenCollectionStreamer &);  . Additional Inherited Members;  Public Types inherited from TGenCollectionProxy; enum  { kBIT_ISSTRING = 0x20000000; , kBIT_ISTSTRING = 0x40000000; };  ; typedef const std::type_info & Info_t;  ;  Public Types inherited from TVirtualCollectionProxy; typedef void *(* CopyIt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:11402,access,accessors,11402,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security,s of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWise;  ;  Protected Attributes inherited from TVirtualCollectionProxy; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions;  TGenCollectionProxy ();  ; TGenCollectionProxy & operator= (const TGenCollectionProxy &);  . Friends; class TCollectionProxyFactory;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:11464,access,accessors,11464,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:23051,access,access,23051,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['access'],['access']
Security,"s read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfBasicUrlbasic url without authentication and options; TStringfBasicUrlOrgsave original url in case of temp redirection; Bool_tfHTTP11true if server support HTTP/1.1; Bool_tfHasModRoottrue if server has mod_root installed; TStringfMsgGetHeadcache GetHead() msg; TStringfMsgReadBuffercache ReadBuffer() msg; TStringfMsgReadBuffer10cache ReadBuffer10() msg; Bool_tfNoProxydon't use proxy; TUrlfProxyproxy URL; Long64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.1 (stays alive between calls); TUrlfUrlOrgsave original url in case of temp redirection; static TUrlfgProxyglobally set proxy URL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=htt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:22174,authenticat,authentication,22174,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,2,['authenticat'],['authentication']
Security,"s starting from the root, coded as 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right ; Definition at line 1231 of file DecisionTree.cxx. ◆ GetNodePurityLimit(). Double_t TMVA::DecisionTree::GetNodePurityLimit ; (; ); const. inline . Definition at line 162 of file DecisionTree.h. ◆ GetPruneStrength(). Double_t TMVA::DecisionTree::GetPruneStrength ; (; ); const. inline . Definition at line 147 of file DecisionTree.h. ◆ GetRandomisedVariables(). void TMVA::DecisionTree::GetRandomisedVariables ; (; Bool_t * ; useVariable, . UInt_t * ; variableMap, . UInt_t & ; nVars . ). Definition at line 1247 of file DecisionTree.cxx. ◆ GetRoot(). virtual DecisionTreeNode * TMVA::DecisionTree::GetRoot ; (; ); const. inlinevirtual . Reimplemented from TMVA::BinaryTree.; Definition at line 94 of file DecisionTree.h. ◆ GetSumWeights(). Double_t TMVA::DecisionTree::GetSumWeights ; (; const EventConstList * ; validationSample); const. calculate the normalization factor for a pruning validation sample ; Definition at line 1118 of file DecisionTree.cxx. ◆ GetTreeID(). Int_t TMVA::DecisionTree::GetTreeID ; (; ). inline . Definition at line 186 of file DecisionTree.h. ◆ GetVariableImportance() [1/2]. vector< Double_t > TMVA::DecisionTree::GetVariableImportance ; (; ). Return the relative variable importance, normalized to all variables together having the importance 1. ; The importance in evaluated as the total separation-gain that this variable had in the decision trees (weighted by the number of events) ; Definition at line 2745 of file DecisionTree.cxx. ◆ GetVariableImportance() [2/2]. Double_t TMVA::DecisionTree::GetVariableImportance ; (; UInt_t ; ivar). returns the relative importance of variable ivar ; Definition at line 2766 of file DecisionTree.cxx. ◆ IsA(). virtual TClass * TMVA::DecisionTree::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::BinaryTree.; Definition at line 243 of file DecisionTree.h. ◆ PruneNode()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:21804,validat,validation,21804,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validation']
Security,"s to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  ;  Static Public Member Functions inherited from TGWidget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void Copy (TObject &) const override;  Copy this to obj. ;  ; void DrawRegion (Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Draw lines in exposed region. ;  ; virtual void HLayout ();  Horizontal layout of widgets (canvas, scrollbar). ;  ; void Init (Pixel_t bg);  Initialize a text view widget. ;  ; virtual void Mark (Long_t xPos, Long_t yPos);  Mark a text region from xPos to yPos. ;  ; virtual void UnMark ();  Clear marked region. ;  ; virtual void VLayout ();  Vertical layout of widgets (canvas, scrollbar). ;  ;  Protected Member Functions inherited from TGView; void DoRedraw () override;  redraw ;  ; virtual Bool_t ItemLayout ();  ; virtual void UpdateRegion (Int_t x, Int_t y, UInt_t w, UInt_t h);  update a part of view ;  ;  Protected Member Functions inherited from TGFrame; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextView.html:30911,expose,exposed,30911,doc/master/classTGTextView.html,https://root.cern,https://root.cern/doc/master/classTGTextView.html,1,['expose'],['exposed']
Security,"s will affect next generation operation (only) ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html:3114,hash,hash,3114,doc/master/classRooStats_1_1UpperLimitMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1UpperLimitMCSModule.html,1,['hash'],['hash']
Security,"s() and GetFieldName() methods.; To recieve data for next result row, NextResultRow() method should be called.; Value from each column can be taken with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitation which method should be used; to get column values. GetString() can be used as generic method,; which should always return correct result, but also convertion between most; basic data types are supported. For instance, if column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has float point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; integer part of the value. One also can test, if value is NULL with IsNull(); method. Buffer length, specified for statement in TSQLServer::Statement() call,; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit number of rows,; which can be accessed with one statement. Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. Current implementation supports date, time, date&time and timestamp; data (all time intervals not supported yet). To set or get date/time values,; following methods should be used:; SetTime()/GetTime() - only t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:6147,access,accessed,6147,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,3,['access'],['accessed']
Security,"s) listed in categoryNameList and that remainder fraction formula be put in state with name remainderStateName. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool_1_1SplitRule.html:1857,hash,hash,1857,doc/master/classRooSimWSTool_1_1SplitRule.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool_1_1SplitRule.html,1,['hash'],['hash']
Security,"s); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605Bool_t TFormula::InitLambdaExpression(const char * formula) {; 606 ; 607 std::string lambdaExpression = formula;; 608 ; 609 // check if formula exist already in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:23063,hash,hasher,23063,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['hash'],['hasher']
Security,"s);  ; void StopEmbedding (const char *name="""");  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html:8390,hash,hash,8390,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooBrowser.html,1,['hash'],['hash']
Security,"s)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; static TCollection::(anonymous)TCollection::kIsOwner. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashTable.html:9434,hash,hashtable,9434,root/html602/THashTable.html,https://root.cern,https://root.cern/root/html602/THashTable.html,2,['hash'],['hashtable']
Security,"s, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:9824,hash,hash,9824,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,3,['hash'],['hash']
Security,"s,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigaby",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:8990,access,access,8990,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,3,['access'],['access']
Security,"s. ; At the moment two engine kinds are supported:. civetweb or http (default); fastcgi. Examples: // creates civetweb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_process = kFALSE . ). Execute WS request. ; Execute WS related operation. ; Definition at line 1299 of file THttpServer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23753,access,access,23753,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['access']
Security,"s. Additionally --with-png=no --with-bzip2=no flags are passed to freetype configuration script. Default values for these options are auto. freetype finds libpng and libbzip2 on the system and builds extra modules. Then attempting to link against freetype one would need to link -lpng -lbzip2 explicitly otherwise linking will returns in undefined references. Otherwise we would need to check for libpng and libbzip2 on the system and adjust FREETYPE_LIBRARIES to include -lpng and -lbzip2. The current solution goes for the minimal configuration. The original request for this update was posted here.; 3D Graphics Libraries; Geometry Libraries; Database Libraries; Networking Libraries; THttpServer; Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class; When command is registered with THttpServer::RegisterCommand() method, one could configure additional arguments which should be submitted when command is executed with cmd.json requests; Introduce restriction rules for objects access with THttpServer::Restrict() method. Up to now general read-only flag was applied - either everything read-only or everything is fully accessible. Now one could restrict access to different parts of objects hierarchy or even fully ‘hide’ them from the client. Restriction based on user account name, which is applied when htdigest authentication is configured. One also able to allow execution of selected methods.; Implement multi.bin and multi.json requests. One could request many items with single HTTP request. Let optimize communication between server and client.; With SNIFF tag in ClassDef() comments one could expose different properties, which than exposed by the TRootSniffer to the client with h.json requests. Such possibility ease implementation of client-side code for custom classes.; Allow to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:18429,access,accessible,18429,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['accessible']
Security,"s. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12466,password,password-hash,12466,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,14,"['password', 'secur']","['password-hash', 'secure']"
Security,"s.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list of function to; 2638/// properly handle the hashes.; 2639 ; 2640void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:102040,hash,hashes,102040,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['hash'],['hashes']
Security,"s.cxx. ◆ TClass() [6/8]. TClass::TClass ; (; ClassInfo_t * ; classInfo, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; Create a TClass object. This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1224 of file TClass.cxx. ◆ TClass() [7/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1275 of file TClass.cxx. ◆ TClass() [8/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1304 of file TClass.cxx. ◆ ~TClass(). TClass::~TClass ; (; ). virtual . TClass dtor. Deletes all list that might have been created. ; Definition at line 1660 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 494 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:51540,access,access,51540,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security,"s.cxx. ◆ TClass() [6/8]. TClass::TClass ; (; ClassInfo_t * ; classInfo, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; Create a TClass object. This object contains the full dictionary of a class. It has list to baseclasses, datamembers and methods. Use this ctor to create a standalone TClass object. Most useful to get a TClass interface to an interpreted class. Used by TTabCom.; This copies the ClassInfo (i.e. does not take ownership of it).; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1291 of file TClass.cxx. ◆ TClass() [7/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const char * ; dfil, . const char * ; ifil = nullptr, . Int_t ; dl = 0, . Int_t ; il = 0, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1342 of file TClass.cxx. ◆ TClass() [8/8]. TClass::TClass ; (; const char * ; name, . Version_t ; cversion, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il, . Bool_t ; silent = kFALSE . ). Internal constructor. ; NoteUse TClass::GetClass(""class"") to get access to a TClass object for a certain class! ; Definition at line 1371 of file TClass.cxx. ◆ ~TClass(). TClass::~TClass ; (; ). virtual . TClass dtor. Deletes all list that might have been created. ; Definition at line 1727 of file TClass.cxx. Member Function Documentation. ◆ AddClass(). void TClass::AddClass ; (; TClass * ; cl). static . static: Add a class to the list and map of classes. ; Definition at line 555 of file TClass.cxx. ◆ AddClassToDeclIdMap(). void TClass::AddClassToDeclIdMap ; (; TDictionary::DeclId_t ; id, . TClass * ; cl . ). static . static: Add a TClass* to the map of classes. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:51541,access,access,51541,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security,"s.h:110; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255180,checksum,checksum,255180,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['checksum'],['checksum']
Security,"s/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ; Definition at line 132 of file RWebWindow.cxx. ◆ SetPosition(). void ROOT::RWebWindow::SetPosition ; (; unsigned ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 269 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 316 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1953 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 324 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1310 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:48135,access,access,48135,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"s/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ; Definition at line 132 of file RWebWindow.cxx. ◆ SetPosition(). void ROOT::RWebWindow::SetPosition ; (; unsigned ; x, . unsigned ; y . ). inline . Set window position. Will be applied if supported by used web display (like CEF or Chromium) ; Definition at line 272 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 319 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1995 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 327 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1352 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:47019,access,access,47019,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"s; 120 static ThreadsMap_t *fgThreadId; //! Thread id's map; 121 static Int_t fgNumThreads; //! Number of registered threads; 122 static Bool_t fgLockNavigators; //! Lock existing navigators; 123 TGeoNavigator *fCurrentNavigator; //! current navigator; 124 TGeoVolume *fCurrentVolume; //! current volume; 125 TGeoVolume *fTopVolume; //! top level volume in geometry; 126 TGeoNode *fTopNode; //! top physical node; 127 TGeoVolume *fMasterVolume; // master volume; 128 TGeoHMatrix *fGLMatrix; // matrix to be used for view transformations; 129 TObjArray *fUniqueVolumes; //-> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:6447,hash,hash,6447,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['hash'],['hash']
Security,"s; Dark and bright colors are used to add 3D effects to graphical objects like TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; Two static functions are available that return the bright or dark color number corresponding to a given color index. If these variants don't already exist, they are created as needed: Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130. Accessible Color Schemes; Choosing an appropriate color scheme is essential for making results easy to understand and interpret. Factors like colorblindness and converting colors to grayscale for publications can impact accessibility. Furthermore, results should be aesthetically pleasing. The following three color schemes, recommended by M. Petroff in arXiv:2107.02270v2 and available on GitHub under the MIT License, meet these criteria.; These three color schemes are available as color sets with 6, 8, and 10 colors, named kP[6, 8, 10]ColorName. For example, kP6Red represents the red color within the P6 color scheme (P for Petroff or Preferred). The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings. It also demonstrates that they are effective in grayscale. Grayscale view of of canvas with colors; One can toggle between a grayscale preview and the regular colored mode using TCanvas::SetGrayscale(). Note that in grayscale mode, access via RGB will return grayscale values according to ITU standards (and close to b&w printer gray-scales), while access via HLS returns de-saturated gray-scales. The image below shows the ROOT co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:6329,access,accessibility,6329,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['access'],['accessibility']
Security,"s; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verbose",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataWeightedAverage.html:40592,access,access,40592,root/html534/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html534/RooDataWeightedAverage.html,1,['access'],['access']
Security,"s; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTArchiveFile::fArchiveNameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the member header of the ZIP archive. Sets the position where; the data starts in the member object. Returns -1 in case of error,; 0 otherwise. Int_t SetCurrentMember(); Find the desired member in the member array and make it the; current member. Returns -1 in case member is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPFile.html:10158,access,access,10158,root/html528/TZIPFile.html,https://root.cern,https://root.cern/root/html528/TZIPFile.html,1,['access'],['access']
Security,"s; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTArchiveFile::fArchiveNameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Long64_t ReadZip64EndLocator(Long64_t pos); Read Zip64 end of central directory locator. Returns -1 in case of error,; -2 in case end locator magic is not found (i.e. not a zip64 file) and; offset of Zip64 end of central directory record in case of success. Int_t ReadZip64EndRecord(Long64_t pos); Read Zip64 end of central directory record. Returns -1 in case of error; and 0 in case of success. Int_t ReadDirectory(); Read the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TZIPFile.html:11651,access,access,11651,root/html530/TZIPFile.html,https://root.cern,https://root.cern/root/html530/TZIPFile.html,3,['access'],['access']
Security,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:34971,access,access,34971,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,2,['access'],['access']
Security,"s;  Precision to be used in ASCII exports. ;  ; static UInt_t fgExportPrecision = 17;  Maximum number of Xtru vertices. ;  ; static Bool_t fgLock = kFALSE;  mutex for navigator booking in MT mode ;  ; static Int_t fgMaxDaughters = 1;  Maximum level in geometry. ;  ; static Int_t fgMaxLevel = 1;  Verbosity level for Info messages (no IO). ;  ; static Int_t fgMaxXtruVert = 1;  Maximum number of daughters. ;  ; static std::mutex fgMutex;  ; static Int_t fgVerboseLevel = 1;  Lock preventing a second geometry to be loaded. ;  . Private Types; typedef std::map< std::string, Double_t > ConstPropMap_t;  ; typedef std::map< std::thread::id, TGeoNavigatorArray * > NavigatorsMap_t;  bits used for voxelization ;  ; typedef NavigatorsMap_t::iterator NavigatorsMapIt_t;  ; typedef std::map< std::thread::id, Int_t > ThreadsMap_t;  ; typedef ThreadsMap_t::const_iterator ThreadsMapIt_t;  . Private Member Functions; void Init ();  Initialize manager class. ;  ; Bool_t InitArrayPNE () const;  Initialize PNE array for fast access via index and unique-id. ;  ; Bool_t InsertPNEId (Int_t uid, Int_t ientry);  Insert a PN entry in the sorted array of indexes. ;  ; Bool_t IsLoopingVolumes () const;  ; void SetLoopVolumes (Bool_t flag=kTRUE);  ; void UpdateElements ();  Update element flags when geometry is loaded from a file. ;  ; void Voxelize (Option_t *option=nullptr);  Voxelize all non-divided volumes. ;  . Private Attributes; Bool_t fActivity;  flag for GL reflections ;  ; TObjArray * fArrayPNE;  ; UChar_t * fBits;  ; TObjArray * fBorderSurfaces;  ; TGeoShape * fClippingShape;  ; Bool_t fClosed;  ; TGeoNavigator * fCurrentNavigator;  Lock existing navigators. ;  ; TVirtualGeoTrack * fCurrentTrack;  ; TGeoVolume * fCurrentVolume;  current navigator ;  ; Bool_t fDrawExtra;  ; TGeoElementTable * fElementTable;  clipping shape for raytracing ;  ; Int_t fExplodedView;  ; TObjArray * fGDMLMatrices;  ; TGeoHMatrix * fGLMatrix;  ; TObjArray * fGShapes;  ; TObjArray * fGVolumes;  list of runtime ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:63101,access,access,63101,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['access'],['access']
Security,sArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter!; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:35424,access,access,35424,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,2,['access'],['access']
Security,"sArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches ; UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_t_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:31106,validat,validate,31106,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,2,"['access', 'validat']","['access', 'validate']"
Security,"sFromStream(istream& istr); read the state of the method from an input stream. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return the MVA value (range [-1;1]) that classifies the; event.according to the majority vote from the total number of; decision trees; In the literature I found that people actually use the; weighted majority vote (using the boost weights) .. However I; did not see any improvement in doing so :(; --> this is currently switched off. void WriteMonitoringHistosToFile( void ); here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); return the variable importance. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void ReadWeightsFromXML(void* ); {}. const std::vector<TMVA::IMethod*>& GetCommittee() const; accessors. { return fCommittee; }. const std::vector<Double_t>& GetBoostWeights() const; { return fBoostWeights; }. std::vector<IMethod*>& GetCommittee(); accessors. { return fCommittee; }. std::vector<Double_t>& GetBoostWeights(); { return fBoostWeights; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCommittee.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCommittee.html:21618,access,accessors,21618,root/html532/TMVA__MethodCommittee.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCommittee.html,2,['access'],['accessors']
Security,"sInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:27837,checksum,checksum,27837,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"sName of this class . ◆ Class_Version(). static constexpr Version_t TNetFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TNetFile.h. ◆ Close(). void TNetFile::Close ; (; Option_t * ; option = """"). overridevirtual . Close remote file. ; Reimplemented from TFile.; Definition at line 208 of file TNetFile.cxx. ◆ ConnectServer(). void TNetFile::ConnectServer ; (; Int_t * ; stat, . EMessageTypes * ; kind, . Int_t ; netopt, . Int_t ; tcpwindowsize, . Bool_t ; forceOpen, . Bool_t ; forceRead . ). protectedvirtual . Connect to remote rootd server. ; Definition at line 570 of file TNetFile.cxx. ◆ Create() [1/2]. void TNetFile::Create ; (; const char * ; url, . Option_t * ; option, . Int_t ; netopt . ). protectedvirtual . Create a NetFile object. ; A net file is the same as a TFile except that it is being accessed via a rootd server. The url argument must be of the form: root[k]://host.dom.ain/file.root. When protocol is ""rootk"" try using kerberos5 authentication. If the file specified in the URL does not exist, is not accessable or can not be created the kZombie bit will be set in the TNetFile object. Use IsZombie() to see if the file is accessable. If the remote daemon thinks the file is still connected, while you are sure this is not the case you can force open the file by preceding the option argument with an ""-"", e.g.: ""-recreate"". Do this only in cases when you are very sure nobody else is using the file. To bypass the writelock on a file, to allow the reading of a file that is being written by another process, explicitly specify the ""+read"" option (""read"" being the default option). The netopt argument can be used to specify the size of the tcp window in bytes (for more info see: http://www.psc.edu/networking/perf_tune.html). The default and minimum tcp window size is 65535 bytes. If netopt < -1 then |netopt| is the number of parallel sockets that will be used to connect to rootd. This option should be used o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:45540,authenticat,authentication,45540,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['authenticat'],['authentication']
Security,"sReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:42421,access,access,42421,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,2,['access'],['access']
Security,"sSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualBranchBrowsable. ←. TCollectionPropertyBrowsable. TMethodBrowsable; ←. TCollectionMethodBrowsable. TNonSplitBrowsable. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualBranchBrowsable.html:10346,access,access,10346,root/html602/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html,2,['access'],['access']
Security,"sSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:17639,access,accessed,17639,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,2,['access'],['accessed']
Security,"sTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THttpCallArg.html:8026,authenticat,authenticated,8026,root/html604/THttpCallArg.html,https://root.cern,https://root.cern/root/html604/THttpCallArg.html,1,['authenticat'],['authenticated']
Security,"sVersion() const; {return fClassVersion;}. TObjArray * GetElements() const; {return fElements;}. ULong_t * GetElems() const; {return fElem;}. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Bool_t forCollection); { return forCollection ? fReadMemberWise : fReadObjectWise; }. TStreamerInfoActions::TActionSequence * GetReadObjectWiseActions(); { return fReadObjectWise; }. Int_t GetNdata() const; {return fNdata;}. Int_t GetNumber() const; {return fNumber;}. Int_t * GetLengths() const; {return fLength;}. ULong_t * GetMethods() const; {return fMethod;}. Int_t * GetNewTypes() const; {return fNewType;}. Int_t * GetOffsets() const; {return fOffset;}. Version_t GetOldVersion() const; {return fOldVersion;}. Int_t GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t * GetTypes() const; {return fType;}. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first). Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TStreamerInfo.h 36061 2010-10-04 16:05:51Z pcanal $ » Last generated: 2010-12-10 21:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:25998,checksum,checksum,25998,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,2,['checksum'],['checksum']
Security,"sVersion() const; {return fClassVersion;}. TObjArray * GetElements() const; {return fElements;}. ULong_t * GetElems() const; {return fElem;}. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Bool_t forCollection); { return forCollection ? fReadMemberWise : fReadObjectWise; }. TStreamerInfoActions::TActionSequence * GetReadObjectWiseActions(); { return fReadObjectWise; }. Int_t GetNdata() const; {return fNdata;}. Int_t GetNumber() const; {return fNumber;}. Int_t * GetLengths() const; {return fLength;}. ULong_t * GetMethods() const; {return fMethod;}. Int_t * GetNewTypes() const; {return fNewType;}. Int_t * GetOffsets() const; {return fOffset;}. Version_t GetOldVersion() const; {return fOldVersion;}. Int_t GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t * GetTypes() const; {return fType;}. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first). Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TStreamerInfo.h 38460 2011-03-16 15:28:08Z pcanal $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStreamerInfo.html:26080,checksum,checksum,26080,root/html530/TStreamerInfo.html,https://root.cern,https://root.cern/root/html530/TStreamerInfo.html,2,['checksum'],['checksum']
Security,"sZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXML objects When saving, all this elements are linked to root xml node At the end StreamerInfo structures are added After xml document is saved, all nodes will be unlinked from root node and kept in memory. ; Only Close() or destructor release memory, used by xml structures ; Definition at line 454 of file TXMLFile.cxx. ◆ Seek(). void TXMLFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). inlinefinalvirtual . Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ; Reimplemented from TFile.; Definition at line 88 of file TXMLFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:68209,access,access,68209,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['access'],['access']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSortedList.html:15345,access,accessible,15345,doc/master/classTSortedList.html,https://root.cern,https://root.cern/doc/master/classTSortedList.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Additional Inherited Members;  Public Types inherited from TObjArray; typedef TObjArrayIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsiste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:16109,access,accessible,16109,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TGeoNavigatorArray (const TGeoNavigatorArray &)=delete;  ; TGeoNavigatorArray & operator= (const TGeoNavigatorArray &)=delete;  . Private Attributes; TGeoNavigator * fCurrentNavigator;  ; TGeoManager * fGeoManager;  . Additional Inherited Members;  Public Types inherited from TObjArray; typedef TObjArrayIter Iterator_t;  ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigatorArray.html:16350,access,accessible,16350,doc/master/classTGeoNavigatorArray.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigatorArray.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TListOfDataMembers (const TListOfDataMembers &)=delete;  Whether the list should contain regular data members or only using decls or both. ;  ; void MapObject (TObject *obj);  Add a pair<id, object> to the map of data members and their ids. ;  ; TListOfDataMembers & operator= (const TListOfDataMembers &)=delete;  ; void Unma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:18907,access,accessible,18907,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TListOfFunctions (const TListOfFunctions &)=delete;  ; TList * GetListForObjectNonConst (const char *name);  Return the set of overloads for this name, collecting all available ones. ;  ; void MapObject (TObject *obj);  Add pair<id, object> to the map of functions and their ids. ;  ; TListOfFunctions & operator= (const TList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:18464,access,accessible,18464,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TOrdCollection (const TOrdCollection &)=delete;  ; Bool_t IllegalIndex (const char *method, Int_t idx) const;  Return true when index out of bounds and print error. ;  ; void Init (Int_t capacity);  Initialize ordered collection. ;  ; Int_t LogIndex (Int_t idx) const;  ; Bool_t LowWaterMark () const;  ; void MoveGapTo (Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTOrdCollection.html:15733,access,accessible,15733,doc/master/classTOrdCollection.html,https://root.cern,https://root.cern/doc/master/classTOrdCollection.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Types; typedef TDictionary::DeclId_t DeclId_t;  . Private Member Functions;  TListOfEnumsWithLock (const TListOfEnumsWithLock &)=delete;  ; TListOfEnumsWithLock & operator= (const TListOfEnumsWithLock &)=delete;  . Additional Inherited Members;  Public Types inherited from TListOfEnums; typedef TDictionary::DeclId_t DeclId_t;  ;  Public Types ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:17487,access,accessible,17487,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Types; typedef TDictionary::DeclId_t DeclId_t;  . Private Member Functions;  TListOfFunctionTemplates (const TListOfFunctionTemplates &)=delete;  ; TList * GetListForObjectNonConst (const char *name);  Return the set of overloads for this name, collecting all available ones. ;  ; void MapObject (TObject *obj);  Add pair<id, object> to the map ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:17603,access,accessible,17603,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TClass * fClass;  ; TObjArray * fKeep;  Pointer to the class of the elements. ;  ;  Protected Attributes inherited from TObjArray; TObject ** fCont;  ; Int_t fLast;  ; Int_t fLowerBound;  Array contents. ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:24297,access,accessible,24297,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:17836,access,accessible,17836,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fJobID;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Att",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGridJobStatusList.html:15547,access,accessible,15547,doc/master/classTGridJobStatusList.html,https://root.cern,https://root.cern/doc/master/classTGridJobStatusList.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; TObject * GetFromTable (Int_t idx) const;  the reference may be in the TRefTable ;  ; Bool_t GetObjectUID (Int_t &uid, TObject *obj, const char *methodname);  Private/static function, check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefArray.html:20704,access,accessible,20704,doc/master/classTRefArray.html,https://root.cern,https://root.cern/doc/master/classTRefArray.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Bool_t BoundsOk (const char *where, Int_t at) const;  ; Int_t GetAbsLast () const;  Return absolute index to last object in array. ;  ; void Init (Int_t s, Int_t lowerBound);  Initialize a TObjArray. ;  ; Bool_t OutOfBoundsError (const char *where, Int_t i) const;  Generate an out-of-bounds error. Always returns false. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray.html:17836,access,accessible,17836,doc/master/classTObjArray.html,https://root.cern,https://root.cern/doc/master/classTObjArray.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; TEnum * FindUnloaded (const char *name);  ; TEnum * Get (DeclId_t id, const char *name);  Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'. ;  ; TClass * GetClass () const;  ; TExMap * GetIds ();  ;  Protected Member Functions inherited from TList; TObjLinkPtr_t * DoSort (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:18040,access,accessible,18040,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void DecrNofKeys ();  ; Int_t IdxAdd (const TObject &obj);  Add object and return its index in the tree. ;  ; void IncrNofKeys ();  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:23148,access,accessible,23148,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSeqCollection.html:12961,access,accessible,12961,doc/master/classTSeqCollection.html,https://root.cern,https://root.cern/doc/master/classTSeqCollection.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; using TObjLinkPtr_t = std::shared_ptr< TObjLink >;  ; using TObjLinkWeakPtr_t = std::weak_ptr< TObjLink >;  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Prote",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:18642,access,accessible,18642,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TList; using TObjLinkPtr_t = std::shared_ptr< TObjLink >;  ; using TObjLinkWeakPtr_t = std::weak_ptr< TObjLink >;  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditHist.html:15920,access,accessible,15920,doc/master/classTGTextEditHist.html,https://root.cern,https://root.cern/doc/master/classTGTextEditHist.html,8,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Attributes; TString fTitle;  . Additional Inherited Members;  Protected Types inherited from TList; using TObjLinkPtr_t = std::shared",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordSelect.html:18799,access,accessible,18799,doc/master/classTParallelCoordSelect.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordSelect.html,1,['access'],['accessible']
Security,"s_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t ObjCompare (TObject *a, TObject *b);  Compare to objects in the collection. Use member Compare() of object a. ;  ; static void QSort (TObject **a, Int_t first, Int_t last);  Sort array of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);  Sort array a of TObject pointers using a quicksort algorithm. ;  ; static void QSort (TObject **a, TObject **b, Int_t first, Int_t last);  ;  Static Public Member Functions inherited from TCollection; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void EmptyGarbageCollection ();  Do the garbage collection. ;  ; static void GarbageCollect (TObject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TQObject; static Bool_t AreAllSignalsBlocked ();  Returns true if all signals are blocked. ;  ; static Bool_t BlockAllSignals (Bool_t b);  Block or unblock all signals. Returns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:24436,access,accessible,24436,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,3,['access'],['accessible']
Security,"sable::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TVirtualBranchBrowsable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TVirtualBranchBrowsable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 99 of file TBranchBrowsable.h. ◆ DeclFileName(). static const char * TVirtualBranchBrowsable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 99 of file TBranchBrowsable.h. ◆ FillListOfBrowsables(). Int_t TVirtualBranchBrowsable::FillListOfBrowsables ; (; TList & ; li, . const TBranch * ; branch, . const TVirtualBranchBrowsable * ; parent = nullptr . ). static . Askes all registered generators to fill their browsables into the list. ; The browsables are generated for a given parent, or (if 0), for a given branch. The branch is passed down to leaves of TVirtualBranchBrowsable, too, as we need to access the branch's TTree to be able to traw. ; Definition at line 138 of file TBranchBrowsable.cxx. ◆ GetBranch(). const TBranch * TVirtualBranchBrowsable::GetBranch ; (; ); const. inline . return the parent branch (might be many levels up) ; Definition at line 60 of file TBranchBrowsable.h. ◆ GetClassType(). TClass * TVirtualBranchBrowsable::GetClassType ; (; ); const. inline . return the type of this browsable object ; Definition at line 66 of file TBranchBrowsable.h. ◆ GetCollectionContainedType(). TClass * TVirtualBranchBrowsable::GetCollectionContainedType ; (; const TBranch * ; branch, . const TVirtualBranchBrowsable * ; parent, . TClass *& ; contained . ). staticprotected . Check whether the branch (or the parent) contains a collection. ; If it does, set ""contained"" to the contained type (if we can retrieve it) and return the TClass for the collection. Set ""contained"" to the branch's (or parent's) contained object's class for non-collections, returning 0.; On",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualBranchBrowsable.html:19033,access,access,19033,doc/master/classTVirtualBranchBrowsable.html,https://root.cern,https://root.cern/doc/master/classTVirtualBranchBrowsable.html,1,['access'],['access']
Security,"sary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any changed information is accepted and again displayed in the window that remains open;; Close - closes the window;; Help - opens online Help.; Below are examples of text buttons. Note the two placement methods. The first example should be used when there are one to three command buttons; the second one when there are more than three buttons. Picture buttons are usually rectangular in shape with an icon or graphics label. These buttons may appear alone or placed in a group at the window’s top or side. They are most frequently used to quickly access commands, many of which are normally accessed through the tool bar. For example, the picture buttons below can be used to provide different styles of a histogram drawing. Here is the example how to create the first button:; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; The picture of file h1_s.xpm is used in the button. All .xpm files are located in the directory $ROOTSYS/icons. You can assign a command directly as a parameter of the picture button constructor. The picture of TGPictureButton can be changed by:; fPicture->SetPicture(""h2_s.xpm"");; The advantage of command buttons is that they are always visible, providing a reminder of their existence. They can be inscribed with a meaningful description of what they do by TGToolTip(""Some describing text""). Their activation is much easier and faster than using a two-step menu bar/pull-down sequence. The only disadvantage of the text and picture buttons is that they consume considerable screen space",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1179306,access,access,1179306,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],"['access', 'accessed']"
Security,"sation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCFMlpANN.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCFMlpANN.html:24354,access,accessors,24354,root/html532/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCFMlpANN.html,1,['access'],['accessors']
Security,"scading menus is recommended and you should be careful in using more. Next lines show how to create a menu bar with File,Test and Help menus:; // menu bar item layout hints; fMBItemLayout = new TGLayoutHints(kLHintsTop|kLHintsLeft,0,4,0,0);; fMBHelpLayout = new TGLayoutHints(kLHintsTop|kLHintsRight);. // menu bar; fMenuBar = new TGMenuBar(fMain,100,20,kHorizontalFrame);. // adding popup menus; fMenuBar->AddPopup(""&File"", fMenuFile, fMBItemLayout);; fMenuBar->AddPopup(""&Test"", fMenuTest, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; Using the method TGMenuBar::AddPopup we add three TGPopupMenu objects to the menu bar fMenuBar. The first parameter is a hot string used by TGMenuTitle object. When you add a popup menu to the menu bar, a TGMenuTitle object is created by the menu bar. It is the name of the popup menu. A menu title should have a one-word name that reflects the purpose of all items within the corresponding popup menu. It should also have a defined character as its unique access key. The second parameter is the popup menu we would like to add. The third one is an object of TGLayoutHints type that defines how the menu title will be laid out in the menu bar. In our example the File and Test menus will be laid out to the left of the menu bar with 4 pixels distance in between, the Help menu - will be laid out to the right.; The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1193176,access,access,1193176,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"scchar);  Un-escape specchars in src from escchar and copy to dst. ;  . Function Documentation. ◆ Compress(). char * Compress ; (; const char * ; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. ◆ EscChar(). int EscChar ; (; const char * ; src, . char * ; dst, . int ; dstlen, . char * ; specchars, . char ; escchar . ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. ◆ Form(). char * Form ; (; const char * ; fmt, .  ; ... . ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. ◆ Hash() [1/3]. UInt_t Hash ; (; const char * ; s). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. ◆ Hash() [2/3]. UInt_t Hash ; (; const TString & ; s). inline . Definition at line 494 of file TString.h. ◆ Hash() [3/3]. UInt_t Hash ; (; const TString * ; s). inline . Definition at line 495 of file TString.h. ◆ operator!=() [1/8]. Bool_t operator!= ; (; const char * ; s1, . const TString & ; s2 . ). inline . Definition at line 807 of file TString.h. ◆ operator!=() [2/8]. Bool_t operator!= ; (; const char * ; s1, . const TSubString & ; s2 . ). inline . Definition at line 844 of file TString.h. ◆ operator!=() [3/8]. Bool_t operator!= ; (; const TString & ; s1, . const char * ; s2 . ). inline . Definition at line 789 of file TString.h. ◆ operator!=() [4/8]. Bool_t operator!= ; (; const TString & ; s1, . const TString & ; s2 . ). inline . Definition at line 773 of file TString.h. ◆ operator!=() [5/8]. Bool_t operator!= ; (; const TString & ; s1, . const TSubString & ; s2 . ). inline . Definition at line 841 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8h.html:6408,hash,hash,6408,doc/master/TString_8h.html,https://root.cern,https://root.cern/doc/master/TString_8h.html,1,['hash'],['hash']
Security,"scourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome First Steps With ROOT. The ROOT framework provides a number of classes, grouped into several class cathegories. To start using ROOT, you may find useful to browse the following documents:. Processing data with ROOT (to learn about the interactive and batch use of ROOT); Analyzing data with ROOT (about histograms and trees; mathematical and statistical tools); Showing results with ROOT (explaining pads, 2D and 3D graphics, and the GUI editor); Simulation in ROOT (about the virtual Monte Carlo and the geometry packages); ROOT I/O (explaining how to use ROOT files and trees, and how to access data from d/b or other nodes). . Processing data with ROOT ›. Navigate through this book; Processing data with ROOT; Showing results with ROOT; Simulation in ROOT; ROOT I/O. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/first-steps-root-1.html:2446,access,access,2446,d/first-steps-root-1.html,https://root.cern,https://root.cern/d/first-steps-root-1.html,2,['access'],['access']
Security,"scription of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).; The second to last bin (bin# nbins) contains the upper-edge (xup EXCLUDED).; The Last bin (bin# nbins+1) contains the overflow.; In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram h with binx, biny, binz, the function returns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they are recomputed during the re-binning.; 3.4 Filling Histograms; A histogram is typically filled with statements like:; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:75535,access,access,75535,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"se Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome About ROOT. ROOT is a framework for data processing, born at CERN, at the heart of the research on high-energy physics. Every day, thousands of physicists use ROOT applications to analyze their data or to perform simulations. With ROOT you can:. Save data You can save your data (and any C++ object) in a compressed binary form in a ROOT file. The object format is also saved in the same file: the ROOT files are self-descriptive. Even in the case the source files describing the data model are not available, the information contained in a ROOT file is be always readable. ROOT provides a data structure, the tree, that is extremely powerful for fast access of huge amounts of data - orders of magnitude faster than accessing a normal file.; Access data Data saved into one or several ROOT files can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Cling C++ interpreter for your interactive sessions and to write macros, or you can compile your program to run at full speed. In both cases, you can also create a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:2649,access,accessed,2649,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['access'],['accessed']
Security,"se of error (like server not initialized). ;  ; virtual void Sync (Int_t mode);  Set synchronisation on or off. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:34396,hash,hash,34396,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['hash'],['hash']
Security,"se of symmetric matrices the size is N*(N+1)/2. ; Definition at line 125 of file SMatrix.icc. ◆ SMatrix() [9/10]. template<class T , unsigned int D1, unsigned int D2, class R > . ROOT::Math::SMatrix< T, D1, D2, R >::SMatrix ; (; const SVector< T, D1 *(D2+1)/2 > & ; v, . bool ; lower = true . ). constructor of a symmetrix a matrix from a SVector containing the lower (upper) triangular part. ; construct from upper/lower block ; Definition at line 858 of file SMatrix.icc. ◆ SMatrix() [10/10]. template<class T , unsigned int D1, unsigned int D2, class R > . ROOT::Math::SMatrix< T, D1, D2, R >::SMatrix ; (; const T & ; rhs). explicit . Construct from a scalar value (only for size 1 matrices) ; Definition at line 138 of file SMatrix.icc. Member Function Documentation. ◆ apply(). template<class T , unsigned int D1, unsigned int D2, class R > . T ROOT::Math::SMatrix< T, D1, D2, R >::apply ; (; unsigned int ; i); const. inline . access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements. ; Same convention for general and symmetric matrices. ; Definition at line 627 of file SMatrix.icc. ◆ Array() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return pointer to internal array ; Definition at line 633 of file SMatrix.icc. ◆ Array() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::Array. inline . return read-only pointer to internal array ; Definition at line 630 of file SMatrix.icc. ◆ At() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ). inline . read/write access to matrix element with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 660 of file SMatrix.icc. ◆ At() [2/2]. tem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:18119,access,access,18119,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,2,['access'],"['access', 'accessing']"
Security,"se, ""delete"" which would call the dtors). The option=""dtor"" is only used when called via the ~TMapFile. ; Implements TVirtualMapFile.; Definition at line 979 of file TMapFile.cxx. ◆ Create(). TMapFile * TMapFile::Create ; (; const char * ; name, . Option_t * ; option = ""READ"", . Int_t ; size = kDefaultMapSize, . const char * ; title = """" . ). static . Create a memory mapped file. ; This opens a file (to which the memory will be mapped) and attaches a memory region to it. Option can be either: ""NEW"", ""CREATE"", ""RECREATE"", ""UPDATE"" or ""READ"" (see TFile). The default open mode is ""READ"". The size argument specifies the maximum size of shared memory file in bytes. TMapFile's can only be created via this method. Create() enforces that a TMapFile is always on the memory mapped heap (when ""NEW"", ""CREATE"" or ""RECREATE"" are used). ; Definition at line 1172 of file TMapFile.cxx. ◆ CreateSemaphore(). void TMapFile::CreateSemaphore ; (; Int_t ; pid = 0). protected . Create semaphore used for synchronizing access to shared memory. ; Definition at line 847 of file TMapFile.cxx. ◆ DeclFileName(). static const char * TMapFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TMapFile.h. ◆ DeleteSemaphore(). void TMapFile::DeleteSemaphore ; (; ). protected . Delete the semaphore. ; Definition at line 877 of file TMapFile.cxx. ◆ FindShadowMapFile(). TMapFile * TMapFile::FindShadowMapFile ; (; ). protected . Returns shadow map file. ; Definition at line 1024 of file TMapFile.cxx. ◆ Get(). TObject * TMapFile::Get ; (; const char * ; name, . TObject * ; delObj = nullptr . ). Return pointer to object retrieved from shared memory. ; The object must be deleted after use. If delObj is a pointer to a previously allocated object it will be deleted. Returns 0 in case object with the given name does not exist. ; Definition at line 800 of file TMapFile.cxx. ◆ GetBaseAddr(). void * TMapFile::GetBaseAddr ; (; ); const. inl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:21209,access,access,21209,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['access'],['access']
Security,"se.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:48980,hash,hashes,48980,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hashes']
Security,"seOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:356923,access,access,356923,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"sed in the most of the cases. They provide a buffered input data and an address of the in-memory target object and allow user to specify the conversion function mapping the data being read to the output format. The second type of the rules, the raw rules, also provide the pointer to the target object but the input is a raw TBuffer object containing the input data member declared as an input to the rule. This type of a rule is provided mainly to handle the file format changes that couldn’t have been handled otherwise and in general should not be used unless there is no other option.; 11.5.6.1 The dictionaries; The most convenient place to specify the conversion rules is a dictionary. One can do that either in a LinkDef file or in the selection xml file being fed to genreflex. The syntax of the rules is the following:. For dictionaries created from a LinkDef file:. #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; The variables in the rules have the following meanin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:499920,checksum,checksum,499920,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['checksum'],['checksum']
Security,"see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 * the GetInput() and GetOutput() member functions.; 54 *; 55 * \tparam Architecture_t The underlying architecture.; 56 */; 57 ; 58template <typename Architecture_t>; 59class TTensorBatch {; 60public:; 61 using Matrix_t = typename Architecture_t::Matrix_t;; 62 using Tensor_t = typename Architecture_t::Tensor_t;; 63 ; 64private:; 65 Tensor_t fInputTensor; ///< The input tensor batch, one matrix one input.; 66 Matrix_t fOutputMatrix; ///< The output matrix representing the ground truth.; 67 Matrix_t fWeightMatrix; ///< The event/example weights; 68 ; 69public:; 70 TTensorBatch(Tensor_t &, Matrix_t &, Matrix_t &);; 71 TTensorBatch(const TTensorBatch &) = default;; 72 TTensorBatch(TTensorBatch &&) = default;; 73 TTensorBatch &operator=(const TTensorBatch &) = default;; 74 TTensorBatch &operator=(TTensorBatch &&) = default;; 75 ; 76 /** Return the tensor representing the input data */; 77 Tensor_t &GetInput() { return fInputTensor; }; 78 /** Return the matrix representing the output data. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TensorDataLoader_8h_source.html:1982,access,accessed,1982,doc/master/TensorDataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html,1,['access'],['accessed']
Security,"selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Drawing expressions using arrays and array elements. Let assume, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:21724,access,access,21724,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['access'],['access']
Security,"ser name and passwd from several sources. ;  ; Int_t GetVersion () const;  ; Int_t ProofAuthSetup ();  Authentication related stuff setup in TProofServ. ;  ; Int_t RfioAuth (TString &user);  RFIO authentication (no longer supported) ;  ; void SetEnvironment ();  Set default authentication environment. ;  ; Int_t SshAuth (TString &user);  SSH client authentication code (no longer supported) ;  ; Int_t SshError (const char *errfile);  . Static Private Member Functions; static Bool_t CheckHost (const char *Host, const char *host);  Check if 'host' matches 'href': this means either equal or ""containing"" it, even with wild cards * in the first field (in the case 'href' is a name, ie not IP address) Returns kTRUE if the two matches. ;  ; static void FileExpand (const char *fin, FILE *ftmp);  Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ;  ; static Int_t ProofAuthSetup (TSocket *sock, Bool_t client);  Setup of authetication related stuff in PROOF run after a successful authentication. ;  ; static void RemoveSecContext (TRootSecContext *ctx);  Tool for removing SecContext ctx from THostAuth listed in fgAuthInfo or fgProofAuthInfo. ;  . Private Attributes; TString fDetails;  ; THostAuth * fHostAuth;  ; TString fPasswd;  ; TString fProtocol;  ; Bool_t fPwHash;  ; TString fRemote;  ; Int_t fRSAKey;  ; TRootSecContext * fSecContext;  ; ESecurity fSecurity;  ; TSocket * fSocket;  ; Int_t fTimeOut;  ; TString fUser;  ; Int_t fVersion;  . Static Private Attributes; static TList * fgAuthInfo = 0;  ; static TString fgAuthMeth [kMAXSEC];  ; static Bool_t fgAuthReUse;  ; static Int_t fgAuthTO = -2;  ; static TString fgDefaultUser;  ; static TDatime fgExpDate;  ; static GlobusAuth_t fgGlobusAuthHook;  ; static Krb5Auth_t fgKrb5AuthHook;  ; static TString fgKrb5Principal;  ; static TDatime fgLastAuthrc;  ; static Int_t fgLastError = -1;  ; static TString fgPasswd;  ; static TPluginHandler * fgPasswdDialog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:18678,authenticat,authentication,18678,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"ser prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); Create authentication object. void CatchTimeOut(); Called in connection with a timer timeout. Bool_t Authenticate(); Authenticate to remote rootd or proofd server. Return kTRUE if; authentication succeeded. void SetEnvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:11369,authenticat,authentication,11369,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"ser@]host[:port][/service][?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd; ignored for proofd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [port] = is the remote port number [service] = service name used to determine the port (for backward compatibility, specification of port as priority) options = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1290 of file TSocket.cxx. ◆ CreateAuthSocket() [2/2]. TSocket * TSocket::CreateAuthSocket ; (; const char * ; user, . const char * ; url, . Int_t ; port, . Int_t ; size = 0, . Int_t ; tcpwindowsize = -1, . TSocket * ; opensock = nullptr, . Int_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:24397,authenticat,authentication,24397,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['authenticat'],['authentication']
Security,"set = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:11077,hash,hash,11077,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,2,['hash'],['hash']
Security,"set in the TWebFile object. Use IsZombie() to see if the file is accessible. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 146 of file TWebFile.cxx. ◆ TWebFile() [3/3]. TWebFile::TWebFile ; (; TUrl ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. ; Definition at line 181 of file TWebFile.cxx. ◆ ~TWebFile(). TWebFile::~TWebFile ; (; ). virtual . Cleanup. ; Definition at line 199 of file TWebFile.cxx. Member Function Documentation. ◆ BasicAuthentication(). TString TWebFile::BasicAuthentication ; (; ). protectedvirtual . Return basic authentication scheme, to be added to the request. ; Definition at line 1385 of file TWebFile.cxx. ◆ CheckProxy(). void TWebFile::CheckProxy ; (; ). protectedvirtual . Check if shell var ""http_proxy"" has been set and should be used. ; Definition at line 353 of file TWebFile.cxx. ◆ Class(). static TClass * TWebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TWebFile.h. ◆ Close(). void TWebFile::Clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:45488,access,accessible,45488,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['accessible']
Security,"set is only processed once.; 469~~~{.py}; 470df_correct = ROOT.RDataFrame(treename, filename);; 471 ; 472h_a = df_correct.Histo1D(""a""); 473h_b = df_correct.Histo1D(""b""); 474h_c = df_correct.Histo1D(""c""); 475 ; 476h_a_val = h_a.GetValue(); 477h_b_val = h_b.GetValue(); 478h_c_val = h_c.GetValue(); 479 ; 480print(f""How many times was the data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; 481~~~; 482 ; 483An incorrect way - the dataset is processed three times.; 484~~~{.py}; 485df_incorrect = ROOT.RDataFrame(treename, filename);; 486 ; 487h_a = df_incorrect.Histo1D(""a""); 488h_a_val = h_a.GetValue(); 489 ; 490h_b = df_incorrect.Histo1D(""b""); 491h_b_val = h_b.GetValue(); 492 ; 493h_c = df_incorrect.Histo1D(""c""); 494h_c_val = h_c.GetValue(); 495 ; 496print(f""How many times was the data set processed? {df_wrong.GetNRuns()} times."") # The answer will be 3 times. ; 497~~~; 498 ; 499It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing; 500RDataFrame to run the loop once and produce all results in one go.; 501 ; 502### Going parallel; 503Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; 504The only modification required to the snippets would be the addition of this line *before* constructing the main; 505dataframe object:; 506~~~{.cpp}; 507ROOT::EnableImplicitMT();; 508~~~; 509Simple as that. More details are given [below](#parallel-execution).; 510 ; 511\anchor collections; 512## Working with collections and object selections; 513 ; 514RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way.; 515 ; 516RVec is a container similar to std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:29620,access,accessing,29620,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessing']
Security,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsHiddenReal.html:33447,access,access,33447,root/html534/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html,1,['access'],['access']
Security,"set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:35593,access,access,35593,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,8,['access'],['access']
Security,"set> are TFileCollection objects); kShowDefault as kExport with in addition a default selection including; the datasets from the current user, the ones from the group; and the common ones. kPrint print the dataset content; no output is returned; kList get a list of available dataset names; kForceScan Re-open files while processing kPrint (do not use the; pre-processed information); kNoHeaderPrint Labelling header is not printed; kQuotaUpdate update {group, user} quotas; no output is returned. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated datase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:15787,checksum,checksum,15787,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['checksum'],['checksum']
Security,"settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; Function returns Promise, which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:25573,access,access,25573,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security,"settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required component",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:143956,validat,validation,143956,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['validat'],['validation']
Security,"sh, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; TInterpreter::DataMemberInfo_TypeSizevirtual int DataMemberInfo_TypeSize(DataMemberInfo_t *) constDefinition TInterpreter.h:466; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *) constDefinition TInterpreter.h:425; TInterpreter::ClassInfo_IsValidvirtual Bool_t ClassInfo_IsValid(ClassInfo_t *) constDefinition TInterpreter.h:421; TInterpreter::AutoParsevirtual Int_t A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:352668,hash,hashtable,352668,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['hash'],['hashtable']
Security,"sh;; 339 ; 340 TVirtualStreamerInfo *GetStreamerInfoImpl(Int_t version, Bool_t silent) const;; 341 ; 342 mutable TVirtualMutex *fOVRMutex = nullptr;; 343 typedef std::multimap<void*, Version_t> RepoCont_t;; 344 mutable RepoCont_t fObjectVersionRepository;; 345 ; 346 void UnregisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 347 void MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) const;; 348 void RegisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 349 ; 350private:; 351 TClass(const TClass& tc) = delete;; 352 TClass& operator=(const TClass&) = delete;; 353 ; 354 bool IsClassStructOrUnion() const { return Property() & (kIsClass|kIsStruct|kIsUnion); }; 355 TList *CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load);; 356 ; 357protected:; 358 TVirtualStreamerInfo *FindStreamerInfo(TObjArray *arr, UInt_t checksum) const;; 359 void GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse);; 360 void GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse);; 361 void GetMissingDictionariesWithRecursionCheck(TCollection &result, TCollection &visited, bool recurse);; 362 void GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse);; 363 ; 364public:; 365 TClass();; 366 TClass(const char *name, Bool_t silent = kFALSE);; 367 TClass(const char *name, Version_t cversion, Bool_t silent = kFALSE);; 368 TClass(const char *name, Version_t cversion, EState theState, Bool_t silent = kFALSE);; 369 TClass(ClassInfo_t *info, Version_t cversion,; 370 const char *dfil, const char *ifil = nullptr,; 371 Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE);; 372 TClass(const char *name, Version_t cversion,; 373 const char *dfil, const char *ifil = nullptr,; 374 Int_t dl = 0, Int_t il = 0, Bool_t silent = kF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:17278,checksum,checksum,17278,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['checksum'],['checksum']
Security,"shList object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehash is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehash then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehash=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!! If the name of an object in the HashList is modified, The hashlist must be Rehashed ; Definition at line 43 of file THashList.cxx. ◆ THashList() [3/3]. THashList::THashList ; (; TObject * ; parent, . Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). For backward compatibility only. Use other ctor. ; Definition at line 51 of file THashList.cxx. ◆ ~THashList(). THashList::~THashList ; (; ). virtual . Delete a hashlist. ; Objects are not deleted unless the THashList is the owner (set via SetOwner()). ; Definition at line 60 of file THashList.cxx. Member Function Documentation. ◆ AddAfter() [1/2]. void THashList::AddAfter ; (; const TObject * ; after, . TObject * ; obj . ). overridevirtual . Insert object after object after in the list. ; Implements TSeqCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 143 of file THashList.cxx. ◆ AddAfter() [2/2]. void THashList::AddAfter ; (; TObjLink * ; after, . TObject * ; obj . ). overridevirtual . Insert object after object after in the list. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 154 of file THashList.cxx. ◆ AddAt(). void THashList::AddAt ; (; TObject * ; obj, . Int_t ; idx . ). overridevirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:23534,hash,hashlist,23534,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hashlist']
Security,"shTableCapacity, . Int_t ; rehash = 0 . ). TMap ctor. See THashTable for a description of the arguments. ; Definition at line 34 of file TMap.cxx. ◆ ~TMap(). TMap::~TMap ; (; ). virtual . TMap dtor. ; Objects are not deleted unless the TMap is the owner (set via SetOwner()). ; Definition at line 44 of file TMap.cxx. Member Function Documentation. ◆ Add() [1/2]. void TMap::Add ; (; TObject * ; key, . TObject * ; value . ). Add a (key,value) pair to the map. ; Definition at line 62 of file TMap.cxx. ◆ Add() [2/2]. void TMap::Add ; (; TObject * ; obj). overridevirtual . This function may not be used (but we need to provide it since it is a pure virtual in TCollection). ; Use Add(key,value) instead. ; Implements TCollection.; Definition at line 54 of file TMap.cxx. ◆ AverageCollisions(). Float_t TMap::AverageCollisions ; (; ); const. Return the ratio of entries vs occupied slots. ; Definition at line 73 of file TMap.cxx. ◆ Capacity(). Int_t TMap::Capacity ; (; ); const. Return number of slots in the hashtable. ; Use GetSize() to get the number of objects stored in the TMap. ; Definition at line 82 of file TMap.cxx. ◆ Class(). static TClass * TMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMap::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 90 of file TMap.h. ◆ Clear(). void TMap::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all (key,value) pairs from the map. ; The keys/values are deleted depending on the state of key-ownership (SetOwner()) and value-ownership (SetOwnerValue()).; To delete these objects regardless of the ownership state use:; Delete() to delete only keys;; DeleteValues() to delete only values;; DeleteAll() to delete both keys and values. . Implements TCollection.; Definition at line 97 of file TMap.cxx. ◆ Collisions() [1/2]. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:18149,hash,hashtable,18149,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['hash'],['hashtable']
Security,"shTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTableIter.html:1954,hash,hashtable,1954,root/html534/THashTableIter.html,https://root.cern,https://root.cern/root/html534/THashTableIter.html,1,['hash'],['hashtable']
Security,"shed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Containers.html:2136,hash,hash,2136,doc/master/group__Containers.html,https://root.cern,https://root.cern/doc/master/group__Containers.html,1,['hash'],['hash']
Security,"should have full path to the item. ;  ; Bool_t CreateItem (const char *fullname, const char *title);  Create item element. ;  ; void CreateOwnTopFolder ();  Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffer instances At the same time such sniffer lost access to all global lists and folders. ;  ; virtual void * FindInHierarchy (const char *path, TClass **cl=nullptr, TDataMember **member=nullptr, Int_t *chld=nullptr);  Search element with specified path Returns pointer on element Optionally one could obtain element class, member description and number of childs. ;  ; TObject * FindTObjectInHierarchy (const char *path);  Search element in hierarchy, derived from TObject. ;  ; const char * GetAutoLoad () const;  return name of configured autoload scripts (or 0) ;  ; const char * GetItemField (const char *fullname, const char *name);  Return field for specified item. ;  ; virtual ULong_t GetItemHash (const char *itemname);  Get hash function for specified item used to detect any changes in the specified object. ;  ; virtual ULong_t GetStreamerInfoHash ();  ; TFolder * GetTopFolder (Bool_t force=kFALSE);  Returns top TFolder instance for the sniffer. ;  ; Bool_t HasRestriction (const char *item_name);  Made fast check if item with specified name is in restriction list If returns true, requires precise check with CheckRestriction() method. ;  ; TClass * IsA () const override;  ; Bool_t IsReadOnly () const;  Returns readonly mode. ;  ; Bool_t IsScanGlobalDir () const;  Returns true when sniffer allowed to scan global directories. ;  ; virtual Bool_t IsStreamerInfoItem (const char *);  ; Bool_t Produce (const std::string &path, const std::string &file, const std::string &options, std::string &res);  Method produce different kind of data out of object. ;  ; Bool_t RegisterCommand (const char *cmdname, const char *method, const char *icon);  Register command which can be executed from web interface. ;  ; Bool_t RegisterObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:2210,hash,hash,2210,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['hash'],['hash']
Security,"signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:6494,checksum,checksum,6494,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['checksum'],['checksum']
Security,"sing on the data members,; and for the collection proxies recursiong on the elements of the; collection and iterating over the element's data members. Bool_t IsFolder(void* obj) const; Return kTRUE if the class has elements. void ReplaceWith(TClass* newcl) const; Inform the other objects to replace this object by the new TClass (newcl). void ResetClassInfo(Long_t tagnum); Make sure that the current ClassInfo is up to date. void ResetClassInfo(); Make sure that the current ClassInfo is up to date. void ResetCaches(); To clean out all caches. void ResetMenuList(); Resets the menu list to it's standard value. void ls(Option_t* opt = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:41797,access,accessible,41797,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['accessible']
Security,"sing the defined architecture ;  . Private Attributes; TString fArchitectureString;  The string defining the architecture: CPU or GPU. ;  ; size_t fBatchDepth;  The depth of the batch used to train the deep net. ;  ; size_t fBatchHeight;  The height of the batch used to train the deep net. ;  ; TString fBatchLayoutString;  The string defining the layout of the batch. ;  ; size_t fBatchWidth;  The width of the batch used to train the deep net. ;  ; bool fBuildNet;  Flag to control whether to build fNet, the stored network used for the evaluation. ;  ; TString fErrorStrategy;  The string defining the error strategy for training. ;  ; TString fInputLayoutString;  The string defining the layout of the input. ;  ; std::vector< size_t > fInputShape;  Contains the batch size (no. ;  ; TString fLayoutString;  The string defining the layout of the deep net. ;  ; DNN::ELossFunction fLossFunction;  The loss function. ;  ; std::unique_ptr< DeepNetImpl_t > fNet;  ; TString fNumValidationString;  The string defining the number (or percentage) of training data used for validation. ;  ; DNN::EOutputFunction fOutputFunction;  The output function for making the predictions. ;  ; size_t fRandomSeed;  The random seed used to initialize the weights and shuffling batches (default is zero) ;  ; bool fResume;  ; KeyValueVector_t fSettings;  Map for the training strategy. ;  ; std::vector< TTrainingSettings > fTrainingSettings;  The vector defining each training strategy. ;  ; TString fTrainingStrategyString;  The string defining the training strategy. ;  ; DNN::EInitialization fWeightInitialization;  The initialization method. ;  ; TString fWeightInitializationString;  The string defining the weight initialization method. ;  ; TensorImpl_t fXInput;  ; HostBufferImpl_t fXInputBuffer;  ; std::unique_ptr< MatrixImpl_t > fYHat;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:32299,validat,validation,32299,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['validat'],['validation']
Security,"sion are allowed. Only non-null parameters are filled by this function. Returns kTRUE in case of success. . Definition at line 842 of file TDataSetManager.cxx. ◆ PrintDataSet(). void TDataSetManager::PrintDataSet ; (; TFileCollection * ; fc, . Int_t ; popt = 0 . ). protected . Formatted printout of the content of TFileCollection 'fc'. ; Options in the form popt = u * 10 + f f 0 => header only, 1 => header + files when printing files u 0 => print file name only, 1 => print full URL ; Definition at line 1043 of file TDataSetManager.cxx. ◆ PrintUsedSpace(). void TDataSetManager::PrintUsedSpace ; (; ). protected . Prints the quota. ; Definition at line 638 of file TDataSetManager.cxx. ◆ ProcessFile(). void TDataSetManager::ProcessFile ; (; TFileInfo * ; fileInfo, . Int_t ; sopt, . Bool_t ; checkstg, . Bool_t ; doall, . TFileStager * ; stager, . Bool_t ; createStager, . const char * ; stageopts, . Bool_t ; dbg, . Bool_t & ; changed, . Bool_t & ; opened . ). static . Locate, stage, or fully validate file ""fileInfo"". ; Definition at line 1560 of file TDataSetManager.cxx. ◆ ReadGroupConfig(). Bool_t TDataSetManager::ReadGroupConfig ; (; const char * ; cf = 0). protected . Read group config file 'cf'. ; If cf == 0 re-read, if changed, the file pointed by fGroupConfigFile .; expects the following directives: Group definition: group <groupname> <user>+ disk quota property <groupname> diskquota <quota in GB> average filesize (to be used when the file size is not available) averagefilesize <average size>{G,g,M,m,K,k} ; Definition at line 206 of file TDataSetManager.cxx. ◆ RegisterDataSet(). Int_t TDataSetManager::RegisterDataSet ; (; const char * ; uri, . TFileCollection * ; dataSet, . const char * ; opt . ). virtual . Register a dataset, perfoming quota checkings, if needed. ; Returns 0 on success, -1 on failure ; Reimplemented in TDataSetManagerFile.; Definition at line 761 of file TDataSetManager.cxx. ◆ RemoveDataSet(). Bool_t TDataSetManager::RemoveDataSet ; (; const char * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:30357,validat,validate,30357,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['validat'],['validate']
Security,"sionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = __null); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:12333,validat,validationSample,12333,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,4,['validat'],"['validation', 'validationSample']"
Security,"sion_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:19362,checksum,checksum,19362,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['checksum'],['checksum']
Security,"sis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:17811,access,accessed,17811,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['access'],['accessed']
Security,"sisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Bool_t IsConstructedFromWeightFile() const; access to event information that needs method-specific information. { return fConstructedFromWeightFile; }. ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:36807,access,accessors,36807,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,3,['access'],['accessors']
Security,"sisType(TMVA::Types::EAnalysisType type); { fAnalysisType = type; }. Types::EAnalysisType GetAnalysisType() const; { return fAnalysisType; }. Bool_t DoRegression() const; { return fAnalysisType == Types::kRegression; }. Bool_t DoMulticlass() const; { return fAnalysisType == Types::kMulticlass; }. void DisableWriting(Bool_t setter); setter method for suppressing writing to XML and writing of standalone classes. { fDisableWriting = setter; }. const TString& GetWeightFileDir() const; { return fFileDir; }. Bool_t IsNormalised() const; are input variables normalised ?. { return fNormalise; }. void SetNormalised(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Float_t GetTWeight(const TMVA::Event* ev) const; access to event information that needs method-specific information. Bool_t IsConstructedFromWeightFile() const; { return fConstructedFromWeightFile; }. void SetCurrentEvent(Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:34511,access,accessors,34511,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,3,['access'],['accessors']
Security,"sition) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when =0 continuous interval; static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize() const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Double_t GetWidth() const; { return fMax - fMin; }. Int_t GetNbins() const; { return fNbins; }. Double_t GetMean() const; { return (fMax + fMin)/2; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Interval.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Interval.html:2650,access,accessors,2650,root/html528/TMVA__Interval.html,https://root.cern,https://root.cern/root/html528/TMVA__Interval.html,1,['access'],['accessors']
Security,sitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore Counting semaphore class; TSeqCollection Sequenceable collection ABC; TServerSocket This class implements server sockets; TSessionDescription Session description; TSessionFrame Session frame; TSessionInputFrame Input frame; TSessionLogView PROOF progress dialog; TSessionOutputFrame Output frame; TSessionQueryFrame Query frame; TSessionServerFrame Server frame; TSessionViewer Session Viewer; TShape Basic shape; TSignalHandler Signal event handler; TSlave PROOF slave server; TSlaveInfo basic info on slave; TSlaveLite PROOF lite worker server; TSlider,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:117866,authenticat,authentication,117866,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['authenticat'],['authentication']
Security,"sitive popup menus.Definition TContextMenu.h:44; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileHandlerDefinition TSysEvtHandler.h:65; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGaxisThe axis painter class.Definition TGaxis.h:24; TGeometryTGeometry description.Definition TGeometry.h:39; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THtmlLegacy ROOT documentation system.Definition THtml.h:40; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLinkSpecial TText object used to show hyperlinks.Definition TLink.h:17; TListA doubly linked list.Definition TList.h:38; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMinuitDefinition TMinuit.h:27; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPaveLabelA Pave (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:4895,hash,hash,4895,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['hash'],['hash']
Security,"siveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 525 while (first) {; 526 auto tlk = first;; 527 first = first->fNext;; 528 // delete only heap objects; 529 auto obj = tlk->GetObject();; 530 tlk->SetObject(nullptr);; 531 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 532 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 533 obj, GetName());; 534 else if (obj && obj->IsOnHeap()); 535 TCollection::GarbageCollect(obj);; 536 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 537 removeDirectory.Add(obj);; 538 ; 539 // The formerly first token, when tlk goes out of scope has no more references; 540 // because of the fFirst.reset(); 541 }; 542 }; 543 ; 544 // These objects cannot expect to have a valid TDirectory anymore;; 545 // e.g. because *this is the TDirectory's list of objects. Even if; 546 // not, they are supposed to be deleted, so we can as well unregister; 547 // them from their directory, even if they are stack-based:; 548 TIter iRemDir(&removeDirectory);; 549 TObject* dirRem = nullptr;; 550 while ((dirRem = iRemDir())) {; 551 (*dirRem->IsA()->GetDirectoryAutoAdd())(dirRem, nullptr);; 552 }; 553 Changed();; 554}; 555 ; 556#if 0; 557////////////////////////////////////////////////////////////////////////////////; 55",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:16508,access,accessing,16508,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['access'],['accessing']
Security,"size and location of the specified window ""id"" without; raising it. x, y - coordinates, which define the new position of the window; relative to its parent.; w, h - the width and height, which define the interior size of; the window. void ResizeWindow(Window_t id, UInt_t w, UInt_t h); Changes the width and height of the specified window ""id"", not; including its borders. This function does not change the window's; upper-left coordinate. w, h - the width and height, which are the interior dimensions of; the window after the call completes. void IconifyWindow(Window_t id); Iconifies the window ""id"". Bool_t NeedRedraw(ULong_t tgwindow, Bool_t force); Notify the low level GUI layer ROOT requires ""tgwindow"" to be; updated. Returns kTRUE if the notification was desirable and it was sent. At the moment only Qt4 layer needs that. One needs explicitly cast the first parameter to TGWindow to make; it working in the implementation. One needs to process the notification to confine; all paint operations within ""expose"" / ""paint"" like low level event; or equivalent. void ReparentWindow(Window_t id, Window_t pid, Int_t x, Int_t y); If the specified window is mapped, ReparentWindow automatically; performs an UnmapWindow request on it, removes it from its current; position in the hierarchy, and inserts it as the child of the specified; parent. The window is placed in the stacking order on top with respect; to sibling windows. void SetWindowBackground(Window_t id, ULong_t color); Sets the background of the window ""id"" to the specified color value; ""color"". Changing the background does not cause the window contents; to be changed. void SetWindowBackgroundPixmap(Window_t id, Pixmap_t pxm); Sets the background pixmap of the window ""id"" to the specified; pixmap ""pxm"". Window_t CreateWindow(Window_t parent, Int_t x, Int_t y, UInt_t w, UInt_t h, UInt_t border, Int_t depth, UInt_t clss, void* visual, SetWindowAttributes_t* attr, UInt_t wtype); Creates an unmapped subwindow for a specified pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:36409,expose,expose,36409,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,6,['expose'],['expose']
Security,"sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 1544",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:455608,access,access,455608,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 1544",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:455641,access,access,455641,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"sk; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://ho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:8911,password,password,8911,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,4,['password'],['password']
Security,"sk; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if fla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:33312,validat,validate,33312,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,1,['validat'],['validate']
Security,"skSetupMatchConversion; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMatchConversionCollection; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMatchLeaf; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMismatch; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMissingBranch; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMissingCompiledCollectionProxy; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupMissingCounterBranch; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupNoCheck; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupNotSetup; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupTreeDestructed; static ROOT::TTreeReaderValueBase::ESetupStatuskSetupVoidPtr. protected:. TStringfBranchNamename of the branch to read data from.; TDictionary*fDicttype that the branch should contain; TLeaf*fLeaf; TStringfLeafName; ROOT::TBranchProxy*fProxyproxy for this branch, owned by TTreeReader; ROOT::TTreeReaderValueBase::EReadStatusfReadStatusread status of this data access; ROOT::TTreeReaderValueBase::ESetupStatusfSetupStatussetup status of this data access; vector<Long64_t>fStaticClassOffsets; Long64_tfTreeLastOffset; TTreeReader*fTreeReadertree reader we belong to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeReaderValueBase(TTreeReader* reader = 0, const char* branchname = 0, TDictionary* dict = 0); Construct a tree value reader and register it with the reader object. ~TTreeReaderValueBase(); Unregister from tree reader, cleanup. ProxyRead(); Try to read the value from the TBranchProxy, returns; the status of the read. TLeaf* GetLeaf(); If we are reading a leaf, return the corresponding TLeaf. void* GetAddress(); Returns the memory address of the object being read. void CreateProxy(); Create the proxy object for our branch. const char* GetBranchDataType(TBranch* branch, TDictionary*& dict) const; Retrieve the type of data stored by branch; put its dictionary into; dict, return its",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TTreeReaderValueBase.html:3029,access,access,3029,root/html602/ROOT__TTreeReaderValueBase.html,https://root.cern,https://root.cern/root/html602/ROOT__TTreeReaderValueBase.html,4,['access'],['access']
Security,"sl, .a, .dll, etc. ;  ; virtual void ShowOutput (RedirectHandle_t *h);  Display the content associated with the redirection described by the opaque handle 'h'. ;  ; virtual void Sleep (UInt_t milliSec);  Sleep milliSec milli seconds. ;  ; virtual TString SplitAclicMode (const char *filename, TString &mode, TString &args, TString &io) const;  This method split a filename of the form: ;  ; virtual void StackTrace ();  Print a stack trace. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual int Symlink (const char *from, const char *to);  Create a symbolic link from file1 to file2. ;  ; virtual void Syslog (ELogLevel level, const char *mess);  Send mess to syslog daemon. ;  ; virtual const char * TempDirectory () const;  Return a user configured or systemwide directory to create temporary files in. ;  ; virtual FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr);  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; virtual int Umask (Int_t mask);  Set the process file creation mode mask. ;  ; virtual const char * UnixPathName (const char *unixpathname);  Convert from a local pathname to a Unix pathname. ;  ; virtual int Unlink (const char *name);  Unlink, i.e. ;  ; virtual void Unload (const char *module);  Unload a shared library. ;  ; virtual void Unsetenv (const char *name);  Unset environment variable. ;  ; virtual int Utime (const char *file, Long_t modtime, Long_t actime);  Set the a files modification and access times. ;  ; virtual char * Which (const char *search, const char *file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual const char * WorkingDirectory ();  Return working directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:18762,secur,secure,18762,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['secur'],['secure']
Security,"sl, .a, .dll, etc. ;  ; virtual void ShowOutput (RedirectHandle_t *h);  Display the content associated with the redirection described by the opaque handle 'h'. ;  ; virtual void Sleep (UInt_t milliSec);  Sleep milliSec milli seconds. ;  ; virtual TString SplitAclicMode (const char *filename, TString &mode, TString &args, TString &io) const;  This method split a filename of the form: ;  ; virtual void StackTrace ();  Print a stack trace. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual int Symlink (const char *from, const char *to);  Create a symbolic link from file1 to file2. ;  ; virtual void Syslog (ELogLevel level, const char *mess);  Send mess to syslog daemon. ;  ; virtual const char * TempDirectory () const;  Return a user configured or systemwide directory to create temporary files in. ;  ; virtual FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr);  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; virtual int Umask (Int_t mask);  Set the process file creation mode mask. ;  ; virtual const char * UnixPathName (const char *unixpathname);  Convert from a local pathname to a Unix pathname. ;  ; virtual void Unload (const char *module);  Unload a shared library. ;  ; virtual void Unsetenv (const char *name);  Unset environment variable. ;  ; virtual int Utime (const char *file, Long_t modtime, Long_t actime);  Set the a files modification and access times. ;  ; virtual char * Which (const char *search, const char *file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual const char * WorkingDirectory ();  Return working directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:19074,secur,secure,19074,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,3,['secur'],['secure']
Security,"slog ; (; ELogLevel ; level, . const char * ; mess . ). virtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented in TUnixSystem.; Definition at line 1686 of file TSystem.cxx. ◆ TempDirectory(). const char * TSystem::TempDirectory ; (; ); const. virtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1482 of file TSystem.cxx. ◆ TempFileName(). FILE * TSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). virtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1499 of file TSystem.cxx. ◆ Umask(). int TSystem::Umask ; (; Int_t ; mask). virtual . Set the process file creation mode mask. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1517 of file TSystem.cxx. ◆ UnixPathName(). const char * TSystem::UnixPathName ; (; const char * ; name). virtual . Convert from a local pathname to a Unix pathname. ; E.g. from \user\root to /user/root. ; Reimplemented in TWinNTSystem.; Definition at line 1063 of file TSystem.cxx. ◆ Unlink(). int TSystem::Unlink ; (; const char * ; name). virtual . Unlink, i.e. ; remove, a file.; If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, while Windows does not allow the file to be deleted and the operation is a no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:95271,secur,security,95271,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['secur'],['security']
Security,"slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:7984,hash,hash,7984,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,4,['hash'],['hash']
Security,"slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TExMap.html:8053,hash,hash,8053,root/html530/TExMap.html,https://root.cern,https://root.cern/root/html530/TExMap.html,4,['hash'],['hash']
Security,"slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TExMap.h 34618 2010-07-27 15:52:34Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TExMap.html:8053,hash,hash,8053,root/html532/TExMap.html,https://root.cern,https://root.cern/root/html532/TExMap.html,4,['hash'],['hash']
Security,"smutableprivate; fDataTClassprivate; fDeclFileLineTClassprivate; fDeclFileNameTClassprivate; fDeleteTClassprivate; fDeleteArrayTClassprivate; fDestructorTClassprivate; fDirAutoAddTClassprivate; fEnumsTClassprivate; fFuncTemplateTClassprivate; fgClassCountTClassprivatestatic; fgClassTypedefHashTClassprivatestatic; fgDtorOnlyTObjectprivatestatic; fGlobalIsATClassprivate; fgObjectStatTObjectprivatestatic; fHasCustomStreamerMemberTClassprivate; fHasRootPcmInfoTClassprivate; FillBuffer(char *&buffer)TNamedvirtual; fImplFileLineTClassprivate; fImplFileNameTClassprivate; FindClassOrBaseMethodWithId(DeclId_t faddr)TClassprivate; FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constTClass; FindConversionStreamerInfo(const TClass *onfile_cl, UInt_t checksum) constTClass; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindStreamerInfo(TObjArray *arr, UInt_t checksum) constTClassprotected; FindStreamerInfo(UInt_t checksum, Bool_t isTransient=kFALSE) constTClass; FindStreamerInfoAbstractEmulated(UInt_t checksum) constTClass; fInstanceCountTClassprivate; fIsATClassprivate; fIsAMethodTClassmutableprivate; fIsOffsetStreamerSetTClassmutableprivate; fIsSyntheticPairTClassprivate; fLastReadInfoTClassmutableprivate; fMergeTClassprivate; fMethodTClassprivate; fNameTNamedprotected; fNewTClassprivate; fNewArrayTClassprivate; fNoInfoOrEmuOrFwdDeclNameRegistryTClassprivatestatic; fObjectVersionRepositoryTClassmutableprivate; fOffsetStreamerTClassmutableprivate; fOnHeapTClassprivate; ForceReload(TClass *oldcl)TClass; fOVRMutexTClassmutableprivate; fPersistentRefTClassprivate; fPropertyTClassmutableprivate; fRealDataTClassprivate; fRefProxyTClassprivate; fResetAfterMergeTClassprivate; fRuntimePropertiesTClassmutableprivate; fSchemaRulesTClassprivate; fSharedLibsTClassprivate; fShowMembersTClassprivate; fSizeofTClassprivate; fStateTClassprivate; fStreamerTClassprivate; fStreamerFuncTClassprivate; fStreamerImplTClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:5244,checksum,checksum,5244,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['checksum'],['checksum']
Security,"socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. The opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void Show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:13375,authenticat,authentication,13375,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,5,['authenticat'],['authentication']
Security,"splacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=( const ForeignVector & v). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8535,access,access,8535,root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"splacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11774,access,access,11774,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"splitlevel = 99 . ). inline . Definition at line 405 of file TTree.h. ◆ Branch() [9/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T ** ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the array addobj being passed. ; NoteThis and the previous overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]addobjArray of the objects to be added. When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizehe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be added. Make sure to pass a pointer to the actual type/class that should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:81945,access,accessed,81945,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['accessed']
Security,"sponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdCl::File*fFileUnderlying XRootD file; XrdSysCondVar*fInitCondVarUsed to block an async open request; XrdCl::OpenFlags::FlagsfModeOpen mode of the current file; TStringfNewUrl; Int_tfQueryReadVParams; Int_tfReadvIorMaxMax size of a single readv chunk; Int_tfReadvIovMaxMax number of readv chunks; XrdCl::URL*fUrlURL of the current file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); Constructor. param url: URL of the entry-point server to be contacted; param mode: initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFile.html:24458,access,access,24458,root/html602/TNetXNGFile.html,https://root.cern,https://root.cern/root/html602/TNetXNGFile.html,2,['access'],['access']
Security,"sponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).; The second to last bin (bin# nbins) contains the upper-edge (xup EXCLUDED).; The Last bin (bin# nbins+1) contains the overflow.; In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram h with binx, biny, binz, the function returns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they are recomputed during the re-binning.; 3.4 Filling Histograms; A histogram is typically filled with statements like:; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; The Fill method computes the bin number corresponding to the given x, y or z argument and increments this bin by the given weight. The Fill() method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2() has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling TH1::AddBinContent(), replace the existing content via TH1::SetBinContent() , and access the bin content of a given bin via TH1::GetBinContent() .;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:76122,access,access,76122,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"sponse. */; 8420 if (ah->nonce == NULL) {; 8421 return 0;; 8422 }; 8423 s = NULL;; 8424 nonce = strtoull(ah->nonce, &s, 10);; 8425 if ((s == NULL) || (*s != 0)) {; 8426 return 0;; 8427 }; 8428 ; 8429 /* Convert the nonce from the client to a number. */; 8430 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8431 ; 8432 /* The converted number corresponds to the time the nounce has been; 8433 * created. This should not be earlier than the server start. */; 8434 /* Server side nonce check is valuable in all situations but one:; 8435 * if the server restarts frequently, but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:243824,attack,attack,243824,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['attack'],['attack']
Security,"sponse. */; 8421 if (ah->nonce == NULL) {; 8422 return 0;; 8423 }; 8424 s = NULL;; 8425 nonce = strtoull(ah->nonce, &s, 10);; 8426 if ((s == NULL) || (*s != 0)) {; 8427 return 0;; 8428 }; 8429 ; 8430 /* Convert the nonce from the client to a number. */; 8431 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8432 ; 8433 /* The converted number corresponds to the time the nounce has been; 8434 * created. This should not be earlier than the server start. */; 8435 /* Server side nonce check is valuable in all situations but one:; 8436 * if the server restarts frequently, but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:243856,attack,attack,243856,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['attack'],['attack']
Security,"ss *onfileClass);  ; void ReadPairFromMap (int nElements, TBuffer &b);  ; void ReadPrimitives (int nElements, TBuffer &b, const TClass *onfileClass);  ; void WriteMap (int nElements, TBuffer &b);  ; void WriteObjects (int nElements, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:10047,access,accessors,10047,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security,"ss *pThis, void *obj, TBuffer &b, const TClass *onfile_class)Schema evolution rules.Definition TClass.h:283; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:73055,checksum,checksum,73055,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,2,['checksum'],['checksum']
Security,"ss *pThis, void *obj, TBuffer &b, const TClass *onfile_class)Schema evolution rules.Definition TClass.h:283; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2772; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5838; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4507; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:72883,checksum,checksum,72883,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['checksum'],['checksum']
Security,"ss = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when this static function is called, it sets the flag whether; events w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Event.html:4323,access,accessor,4323,root/html602/TMVA__Event.html,https://root.cern,https://root.cern/root/html602/TMVA__Event.html,2,['access'],['accessor']
Security,"ss R > . template<class A , class R2 > . bool ROOT::Math::SMatrix< T, D1, D2, R >::operator> ; (; const Expr< A, T, D1, D2, R2 > & ; rhs); const. element wise comparison ; Definition at line 367 of file SMatrix.icc. ◆ operator>() [2/3]. template<class T , unsigned int D1, unsigned int D2, class R > . template<class R2 > . bool ROOT::Math::SMatrix< T, D1, D2, R >::operator> ; (; const SMatrix< T, D1, D2, R2 > & ; rhs); const. element wise comparison ; Definition at line 357 of file SMatrix.icc. ◆ operator>() [3/3]. template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::operator> ; (; const T & ; rhs); const. element wise comparison ; Definition at line 347 of file SMatrix.icc. ◆ operator[]() [1/2]. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . SMatrixRow ROOT::Math::SMatrix< T, D1, D2, R >::operator[] ; (; unsigned int ; i). inline . read/write access to matrix element with indices starting from 0 : m[i][j] ; Definition at line 402 of file SMatrix.h. ◆ operator[]() [2/2]. template<class T , unsigned int D1, unsigned int D2 = D1, class R = MatRepStd<T, D1, D2>> . SMatrixRow_const ROOT::Math::SMatrix< T, D1, D2, R >::operator[] ; (; unsigned int ; i); const. inline . read only access to matrix element, with indices starting from 0 : m[i][j] ; Definition at line 398 of file SMatrix.h. ◆ Place_at() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . template<class A , unsigned int D3, unsigned int D4, class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2, R >::Place_at ; (; const Expr< A, T, D3, D4, R2 > & ; rhs, . unsigned int ; row, . unsigned int ; col . ). place a matrix expression in this matrix ; Definition at line 564 of file SMatrix.icc. ◆ Place_at() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . template<unsigned int D3, unsigned int D4, class R2 > . SMatrix< T, D1, D2, R > & ROOT::Math::SMatrix< T, D1, D2,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:34975,access,access,34975,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security,"ss dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the folder.; Here is an example of a folder’s path name:; //root/Event/Hits/TCP; One does not have to specify the full path name. If the partial path name is unique, it will find it; otherwise it will return the first occurrence of the path.; The first diagram shows a system without folders. The objects have pointers to each other to access each other’s data. Pointers are an efficient way to share data between classes. However, a direct pointer creates a direct coupling between classes. This design can become a very tangled web of dependencies in a system with a large number of classes. In the second diagram, a reference to the data is in the folder and the consumers refer to the folder rather than each other to access the data. The naming and search service provided by the ROOT folders hierarchy provides an alternative. It loosely couples the classes and greatly enhances I/O operations. In this way, folders separate the data from the algorithms and greatly improve the modularity of an application by minimizing the class dependencies. In addition, the folder hierarchy creates a picture of the data organization. This is useful when discussing data design issues or when learning the data organization. The example below illustrates this point.; 10.3 How to Use Folders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by the producer, and creating a reference to the folder by the user.; 10.3.1 Creating a Folder Hierarchy; To create a folder hierarchy you add the top folder of your hierarchy to //root. Then you add a folder to an existing folder with the TFolder::AddFolder method. This method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:419901,access,access,419901,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ss for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymmErrors class ;  CRooHistConstraint;  ►CRooHistErrorRooHistError is a singleton class used to calculate the error bars for each bin of a RooHist object ;  CBinomialSumAsym;  CBinomialSumEff;  CPoissonSum;  CRooHistFuncRooHistFunc implements a real-valued function sampled from a multidimensional histogram ;  CRooHistPdfRooHistPdf implements a probablity density function sampled from a multidimensional histogram ;  CRooImproperIntegrator1DSpecial numeric integrator that can handle integrals over open domains ;  CRooIntRooInt is a minimal implementation of a TObject holding a Int_t value ;  ►CRooIntegralMorph;  CMorphCacheElem;  CRooIntegrator1DRooIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooIntegrator2DRooIntegrator2D implements a numeric two-dimensiona integrator in terms of a recursive application of RooIntegrator1D ;  CRooIntegratorBindingFunction binding representing the output of a RooAbsIntegrator ;  CRooInvTransformLightweight function binding that returns the inverse of an input function binding Apply the change of variables transformation x -> 1/x to the input function and its range ;  CRooJeffreysPriorRooJeffreysPrior ;  CRooKeysPdfClass RooKeysPdf implements a one-dimensional kernel estimation p.d.f which model the distribution of an arbitrary input dataset as a superposition of Gaussian kernels, one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:92440,hash,hash,92440,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['hash'],['hash']
Security,"ss from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TCollection::Clearvoid Clear(Option_t *option="""") override=0; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TColorThe color creation and management class.Definition TColor.h:21; TColor::InitializeColorsstatic void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:132163,access,access,132163,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['access'],['access']
Security,"ss from the list and map of classesDefinition TClass.cxx:585; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TCollection::Clearvoid Clear(Option_t *option="""") override=0; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TColorThe color creation and management class.Definition TColor.h:21; TColor::InitializeColorsstatic void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:132339,access,access,132339,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['access'],['access']
Security,"ss information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SUGGEST_NEW_INTERFACE to switch on deprecation warnings for the functions in question. Similarly, the bin content can now be set using an index, making prior loading of a certain coordinate unnecessary:; for (int i=0 ; i<hist->numEntries() ; i++) {; - hist->get(i) ;; - hist->set(hist->weight() / sum);; + hist->set(i, hist->weight(i) / sum, 0.);; }. More const correctness. calc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:22764,access,accesses,22764,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['access'],['accesses']
Security,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045937,access,accessing,1045937,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessing']
Security,"ss to data pointer ; Definition at line 75 of file BasicFCN.h. ◆ HasHessian(). template<class DerivFunType , class ModelFunType , class DataType > . virtual bool ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::HasHessian ; (; ); const. inlinevirtual . flag to indicate if can compute Hessian ; Reimplemented from ROOT::Math::BasicFitMethodFunction< DerivFunType >.; Definition at line 84 of file BasicFCN.h. ◆ ModelFunction(). template<class DerivFunType , class ModelFunType , class DataType > . virtual const IModelFunction & ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::ModelFunction ; (; ); const. inlinevirtual . access to const reference to the model function ; Definition at line 78 of file BasicFCN.h. ◆ ModelFunctionPtr(). template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr< IModelFunction > ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::ModelFunctionPtr ; (; ); const. inline . access to function pointer ; Definition at line 81 of file BasicFCN.h. ◆ SetData(). template<class DerivFunType , class ModelFunType , class DataType > . void ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::SetData ; (; const std::shared_ptr< DataType > & ; data). inlineprotected . Set the data pointer. ; Definition at line 98 of file BasicFCN.h. ◆ SetModelFunction(). template<class DerivFunType , class ModelFunType , class DataType > . void ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::SetModelFunction ; (; const std::shared_ptr< IModelFunction > & ; func). inlineprotected . Set the function pointer. ; Definition at line 101 of file BasicFCN.h. Member Data Documentation. ◆ fData. template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr<DataType> ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::fData. protected . Definition at line 104 of file BasicFCN.h. ◆ fFunc. template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr<IM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html:7550,access,access,7550,doc/master/classROOT_1_1Fit_1_1BasicFCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html,1,['access'],['access']
Security,"ss } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; Here is running example and source code; This examples shows how read TTree from binary file and create TSelector object. Logically it is similar to original TSelector class - for every read entry TSelector::Process() method is called. Selected branches can be accessed from tgtobj data member. At the end of tree reading TSelector::Terminate() method will be called.; As third parameter of treeProcess() function one could provide object with arguments; let args = { numentries: 1000, firstentry: 500 };; treeProcess(tree, selector, args);; 1.11.6 TGeo API; Any supported TGeo object can be drawn directly with normal draw() function.; If necessary, one can create three.js model for supported object directly and use such model separately. This can be done with the function:; import { build } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; let opt = { numfaces: 100000 };; let obj3d = build(obj, opt);; scene.add( obj3d );; Following options can be specified:. numfaces - approximate maximal number of faces in three.js model (default 100000); numnodes - approximate maximal number of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:30161,access,accessed,30161,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['accessed']
Security,"ss  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleDescriptorBuilder;  A helper class for piece-wise construction of an RNTupleDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDirectAccessView< T >;  A view variant that provides direct access to the I/O buffers. More...;  ; class  ROOT::Experimental::Internal::RNTupleFileWriter;  Write RNTuple data blocks in a TFile or a bare file container. More...;  ; class  ROOT::Experimental::RNTupleFillContext;  A context for filling entries (data) into clusters of an RNTuple. More...;  ; class  ROOT::Experimental::RNTupleFillStatus;  A status object after filling an entry. More...;  ; class  ROOT::Experimental::RNTupleFormatter;  Contains helper functions for RNTupleReader::PrintInfo() and RPrintSchemaVisitor::VisitField() More...;  ; class  ROOT::Experimental::RNTupleGlobalRange;  Used to loop over indexes (entries or collections) between start and end. More...;  ; class  ROOT::Experimental::RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleIndex;  Builds an index on one or several fields of an RNTuple so it can be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:7800,access,access,7800,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['access'],['access']
Security,"ss(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1533 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1534 if (fState == kHasTClassInit) {; 1535 if (fImplFileLine == -1 && fClassVersion == 0) {; 1536 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1537 // information. Since it is transient, it is more than likely that the lack; 1538 // will be harmles.; 1539 } else {; 1540 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1541 ""initialization routine."",; 1542 fName.Data());; 1543 }; 1544 } else {; 1545 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1546 if (!ispairbase); 1547 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1548 }; 1549 }; 1550 ; 1551 fgClassCount++;; 1552 SetUniqueID(fgClassCount);; 1553 ; 1554 // Make the typedef-expanded -> original hash table entries.; 1555 // There may be several entries for any given key.; 1556 // We only make entries if the typedef-expanded name; 1557 // is different from the original name.; 1558 TString resolvedThis;; 1559 if (!givenInfo && strchr (name, '<')) {; 1560 if ( fName != name) {; 1561 if (!fgClassTypedefHash) {; 1562 fgClassTypedefHash = new THashTable (100, 5);; 1563 fgClassTypedefHash->SetOwner (kTRUE);; 1564 }; 1565 ; 1566 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1567 SetBit (kHasNameMapNode);; 1568 ; 1569 }; 1570 resolvedThis = TClassEdit::ResolveTypedef (name, kTRUE);; 1571 if (resolvedThis != name) {; 1572 if (!fgClassTypedefHash) {; 1573 fgClassTypedefHash = new THashTable (100, 5);; 1574 fgClassTypedefHash->SetOwner (kTRUE);; 1575 }; 1576 ; 1577 fgClassTypedefHash->Add (new TNameMapNode (resolvedThis, fName));; 1578 SetBit (kHasNameMapNode);; 1579 }; 1580 ; 1581 }; 1582 ; 1583 //In case a class w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:60132,hash,hash,60132,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ss(this);; 1593 return;; 1594 }; 1595 }; 1596 }; 1597 }; 1598 }; 1599 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1600 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1601 if (fState == kHasTClassInit) {; 1602 if (fImplFileLine == -1 && fClassVersion == 0) {; 1603 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1604 // information. Since it is transient, it is more than likely that the lack; 1605 // will be harmles.; 1606 } else {; 1607 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1608 ""initialization routine."",; 1609 fName.Data());; 1610 }; 1611 } else {; 1612 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1613 if (!ispairbase); 1614 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1615 }; 1616 }; 1617 ; 1618 fgClassCount++;; 1619 SetUniqueID(fgClassCount);; 1620 ; 1621 // Make the typedef-expanded -> original hash table entries.; 1622 // There may be several entries for any given key.; 1623 // We only make entries if the typedef-expanded name; 1624 // is different from the original name.; 1625 TString resolvedThis;; 1626 if (!givenInfo && strchr (name, '<')) {; 1627 if ( fName != name) {; 1628 if (!fgClassTypedefHash) {; 1629 fgClassTypedefHash = new THashTable (100, 5);; 1630 fgClassTypedefHash->SetOwner (kTRUE);; 1631 }; 1632 ; 1633 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1634 SetBit (kHasNameMapNode);; 1635 ; 1636 }; 1637 resolvedThis = TClassEdit::ResolveTypedef (name, kTRUE);; 1638 if (resolvedThis != name) {; 1639 if (!fgClassTypedefHash) {; 1640 fgClassTypedefHash = new THashTable (100, 5);; 1641 fgClassTypedefHash->SetOwner (kTRUE);; 1642 }; 1643 ; 1644 fgClassTypedefHash->Add (new TNameMapNode (resolvedThis, fName));; 1645 SetBit (kHasNameMapNode);; 1646 }; 1647 ; 1648 }; 1649 ; 1650 //In case a class w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:62883,hash,hash,62883,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ss* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysErro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TExMap.html:3882,hash,hash,3882,root/html602/TExMap.html,https://root.cern,https://root.cern/root/html602/TExMap.html,2,['hash'],['hash']
Security,"ss. It has list to baseclasses, datamembers and methods. TClass(const TClass& tc); copy constructor. TClass& operator=(const TClass& ); assignement operator. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:19605,checksum,checksum,19605,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['checksum'],['checksum']
Security,"ss;; 857 if (scopeEnumeration.Contains(""(unnamed)"")) {; 858 // FIXME: need to investigate the numbering scheme.; 859 md5EnumClass.Append(scopeName);; 860 md5EnumClass.Append(""::@1@1"");; 861 } else {; 862 // If the enumeration is not anonymous we put ""scopeName::Enumeration"" in a TString,; 863 // which will be hashed with MD5 later.; 864 md5EnumClass.Append(scopeEnumeration);; 865 // We extract the part after ""::"" (this is the enumerator name).; 866 TString enumOnlyName = TClassEdit::GetUnqualifiedName(scopeEnumeration);; 867 // The syntax is ""Class::EnumeratorEnumerator; 868 md5EnumClass.Append(enumOnlyName);; 869 }; 870 // The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".; 871 TString md5Enumerator(""@ "");; 872 md5Enumerator.Append(scopeName);; 873 md5Enumerator.Append(""::"");; 874 md5Enumerator.Append(dataMemberName);; 875 md5Enumerator.Append(dataMemberName);; 876 // We make the URL for the ""scopeName"".; 877 TString url = UrlGenerator(scopeName, scopeType);; 878 // Then we have to append the hashed text for the enumerator.; 879 url.Append(""#a"");; 880 url.Append(md5EnumClass.MD5());; 881 // We append ""a"" and then the next hashed text.; 882 url.Append(""a"");; 883 url.Append(md5Enumerator.MD5());; 884 return url;; 885}; 886} // namespace; 887 ; 888namespace {; 889////////////////////////////////////////////////////////////////////////////////; 890/// The function generates URL for enumeration. The hashed text consist of:; 891/// ""Class::EnumerationEnumeration"".; 892///; 893/// \param[in] scopeName the name of the class/namespace/struct; 894/// \param[in] enumeration the name of the enumeration; 895/// \param[in] scopeType enumerator for class/namespace/struct; 896 ; 897static TString GetUrlForEnumeration(TString scopeName, const TString &enumeration, EUrl scopeType); 898{; 899 // The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; 900 // The text is ""Class::EnumerationEnumeration.; 901 TString md5Enumeration(scopeName);; 902",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:32936,hash,hashed,32936,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['hash'],['hashed']
Security,"ssID uniquely identifies a ROOT job. The TProcessID title consists of a TUUID object, which provides a globally unique identifier. The TUUID class implements the UUID (Universally Unique Identifier), also known as GUID (Globally Unique Identifier). A UUID is 128 bits long, and if generated according to this algorithm, is either guaranteed to be different from all other UUID generated until 3400 A.D. or extremely likely to be different.; The TROOT constructor automatically creates a TProcessID. When a TFile contains referenced objects, the TProcessID object is written to the file. If a file has been written in multiple sessions (same machine or not), a TProcessID is written for each session. The TProcessID objects are used by TRef to uniquely identify the referenced TObject.; When a referenced object is read from a file (its bit kIsReferenced is set), this object is entered into the objects table of the corresponding TProcessID. Each TFile has a list of TProcessIDs (see TFile::fProcessIDs) also accessible from TProcessID::fgPIDs (for all files). When this object is deleted, it is removed from the table via the cleanup mechanism invoked by the TObject destructor. Each TProcessID has a table (TObjArray *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID, a pointer to this unique object may be found using fObjects->At(fUniqueID). In the same way, when a TRef::GetObject is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See TProcessID::GetObjectWithID and PutObjectWithID.; 11.4.4.2 Object Number; When an object is referenced, a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. The fUniqueID is the serial object number in the current session. One can retrieve the current fgNumber value by calling the static function TProcessID::GetObjectCount at any",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:483980,access,accessible,483980,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"ssOffsetRecurse(const TClass* toBase); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Returns -2 if cl is a base class, but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:34869,access,accessor,34869,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,1,['access'],['accessor']
Security,"ssification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodTMlpANN.html:16777,validat,validation,16777,root/html530/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodTMlpANN.html,3,['validat'],['validation']
Security,"ssification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:18025,validat,validation,18025,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,2,['validat'],['validation']
Security,"ssing key: \"""" + key + ""\""\n"";; 237 error_string += ""Expected \"" at the end of the value."";; 238 return false;; 239 }; 240 result[key] = command.substr( 1, l-1 );; 241 } else {; 242 l = command.find(' ', 1);; 243 if (l == std::string::npos) l = command.size();; 244 result[key] = command.substr( 0, l );; 245 }; 246 }; 247 ; 248 //--------------------------------------------------------------------; 249 // Everything went ok; 250 ///////////////////////////////////////////////////////////////////////; 251 ; 252 if( l == command.size() ); 253 break;; 254 command = command.substr( l+1 );; 255 }; 256 std::map<std::string, std::string>::const_iterator it1;; 257 it1 = result.find(""oldtype"");; 258 if ( it1 != result.end() ) {; 259 std::map<std::string, std::string>::const_iterator it2;; 260 it2 = result.find(""source"");; 261 if ( it2 != result.end() ) {; 262 result[""source""] = it1->second + "" "" + it2->second;; 263 }; 264 }; 265 if ( result.find(""version"") == result.end() && result.find(""checksum"") == result.end() ) {; 266 result[""version""] = ""[1-]"";; 267 }; 268 ; 269 //------------------------------------------------------------------------; 270 // ""include"" tag. Replace "";"" with "","" for backwards compatibility with; 271 // ROOT5; 272 //////////////////////////////////////////////////////////////////////////; 273 ; 274 auto const includeKeyName = ""include"";; 275 auto includeTag = result.find(includeKeyName);; 276 if (includeTag != result.end()){; 277 auto & includeTagValue = includeTag->second;; 278 std::replace_if (includeTagValue.begin(),; 279 includeTagValue.end(),; 280 [](char c){ return c == ';';},; 281 ',');; 282 result[includeKeyName] = includeTagValue;; 283 }; 284 ; 285 return ValidateRule( result, error_string);; 286 }; 287 ; 288 /////////////////////////////////////////////////////////////////////////////; 289 /// Validate if the user specified rules are correct; 290 ; 291 static Bool_t ValidateRule( const std::map<std::string, std::string>& rule, std::string &error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:9715,checksum,checksum,9715,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['checksum'],['checksum']
Security,"ssion(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. Bool_t MatchUrl(const char* url); Checks if 'url' refers to the same 'user@host:port' entity as the URL; in memory. TProofMgr::MatchUrl cannot be used here because of the; 'double' default port, implying an additional check on the port effectively; open. void ShowWorkers(); Show available workers. const char * GetMssUrl(Bool_t = kFALSE); Gets the URL to be prepended to paths when accessing the MSS associated; with the connected cluster, if any. The information is retrieved from; the cluster the first time or if retrieve is true. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Bool_t HandleInput(const void* ); Handle asynchronous input on the socket. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current user.; If 'hard' is true sessions are signalled for termination and moved to; terminate at all stages (top master, sub-master, workers). Otherwise; (default) only top-master sessions are asked to terminate, triggering; a gentle session termination. In all cases all sessions should be gone; after a few (2 or 3) session checking cycles.; A user with superuser privileges can also asks cleaning for an different; user, specified by 'usr', or for all users (usr = *); Return 0 on success, -1 in case of error. TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v \""| SvcMsg\"""", Bool_t rescan = kFALSE); Get logs or log tails from last session a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:11528,access,accessible,11528,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,3,['access'],['accessible']
Security,"ssionDefinition TApplication.h:49; TApplication::NoLogOptBool_t NoLogOpt() constDefinition TApplication.h:143; TApplication::NoLogoOptBool_t NoLogoOpt() constDefinition TApplication.h:144; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TBenchmarkThis class is a ROOT utility to help benchmarking applications.Definition TBenchmark.h:29; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileHandlerDefinition TSysEvtHandler.h:65; TFileHandler::Removevoid Remove() overrideRemove file event handler from system file handler list.Definition TSysEvtHandler.cxx:137; TFileHandler::Addvoid Add() overrideAdd file event handler to system file handler list.Definition TSysEvtHandler.cxx:126; TInterpreter::GetPromptvirtual char * GetPrompt()=0; TInterpreter::SaveGlobalsContextvirtual void SaveGlobalsContext()=0; TInterpreter::EndOfLineActionvirtual void EndOfLineAction()=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::SetGetlinevirtual void SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line))=0; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::GetMorevirtual Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:34654,hash,hash,34654,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['hash'],['hash']
Security,"ssuming that T is copiable: this should be the case; 239 // for all result types in use, as they are copied for each slot; 240 variedResults.emplace_back(new T{*resPtr.fObjPtr});; 241 ; 242 // Check if the result's type T inherits from TNamed; 243 if constexpr (std::is_base_of<TNamed, T>::value) {; 244 // Get the current variation name; 245 std::string variationName = variations[i];; 246 // Replace the colon with an underscore; 247 std::replace(variationName.begin(), variationName.end(), ':', '_'); ; 248 // Get a pointer to the corresponding varied result; 249 auto &variedResult = variedResults.back();; 250 // Set the varied result's name to NOMINALNAME_VARIATIONAME; 251 variedResult->SetName((std::string(variedResult->GetName()) + ""_"" + variationName).c_str());; 252 }; 253 }; 254 ; 255 std::vector<void *> typeErasedResults;; 256 typeErasedResults.reserve(variedResults.size());; 257 for (auto &res : variedResults); 258 typeErasedResults.emplace_back(&res);; 259 ; 260 // Create the RVariedAction and inject it in the computation graph.; 261 // This recursively creates all the required varied column readers and upstream nodes of the computation graph.; 262 variedAction = nominalAction->MakeVariedAction(std::move(typeErasedResults));; 263 }; 264 ; 265 return RDFInternal::MakeResultMap<T>(resPtr.fObjPtr, std::move(variedResults), std::move(variations),; 266 *resPtr.fLoopManager, std::move(nominalAction), std::move(variedAction));; 267}; 268 ; 269using SnapshotPtr_t = ROOT::RDF::RResultPtr<ROOT::RDF::RInterface<ROOT::Detail::RDF::RLoopManager, void>>;; 270SnapshotPtr_t VariationsFor(SnapshotPtr_t resPtr);; 271 ; 272/// \brief Add ProgressBar to a ROOT::RDF::RNode; 273/// \param[in] df RDataFrame node at which ProgressBar is called.; 274///; 275/// The ProgressBar can be added not only at the RDataFrame head node, but also at any any computational node,; 276/// such as Filter or Define.; 277/// ###Example usage:; 278/// ~~~{.cpp}; 279/// ROOT::RDataFrame df(""tree"", ""file.r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:11961,inject,inject,11961,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['inject'],['inject']
Security,"st * ; std, . TList * ; nin, . Option_t * ; opt = """" . ). static . Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ; 'nin' info has priority. 'std' is cleaned from inactive members. 'nin' members used to update existing members in 'std' are removed from 'nin', do that they do not leak opt = ""P"" for proofauthinfo. ; Definition at line 3611 of file TAuthenticate.cxx. ◆ PromptPasswd(). char * TAuthenticate::PromptPasswd ; (; const char * ; prompt = ""Password: ""). static . Static method to prompt for the user's passwd to be used for authentication to rootd or proofd. ; Uses non-echoing command line to get passwd. Returns passwd (which must de deleted by caller) or 0. If non-interactive run (eg ProofServ) returns -1 ; Definition at line 1142 of file TAuthenticate.cxx. ◆ PromptUser(). char * TAuthenticate::PromptUser ; (; const char * ; remote). static . Static method to prompt for the user name to be used for authentication to rootd or proofd. ; User is asked to type user name. Returns user name (which must be deleted by caller) or 0. If non-interactive run (eg ProofServ) returns default user. ; Definition at line 1102 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [1/2]. Int_t TAuthenticate::ProofAuthSetup ; (; ). private . Authentication related stuff setup in TProofServ. ; This is the place where the buffer send by the client / master is decoded. It contains also password information, if the case requires. Return 0 on success, -1 on failure. ; Definition at line 3699 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [2/2]. Int_t TAuthenticate::ProofAuthSetup ; (; TSocket * ; sock, . Bool_t ; client . ). staticprivate . Setup of authetication related stuff in PROOF run after a successful authentication. ; Return 0 on success, -1 on failure. ; Definition at line 3820 of file TAuthenticate.cxx. ◆ ReadRootAuthrc(). Int_t TAuthenticate::ReadRootAuthrc ; (; ). static . Read authenticati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:34424,authenticat,authentication,34424,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
