id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.7/apidoc/functions.html:58466,Availability,mask,mask,58466,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58602,Availability,mask,mask,58602," objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58699,Availability,mask,mask,58699,"shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58861,Availability,mask,masklist,58861,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional ent",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58879,Availability,mask,mask,58879,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional ent",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:74002,Availability,down,down,74002,"he; measurement is the corresponding eigenvalue. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opQobjThe measurement operator. targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.operations.gates.expand_operator; to expand op into full dimension. Returns. measured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:74509,Availability,down,down,74509,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator corresponding to the collapsed state as well as the; collapsed state. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opslist of QobjList of measurement operators \(M_i\) or kets. Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of ta",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:92409,Availability,error,error,92409,"aces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation values are; requested via the “e_ops” argument.; “store_final_state”: store final state even though expectation values are; requested via the “e_ops” argument. Parameters. Hqutip.QobjSystem Hamiltonian. psi0:class: qutip.QobjInitial state vector (ket). tlistNone / list / arrayList of times on which to evolve the initial state. If None, nothing; happens but the code won’t break. krylov_dim: intDimension of Krylov approximation subspaces used for the time; evolution approximation. e_opsNone / list of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. optionsOptions; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the finalsolution. (Defaults to 1e-8). nsteps: maximum number of krylov’s internal number of Lanczositerations. (Defaults to 10000). progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. sparsebool (default False)Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; tlist, or an array result.states of state vectors corresponding; to the times tlist [if e_ops is an empty list]. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfiel",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:118006,Availability,avail,available,118006,"Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct t",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:123285,Availability,error,errors,123285,"qrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the elemen",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:124747,Availability,error,errors,124747,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarr",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:126460,Availability,error,errors,126460,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:128161,Availability,error,errors,128161,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlatio",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:129950,Availability,error,errors,129950,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:131637,Availability,error,errors,131637," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of time",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:133427,Availability,error,errors,133427,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:135146,Availability,error,errors,135146,"t is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-sta",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:137035,Availability,error,errors,137035,"or; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:138431,Availability,error,errors,138431,"ver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s p",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145141,Availability,avail,availability,145141,"a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ system",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:147364,Availability,toler,tolerance,147364,"ominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210017,Availability,error,error,210017,"peroperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210185,Availability,error,error,210185,"imes \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210482,Availability,error,error,210482," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210729,Availability,error,error,210729,"TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211402,Availability,error,error,211402,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_ty",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:214421,Availability,error,error,214421,"can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:214488,Availability,error,error,214488,"alQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:215462,Availability,error,error,215462,"n the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:217034,Availability,error,error,217034," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:217054,Availability,error,error,217054," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:220895,Availability,error,error,220895,"nstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitu",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:221374,Availability,error,error,221374,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:221394,Availability,error,error,221394,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:222860,Availability,error,error,222860,"can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:222927,Availability,error,error,222927,"lQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencie",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:224572,Availability,error,error,224572,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific d",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:225403,Availability,error,error,225403,"ions for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type.; (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works.; (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator objec",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:225423,Availability,error,error,225423,"ions for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type.; (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works.; (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator objec",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:228372,Availability,error,error,228372,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229121,Availability,error,error,229121,"ill suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) th",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229859,Availability,error,error,229859,"slot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229879,Availability,error,error,229879,"lse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:231342,Availability,error,error,231342,"mput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:231409,Availability,error,error,231409,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequenci",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:233055,Availability,error,error,233055," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details). tslot_paramsdictParameters for the Ti",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:236347,Availability,error,error,236347,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:237199,Availability,error,error,237199," for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depen",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:237609,Availability,error,error,237609,"=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots w",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:237629,Availability,error,error,237629,"im_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; duratio",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:239095,Availability,error,error,239095," can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:239162,Availability,error,error,239162,"ialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note tha",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:240135,Availability,error,error,240135,"r target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictPara",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:241708,Availability,error,error,241708,"r the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer; classes for details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type; (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details.). tslot_paramsdictParameters for the TimeslotComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:241728,Availability,error,error,241728,"r the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer; classes for details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type; (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details.). tslot_paramsdictParameters for the TimeslotComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:244828,Availability,error,error,244828,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:245601,Availability,error,error,245601,"atsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provid",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:246266,Availability,error,error,246266,"thod_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:246433,Availability,error,error,246433,"ffset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_ts",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:247788,Availability,error,error,247788,"nput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:247855,Availability,error,error,247855,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:248828,Availability,error,error,248828,"en the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:252901,Availability,error,error,252901," pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:43189,Deployability,configurat,configuration,43189,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:43278,Deployability,configurat,configurations,43278," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:67165,Deployability,continuous,continuous,67165,"source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:79109,Deployability,integrat,integrating,79109," M_i\); projection operators if ops correspond to; projectors (s.t. \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:81713,Deployability,integrat,integrating,81713,"ions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Options, which; contains either an array of expectation values for the times; specified by tlist, or an array or state vectors; corresponding to the times in tlist (if e_ops is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:84047,Deployability,integrat,integration,84047,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:84686,Deployability,integrat,integrator,84686," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by q",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:85023,Deployability,integrat,integrator,85023,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:89790,Deployability,integrat,integration,89790,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; qutip.Qobj.eigenstates to get the eigenstates and -values,; and use QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. r",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151414,Deployability,configurat,configuration,151414,"mulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151794,Deployability,integrat,integrated,151794,"e propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:170680,Deployability,integrat,integrated,170680,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:171412,Deployability,integrat,integrated,171412,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:209889,Deployability,configurat,configuration,209889,"olve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:212887,Deployability,configurat,configuration,212887,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:269043,Deployability,update,updated,269043,"isplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20305,Energy Efficiency,charge,charge,20305,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20369,Energy Efficiency,charge,charge,20369,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20390,Energy Efficiency,charge,charge,20390,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20451,Energy Efficiency,charge,charge,20451,"0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20509,Energy Efficiency,charge,charge,20509,"s a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Pa",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:20577,Energy Efficiency,charge,charge,20577,"rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (defaul",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:100642,Energy Efficiency,power,power,100642,"e lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increa",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:107962,Energy Efficiency,power,power,107962,"uate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). optio",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:108408,Energy Efficiency,energy,energy,108408,"max=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. P",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:139662,Energy Efficiency,power,power,139662,"op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_like",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:140117,Energy Efficiency,power,power,140117,"tionary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_ss(H, wlist, c_ops, a_op, b_op)[source]¶; Calculate the spectrum of the correlation function; \(\l",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:143207,Energy Efficiency,power,power,143207,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:143236,Energy Efficiency,power,power,143236,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:143849,Energy Efficiency,reduce,reduced,143849,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145314,Energy Efficiency,power,power,145314,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145323,Energy Efficiency,power,power-gmres,145323,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145338,Energy Efficiency,power,power-lgmres,145338,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145354,Energy Efficiency,power,power-bicgstab,145354,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145662,Energy Efficiency,power,power,145662,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145676,Energy Efficiency,power,power,145676,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145698,Energy Efficiency,power,power,145698,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145714,Energy Efficiency,power,power-gmres,145714,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145729,Energy Efficiency,power,power-lgmres,145729,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:145745,Energy Efficiency,power,power-bicgstab,145745,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:147213,Energy Efficiency,power,power,147213,"inimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated aut",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:148578,Energy Efficiency,reduce,reduced,148578,"xplicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, default 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optionalITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:160832,Energy Efficiency,energy,energy,160832,"cks(rho)[source]¶; Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. square_blocks: list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:161085,Energy Efficiency,energy,energy,161085,"list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:161121,Energy Efficiency,energy,energy,161121,"locks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:163964,Energy Efficiency,energy,energy,163964,"of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate bloc",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:164099,Energy Efficiency,energy,energy,164099,"rameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate blocks in the density matrix. Parameters. rhoqutip.QobjDensity matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins. Returns. purityfloatThe pu",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:170203,Energy Efficiency,efficient,efficient,170203,"ix. This cannot have tensor-product; structure. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of \(\hbar\) in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:170560,Energy Efficiency,efficient,efficient,170560,"onds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:173414,Energy Efficiency,efficient,efficient,173414,"urce]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:180012,Energy Efficiency,energy,energy,180012,"ax=None, threshold=None)[source]¶; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, ax",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:180079,Energy Efficiency,energy,energy,180079,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:180126,Energy Efficiency,energy,energy,180126,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. res",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:180433,Energy Efficiency,energy,energy,180433,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWheth",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:180494,Energy Efficiency,energy,energy,180494,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWhether or not to show the legend. figa matplotlib Figure instanceThe Figure c",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211043,Energy Efficiency,reduce,reduces,211043,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:259082,Energy Efficiency,energy,energy,259082,"ith maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:259150,Energy Efficiency,energy,energy,259150,"the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:259353,Energy Efficiency,energy,energy,259353,"ithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestr or pathlib.Pat",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:265295,Energy Efficiency,schedul,scheduling,265295,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced v",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:265640,Energy Efficiency,schedul,scheduled,265640,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evalua",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:266897,Energy Efficiency,schedul,scheduling,266897,"rgs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:267242,Energy Efficiency,schedul,scheduled,267242,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:961,Integrability,depend,dependent,961,". Functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:24918,Integrability,depend,depending,24918,"ntity(dims, excitations)[source]¶; Generate the identity operator for the excitation-number restricted; state space defined by the dims and exciations arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters. dimslistA list of the dimensions of each subsystem of a composite quantum; system. excitationsintegerThe maximum number of excitations that are to be included in the; state space. statelist of integersThe state in the number basis representation. Returns. opQobjA Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by dims and; exciations. identity(dims)[source]¶; Identity operator. Alternative name to qeye. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. jmat(j, *args)[source]¶; Higher-order spin operators:. Parameters. jfloatSpin of operator. argsstrWhich operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no args given, then output is [‘x’,’y’,’z’]. Returns. jmatqobj / ndarrayqobj for requested spin operator(s). Notes; If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.; Examples; >>> jmat(1) ; [ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. momentum(N, offset=0)[source]¶; Momentum operator p=-1j/sq",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:28347,Integrability,depend,depending,28347,"_likeArray of elements to place along the selected diagonals. offsetssequence of ints; Sequence for diagonals to be set:; k=0 main diagonal; k>0 kth upper diagonal; k<0 kth lower diagonal. dimslist, optionalDimensions for operator. shapelist, tuple, optionalShape of operator. If omitted, a square operator large enough; to contain the diagonals is generated. See also. scipy.sparse.diagsfor usage information. Notes; This function requires SciPy 0.11+.; Examples; >>> qdiags(sqrt(range(1, 4)), 1) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. qeye(dimensions)[source]¶; Identity operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> s",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:29197,Integrability,depend,depending,29197,", then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> sigmam() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]. sigmap()[source]¶; Creation operator for Pauli spins.; Examples; >>> sigmap() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 0. 0.]]. sigmax()[source]¶; Pauli spin 1/2 sigma-x operator; Examples; >>> sigmax() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. sigmay()[source]¶; Pauli spin 1/2 sigma-y operator.; Examples; >>> sigmay() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-1.j]; [ 0.+1.j 0.+0.j]]. sigmaz()[source]¶; Pauli spin 1/2 sigma-z operator.; Examples; >>> sigmaz() ; Quantum object: dims = [[2], [2]], shape = [2, 2], t",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58238,Integrability,contract,contracted,58238,"ce]¶; Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transp",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58313,Integrability,contract,contracted,58313,"t spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:79109,Integrability,integrat,integrating,79109," M_i\); projection operators if ops correspond to; projectors (s.t. \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:79824,Integrability,depend,dependent,79824,"uation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as f(t, state) and return the expectation value. A single; callback’s expectation value can be any type, but a callback part of a; list must return a number as the expectation value. For operators, the; result’s expect will be computed by qutip.expect when the state; is a ket. For operator evolution, the overlap is computed by:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional ins",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:80642,Integrability,depend,dependent,80642,"n; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as f(t, state) and return the expectation value. A single; callback’s expectation value can be any type, but a callback part of a; list must return a number as the expectation value. For operators, the; result’s expect will be computed by qutip.expect when the state; is a ket. For operator evolution, the overlap is computed by:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Options, which; contains either an array of expectation values for the times; specified by tlist, or an array or state vectors; corresponding to the times in tlist (if e_ops is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a give",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:81713,Integrability,integrat,integrating,81713,"ions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Options, which; contains either an array of expectation values for the times; specified by tlist, or an array or state vectors; corresponding to the times in tlist (if e_ops is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:82441,Integrability,depend,dependent,82441,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:82471,Integrability,depend,dependent,82471,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:82801,Integrability,depend,dependent,82801,"apse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluatin",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:83277,Integrability,depend,dependence,83277,"eroperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an elemen",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:83732,Integrability,depend,dependent,83732,"rmat) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:84047,Integrability,integrat,integration,84047,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:84686,Integrability,integrat,integrator,84686," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by q",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:85023,Integrability,integrat,integrator,85023,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:85164,Integrability,depend,dependent,85164," even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.solver.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; sh",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:85955,Integrability,depend,dependent,85955,"utip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.solver.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and po",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87100,Integrability,depend,dependent,87100,"hereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87206,Integrability,depend,dependent,87206,"hereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87329,Integrability,depend,dependent,87329,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87415,Integrability,depend,dependent,87415,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87505,Integrability,depend,dependent,87505,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:87633,Integrability,depend,dependent,87633," mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:88568,Integrability,depend,dependent,88568," with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbit",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:89790,Integrability,integrat,integration,89790,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; qutip.Qobj.eigenstates to get the eigenstates and -values,; and use QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. r",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:90346,Integrability,depend,dependent,90346,"st, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; qutip.Qobj.eigenstates to get the eigenstates and -values,; and use QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Krylov Subspace Solver¶. krylovsolve(H: qutip.qobj.Qobj, psi0: qutip.qobj.Qobj, tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:90735,Integrability,depend,dependence,90735,"0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; qutip.Qobj.eigenstates to get the eigenstates and -values,; and use QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Krylov Subspace Solver¶. krylovsolve(H: qutip.qobj.Qobj, psi0: qutip.qobj.Qobj, tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95481,Integrability,depend,dependent,95481,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95614,Integrability,depend,dependent,95614,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95785,Integrability,depend,dependence,95785,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95937,Integrability,depend,dependence,95937,"_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opsli",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:96150,Integrability,depend,dependence,96150,"functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when e",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:96437,Integrability,depend,dependence,96437,"le.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProg",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:100427,Integrability,depend,dependent,100427,"and the transformation should be made; back to the lab frame. f_energiesarray_like of float, optionalThe precalculated Floquet quasienergies. Necessary if; floquet_basis is False and the transformation should be made; back to the lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:100481,Integrability,depend,dependence,100481,"ame. f_energiesarray_like of float, optionalThe precalculated Floquet quasienergies. Necessary if; floquet_basis is False and the transformation should be made; back to the lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alph",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:101853,Integrability,depend,dependent,101853,"able_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:101971,Integrability,depend,dependence,101971,"des_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-d",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:102132,Integrability,depend,dependent,102132,"; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at ti",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:102852,Integrability,depend,dependent,102852,"ime-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate th",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:102970,Integrability,depend,dependence,102970,"-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet m",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:103312,Integrability,depend,dependence,103312,"ian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe pe",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:103562,Integrability,depend,dependence,103562,"loquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompos",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:104196,Integrability,depend,dependent,104196,"rce]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Flo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:104250,Integrability,depend,dependence,104250,"lated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:105713,Integrability,depend,dependent,105713,"tateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Par",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:105767,Integrability,depend,dependence,105767,"energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of ini",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:107020,Integrability,depend,dependent,107020,"ergies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the colla",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:107074,Integrability,depend,dependence,107074,"or a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dep",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:108071,Integrability,depend,dependence,108071,"me-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solve",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:108241,Integrability,depend,dependent,108241,"(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:109416,Integrability,depend,dependent,109416,"y/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:109771,Integrability,depend,dependence,109771,"r solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the determin",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:110502,Integrability,depend,depending,110502," for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:111660,Integrability,depend,dependent,111660,"ist of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:111702,Integrability,depend,depend,111702,"le classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.R",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:111924,Integrability,depend,dependent,111924," stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqut",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:112046,Integrability,depend,depend,112046," of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:112141,Integrability,depend,dependent,112141,"tor or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be unifo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:112372,Integrability,depend,depend,112372,"sultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 function",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:112942,Integrability,depend,dependent,112942,"erministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:112984,Integrability,depend,depend,112984,"Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matr",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:113189,Integrability,depend,dependent,113189,"tors. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:113420,Integrability,depend,depend,113420,"utip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opsl",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:114910,Integrability,depend,depending,114910,"; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:114998,Integrability,depend,dependent,114998,"density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.Resul",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:115040,Integrability,depend,depend,115040,"iformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0,",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:115262,Integrability,depend,dependent,115262,"ators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:115384,Integrability,depend,depend,115384,"nd d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:115479,Integrability,depend,dependent,115479,"tion singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse oper",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:115710,Integrability,depend,depend,115710,"esult. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; quti",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:117018,Integrability,depend,depending,117018,"ip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic so",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:117106,Integrability,depend,dependent,117106,"; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:117148,Integrability,depend,depend,117148,"unction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler metho",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:117345,Integrability,depend,dependent,117345,"e vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruya",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:117576,Integrability,depend,depend,117576,"esingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:122523,Integrability,depend,dependent,122523,"r of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.so",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:122945,Integrability,depend,dependent,122945,"4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent fo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:123929,Integrability,depend,dependent,123929,"s, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist,",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:124351,Integrability,depend,dependent,124351,"Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0Qobj",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:125295,Integrability,depend,dependent,125295,"nt 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options cla",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:125974,Integrability,depend,dependent,125974,"se=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculat",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:127220,Integrability,depend,dependent,127220,"nte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:127642,Integrability,depend,dependent,127642," index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using th",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:128777,Integrability,depend,dependent,128777,"t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver opt",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:129450,Integrability,depend,dependent,129450," reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; C",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:130816,Integrability,depend,dependent,130816,"ement list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quan",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:131236,Integrability,depend,dependent,131236,"s; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calc",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:132355,Integrability,depend,dependent,132355," solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursive",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:133026,Integrability,depend,dependent,133026," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\r",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:134305,Integrability,depend,dependent,134305,"ecause; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:134725,Integrability,depend,dependent,134725," instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression the",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:135943,Integrability,depend,dependent,135943,"ries). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:136614,Integrability,depend,dependent,136614,"ion function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \lef",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:149896,Integrability,depend,dependent,149896,"ints when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:150148,Integrability,depend,dependent,150148,"objSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. N",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151021,Integrability,depend,dependent,151021,"gator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151094,Integrability,depend,dependent,151094,"slist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamilt",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151794,Integrability,integrat,integrated,151794,"e propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:163139,Integrability,depend,depending,163139,"s to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe GHZ state density matrix in the requested basis. ground(N, basis='dicke')[source]¶; Generate the density matrix of the ground state.; This state is given by (N/2, -N/2) in the Dicke basis. If the argument; basis is “uncoupled” then it generates the state in a; \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe ground state density matrix in the requested basis. identity_uncoupled(N)[source]¶; Generate the identity in a \(2^N\)-dimensional Hilbert space.; The identity matrix is formed from the tensor product of N TLSs. Parameters. N: intThe number of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:170680,Integrability,integrat,integrated,170680,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:171412,Integrability,integrat,integrated,171412,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:213220,Integrability,depend,dependent,213220,"', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:213440,Integrability,depend,dependent,213440,"_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:215692,Integrability,depend,dependent,215692,"ng local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each t",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:221659,Integrability,depend,dependent,221659," guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:221878,Integrability,depend,dependent,221878,"urce]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229233,Integrability,wrap,wrapper,229233,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:230155,Integrability,depend,dependent,230155,"to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:230366,Integrability,depend,dependent,230366," format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:237895,Integrability,depend,dependent,237895,"s=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar valu",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:238115,Integrability,depend,dependent,238115,"file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:240367,Integrability,depend,dependent,240367,"g local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each times",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:245713,Integrability,wrap,wrapper,245713," error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:246601,Integrability,depend,dependent,246601,"ource]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:246812,Integrability,depend,dependent,246812,"and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:249064,Integrability,depend,dependent,249064," local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:254278,Integrability,rout,routines,254278,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:256287,Integrability,rout,routine,256287,"mutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if necessary. Parameters. Asparse matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the prod",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:256898,Integrability,rout,routine,256898," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:257004,Integrability,rout,routines,257004," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:267695,Integrability,depend,dependencies,267695," to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:268013,Integrability,depend,dependencies,268013,"iew, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyri",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:43189,Modifiability,config,configuration,43189,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:43278,Modifiability,config,configurations,43278," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:47109,Modifiability,extend,extend,47109,"tum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input quantum objects. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_ops)[source]¶; Convert a list of Kraus operators into Choi representation of the channel.; Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters. kraus_opslist[Qobj]The list of Kraus operators to be converted to Choi representation. Returns. choiQobjA quantum object representing the",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:47317,Modifiability,extend,extend,47317,"eate a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_ops)[source]¶; Convert a list of Kraus operators into Choi representation of the channel.; Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters. kraus_opslist[Qobj]The list of Kraus operators to be converted to Choi representation. Returns. choiQobjA quantum object representing the same map as kraus_ops, such that; choi.superrep == ""choi"". kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a supero",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:67176,Modifiability,variab,variable,67176,"source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:79203,Modifiability,evolve,evolve,79203,"to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as f(t, s",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:81845,Modifiability,evolve,evolved,81845,"simulation. Returns. output: ResultAn instance of the class Options, which; contains either an array of expectation values for the times; specified by tlist, or an array or state vectors; corresponding to the times in tlist (if e_ops is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:92004,Modifiability,evolve,evolve,92004,", tlist: numpy.array, krylov_dim: int, e_ops=None, options=None, progress_bar: Optional[bool] = None, sparse: bool = False)[source]¶; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (“psi0”) finding an approximation for the time; evolution operator of Hamiltonian (“H”) by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation values are; requested via the “e_ops” argument.; “store_final_state”: store final state even though expectation values are; requested via the “e_ops” argument. Parameters. Hqutip.QobjSystem Hamiltonian. psi0:class: qutip.QobjInitial state vector (ket). tlistNone / list / arrayList of times on which to evolve the initial state. If None, nothing; happens but the code won’t break. krylov_dim: intDimension of Krylov approximation subspaces used for the time; evolution approximation. e_opsNone / list of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. optionsOptions; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the finalsolution. (Defaults to 1e-8). nsteps: maximum number of krylov’s internal number of Lanczositerations. (Defaults to 10000). progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. sparsebool (default False)Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; tlist",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:94105,Modifiability,coupling,couplingto,94105,"rresponding; to the times tlist [if e_ops is an empty list]. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.solver.OptionsOptions for the ODE solver. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains either; an array of expectation values for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an i",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95072,Modifiability,coupling,coupling,95072,"em given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95268,Modifiability,coupling,coupling,95268,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95408,Modifiability,variab,variable,95408,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95669,Modifiability,variab,variable,95669,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95730,Modifiability,variab,variables,95730,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:95813,Modifiability,variab,variable,95813,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:97133,Modifiability,coupling,coupling,97133,"line objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, rho0, tlist, e_ops, options=None, floquet_basis=True, f_modes_0=None, f_modes_table_t=None, f_energies=None, T=None)[source]¶;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:100542,Modifiability,variab,variables,100542,"Floquet quasienergies. Necessary if; floquet_basis is False and the transformation should be made; back to the lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qu",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:101908,Modifiability,variab,variables,101908,"quet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with va",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:102907,Modifiability,variab,variables,102907,"variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:104311,Modifiability,variab,variables,104311,"dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states fo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:105828,Modifiability,variab,variables,105828,"on to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floq",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:107135,Modifiability,variab,variables,107135,"loquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None, options=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicate",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:109832,Modifiability,variab,variables,109832,"sults in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151177,Modifiability,config,config,151177,"tonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151414,Modifiability,config,configuration,151414,"mulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:191442,Modifiability,enhance,enhance,191442,"ich the plot will be drawn. savebool {False , True}Whether to save the figure or not. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. The first entry of the ket defines the coefficient; c_{l,-l}, while the last entry of the ket defines the; coefficient c_{l, l}. Parameters. thetaint/float/list/arrayPolar angles in [0, pi]. phiint/float/list/arrayAzimuthal angles in [0, 2*pi]. argslist/arraylist of ket vectors. Returns. array for angular wave function evaluated at allpossible combinations of theta and phi. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data value",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:191579,Modifiability,variab,variables,191579,"ig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. The first entry of the ket defines the coefficient; c_{l,-l}, while the last entry of the ket defines the; coefficient c_{l, l}. Parameters. thetaint/float/list/arrayPolar angles in [0, pi]. phiint/float/list/arrayAzimuthal angles in [0, 2*pi]. argslist/arraylist of ket vectors. Returns. array for angular wave function evaluated at allpossible combinations of theta and phi. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. neg_colorstr",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:209889,Modifiability,config,configuration,209889,"olve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210507,Modifiability,variab,variables,210507," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211078,Modifiability,variab,variables,211078,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211165,Modifiability,variab,variables,211165,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211245,Modifiability,variab,variables,211245,"ntly two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, m",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:212887,Modifiability,config,configuration,212887,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:221181,Modifiability,variab,variables,221181,"ization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau ar",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:223999,Modifiability,variab,variable,223999,"of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calcula",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:224514,Modifiability,variab,variable,224514,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific d",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229666,Modifiability,variab,variables,229666,"ff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau arr",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232482,Modifiability,variab,variable,232482,"f the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232997,Modifiability,variab,variable,232997," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details). tslot_paramsdictParameters for the Ti",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:258676,Modifiability,coupling,coupling,258676,"nerate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thflo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:262123,Modifiability,variab,variable,262123,"This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_m",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:262546,Modifiability,variab,variables,262546,"Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of; qutip.parallel.parallel_map. Param",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:262606,Modifiability,variab,variables,262606," of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of; qutip.parallel.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of va",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:59215,Performance,concurren,concurrence,59215,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:59256,Performance,concurren,concurrence,59256,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:74363,Performance,perform,perform,74363,"sured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator corresponding to the collapsed state as well as the; collapsed state. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opslist of QobjList of measurement operators \(M_i\) or kets. Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:74415,Performance,perform,perform,74415,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator corresponding to the collapsed state as well as the; collapsed state. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opslist of QobjList of measurement operators \(M_i\) or kets. Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of ta",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:146789,Performance,perform,perform,146789,"olvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:147096,Performance,perform,perform,147096,"ed into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:173911,Performance,perform,performance,173911,"hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True, color_style='scaled')[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or su",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210439,Performance,optimiz,optimize,210439," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:211895,Performance,optimiz,optimization,211895," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:215375,Performance,optimiz,optimize,215375,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:215560,Performance,optimiz,optimize,215560,"rol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:216068,Performance,optimiz,optimize,216068," above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:220070,Performance,optimiz,optimizer,220070,"pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:220143,Performance,optimiz,optimizer,220143,"e assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:223810,Performance,perform,performane,223810,"idelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:224140,Performance,optimiz,optimize,224140,"are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the sp",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:224438,Performance,optimiz,optimize,224438,"ride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) comp",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232292,Performance,perform,performance,232292,"delity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are as",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232623,Performance,optimiz,optimize,232623,"re specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the Fideli",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232921,Performance,optimiz,optimize,232921,"ide these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:240048,Performance,optimiz,optimize,240048,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dyn",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:240234,Performance,optimiz,optimize,240234," squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pr",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:240735,Performance,optimiz,optimize,240735,"hm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer; classes for details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradie",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:248741,Performance,optimiz,optimize,248741,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:248926,Performance,optimiz,optimize,248926,"trol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParame",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:249432,Performance,optimiz,optimize,249432,"ee above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC.;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:257986,Performance,perform,performing,257986,"hill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(v",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:260788,Performance,load,loaded,260788,"photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestr or pathlib.PathName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestr or pathlib.PathName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestr or pathlib.PathName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:264633,Performance,load,load-balanced,264633,"the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Semidefinite Programming¶; This module implements internal-use functions for semidefinite programming. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:265354,Performance,load,load-balanced,265354,"w_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instanc",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:266282,Performance,load,load-balanced,266282,"ing the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:266956,Performance,load,load-balanced,266956,"view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string contai",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:44758,Safety,avoid,avoids,44758," a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part of collapse operator. bQobj or QobjEvo (optional)Right part of collapse operator. If not specified, b defaults to a. Returns. Dqobj, QobjEvoLindblad dissipator superoperator. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. operator_to_vector(op)[source]¶; Create a vector representation given a quantum operator in matrix form.; The passed object should have a Qobj.type of ‘oper’ or ‘super’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in matrix form. This must have a type of ‘oper’ or; ‘super’. Returns. Qobj or QobjEvoThe same object, but re-cast into a column-stacked-vector form of type; ‘operator-ket’. The output is the same type as the passed object. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:61216,Safety,detect,detect,61216,"alculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. E",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:118765,Safety,predict,predictor-correctorGeneralization,118765,"ticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:119053,Safety,predict,predictor-corrector,119053,"sesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:121384,Safety,predict,predictor,121384,"ochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolutio",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:268536,Safety,detect,detecting,268536,"isplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:184401,Security,access,access,184401,"be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; See also [1].; References. 1; J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, Qubism: self-similar visualization of many-body; wavefunctions, New J. Phys. 14 053028, arXiv:1112.3560; (2012), open access. plot_schmidt(ket, splitting=None, labels_iteration=(3, 2), theme='light', fig=None, ax=None, figsize=(6, 6))[source]¶; Plotting scheme related to Schmidt decomposition.; Converts a state into a matrix (A_ij -> A_i^j),; where rows are first particles and columns - last.; See also: plot_qubism with how=’before_after’ for a similar plot. Parameters. ketQobjPure state for plotting. splittingintPlot for a number of first particles versus the rest.; If not given, it is (number of particles + 1) // 2. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. labels_iterationint or pair of ints (default (3,2))Number of particles to be shown as tick labels,; for first (vertical) and last (horizontal) particles, respectively. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the m",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:210357,Security,access,accessible,210357,"rator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:219726,Security,access,accessible,219726," value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gu",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:219914,Security,access,accessed,219914,"or a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a contro",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:220017,Security,access,accessed,220017,"ed for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:228193,Security,access,accessible,228193,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system a",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:236167,Security,access,accessible,236167,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:244648,Security,access,accessible,244648,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:252721,Security,access,accessible,252721,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:59799,Testability,log,logarithm,59799,"; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(r",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:60550,Testability,log,logarithm,60550,"45, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:61047,Testability,log,logarithm,61047,"tLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-N",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:61854,Testability,log,log,61854,"p.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:62129,Testability,log,logarithm,62129," the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. bures_angle(A, B)[source]¶; Returns the Bures Angle between two density matrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:64894,Testability,test,testing,64894," norm of. BQobj or NoneIf provided, the diamond norm of \(A - B\) is taken instead. solverstrSolver to use with CVXPY. One of “CVXOPT” (default) or “SCS”. The; latter tends to be significantly faster, but somewhat less accurate. verboseboolIf True, prints additional information about the solution. force_solveboolIf True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. sparseboolWhether to use sparse matrices in the convex optimisation problem.; Default True. Returns. dnfloatDiamond norm of q_oper. Raises. ImportErrorIf CVXPY cannot be imported. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332). hellinger_dist(A, B, sparse=False, tol=0)[source]¶; Calculates the quantum Hellinger distance between two density matrices.; Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))); See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, “Geometric; measures of quantum correlations with Bures and Hellinger distances”; arXiv:1611.03449. Parameters. Aqutip.QobjDensity matrix or state vector. Bqutip.QobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. hellinger_distfloatQuantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjD",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:65708,Testability,test,testing,65708,"bjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332). hellinger_dist(A, B, sparse=False, tol=0)[source]¶; Calculates the quantum Hellinger distance between two density matrices.; Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))); See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, “Geometric; measures of quantum correlations with Bures and Hellinger distances”; arXiv:1611.03449. Parameters. Aqutip.QobjDensity matrix or state vector. Bqutip.QobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. hellinger_distfloatQuantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Exam",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:66769,Testability,test,testing,66769,"95). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:69958,Testability,log,logarithmic,69958,"ue hbar=1. Returns. corr_matndarrayArray of complex numbers or Qobj’s; A 2-dimensional array of covariance values for the field quadratures,; or, if rho=0, a matrix of operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continuous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two mod",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:70461,Testability,log,logarithmic,70461,"rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continuous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. RndarrayThe quadrature correlation matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:118308,Testability,test,tested,118308,". sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:219259,Testability,log,logger,219259,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:224038,Testability,test,tested,224038,"um allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each time",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:227486,Testability,log,logger,227486,"tribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, default ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:232521,Testability,test,tested,232521,"m allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value;",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:235460,Testability,log,logger,235460,"to be attribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:243941,Testability,log,logger,243941,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:252016,Testability,log,logger,252016,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object. The key; value pairs are assumed to be attribute name value pairs. They applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses fo",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:63758,Usability,simpl,simplified,63758,"objQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. bures_angle(A, B)[source]¶; Returns the Bures Angle between two density matrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. anglefloatBures angle between density matrices. bures_dist(A, B)[source]¶; Returns the Bures distance between two density matrices A & B.; The Bures distance ranges from 0, for states with unit fidelity,; to sqrt(2). Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatBures distance between density matrices. dnorm(A, B=None, solver='CVXOPT', verbose=False, force_solve=False, sparse=True)[source]¶; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13].; The diamond norm SDP is solved by using CVXPY. Parameters. AQobjQuantum map to take the diamond norm of. BQobj or NoneIf provided, the diamond norm of \(A - B\) is taken instead. solverstrSolver to use with CVXPY. One of “CVXOPT” (default) or “SCS”. The; latter tends to be significantly faster, but somewhat less accurate. verboseboolIf True, prints additional information about the solution. force_solveboolIf True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. sparseboolWhether to use sparse matrices in the convex optimisation problem.; Default True. Returns. dnfloatDiamond norm of q_oper. Raises. ImportErrorIf CVXPY cannot be imported. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:88828,Usability,progress bar,progress bar,88828,"_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolve will be removed in QuTiP 5. Please use; sesolve or mesolve for general-purpose; integration of the Schroedinge",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:118135,Usability,simpl,simple,118135,", see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:119484,Usability,usab,usable,119484,"uations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. O",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:120407,Usability,usab,usable,120407,"in while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredic",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:120768,Usability,usab,usable,120768,"strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:150645,Usability,progress bar,progress bar,150645,"{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:151151,Usability,clear,clears,151151,"tonians and; collapse operators. optionsqutip.solver.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:208843,Usability,learn,learningtimes,208843," for QASM file to be imported. In case of; string input, the parameter strmode must be True. modestrQASM mode to be read in. When mode is “qiskit”,; the “qelib1.inc” include is automatically included,; without checking externally. Otherwise, each include is; processed. versionstrQASM version of the QASM file. Only version 2.0 is currently supported. strmodeboolif specified as True, indicates that qasm_input is in string format; rather than from file. Returns. qcQubitCircuitReturns a QubitCircuit object specified in the QASM file. save_qasm(qc, file_loc)[source]¶; Save QASM output of circuit object to file. Parameters. qc: :class:`.QubitCircuit`circuit object to produce QASM output for. Non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configurati",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:229224,Usability,simpl,simply,229224,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:245704,Usability,simpl,simply,245704," error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:265754,Usability,progress bar,progress bar,265754,". Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Cl",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:267356,Usability,progress bar,progress bar,267356," these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array o",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/development/contributing.html:6183,Availability,reliab,reliably,6183,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:6721,Availability,avail,available,6721,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8686,Availability,failure,failures,8686,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change typ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8739,Availability,error,error,8739,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change typ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10459,Availability,down,down,10459,"tory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11459,Availability,avail,available,11459,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11687,Availability,avail,available,11687,"that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been ch",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12798,Availability,failure,failure,12798,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:13686,Availability,error,errors,13686,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3063,Deployability,update,update,3063," result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are i",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3406,Deployability,install,installing,3406,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3554,Deployability,install,installation,3554," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3572,Deployability,release,release,3572," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3766,Deployability,install,installation,3766," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3833,Deployability,install,installation,3833," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4298,Deployability,install,installed,4298,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4345,Deployability,install,install,4345,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4499,Deployability,install,installed,4499,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4520,Deployability,install,install,4520,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4574,Deployability,install,install,4574,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5015,Deployability,install,installation,5015,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5043,Deployability,install,installation,5043,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:6118,Deployability,install,install,6118," python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:6331,Deployability,update,updated,6331," is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are fun",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:7518,Deployability,release,release,7518," is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:7823,Deployability,update,update,7823,"e this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use som",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8571,Deployability,install,installed,8571,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, d",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:9639,Deployability,install,installing,9639,"xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10872,Deployability,install,install,10872,"ort description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11030,Deployability,configurat,configuration,11030,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11091,Deployability,install,install,11091,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11136,Deployability,configurat,configuration,11136,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11286,Deployability,install,install,11286,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11399,Deployability,update,update,11399,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11801,Deployability,release,release,11801,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11854,Deployability,install,install,11854,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12098,Deployability,install,installed,12098,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12469,Deployability,install,installation,12469,"te their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12654,Deployability,update,update,12654,"n.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests f",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12842,Deployability,install,installed,12842,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:14106,Deployability,update,updated,14106,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4590,Integrability,depend,dependencies,4590,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5639,Integrability,rout,routines,5639,"ary development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8493,Integrability,depend,depending,8493,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, d",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:9553,Integrability,depend,depending,9553,"nutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documen",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10274,Integrability,depend,dependencies,10274," add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend y",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10642,Integrability,depend,dependencies,10642,"nstalling towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.;",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10892,Integrability,depend,dependencies,10892,"ort description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11294,Integrability,depend,dependencies,11294,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12806,Integrability,message,messages,12806,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12872,Integrability,depend,dependencies,12872,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:7259,Modifiability,variab,variable,7259,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11030,Modifiability,config,configuration,11030,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11136,Modifiability,config,configuration,11136,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5180,Performance,load,load,5180,"version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temp",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5909,Safety,detect,detect,5909,"r you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:6164,Safety,detect,detection,6164,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11956,Security,access,accessible,11956,"requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will b",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:1096,Testability,test,testing,1096,"atter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:2088,Testability,test,tests,2088,"vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of thi",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:2705,Testability,test,tests,2705,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:2800,Testability,test,tests,2800,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:2835,Testability,test,tests,2835,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3880,Testability,test,tests,3880,"es are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to bu",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4000,Testability,test,testing,4000,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4032,Testability,test,tests,4032,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:4169,Testability,test,test,4169,"ndards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. f",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:6742,Testability,test,test,6742,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8370,Testability,test,test,8370,"o not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8410,Testability,test,test,8410,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8446,Testability,test,tests,8446,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8605,Testability,test,tests,8605,"ry to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:8880,Testability,test,tests,8880,"other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short descrip",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:9000,Testability,test,tests,9000,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:9074,Testability,test,tests,9074,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:9115,Testability,test,tests,9115,"me it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built u",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11580,Testability,test,test,11580,"o keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you w",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:13630,Testability,test,tests,13630,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:13808,Testability,test,test,13808,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:2920,Usability,feedback,feedback,2920,"add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The b",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3399,Usability,simpl,simply,3399,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:3711,Usability,guid,guide,3711," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:5056,Usability,guid,guide,5056,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:7346,Usability,guid,guidelines,7346,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:10396,Usability,simpl,simply,10396,"tory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:11780,Usability,guid,guide,11780,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:12161,Usability,simpl,simply,12161,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:13076,Usability,guid,guide,13076,"stalled all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ;",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/contributing.html:13181,Usability,guid,guide,13181,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html
https://qutip.org/docs/4.7/development/development.html:614,Deployability,release,releases,614,". Development Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Ch",MatchSource.WIKI,docs/4.7/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/development.html
https://qutip.org/docs/4.7/development/development.html:1033,Deployability,integrat,integration,1033,"thon; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Relea",MatchSource.WIKI,docs/4.7/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/development.html
https://qutip.org/docs/4.7/development/development.html:1326,Deployability,release,release,1326,"the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Next ; Previous. © Copyrigh",MatchSource.WIKI,docs/4.7/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/development.html
https://qutip.org/docs/4.7/development/development.html:2401,Deployability,update,updated,2401,"mentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/development.html
https://qutip.org/docs/4.7/development/development.html:1033,Integrability,integrat,integration,1033,"thon; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Relea",MatchSource.WIKI,docs/4.7/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/development.html
https://qutip.org/docs/4.7/development/docs.html:5740,Deployability,update,updated,5740,"ecified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1090,Modifiability,config,configured,1090,"ox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1481,Testability,test,tests,1481,"lbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, te",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2106,Testability,test,test,2106," in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the sa",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2144,Testability,test,testcode,2144,"can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print t",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2204,Testability,test,testcode,2204," the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2299,Testability,test,testoutput,2299,"ease refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To c",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2323,Testability,test,testoutput,2323,"individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2361,Testability,test,testcode,2361," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2476,Testability,test,tests,2476,"est way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doc",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2640,Testability,test,testcode,2640,"he documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directiv",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2802,Testability,test,testcode,2802,"y the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests a",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:3271,Testability,test,tested,3271,"). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:3814,Testability,test,tests,3814,"efault, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the name",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:5486,Testability,test,testing,5486,"ecified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:612,Usability,guid,guide,612,". Working with the QuTiP Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:670,Usability,guid,guide,670,". Working with the QuTiP Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:830,Usability,learn,learn,830,". Working with the QuTiP Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:906,Usability,guid,guide,906,". Working with the QuTiP Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1219,Usability,guid,guide,1219,"tation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1376,Usability,guid,guidelines,1376,". Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1434,Usability,guid,guide,1434,". Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:1522,Usability,simpl,simplest,1522,". Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; spec",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:2400,Usability,simpl,simpler,2400," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/docs.html:5561,Usability,learn,learn,5561,"ecified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html
https://qutip.org/docs/4.7/development/ideas.html:1380,Deployability,update,updated,1380,". Ideas for future QuTiP development — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; Ideas for significant new features are listed here. For the general roadmap,; see QuTiP Development Roadmap. QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Google Summer of Code¶; Many possible extensions and improvements to QuTiP have been documented as; part of Google Summer of Code:. GSoC 2021; GSoC 2022. Completed Projects¶; These projects have been completed:. TensorFlow Data Backend. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas.html
https://qutip.org/docs/4.7/development/release_distribution.html:11017,Availability,down,download,11017,"rs are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version numb",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11429,Availability,down,down,11429,"y merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12473,Availability,avail,available,12473," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12893,Availability,down,download,12893,"evious deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13577,Availability,down,down,13577,"t Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and cl",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15326,Availability,down,down,15326,"into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zi",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15748,Availability,down,down,15748,"recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17027,Availability,down,downloads,17027,"d (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases sec",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17718,Availability,down,download,17718," Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-fee",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18969,Availability,down,downloaded,18969,"hen you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are foun",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19049,Availability,down,download,19049,"tip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.;",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:958,Deployability,update,updates,958,"﻿. Release and Distribution — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-chang",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:987,Deployability,release,release,987,"﻿. Release and Distribution — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-chang",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1010,Deployability,release,releases,1010,"﻿. Release and Distribution — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-chang",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1214,Deployability,release,release,1214," Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do no",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1275,Deployability,deploy,deploy,1275,"velopment; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1370,Deployability,deploy,deploy,1370,"velopment; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1458,Deployability,release,release,1458,"elease; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1606,Deployability,deploy,deploying,1606,"optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1802,Deployability,release,released,1802,". Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a s",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1936,Deployability,patch,patch,1936,"e and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1942,Deployability,release,release,1942,"e and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:1989,Deployability,update,update-changelog,1989,"ease and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if neces",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2023,Deployability,release,release,2023,"ease and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if neces",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2062,Deployability,release,release,2062," to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of releas",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2074,Deployability,update,update-changelog,2074," to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of releas",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2187,Deployability,release,release,2187,"k.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the ch",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2276,Deployability,release,release,2276,"; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-n",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2294,Deployability,release,releases,2294,"urce packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main q",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2547,Deployability,release,release,2547,"with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2612,Deployability,update,updated,2612,"kage to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involv",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2974,Deployability,release,release,2974,"ng a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream ma",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3067,Deployability,release,release,3067," fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a comm",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3285,Deployability,release,release,3285,"e made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3462,Deployability,release,release,3462,"ge that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Creat",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3505,Deployability,release,release,3505,"ge that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Creat",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3566,Deployability,release,release,3566,"ge that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Creat",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3659,Deployability,release,release,3659,"ges to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on quti",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3713,Deployability,release,release,3713,"ges to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on quti",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:3734,Deployability,release,release,3734,"hanged docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for e",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:4099,Deployability,release,release,4099,"t type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:4956,Deployability,release,release,4956," at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSI",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5090,Deployability,release,release,5090," the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have ch",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5108,Deployability,release,release,5108," the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have ch",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5245,Deployability,release,release,5245,"ill be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5478,Deployability,release,release,5478,"without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull re",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5619,Deployability,release,release,5619,"t the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffi",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6170,Deployability,release,released,6170,"ersion string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is vi",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6371,Deployability,release,release,6371,"the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X)",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6396,Deployability,release,release,6396,"the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X)",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6490,Deployability,release,release,6490,"git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6714,Deployability,release,release,6714,"ou will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only b",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6730,Deployability,deploy,deploy,6730,"branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Ch",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6800,Deployability,release,released,6800,"d, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6940,Deployability,patch,patch,6940,"d, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:7189,Deployability,release,release,7189," have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only n",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:7390,Deployability,update,update,7390,"r release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.;",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:7511,Deployability,release,release,7511,"h to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single com",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:7783,Deployability,release,release,7783,"ch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9717,Deployability,patch,patch,9717,"se and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes y",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9793,Deployability,patch,patch,9793,"se and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes y",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9930,Deployability,release,release,9930,"tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and D",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10177,Deployability,release,release,10177,"he commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitH",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10633,Deployability,update,updated,10633,"a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10825,Deployability,release,release,10825,"enerally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10841,Deployability,deploy,deploy,10841," are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for som",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11267,Deployability,deploy,deploy,11267,"ip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11479,Deployability,release,release,11479,"y merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11617,Deployability,release,release,11617,"en updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, cl",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11767,Deployability,deploy,deployment,11767,"ify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the bel",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11919,Deployability,deploy,deployment,11919,"binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the sou",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12147,Deployability,upgrade,upgrades,12147,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12169,Deployability,release,releases,12169,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12205,Deployability,release,release,12205,"y.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12321,Deployability,deploy,deployment,12321,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12352,Deployability,deploy,deployment,12352,"ader notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, li",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12487,Deployability,install,install,12487," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12502,Deployability,install,install,12502," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13443,Deployability,deploy,deployment,13443,"n will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this i",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13706,Deployability,deploy,deployment,13706,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentat",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13778,Deployability,deploy,deployment,13778,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentat",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13929,Deployability,deploy,deployed,13929,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14067,Deployability,deploy,deploy,14067,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14078,Deployability,release,release,14078,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14330,Deployability,release,release,14330," its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14396,Deployability,release,release,14396,"ployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other wor",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14467,Deployability,patch,patch,14467,"ployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other wor",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14473,Deployability,release,release,14473,"ployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other wor",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14793,Deployability,release,release,14793,"derstood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, an",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15234,Deployability,release,release,15234,"been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after t",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15287,Deployability,release,release,15287," Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15684,Deployability,patch,patch,15684,"recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15690,Deployability,release,release,15690,"recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15730,Deployability,release,release,15730,"recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:15889,Deployability,release,release,15889,"e qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16416,Deployability,release,release,16416,"VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into t",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16596,Deployability,update,updated,16596,"our-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16614,Deployability,patch,patch,16614,"our-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16620,Deployability,release,release,16620,"our-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16844,Deployability,release,release,16844,"derneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16926,Deployability,release,releases,16926," .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Sourc",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17167,Deployability,release,release,17167,"nd qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17326,Deployability,release,release,17326,"those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and z",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17745,Deployability,release,release,17745,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fo",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17781,Deployability,update,updated,17781,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fo",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17841,Deployability,release,release,17841," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHu",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:17857,Deployability,update,updated,17857," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHu",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18151,Deployability,release,release,18151,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the ve",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18183,Deployability,release,release,18183,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the ve",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18263,Deployability,release,releases,18263,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the ve",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18323,Deployability,release,release,18323,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18350,Deployability,update,updated,18350,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18408,Deployability,release,release,18408,"l into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected i",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18539,Deployability,update,updated,18539,"removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to you",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18586,Deployability,release,release,18586,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18641,Deployability,release,releases,18641,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18907,Deployability,release,release,18907,"heir filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channe",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19239,Deployability,update,update,19239,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:20101,Deployability,update,updated,20101,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12698,Energy Efficiency,monitor,monitor,12698,"; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instru",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13234,Energy Efficiency,monitor,monitor,13234," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built a",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8110,Integrability,depend,depending,8110," you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9160,Integrability,message,message,9160," to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9723,Integrability,depend,depends,9723,"se and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes y",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:11540,Integrability,depend,depending,11540,"R. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version ap",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:13892,Integrability,message,message,13892,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16085,Integrability,wrap,wrap,16085,"wser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINO",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18865,Integrability,interface,interface,18865,"heir filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channe",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19848,Modifiability,config,config,19848,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:6702,Performance,perform,perform,6702,"ou will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only b",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10813,Performance,perform,perform,10813,"enerally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12299,Performance,perform,perform,12299,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:14928,Safety,safe,safe,14928,"e a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8388,Security,hash,hash,8388,"fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8445,Security,hash,hash,8445," from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is th",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8619,Security,hash,hash,8619,"s branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will eith",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8663,Security,hash,hash,8663,"it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a ver",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8961,Security,hash,hash,8961,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9184,Security,hash,hashes,9184," to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9313,Security,hash,hashes,9313,"with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever ve",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:16804,Security,access,access,16804,"derneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:18820,Security,checksum,checksum,18820,"heir filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channe",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19257,Security,checksum,checksum,19257,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:5839,Testability,test,tests,5839,"in the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pu",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:7927,Testability,log,log,7927,"ine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single comm",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8228,Testability,log,log,8228,"ip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear loc",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8290,Testability,log,log,8290,"ip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear loc",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8907,Testability,log,log,8907,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:8929,Testability,log,log,8929,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9121,Testability,log,log,9121,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10482,Testability,test,tests,10482,"ry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be cal",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:12133,Testability,test,testing,12133,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19608,Testability,test,tests,19608,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19659,Testability,test,tests,19659,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:19771,Testability,test,test,19771,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:2582,Usability,guid,guide,2582,"kage to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involv",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:9649,Usability,simpl,simple,9649,"se and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes y",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/release_distribution.html:10379,Usability,clear,clear,10379,"1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below.",MatchSource.WIKI,docs/4.7/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html
https://qutip.org/docs/4.7/development/roadmap.html:3491,Availability,mainten,maintence,3491,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9759,Availability,mask,masking,9759," deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:11420,Availability,error,errors,11420,"rally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is i",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15642,Availability,avail,available,15642,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:416,Deployability,integrat,integration,416,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:709,Deployability,release,release,709,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:1270,Deployability,release,release,1270,"TiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence qutip.org. The QuTiP Community includes all the; people who have supported the project since in",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:4059,Deployability,release,release,4059," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:4242,Deployability,install,installed,4242,"pe of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a depen",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:4853,Deployability,integrat,integrated,4853,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:4936,Deployability,install,installed,4936,"he freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:5105,Deployability,install,installed,5105," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconve",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:5804,Deployability,integrat,integrated,5804,"es. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6200,Deployability,integrat,integrated,6200,"e; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package symps",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6415,Deployability,integrat,integrated,6415,"at we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wr",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6838,Deployability,integrat,integrated,6838," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true a",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:8505,Deployability,integrat,integration,8505,"st version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, suc",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:8736,Deployability,deploy,deploying,8736,"pect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9018,Deployability,integrat,integrated,9018," cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9162,Deployability,integrat,integrated,9162,"ore distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12866,Deployability,toggle,toggle,12866," file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers ch",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15222,Deployability,release,release,15222,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15306,Deployability,release,release,15306,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15447,Deployability,integrat,integration,15447,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15571,Deployability,release,release,15571,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15813,Deployability,release,release,15813,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15856,Deployability,release,released,15856,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15962,Deployability,update,updated,15962,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:416,Integrability,integrat,integration,416,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:3523,Integrability,depend,dependences,3523,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:3595,Integrability,depend,depend,3595,"iP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; des",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:4853,Integrability,integrat,integrated,4853,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:5172,Integrability,depend,dependency,5172," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconve",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:5804,Integrability,integrat,integrated,5804,"es. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6200,Integrability,integrat,integrated,6200,"e; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package symps",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6415,Integrability,integrat,integrated,6415,"at we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wr",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6838,Integrability,integrat,integrated,6838," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true a",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:6994,Integrability,depend,depends,6994,"pportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, devel",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:7056,Integrability,depend,dependency,7056,"tion subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:7434,Integrability,wrap,wrapper,7434,"package; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:8505,Integrability,integrat,integration,8505,"st version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, suc",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:8765,Integrability,depend,dependent,8765,"pect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9018,Integrability,integrat,integrated,9018," cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9162,Integrability,integrat,integrated,9162,"ore distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9824,Integrability,depend,dependent,9824,"he data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10097,Integrability,wrap,wrapper,10097,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10335,Integrability,interface,interface,10335,"new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python log",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12201,Integrability,interface,interface,12201,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Dev",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15447,Integrability,integrat,integration,15447,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:3919,Modifiability,enhance,enhancement,3919," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9690,Modifiability,variab,variables,9690," deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:9834,Modifiability,variab,variable,9834,"he data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10115,Modifiability,variab,variable,10115,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:11167,Modifiability,layers,layers,11167," optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12433,Modifiability,flexible,flexible,12433," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the de",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12476,Modifiability,flexible,flexible,12476,"ing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12929,Modifiability,config,configure,12929,"s. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. statu",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:8662,Performance,perform,performance,8662,"ns – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10177,Performance,optimiz,optimize,10177,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:13721,Performance,perform,performance,13721,"void these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; completed. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:11603,Safety,avoid,avoided,11603,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12734,Safety,avoid,avoid,12734,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12269,Security,access,accessible,12269,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Dev",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:3740,Testability,test,testing,3740," scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTi",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:7656,Testability,test,tests,7656,"s will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity f",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10945,Testability,log,logging,10945,"ining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, c",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:11352,Testability,log,logging,11352," a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in educa",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:11925,Testability,log,logging,11925,". main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have slider",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15678,Testability,test,test,15678,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15798,Testability,test,testing,15798,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:15841,Testability,test,tested,15841,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:7795,Usability,simpl,simplifcation,7795,"QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum ",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10273,Usability,learn,learning,10273,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:10652,Usability,simpl,simplify,10652,"Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized component",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12071,Usability,simpl,simple,12071,"olvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuit",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/development/roadmap.html:12348,Usability,learn,learners,12348,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead",MatchSource.WIKI,docs/4.7/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html
https://qutip.org/docs/4.7/guide/guide-basics.html:1316,Availability,avail,available,1316,"ath. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:9629,Availability,error,error,9629,"atrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eige",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:1179,Deployability,install,installation,1179,"c Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structu",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:14505,Deployability,update,updated,14505,"822695]; [0.26105441 0.26093584 0.18523331 0.10374209 0.06263061]; [0.14620658 0.14614018 0.10374209 0.05810197 0.035077 ]; [0.08826704 0.08822695 0.06263061 0.035077 0.0211765 ]]. >>> coherent_dm(5, 1).diag(); array([0.36791117, 0.36757705, 0.18523331, 0.05810197, 0.0211765 ]). >>> coherent_dm(5, 1).full(); array([[0.36791117+0.j, 0.36774407+0.j, 0.26105441+0.j, 0.14620658+0.j,; 0.08826704+0.j],; [0.36774407+0.j, 0.36757705+0.j, 0.26093584+0.j, 0.14614018+0.j,; 0.08822695+0.j],; [0.26105441+0.j, 0.26093584+0.j, 0.18523331+0.j, 0.10374209+0.j,; 0.06263061+0.j],; [0.14620658+0.j, 0.14614018+0.j, 0.10374209+0.j, 0.05810197+0.j,; 0.035077 +0.j],; [0.08826704+0.j, 0.08822695+0.j, 0.06263061+0.j, 0.035077 +0.j,; 0.0211765 +0.j]]). >>> coherent_dm(5, 1).norm(); 1.0000000175063126. >>> coherent_dm(5, 1).sqrtm(); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0.36791117+3.66778589e-09j 0.36774407-2.13388761e-09j; 0.26105441-1.51480558e-09j 0.14620658-8.48384618e-10j; 0.08826704-5.12182118e-10j]; [0.36774407-2.13388761e-09j 0.36757705+2.41479965e-09j; 0.26093584-1.11446422e-09j 0.14614018+8.98971115e-10j; 0.08822695+6.40705133e-10j]; [0.26105441-1.51480558e-09j 0.26093584-1.11446422e-09j; 0.18523331+4.02032413e-09j 0.10374209-3.39161017e-10j; 0.06263061-3.71421368e-10j]; [0.14620658-8.48384618e-10j 0.14614018+8.98971115e-10j; 0.10374209-3.39161017e-10j 0.05810197+3.36300708e-10j; 0.035077 +2.36883273e-10j]; [0.08826704-5.12182118e-10j 0.08822695+6.40705133e-10j; 0.06263061-3.71421368e-10j 0.035077 +2.36883273e-10j; 0.0211765 +1.71630348e-10j]]. >>> coherent_dm(5, 1).tr(); 1.0. >>> (basis(4, 2) + basis(4, 1)).unit(); Quantum object: dims = [[4], [1]], shape = (4, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0.70710678]; [0. ]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:4956,Energy Efficiency,charge,charge,4956,"ying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states.; Therefore, QuTiP includes predefined objects for a variety of states and operators:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:8537,Integrability,message,message,8537,"es (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. ",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:2018,Modifiability,variab,variables,2018,"ography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the names of Python classes, such as Qobj(), are capitalized whereas the names of functions are not. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; print(Qobj([[1],[2],[3],[4],[5]])). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), t",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:1206,Performance,load,load,1206," class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra ",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:1295,Performance,load,load,1295,"ath. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:1674,Performance,load,loaded,1674,"ocesses; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:7425,Security,access,accessed,7425," =; [[0.]; [0.]; [0.]; [1.]; [0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex1",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:8661,Security,access,access,8661,"e print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); -----------------------------------",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-basics.html:10071,Testability,log,logic,10071,">>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not spars",MatchSource.WIKI,docs/4.7/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:2233,Availability,avail,available,2233,"ing the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:5824,Availability,down,down,5824,"nctions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.bloch.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). Again, the same plot can be generated using the qutip.bloch3d.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leading to a higher ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14310,Deployability,install,installing,14310,"pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14476,Deployability,install,install,14476,"ubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:15267,Deployability,update,updated,15267,"ubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:13036,Modifiability,evolve,evolve,13036,"the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to te",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:1856,Performance,load,load,1856,"Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:;",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:1947,Performance,load,loads,1947,"documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(p",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:10891,Security,access,accessed,10891,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:2045,Usability,simpl,simply,2045,"ng. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3363,Usability,clear,clear,3363," single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is be",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3467,Usability,clear,clear,3467," and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted,",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3852,Usability,clear,clear,3852,"och(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and sha",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:4119,Usability,clear,clear,4119,"commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:4132,Usability,clear,clear,4132," the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:5391,Usability,clear,clear,5391,"s because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.bloch.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). Again, the same plot can be generated using the qutip.bloch3d.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing b",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:5403,Usability,clear,clear,5403,"multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.bloch.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). Again, the same plot can be generated using the qutip.bloch3d.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:11816,Usability,clear,clear,11816," [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0:",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:13908,Usability,clear,clear,13908,"e > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax.",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14158,Usability,simpl,simple,14158,"turn output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be view",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14767,Usability,clear,clear,14767,"ubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-control.html:6019,Availability,error,error,6019,"then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11760,Availability,down,down,11760,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11832,Availability,avail,available,11832,"ter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, a",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12901,Availability,error,errors,12901,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11641,Deployability,integrat,integration,11641,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12709,Deployability,integrat,integration,12709,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12853,Deployability,integrat,integration,12853,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13334,Deployability,integrat,integrated,13334,"ch time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14436,Deployability,configurat,configuration,14436,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14660,Deployability,configurat,configuration,14660,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17370,Deployability,configurat,configuration,17370," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:18173,Deployability,update,updated,18173," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8045,Energy Efficiency,efficient,efficient,8045,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited m",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8336,Energy Efficiency,reduce,reduces,8336,"we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exac",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9114,Energy Efficiency,reduce,reduces,9114," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9313,Energy Efficiency,efficient,efficient,9313,"vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9668,Energy Efficiency,efficient,efficient,9668," known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11152,Energy Efficiency,efficient,efficiently,11152," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:18011,Energy Efficiency,efficient,efficient,18011," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:4295,Integrability,depend,dependent,4295,"} \ket{\psi} = -i H(t)\ket{\psi}\]; Note we use units where \(\hbar=1\) throughout. The solutions to Schrödinger’s equation are of the form:. \[\ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8971,Integrability,wrap,wrapper,8971,"and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other opti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11641,Integrability,integrat,integration,11641,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12709,Integrability,integrat,integration,12709,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12853,Integrability,integrat,integration,12853,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13334,Integrability,integrat,integrated,13334,"ch time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14180,Integrability,interface,interface,14180,"; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14704,Integrability,wrap,wrapper,14704,"ded for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be ac",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:4478,Modifiability,evolve,evolve,4478,"t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of meri",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6215,Modifiability,variab,variables,6215,"_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then loo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6331,Modifiability,variab,variable,6331,"_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then loo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6587,Modifiability,variab,variables,6587,"ontrol amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6656,Modifiability,variab,variable,6656,"ontrol amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6966,Modifiability,variab,variable,6966,"d \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8150,Modifiability,variab,variables,8150," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required,",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9185,Modifiability,variab,variable,9185," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13418,Modifiability,variab,variable,13418,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13697,Modifiability,extend,extended,13697,"t integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrap",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13933,Modifiability,config,configurability,13933,",; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14095,Modifiability,flexible,flexible,14095,"ementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a conta",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14436,Modifiability,config,configuration,14436,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14660,Modifiability,config,configuration,14660,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17370,Modifiability,config,configuration,17370," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17902,Modifiability,config,configure,17902," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:10150,Performance,perform,performing,10150,"entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), thi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11164,Performance,optimiz,optimize,11164," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12803,Performance,optimiz,optimization,12803,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13377,Performance,optimiz,optimize,13377,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13399,Performance,perform,perform,13399,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14601,Performance,load,loadparams,14601,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14725,Performance,optimiz,optimize,14725," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14749,Performance,perform,perform,14749," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:15823,Performance,perform,performed,15823,"orithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The opti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17145,Performance,perform,performance,17145,"is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6459,Usability,simpl,simplest,6459,"get \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidel",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6909,Usability,clear,clearly,6909,"d \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9398,Usability,simpl,simple,9398,"ere all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evoluti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14152,Usability,simpl,simple,14152,"; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14421,Usability,simpl,simply,14421,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:16093,Usability,simpl,simply,16093,"on operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17233,Usability,simpl,simplest,17233,"f course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17741,Usability,simpl,simply,17741," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:2728,Availability,avail,available,2728,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_3op_1t; \(\left<A(0)B(\tau)C(0)\right>\). qutip.correlation.correlation_3op_2t; \(\left<A(t)B(t+\tau)C(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:12708,Deployability,update,updated,12708,"unched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_3op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(0)\right>\) (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do \(a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)\).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and Fock state.; import numpy as np; import matplotlib.pyplot as plt; import qutip. N = 25; taus = np.linspace(0, 25.0, 200); a = qutip.destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [; {'state': qutip.coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': qutip.thermal_dm(N, 2), 'label': ""thermal state""},; {'state': qutip.fock_dm(N, 2), 'label': ""Fock state""},; ]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = qutip.mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = qutip.correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4570,Energy Efficiency,power,power,4570,"tion solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qu",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:5162,Energy Efficiency,power,power,5162,"ion_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting s",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:6312,Energy Efficiency,power,power,6312,"upling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4834,Integrability,depend,dependent,4834,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:1280,Modifiability,evolve,evolved,1280,"tion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:5359,Modifiability,coupling,coupling,5359,"plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolv",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4861,Performance,perform,performs,4861,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2623,Deployability,update,updated,2623,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:524,Integrability,depend,dependent,524,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1842,Integrability,depend,dependent,1842,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2264,Integrability,depend,dependent,2264,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-heom.html:1584,Deployability,update,updated,1584,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1914,Availability,down,down,1914,"ics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”.",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1945,Availability,down,down,1945,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states wit",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:2038,Availability,down,down,2038,"phy; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures th",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:2990,Availability,down,down,2990,"spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3233,Availability,down,down,3233,"max which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvecto",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3397,Availability,down,down,3397,"ement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3421,Availability,down,down,3421,"self:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement wil",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3492,Availability,down,down,3492,"ne of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3821,Availability,down,down,3821,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3845,Availability,down,down,3845,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:4511,Availability,down,down,4511,"nd down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conven",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:4539,Availability,down,down,4539,"1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspace",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5411,Availability,down,down,5411,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5434,Availability,down,down,5434,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:11703,Deployability,update,updated,11703," measurement statistics for projection operators,; we can use the measurement_statistics function with the second argument being a list of projectors.; Consider again, the state \(\ket{0+}\).; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by PZ2 which allow us to measure only; on the second qubit. Since the second qubit has the state \(\ket{+}\), we get; the following result.; collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). Output:; [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. print(probabilities). Output:; [0.4999999999999999, 0.4999999999999999]. The function measurement_statistics then returns two values:. collapsed_states is an array of the possible final states after the; measurement is complete. Each element of the array is a Qobj.; probabilities is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly \(\ket{00}\) and \(\ket{01}\); with equal probability, as expected. The two lists are in the same order. Note; When measurement_statistics; is invoked with the second argument; being a list of projectors, it acts as an alias to; measurement_statistics_povm. The measurement_statistics function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; measurement_statistics_observable; and measurement_statistics_povm.; Furthermore, the measure_povm; and measurement_statistics_povm functions can; handle POVM measurements which are more general than projective measurements. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1573,Performance,perform,perform,1573,"nerating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to p",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:6812,Performance,perform,perform,6812,"lus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7072,Performance,perform,perform,7072," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:8091,Performance,perform,perform,8091," What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:; >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ; array([-1., 1.]). >>> eigenstates ; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities ; [0.5000000000000001, 0.4999999999999999]. The measurement_statistics function then returns three values; when called with a single observable:. eigenvalues is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; the value is array([-1., -1.]).; eigenstates is an array of the eigenstates of the measurement operator, i.e.; a list of the possible final states after the measurement is complete.; Each element of the array is a Qobj.; probab",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1581,Usability,simpl,simple,1581,"nerating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to p",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5147,Usability,simpl,simply,5147,"he x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7057,Usability,learn,learned,7057," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7120,Usability,learn,learned,7120," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1752,Availability,avail,available,1752,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:2033,Deployability,update,updated,2033,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1834,Security,access,accessible,1834,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:947,Usability,guid,guide,947,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1036,Usability,guid,guide,1036,"; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sph",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1248,Usability,guid,guide,1248,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6111,Deployability,configurat,configurations,6111,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6626,Deployability,update,updated,6626,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6403,Energy Efficiency,power,powerful,6403,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1606,Modifiability,variab,variables,1606,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1655,Modifiability,variab,variables,1655,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6111,Modifiability,config,configurations,6111,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1340,Performance,perform,performing,1340,"amics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.pa",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1418,Performance,perform,performed,1418,"; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:4682,Performance,perform,performance,4682,"ere the qutip.parallel.parallel_map and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; >>> def sum_diff(x, y, z=0): return x + y, x - y, z. >>> parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. >>> parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:2461,Safety,avoid,avoid,2461,"el.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. >>> result = parallel_map(func1, range(5)). >>> print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; >>> def func2(x): return x, Qobj(x), 'a' * x. >>> a, b, c = parfor(func2, range(5)). >>> print(a); [0 1 2 3 4]. >>> print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[4.",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-qip.html:1626,Deployability,update,updated,1626,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:1445,Energy Efficiency,schedul,scheduler,1445,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-random.html:2753,Availability,down,down,2753,"6 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that specifies the dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the distributions supported by QuTiP support additional parameters as well, namely density and rank. In particular,; the rand_herm and rand_dm functions return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the density keyword argument. By contrast, the rand_dm_ginibre and; rand_super_bcsz take as an argument the rank of the generated object, such that passing rank=1 returns a random; pure state or unitary channel, respectively. Passing rank=None specifies that the generated object should be; full-rank for the given dimension.; For example,; >>> rand_dm(5, density=0.5); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:7617,Deployability,update,updated,7617,"ata =; [[ 2.51387054-5.55111512e-17j 0.81161447+2.02283642e-01j; 0. +0.00000000e+00j 0.875 +3.35634092e-01j; 0.81161447+2.02283642e-01j]; [ 0.81161447-2.02283642e-01j 1.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 0.375 +0.00000000e+00j]; [ 0. +0.00000000e+00j 0. +0.00000000e+00j; 2. +0.00000000e+00j 0. +0.00000000e+00j; 0. +0.00000000e+00j]; [ 0.875 -3.35634092e-01j -0.76700198-5.53011066e-01j; 0. +0.00000000e+00j 2.73612946+0.00000000e+00j; -0.76700198-5.53011066e-01j]; [ 0.81161447-2.02283642e-01j 0.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 1.375 +0.00000000e+00j]]. >>> H.eigenenergies() ; array([7.70647994e-17, 1.00000000e+00, 2.00000000e+00, 3.00000000e+00,; 4.00000000e+00]). In order to generate a random object with a given spectrum QuTiP applies a series of random complex Jacobi rotations. This technique requires many steps to build the desired quantum object, and is thus suitable only for objects with Hilbert dimensionality \(\lesssim 1000\). Composite random objects¶; In many cases, one is interested in generating random quantum objects that correspond to composite systems generated using the qutip.tensor.tensor function. Specifying the tensor structure of a quantum object is done using the dims keyword argument in the same fashion as one would do for a qutip.Qobj object:; >>> rand_dm(4, 0.5, dims=[[2,2], [2,2]]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 0.13622928+0.j 0. +0.j 0.01180807-0.01739166j; 0. +0.j ]; [ 0. +0.j 0.14600238+0.j 0.10335328+0.21790786j; -0.00426027-0.02193627j]; [ 0.01180807+0.01739166j 0.10335328-0.21790786j 0.57566072+0.j; -0.0670631 +0.04124094j]; [ 0. +0.j -0.00426027+0.02193627j -0.0670631 -0.04124094j; 0.14210761+0.j ]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:1221,Testability,test,testing,1221,"tter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Fu",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-saving.html:8451,Deployability,update,updated,8451,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:599,Performance,load,loading,599,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:634,Performance,load,loading,634,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1527,Performance,perform,performed,1527,"iP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1701,Performance,load,loading,1701,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1738,Performance,load,load,1738,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2161,Performance,load,loads,2161,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2687,Performance,load,loaded,2687," qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3115,Performance,load,load,3115,"tip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3486,Performance,load,loaded,3486,"adystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and thre",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3932,Performance,load,loading,3932,"ect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:4316,Performance,load,load,4316,"10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does; >>> a = dest",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:7988,Performance,load,loaded,7988,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2909,Testability,test,testing,2909,"e takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2263,Usability,simpl,simple,2263,"ad back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) *",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1494,Availability,toler,tolerance,1494,"tum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1936,Availability,toler,tolerance,1936,"umentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possi",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:3398,Deployability,update,updated,3398,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:3142,Integrability,depend,dependent,3142,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:2604,Performance,load,loaded,2604,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1998,Usability,simpl,simple,1998,"ifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openm",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:2776,Usability,simpl,simple,2776,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-states.html:13711,Availability,down,downarrow,13711,". Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; print(sigmaz()). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. spin2 = basis(2, 1). print(spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. print(sigmaz() * spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) sta",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:14404,Availability,down,downarrow,14404," The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:14670,Availability,down,downarrow,14670,"corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16512,Availability,down,down,16512,", 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16637,Availability,down,down,16637,"ity matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:33206,Deployability,update,updated,33206,"ensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; print(J.istp). Output:; False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true.; >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:11538,Energy Efficiency,energy,energy,11538,"9080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; print(vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. c = create(2). print(c * vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spin state gives:; print(",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:3831,Integrability,depend,dependence,3831," =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; c = create(5). print(c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; print(c * c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; print(c ** 2 * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; print(c * a * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; print(c * a * (c * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; print(c * a * (c**2 * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; print(c * a * (c**2 * vac).unit()). Output:; Quant",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19737,Modifiability,extend,extended,19737,"pace can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to plot the elements of \(S\) as a Hinton diagr",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1415,Performance,perform,performing,1415,"\(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:30545,Performance,perform,perform,30545,"+0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19581,Security,expose,exposed,19581," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10383,Testability,test,testing,10383,"29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:;",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10434,Testability,test,testing,10434,"2109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10823,Testability,test,testing,10823,". ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.si",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10988,Testability,assert,assert,10988,"o each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a ha",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15232,Testability,test,testing,15232," the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15283,Testability,test,testing,15283,"e underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect functio",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15362,Testability,test,testing,15362,"ith the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the i",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15479,Testability,test,testing,15479,"tion. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and o",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16535,Testability,test,testing,16535,"98j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuT",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16592,Testability,test,testing,16592,"ays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator fun",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16900,Testability,test,testing,16900,"0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = ope",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16959,Testability,test,testing,16959,"ple, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = ve",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:17993,Testability,test,testing,17993,", two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The type attribute indicates whether a quantum object is; a vector corresponding to an operator (operator-ket), or its Hermitian; conjugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19175,Testability,test,testing,19175,"jugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], sh",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:29788,Testability,test,testing,29788,").eigenenergies()). Output:; [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the \(\chi\)-matrix representation,. \[\Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,\]; where \(\{B_\alpha\}\) is a basis for the space of matrices acting; on \(\mathcal{H}\). In QuTiP, this basis is taken to be the Pauli; basis \(B_\alpha = \sigma_\alpha / \sqrt{2}\). Conversion to the; \(\chi\) formalism is handled by the to_chi; function.; chi = to_chi(S); print(chi). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\math",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1237,Usability,guid,guide,1237,"sity matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0.",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1392,Usability,guid,guide,1392,"\(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:7565,Usability,simpl,simplest,7565,"rint(d * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. print(d * s * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; ket = basis(5, 2). print(ket * ket.dag()). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; print(fock_dm(5, 2)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. print(ket2dm(ket)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number states we can do the following:; prin",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:22983,Usability,simpl,simply,22983,"\otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|].\]; In QuTiP, \(J(\Lambda)\) can be found by calling the to_choi; function on a type=""super"" Qobj.; X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. print(to_choi(spre(qeye(2)))). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a Qobj instance is already in the Choi superrep, then calling to_choi; does nothing:; print(to_choi(J)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the to_super function.; As with to_choi, to_super is idempotent:; print(to_super(J) - S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. print(to_super(S)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let \(\{A_i\}\) be a set of operators such that; \(J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|\).; We can write \(J(\Lambda)\) in this way; for any hermicity-preserving map; that is, for any map \(\Lambda\) such that \(J(\Lambda) = J^\dagger(\Lambda)\).; These operators then form the Kraus representation of \(\Lambda\). In particular, for any input \(\rho\),. \[\Lambda(\",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:31681,Usability,simpl,simply,31681,"spose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; p",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5572,Availability,down,downside,5572,"n be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:6919,Availability,error,error,6919,"ate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:7515,Availability,avail,available,7515,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:11773,Deployability,update,updated,11773,"nd weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equation', 'Steady State')); plt.title(; r'Decay of Fock state $\left|10\rangle\right.$'; r' in a thermal environment with $\langle n\rangle=2$'; ); plt.show(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:2550,Energy Efficiency,power,power,2550,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:2582,Energy Efficiency,power,power,2582,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:3423,Energy Efficiency,power,power,3423,"teratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory nee",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:4688,Energy Efficiency,reduce,reduced,4688,"essary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these it",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:4990,Energy Efficiency,power,power,4990,"m with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditi",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5027,Energy Efficiency,power,power,5027,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5074,Energy Efficiency,power,power,5074,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5212,Energy Efficiency,power,power,5212,"e solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:7637,Energy Efficiency,power,power,7637,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a i",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5148,Integrability,rout,routine,5148,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:10489,Modifiability,coupling,coupling,10489," decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:3624,Performance,perform,performance,3624,"MRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:8860,Performance,perform,perform,8860,"ng factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:10144,Performance,perform,perform,10144,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.d",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:1838,Usability,simpl,simple,1838," documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution v",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:9667,Usability,simpl,simple,9667,"less explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay ope",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:3179,Availability,down,down,3179,"qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:; print(tensor(basis(2, 0), basis(2, 0))). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:13118,Deployability,update,updated,13118,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4659,Energy Efficiency,energy,energy,4659," [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4813,Energy Efficiency,energy,energy,4813,"n a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:6217,Energy Efficiency,energy,energy,6217,"ntity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 5.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0.1 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 6.75; 0. 0. 0. 0. 0. 0.; 0. 0. 0.1118034 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 8. 0. 0. 0. 0. 0.; 0. 0. 0. 0.12247449 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 9",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:8373,Energy Efficiency,reduce,reduces,8373,"0. 0. 0. 0. 0. 0.14142136; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 11.75 0. 0.; 0. 0. 0. 0. 0. 0.; 0.15 0. ]; [ 0. 0.05 0. 0. 0. 0.; 0. 0. 0. 0. -0.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0.07071068 0. 0. 0.; 0. 0. 0. 0. 0. 0.75; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0.08660254 0. 0.; 0. 0. 0. 0. 0. 0.; 2. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0.1 0.; 0. 0. 0. 0. 0. 0.; 0. 3.25 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.1118034; 0. 0. 0. 0. 0. 0.; 0. 0. 4.5 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0.12247449 0. 0. 0. 0. 0.; 0. 0. 0. 5.75 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0.13228757 0. 0. 0. 0.; 0. 0. 0. 0. 7. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0.14142136 0. 0. 0.; 0. 0. 0. 0. 0. 8.25; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0.15 0. 0.; 0. 0. 0. 0. 0. 0.; 9.5 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 10.75 ]]. Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. >>> psi.ptrace(1); Quantum object: dims = [[2], [2]], shape = (2, ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:12605,Integrability,contract,contracting,12605,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:12675,Integrability,contract,contraction,12675,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:3277,Modifiability,extend,extended,3277,"ut:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:6113,Modifiability,coupling,coupling,6113,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:11577,Performance,perform,performs,11577,"eroperators can be represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.superop_reps.to_super:; >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4528,Usability,simpl,simple,4528,"or on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). O",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:5969,Usability,simpl,simplest,5969,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:11169,Availability,error,errors,11169,"in tomography._index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:15614,Deployability,update,updated,15614,"e superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:8542,Energy Efficiency,efficient,efficient,8542,"s[1]). fig.tight_layout(). plt.show(). Husimi Q-function¶; The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. \[Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>\]; where \(\left|\alpha\right>\) is a coherent state and; \(\alpha = x + iy\). In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function qfunc, as; demonstrated below.; Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the QFunc class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling qfunc in a loop.; xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). Visualizing operators¶; Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements.; QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, qutip.visualization.matrix_histogram and; qutip.visualization.matrix_histogram_complex, and as Hinton diagram of weighted; squares, qutip.visualiza",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:15417,Integrability,depend,dependent,15417,"e superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:1718,Performance,perform,perform,1718,"putation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:12512,Security,access,access,12512,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide.html:3633,Deployability,update,updated,3633,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:1703,Integrability,depend,dependent,1703,"ormation Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis pro",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:2897,Performance,load,loading,2897,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:2932,Performance,load,loading,2932,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/modules/index.html:346,Availability,avail,available,346,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:2201,Deployability,update,updated,2201," module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:1477,Energy Efficiency,schedul,scheduler,1477," module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:529,Performance,optimiz,optimizer,529,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:2192,Deployability,update,updated,2192,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:1351,Modifiability,extend,extend,1351,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:1506,Modifiability,extend,extended,1506,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:3718,Deployability,update,updated,3718,"er which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:2269,Integrability,depend,depend,2269,"20,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit b",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:990,Modifiability,enhance,enhance,990,"ion of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1273,Modifiability,enhance,enhanced,1273,"deas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical sy",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1528,Modifiability,enhance,enhance,1528,"ogle Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Ham",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1764,Usability,simpl,simple,1764,"l description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code c",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:3544,Usability,guid,guide,3544,"er which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1708,Availability,error,error,1708,"thon. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python sc",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2132,Availability,error,error,2132,"lasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Krista",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2402,Availability,error,error,2402," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2533,Availability,error,error,2533,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3399,Availability,error,error,3399,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:921,Deployability,release,release,921,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1571,Deployability,integrat,integration,1571,"Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,Deployability,integrat,integrate,2291,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2570,Deployability,integrat,integration,2570,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3801,Deployability,update,updated,3801,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1929,Energy Efficiency,schedul,schedule,1929,"qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (eta",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3664,Energy Efficiency,schedul,schedule,3664,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1571,Integrability,integrat,integration,1571,"Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,Integrability,integrat,integrate,2291,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2550,Integrability,protocol,protocols,2550,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2570,Integrability,integrat,integration,2570,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1038,Modifiability,enhance,enhanced,1038,"TiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues an",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2394,Performance,perform,perform,2394," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2351,Safety,avoid,avoid,2351,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1703,Deployability,toggle,toggle,1703,"on. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gm",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:2870,Deployability,update,updated,2870,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1087,Integrability,interface,interface,1087,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1393,Modifiability,flexible,flexible,1393,"imated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks int",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1954,Modifiability,config,configure,1954,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1155,Security,access,accessible,1155,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:957,Usability,simpl,simple,957,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1234,Usability,learn,learners,1234,"entation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processi",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:3440,Deployability,update,updated,3440,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:1614,Energy Efficiency,efficient,efficiently,1614,"ckend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some i",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2090,Energy Efficiency,efficient,efficiently,2090,"i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not requi",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2180,Energy Efficiency,efficient,efficiently,2180,"itten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (ja",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2415,Performance,perform,performance,2415,"es already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2602,Testability,benchmark,benchmark,2602,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2714,Testability,benchmark,benchmark,2714,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2845,Testability,benchmark,benchmark,2845,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/gallery/build/index.html:844,Deployability,update,updated,844,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:448,Availability,down,download,448,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:1964,Deployability,update,updated,1964,"um Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:446,Availability,down,download,446,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:756,Deployability,continuous,continuous,756,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:1905,Deployability,update,updated,1905,"c use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:428,Availability,down,download,428,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:1943,Deployability,update,updated,1943,"uTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2991,Availability,down,downside,2991,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:3361,Availability,robust,robust,3361,"ten desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hb",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5578,Deployability,integrat,integration,5578," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:18717,Deployability,update,updated,18717,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2225,Energy Efficiency,energy,energy,2225,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2525,Energy Efficiency,power,power,2525,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:8291,Energy Efficiency,power,power,8291,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:8573,Energy Efficiency,energy,energy,8573," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\bet",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:9472,Energy Efficiency,power,power,9472,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nest",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14716,Energy Efficiency,efficient,efficient,14716,"-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations preven",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14863,Energy Efficiency,efficient,efficient,14863,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15021,Energy Efficiency,power,power,15021,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15405,Energy Efficiency,power,power,15405,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17829,Energy Efficiency,power,power,17829,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:512,Integrability,depend,dependent,512,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:662,Integrability,depend,dependent,662,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:4980,Integrability,depend,depends,4980," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the ba",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5528,Integrability,depend,dependence,5528,"Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5578,Integrability,integrat,integration,5578," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:13678,Integrability,depend,dependent,13678,"_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, H_ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:13792,Integrability,depend,dependent,13792,"use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, H_ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14058,Integrability,depend,dependent,14058,"list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14309,Integrability,depend,dependent,14309,"uments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14808,Integrability,depend,dependent,14808,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14930,Integrability,depend,dependent,14930,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14994,Integrability,depend,dependent,14994,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15152,Integrability,depend,dependent,15152,"aster equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponen",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15453,Integrability,depend,dependent,15453,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15727,Integrability,depend,dependent,15727,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15777,Integrability,depend,dependent,15777,"elies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kap",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15978,Integrability,depend,dependent,15978,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16262,Integrability,depend,dependent,16262,"rmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17349,Integrability,depend,dependence,17349,"pa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17854,Integrability,depend,dependence,17854,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:18546,Integrability,depend,dependent,18546,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2837,Modifiability,coupling,coupling,2837,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5564,Modifiability,extend,extending,5564," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:10554,Modifiability,coupling,coupling,10554,"ectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument.; To illustrate how to calculate the Bloch-Redfield tensor, let’s consider a two-level atom. (8)¶\[ H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z\]; delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, H_ekets = bloch_redfield_tensor(H, [[sigmax(), ohmic_spectrum]]). print(R). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15993,Modifiability,coupling,coupling,15993,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16372,Modifiability,coupling,coupling,16372,"nt, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For exam",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16436,Modifiability,coupling,coupling,16436,"nto time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16771,Modifiability,coupling,coupling,16771,"endent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kapp",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17135,Modifiability,coupling,coupling,17135,"appa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17716,Modifiability,coupling,coupling,17716," destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14563,Performance,scalab,scalability,14563," psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, exc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15572,Safety,avoid,avoid,15572,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2015,Usability,clear,clear,2015,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:9577,Usability,simpl,simplify,9577," =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:6161,Deployability,update,updated,6161,"n values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:592,Integrability,depend,dependent,592,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:2939,Security,access,access,2939,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3986,Security,access,access,3986,"do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload f",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:4475,Security,access,accessed,4475,"om the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_res",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3002,Usability,guid,guide,3002,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3178,Usability,simpl,simply,3178," used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style index",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:4903,Usability,simpl,simplicity,4903,"using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_resul",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1537,Deployability,integrat,integration,1537,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:20471,Deployability,update,updated,20471," * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, by using:. output = fmmesolve(H, psi0, tlist, [sigmax()], [num(2)], [noise_spectrum], T, args, floquet_basis=False); p_ex = output.expect[0]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1768,Energy Efficiency,efficient,efficiently,1768,"ing for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12443,Energy Efficiency,efficient,efficiently,12443,"t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12596,Energy Efficiency,efficient,efficiently,12596," same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18674,Energy Efficiency,power,power,18674,"ccept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:499,Integrability,depend,dependent,499,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1423,Integrability,depend,dependent,1423,"lver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1537,Integrability,integrat,integration,1537,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1603,Integrability,depend,dependent,1603,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2135,Integrability,depend,dependent,2135,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2297,Integrability,depend,dependent,2297,"opyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2403,Integrability,depend,dependent,2403,"lism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2709,Integrability,depend,dependent,2709,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but o",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2937,Integrability,depend,dependent,2937," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:3141,Integrability,depend,dependence,3141,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:5001,Integrability,depend,dependent,5001,"\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)¶\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:6580,Integrability,depend,dependent,6580,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*np.pi / omega; >>> f_modes_0, f_energies = floquet_modes(H, T, args); >>> f_energies ; array([-2.83131212, 2.83131212]); >>> f_modes_0 ; [Quantum object: dims = [[2], [1]], shape = (2, 1)",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:11095,Integrability,depend,dependent,11095,"(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * np.random.rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; import numpy as np; from matplotlib import pyplot. import qutip. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.5 * 2*np.pi; omega = 1.0 * 2*np.pi; T = (2*np.pi)/omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2, 0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = qutip.floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet stat",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:13112,Integrability,depend,dependent,13112,"ction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = qutip.floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:14948,Integrability,depend,dependent,14948,"e results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using; output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17071,Integrability,depend,dependent,17071,"a_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. Th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18809,Integrability,depend,dependent,18809," implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:15781,Modifiability,coupling,coupling,15781,"em that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:16579,Modifiability,evolve,evolves,16579,"phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density fu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17427,Modifiability,coupling,coupling,17427,"ta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17710,Modifiability,coupling,coupling,17710,"alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18146,Modifiability,extend,extends,18146,"onment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:16313,Usability,simpl,simplified,16313," (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fm",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:3141,Deployability,update,updated,3141,"ystem Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:494,Integrability,depend,dependent,494,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1467,Modifiability,evolve,evolves,1467,"Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:2234,Performance,perform,performed,2234," in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built wit",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3080,Availability,error,error,3080,"t orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the f",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3111,Availability,error,error,3111,"n the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesol",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3221,Availability,error,error,3221,")¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a k",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:6859,Deployability,update,updated,6859,"= krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, rand_herm, rand_ket; >>> import numpy as np; >>> from time import time; >>> def time_krylov(psi0, H, tlist, sparse):; >>> start = time(); >>> krylovsolve(H, psi0, tlist, krylov_dim=30, sparse=sparse); >>> end = time(); >>> return end - start; >>> dim = 2000; >>> tlist = np.linspace(0, 1, 10); >>> psi0 = rand_ket(dim, seed=0); >>> H_sparse = rand_herm(dim, density=0.1, seed=0); >>> H_dense = rand_herm(dim, density=0.9, seed=0); >>> # first index for type of H and second index for sparse = True or False (dense); >>> t_ss = time_krylov(psi0, H_sparse, tlist, sparse=True); >>> t_sd = time_krylov(psi0, H_sparse, tlist, sparse=False); >>> t_ds = time_krylov(psi0, H_dense, tlist, sparse=True); >>> t_dd = time_krylov(psi0, H_dense, tlist, sparse=False); >>> print(f""Average time of solution for a sparse H is {round((t_sd)/t_ss, 2)} faster for sparse=True in comparison to sparse=False""); >>> print(f""Average time of solution for a dense H is {round((t_dd)/t_ds, 2)} slower for sparse=True in comparison to sparse=False""); Average time of solution for a sparse H is 2.46 faster for sparse=True in comparison to sparse=False; Average time of solution for a dense H is 0.45 slower for sparse=True in comparison to sparse=False. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2476,Energy Efficiency,reduce,reduced,2476,"s. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resid",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:533,Integrability,depend,dependent,533,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1519,Modifiability,evolve,evolves,1519," Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2160,Modifiability,evolve,evolved,2160,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this ca",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3863,Performance,optimiz,optimize,3863," when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as opposed to a density matrix, and the additional parameter krylov_dim that defines the maximum allowed Krylov-subspace dimension. The maximum number of allowed Lanczos partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((di",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:5411,Performance,optimiz,optimized,5411,"os partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((dim - 1) / 2.0, ""x""); >>> psi0 = rand_ket(dim); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, rand_herm, rand_ket; >>> import numpy as np; >>> from time import time; >>> def time_krylov(psi0, H, tlist, sparse):; >>> start = time(); >>> krylovsolve(H, psi0, tlist, krylov_dim=30, sparse=sparse); >>> end = time(); >>> return end - start; >>> dim = 2000; >>> tlist = np.linspace(0, 1, 10); >>> psi0 = rand_ket(dim, seed=0); >>> H_sparse = rand_herm(dim, density=0.1, seed=0); >>> H_dense = rand_herm(dim, density=0.9, seed=0); >>> # first index for type of H and second index for sparse = True or False (dense); >>> t_ss = time_krylov(psi0, H_sparse, tlist, sparse=True); >>> t_sd = time_krylov(psi0, H_sparse, tlist, sparse=False); >>> t_ds = time_krylov(psi0, H_dense, tlist, sparse=True); >>> t_dd = time_krylov(psi0, H_dense, tlist, sparse=False); >>> print(f""Average time of solution for a sparse H is {round((t_sd)/t_ss, 2)} faster for",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1913,Usability,simpl,simplest,1913,"Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are pract",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:4507,Usability,simpl,simple,4507,"ions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as opposed to a density matrix, and the additional parameter krylov_dim that defines the maximum allowed Krylov-subspace dimension. The maximum number of allowed Lanczos partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((dim - 1) / 2.0, ""x""); >>> psi0 = rand_ket(dim); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, ra",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:14626,Deployability,update,updated,14626,"equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() in the fourth; parameter to the qutip.mesolve function and moving the expectation; operators [sigmaz(), sigmay()] to the fifth argument.; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code; >>> times = np.linspace(0.0, 10.0, 200); >>> psi0 = tensor(fock(2,0), fock(10, 5)); >>> a = tensor(qeye(2), destroy(10)); >>> sm = tensor(destroy(2), qeye(10)); >>> H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); >>> result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); >>> plt.figure() ; >>> plt.plot(times, result.expect[0]) ; >>> plt.plot(times, result.expect[1]) ; >>> plt.xlabel('Time') ; >>> plt.ylabel('Expectation values') ; >>> plt.legend((""cavity photon number"", ""atom excitation probability"")) ; >>> plt.show() . Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2901,Energy Efficiency,efficient,efficient,2901,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:6481,Energy Efficiency,energy,energy,6481,")]); >>> fig, ax = plt.subplots(); >>> ax.plot(result.times, result.expect[0]) ; >>> ax.plot(result.times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . If an empty list of operators is passed as fourth parameter, the qutip.sesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; >>> times = [0.0, 1.0]; >>> result = sesolve(H, psi0, times, []); >>> result.states ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:8253,Energy Efficiency,reduce,reduced,8253,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires:",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:10300,Energy Efficiency,energy,energy,10300," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:10882,Energy Efficiency,energy,energy,10882,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:11095,Energy Efficiency,energy,energy,11095,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:12877,Energy Efficiency,energy,energy,12877,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() in the fourth; parameter to the qutip.mesolve function and moving the expectation; operators [sigmaz(), sigmay()] to the fifth argument.; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavit",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:585,Integrability,depend,dependent,585,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:3406,Modifiability,evolve,evolves,3406,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> result = sesolve(H, psi0, times, [sigmaz()]). See the next section for examples on how dissipation is included by defining a list of collapse operators and using qutip.mesolve instead.; The function qutip.sesolve returns an instance of qutip.solver.Result, as described in the previous section Dynamics Simulation Results. The attribute expect in result is a list of expectation values for the operators that are included in the list in the fourth argument. Adding operators to this list results in a larger output list returned by the function (one array of numbers, correspon",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2331,Performance,perform,perform,2331,"ter Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:7963,Performance,perform,perform,7963,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculati",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:8939,Performance,perform,perform,8939,"ystem, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
