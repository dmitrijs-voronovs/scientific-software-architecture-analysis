id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:111411,Energy Efficiency,allocate,allocated,111411,"o do this round.; 2770 } else if (element->IsaPointer()) {; 2771 elementName.Form(""*%s"",element->GetFullName());; 2772 insp.Inspect(fClass, insp.GetParent(), elementName.Data(), eaddr, isTransient);; 2773 } else {; 2774 insp.Inspect(fClass, insp.GetParent(), element->GetFullName(), eaddr, isTransient);; 2775 Int_t etype = element->GetType();; 2776 switch(etype) {; 2777 case kObject:; 2778 case kAny:; 2779 case kTObject:; 2780 case kTString:; 2781 case kTNamed:; 2782 case kSTL:; 2783 {; 2784 TClass *ecl = element->GetClassPointer();; 2785 if (ecl && (fClass!=ecl /* This happens 'artificially for stl container see the use of ""This"" */)) {; 2786 insp.InspectMember(ecl, eaddr, TString(element->GetName()) + ""."", isTransient);; 2787 }; 2788 break;; 2789 }; 2790 } // switch(etype); 2791 } // if IsaPointer(); 2792 } // Loop over elements; 2793 ; 2794 // And now do the base classes; 2795 next.Reset();; 2796 element = (TStreamerElement*) next();; 2797 for (; element; element = (TStreamerElement*) next()) {; 2798 if (element->IsBase()) {; 2799 // Skip elements which have not been allocated memory.; 2800 if (element->GetOffset() == kMissing) {; 2801 continue;; 2802 }; 2803 ; 2804 char* eaddr = ((char*)obj) + element->GetOffset();; 2805 ; 2806 TClass *ecl = element->GetClassPointer();; 2807 if (ecl) {; 2808 ecl->CallShowMembers(eaddr, insp, isTransient);; 2809 }; 2810 } // If is a abse; 2811 } // Loop over elements; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Make a clone of an object using the Streamer facility.; 2816/// If newname is specified, this will be the name of the new object.; 2817 ; 2818TObject *TStreamerInfo::Clone(const char *newname) const; 2819{; 2820 TStreamerInfo *newinfo = (TStreamerInfo*)TNamed::Clone(newname);; 2821 if (newname && newname[0] && fName != newname) {; 2822 TObjArray *newelems = newinfo->GetElements();; 2823 Int_t ndata = newelems->GetEntriesFast();; 2824 for(Int_t i = 0; i < ndata;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:192285,Energy Efficiency,allocate,allocate,192285,"zed"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762 }; 4763}; 4764 ; 4765////////////////////////////////////////////////////////////////////////////////; 4766/// An emulated object is created at address obj, if obj is null we; 4767/// allocate memory for the object.; 4768 ; 4769void* TStreamerInfo::New(void *obj); 4770{; 4771 //???FIX ME: What about varying length array elements?; 4772 ; 4773 char* p = (char*) obj;; 4774 ; 4775 TIter next(fElements);; 4776 ; 4777 if (!p) {; 4778 // Allocate and initialize the memory block.; 4779 p = new char[fSize];; 4780 memset(p, 0, fSize);; 4781 }; 4782 ; 4783 next.Reset();; 4784 TStreamerElement* element = (TStreamerElement*) next();; 4785 ; 4786 for (; element; element = (TStreamerElement*) next()) {; 4787 ; 4788 // Skip elements which have not been allocated memory.; 4789 if (element->GetOffset() == kMissing) {; 4790 continue;; 4791 }; 4792 ; 4793 // Skip elements for which we do not have any class; 4794 // information. FIXME: Document how this could happen.; 4795 TClass* cle = element->GetClassPointer();; 4796 if (!",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:192849,Energy Efficiency,allocate,allocated,192849,"fset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762 }; 4763}; 4764 ; 4765////////////////////////////////////////////////////////////////////////////////; 4766/// An emulated object is created at address obj, if obj is null we; 4767/// allocate memory for the object.; 4768 ; 4769void* TStreamerInfo::New(void *obj); 4770{; 4771 //???FIX ME: What about varying length array elements?; 4772 ; 4773 char* p = (char*) obj;; 4774 ; 4775 TIter next(fElements);; 4776 ; 4777 if (!p) {; 4778 // Allocate and initialize the memory block.; 4779 p = new char[fSize];; 4780 memset(p, 0, fSize);; 4781 }; 4782 ; 4783 next.Reset();; 4784 TStreamerElement* element = (TStreamerElement*) next();; 4785 ; 4786 for (; element; element = (TStreamerElement*) next()) {; 4787 ; 4788 // Skip elements which have not been allocated memory.; 4789 if (element->GetOffset() == kMissing) {; 4790 continue;; 4791 }; 4792 ; 4793 // Skip elements for which we do not have any class; 4794 // information. FIXME: Document how this could happen.; 4795 TClass* cle = element->GetClassPointer();; 4796 if (!cle) {; 4797 continue;; 4798 }; 4799 ; 4800 char* eaddr = p + element->GetOffset();; 4801 Int_t etype = element->GetType();; 4802 ; 4803 //cle->GetStreamerInfo(); //necessary in case ""->"" is not specified; 4804 ; 4805 switch (etype) {; 4806 ; 4807 case kAnyP:; 4808 case kObjectP:; 4809 case kSTLp:; 4810 {; 4811 // Initialize array of pointers with null pointers.; 4812 char** r = (char**) eaddr;; 4813 Int_t len = element->GetArrayLength();; 4814 for (Int_t i = 0; i < len; ++i) {; 4815 r[i] = 0;; 4816 }; 4817 }; 4818 break;; 4819 ; 4820 case kObjectp:; 4821 case kAnyp:; 4822 {; 4823 // If the option ""->"" is given in the data member com",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:196512,Energy Efficiency,allocate,allocate,196512,"info = cle->GetStreamerInfoAbstractEmulated();; 4858 if (einfo) einfo->New(eaddr);; 4859 } else {; 4860 cle->New(eaddr);; 4861 }; 4862 break;; 4863 }; 4864 case kObject:; 4865 case kAny:; 4866 case kTObject:; 4867 case kTString:; 4868 case kTNamed:; 4869 {; 4870 cle->New(eaddr);; 4871 }; 4872 break;; 4873 ; 4874 case kSTL:; 4875 {; 4876 if (strcmp(element->GetName(),""This"")==0 &&; 4877 !cle->GetCollectionProxy()) {; 4878 // missing information, avoid infinite loop; 4879 // by doing nothing ....; 4880 } else {; 4881 if (cle->GetCollectionProxy()); 4882 cle->GetCollectionProxy()->New(eaddr);; 4883 else; 4884 cle->New(eaddr);; 4885 }; 4886 }; 4887 break;; 4888 ; 4889 case kObject + kOffsetL:; 4890 case kAny + kOffsetL:; 4891 case kTObject + kOffsetL:; 4892 case kTString + kOffsetL:; 4893 case kTNamed + kOffsetL:; 4894 case kSTL + kOffsetL:; 4895 {; 4896 Int_t size = cle->Size();; 4897 char* r = eaddr;; 4898 Int_t len = element->GetArrayLength();; 4899 for (Int_t i = 0; i < len; ++i, r += size) {; 4900 cle->New(r);; 4901 }; 4902 }; 4903 break;; 4904 ; 4905 } // switch etype; 4906 } // for TIter next(fElements); 4907 ; 4908 for(int nbase = 0; nbase < fNVirtualInfoLoc; ++nbase) {; 4909 *(TStreamerInfo**)(p + fVirtualInfoLoc[nbase]) = this;; 4910 }; 4911 return p;; 4912}; 4913 ; 4914////////////////////////////////////////////////////////////////////////////////; 4915/// An array of emulated objects is created at address ary, if ary is null,; 4916/// we allocate memory for the array.; 4917 ; 4918void* TStreamerInfo::NewArray(Long_t nElements, void *ary); 4919{; 4920 if (fClass == 0) {; 4921 Error(""NewArray"", ""TClass pointer is null!"");; 4922 return 0;; 4923 }; 4924 ; 4925 Int_t size = fClass->Size();; 4926 ; 4927 char* p = (char*) ary;; 4928 ; 4929 if (!p) {; 4930 Long_t len = nElements * size + sizeof(Long_t)*2;; 4931 p = new char[len];; 4932 memset(p, 0, len);; 4933 }; 4934 ; 4935 // Store the array cookie; 4936 Long_t* r = (Long_t*) p;; 4937 r[0] = size;; 4938 r[1] = nE",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:200221,Energy Efficiency,allocate,allocated,200221,"f (ele->GetOffset() == kMissing) continue;; 4978 char* eaddr = p + ele->GetOffset();; 4979 ; 4980 ; 4981 Int_t etype = ele->GetType();; 4982 ; 4983 switch(etype) {; 4984 case TStreamerInfo::kOffsetP + TStreamerInfo::kBool: DeleteBasicPointer(eaddr,ele,Bool_t); continue;; 4985 case TStreamerInfo::kOffsetP + TStreamerInfo::kChar: DeleteBasicPointer(eaddr,ele,Char_t); continue;; 4986 case TStreamerInfo::kOffsetP + TStreamerInfo::kShort: DeleteBasicPointer(eaddr,ele,Short_t); continue;; 4987 case TStreamerInfo::kOffsetP + TStreamerInfo::kInt: DeleteBasicPointer(eaddr,ele,Int_t); continue;; 4988 case TStreamerInfo::kOffsetP + TStreamerInfo::kLong: DeleteBasicPointer(eaddr,ele,Long_t); continue;; 4989 case TStreamerInfo::kOffsetP + TStreamerInfo::kLong64: DeleteBasicPointer(eaddr,ele,Long64_t); continue;; 4990 case TStreamerInfo::kOffsetP + TStreamerInfo::kFloat16:; 4991 case TStreamerInfo::kOffsetP + TStreamerInfo::kFloat: DeleteBasicPointer(eaddr,ele,Float_t); continue;; 4992 case TStreamerInfo::kOffsetP + TStreamerInfo::kDouble32:; 4993 case TStreamerInfo::kOffsetP + TStreamerInfo::kDouble: DeleteBasicPointer(eaddr,ele,Double_t); continue;; 4994 case TStreamerInfo::kOffsetP + TStreamerInfo::kUChar: DeleteBasicPointer(eaddr,ele,UChar_t); continue;; 4995 case TStreamerInfo::kOffsetP + TStreamerInfo::kUShort: DeleteBasicPointer(eaddr,ele,UShort_t); continue;; 4996 case TStreamerInfo::kOffsetP + TStreamerInfo::kUInt: DeleteBasicPointer(eaddr,ele,UInt_t); continue;; 4997 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong: DeleteBasicPointer(eaddr,ele,ULong_t); continue;; 4998 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong64:DeleteBasicPointer(eaddr,ele,ULong64_t); continue;; 4999 case TStreamerInfo::kCharStar: DeleteBasicPointer(eaddr,ele,Char_t); continue;; 5000 }; 5001 ; 5002 ; 5003 ; 5004 TClass* cle = ele->GetClassPointer();; 5005 if (!cle) continue;; 5006 ; 5007 ; 5008 if (etype == kObjectp || etype == kAnyp) {; 5009 // Destroy an array of pre-allocated objects.",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:200661,Energy Efficiency,allocate,allocated,200661,"BasicPointer(eaddr,ele,UChar_t); continue;; 4995 case TStreamerInfo::kOffsetP + TStreamerInfo::kUShort: DeleteBasicPointer(eaddr,ele,UShort_t); continue;; 4996 case TStreamerInfo::kOffsetP + TStreamerInfo::kUInt: DeleteBasicPointer(eaddr,ele,UInt_t); continue;; 4997 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong: DeleteBasicPointer(eaddr,ele,ULong_t); continue;; 4998 case TStreamerInfo::kOffsetP + TStreamerInfo::kULong64:DeleteBasicPointer(eaddr,ele,ULong64_t); continue;; 4999 case TStreamerInfo::kCharStar: DeleteBasicPointer(eaddr,ele,Char_t); continue;; 5000 }; 5001 ; 5002 ; 5003 ; 5004 TClass* cle = ele->GetClassPointer();; 5005 if (!cle) continue;; 5006 ; 5007 ; 5008 if (etype == kObjectp || etype == kAnyp) {; 5009 // Destroy an array of pre-allocated objects.; 5010 Int_t len = ele->GetArrayLength();; 5011 if (!len) {; 5012 len = 1;; 5013 }; 5014 void** r = (void**) eaddr;; 5015 for (Int_t j = len - 1; j >= 0; --j) {; 5016 if (r[j]) {; 5017 cle->Destructor(r[j]);; 5018 r[j] = 0;; 5019 }; 5020 }; 5021 }; 5022 ; 5023 if ((etype == kObjectP || etype == kAnyP || etype == kSTLp) && !ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5024 // Destroy an array of pointers to not-pre-allocated objects.; 5025 Int_t len = ele->GetArrayLength();; 5026 if (!len) {; 5027 len = 1;; 5028 }; 5029 void** r = (void**) eaddr;; 5030 for (Int_t j = len - 1; j >= 0; --j) {; 5031 if (r[j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:249977,Energy Efficiency,allocate,allocated,249977,"kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7363; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing i",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:282249,Energy Efficiency,allocate,allocate,282249,"nfo::BuildForBool_t BuildFor(const TClass *cl) overrideCheck if we can build this for foreign class - do we have some rules to do that.Definition TStreamerInfo.cxx:1291; TStreamerInfo::Buildvoid Build(Bool_t isTransient=kFALSE) overrideBuild the I/O data structure for the current class version.Definition TStreamerInfo.cxx:263; TStreamerInfo::BuildOldvoid BuildOld() overriderebuild the TStreamerInfo structureDefinition TStreamerInfo.cxx:1705; TStreamerInfo::fReadMemberWiseTStreamerInfoActions::TActionSequence * fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:287279,Energy Efficiency,allocate,allocate,287279," as if Build or BuildOld was never called on it (usef...Definition TStreamerInfo.cxx:2616; TStreamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::fSizeInt_t fSize!size of the persistent classDefinition TStreamerInfo.h:92; TStreamerInfo::GetTypedValueAuxstatic T GetTypedValueAux(Int_t type, void *ladd, int k, Int_t len)Get the value from inside a collection.Definition TStreamerInfo.cxx:4338; TStreamerInfo::GenerateDeclarationvoid GenerateDeclaration(FILE *fp, FILE *sfp, const TList *subClasses, Bool_t top=kTRUE)Write the Declaration of class.Definition TStreamerInfo.cxx:3668; TStreamerInfo::PrintValueAuxstatic void PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::NewArrayvoid * NewArray(Long_t nElements, void *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::CompareContentBool_t CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) overrideReturn True if",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:10243,Integrability,message,messages,10243,"of RVec (see 6.24 release notes); 299 if (strncmp(GetName(), ""ROOT::VecOps::RVec<"", 19) == 0) {; 300 Warning(""Build"", ""Due to some major, backward-incompatible improvements planned for ROOT::RVec, direct I/O of ""; 301 ""ROOT::RVec objects will break between v6.24 and v6.26. Please use std::vectors instead. See ""; 302 ""the release notes of v6.24 for more information."");; 303 }; 304 ; 305 TStreamerElement::Class()->IgnoreTObjectStreamer();; 306 ; 307 fClass->BuildRealData(nullptr, isTransient);; 308 ; 309 fCheckSum = fClass->GetCheckSum();; 310 ; 311 Bool_t needAllocClass = kFALSE;; 312 Bool_t wasCompiled = fComp != 0;; 313 ROOT::TSchemaRuleSet::TMatches rules;; 314 if (fClass->GetSchemaRules()) {; 315 rules = fClass->GetSchemaRules()->FindRules(fClass->GetName(), fClassVersion);; 316 }; 317 ; 318 //; 319 // Iterate over base classes.; 320 //; 321 ; 322 // ROOT-9808: Here we skip the investigations of the base classes in case; 323 // this is a pair, otherwise, on some STL implementations, it can happen that; 324 // pair has mother classes which are an internal implementation detail and; 325 // would result in bogus messages printed on screen.; 326 if (!TClassEdit::IsStdPair(fClass->GetName())) {; 327 const bool isCollection = fClass->GetCollectionProxy();; 328 const bool isString = !strcmp(fClass->GetName(), ""string"");; 329 TBaseClass* base = 0;; 330 TIter nextb(fClass->GetListOfBases());; 331 while ((base = (TBaseClass*)nextb())) {; 332 TStreamerElement* element = 0;; 333 Int_t offset = base->GetDelta();; 334 if (offset == kMissing) {; 335 continue;; 336 }; 337 if (offset == kNeedObjectForVirtualBaseClass) {; 338 if (!isTransient); 339 Error(""Build()"", ""Cannot stream virtual base %s of class %s"",; 340 base->GetName(), fClass->GetName());; 341 continue;; 342 }; 343 const char* bname = base->GetName();; 344 const char* btitle = base->GetTitle();; 345 // this case appears with STL collections as base class.; 346 if (!strcmp(bname, ""string"")) {; 347 element = new TStreame",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23867,Integrability,inject,inject,23867,"is value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:29553,Integrability,message,message,29553," if (fClass->GetCollectionType() > ROOT::kNotSTL) {; 780 const bool isOldRVec = fClass->GetCollectionType() == ROOT::kROOTRVec && (fElements->GetEntries() == 1) &&; 781 !strcmp(fElements->At(0)->GetName(), ""fData"");; 782 if (!isOldRVec && TClassEdit::IsSTLCont(fClass->GetName())) {; 783 // We have a collection that is indeed an STL collection,; 784 // we know we don't need its streamerInfo.; 785 SetBit(kCanDelete);; 786 return;; 787 }; 788 }; 789 bool isStdPair = TClassEdit::IsStdPair(GetName());; 790 ; 791 if (0 == strcmp(""string"",fClass->GetName())) {; 792 // We know we do not need any offset check for a string; 793 SetBit(kCanDelete);; 794 return;; 795 }; 796 ; 797 const TObjArray *array = fClass->GetStreamerInfos();; 798 TStreamerInfo* info = 0;; 799 ; 800 if (fClass->GetState() == TClass::kNoInfo && array->IsEmpty()) {; 801 // We have an emulated class that has no TStreamerInfo, this; 802 // means it was created to insert a (default) rule. Consequently; 803 // the error message about the missing dictionary was not printed.; 804 // For consistency, let's print it now!; 805 ; 806 ::Warning(""TClass::TClass"", ""no dictionary for class %s is available"", GetName());; 807 }; 808 ; 809 // Case of a custom collection (the user provided a CollectionProxy; 810 // for a class that is not an STL collection).; 811 if (GetElements()->GetEntriesFast() == 1) {; 812 TObject *element = GetElements()->UncheckedAt(0);; 813 Bool_t isstl = element && strcmp(""This"",element->GetName())==0;; 814 if (isstl && !fClass->GetCollectionProxy()) {; 815 if (element->GetTitle()[0] == '<') {; 816 // We know the content.; 817 TString content = element->GetTitle();; 818 Int_t level = 1;; 819 for(Int_t c = 1; c < content.Length(); ++c) {; 820 if (content[c] == '<') ++level;; 821 else if (content[c] == '>') --level;; 822 if (level == 0) {; 823 content.Remove(c+1);; 824 break;; 825 }; 826 }; 827 content.Prepend(""vector"");; 828 TClass *clequiv = TClass::GetClass(content);; 829 TVirtualCollectionProxy *pr",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:100858,Integrability,inject,inject,100858,"; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2515 ; 2516 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 2517 R__TObjArray_InsertBefore( fElements, copy, element );; 2518 next(); // move the cursor passed the insert object.; 2519 copy->SetBit(TStreamerElement::kRepeat);; 2520 element = copy;; 2521 ; 2522 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 2523 } else {; 2524 // If the element is just cached and not repeat, we need to inject an element; 2525 // to insure the writing.; 2526 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 2527 R__TObjArray_InsertAfter( fElements, writecopy, element );; 2528 next(); // move the cursor passed the insert object.; 2529 writecopy->SetBit(TStreamerElement::kWrite);; 2530 writecopy->SetNewType( writecopy->GetType() );; 2531 writecopy->SetOffset(element->GetOffset());; 2532 }; 2533 element->SetBit(TStreamerElement::kCache);; 2534 element->SetNewType( element->GetType() );; 2535 element->SetOffset(infoalloc ? infoalloc->GetOffset(element->GetName()) : 0);; 2536 } else if (rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2537 // The data member exist in the onfile StreamerInfo and there is a rule; 2538 // that has the same member 'only' has a target ... so this means we are; 2539 // asked to ignore the input data ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:107032,Integrability,message,message,107032,"os; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left);; 2683 }; 2684 }; 2685 }; 2686 void Clear() {; 2687 fName.Clear();; 2688 fClassName.Clear();; 2689 fComment.Clear();; 2690 }; 2691 /* Hide this not yet used implementation to suppress warnings message; 2692 from icc 11; 2693 Bool_t operator==(const TMemberInfo &other) {; 2694 return fName==other.fName; 2695 && fClassName == other.fClassName; 2696 && fComment == other.fComment;; 2697 }; 2698 */; 2699 Bool_t operator!=(const TMemberInfo &other) {; 2700 if (fName != other.fName) return kTRUE;; 2701 if (fDataType < TStreamerInfo::kObject) {; 2702 // For simple type, let compare the data type; 2703 if (fDataType != other.fDataType) {; 2704 if ( (fDataType == 4 && other.fDataType == 16); 2705 || (fDataType == 16 && other.fDataType == 4) ) {; 2706 // long and 'long long' have the same file format; 2707 } else if ( (fDataType == 14 && other.fDataType == 17); 2708 || (fDataType == 17 && other.fDataType == 14) ) {; 2709 // unsigned long and 'unsigned long long' have the same file format; 2710 } else if ( (fDataType == 3 && other.fDataType == 6); 2711 ||(fDataType == 6 && other.fDataType == 3) ){; 2712 // Int_t and kCounter. As the switch from Int_t (3) to; 2713 // kCounter (6) might be triggere",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:113336,Integrability,message,message,113336,"bject *element = newelems->UncheckedAt(i);; 2826 if (element->IsA() == TStreamerLoop::Class()) {; 2827 TStreamerLoop *eloop = (TStreamerLoop*)element;; 2828 if (fName == eloop->GetCountClass()) {; 2829 eloop->SetCountClass(newname);; 2830 eloop->Init();; 2831 }; 2832 } else if (element->IsA() == TStreamerBasicPointer::Class()) {; 2833 TStreamerBasicPointer *eptr = (TStreamerBasicPointer*)element;; 2834 if (fName == eptr->GetCountClass()) {; 2835 eptr->SetCountClass(newname);; 2836 eptr->Init();; 2837 }; 2838 }; 2839 }; 2840 }; 2841 ++fgCount;; 2842 newinfo->fNumber = fgCount;; 2843 return newinfo;; 2844}; 2845 ; 2846////////////////////////////////////////////////////////////////////////////////; 2847/// Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 2848///; 2849/// In this context 'Equivalent' means the same number of persistent data member which the same actual C++ type and; 2850/// the same name.; 2851/// If 'warn' is true, Warning message are printed to explicit the differences.; 2852/// If 'complete' is false, stop at the first error, otherwise continue until all members have been checked.; 2853 ; 2854Bool_t TStreamerInfo::CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file); 2855{; 2856 Bool_t result = kTRUE;; 2857 R__ASSERT( (cl==0 || info==0) && (cl!=0 || info!=0) /* must compare to only one thing! */);; 2858 ; 2859 TString name;; 2860 TString type;; 2861 TStreamerElement *el;; 2862 TStreamerElement *infoel = 0;; 2863 ; 2864 TIter next(GetElements());; 2865 TIter infonext((TList*)0);; 2866 TIter basenext((TList*)0);; 2867 TIter membernext((TList*)0);; 2868 if (info) {; 2869 infonext = info->GetElements();; 2870 }; 2871 if (cl) {; 2872 TList *tlb = cl->GetListOfBases();; 2873 if (tlb) { // Loop over bases; 2874 basenext = tlb;; 2875 }; 2876 tlb = cl->GetListOfDataMembers();; 2877 if (tlb) {; 2878 membernext = tlb;; 2879 }; 2880 }; 2881 ; 2882 // First let's compare base ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:127454,Integrability,depend,dependencies,127454," and more precise to use last element offset +size; 3145 //on 64 bit machines, offset may be forced to be a multiple of 8 bytes; 3146 fSize = element ? element->GetOffset() + element->GetSize() : 0;; 3147 if (fNVirtualInfoLoc > 0 && (fVirtualInfoLoc[0]+sizeof(TStreamerInfo*)) >= (ULong_t)fSize) {; 3148 fSize = fVirtualInfoLoc[0] + sizeof(TStreamerInfo*);; 3149 }; 3150 ; 3151 // On some platform and in some case of layout non-basic data types needs; 3152 // to be aligned. So let's be on the safe side and align on the size of; 3153 // the pointers. (Question: is that the right thing on x32 ABI ?); 3154 constexpr size_t kSizeOfPtr = sizeof(void*);; 3155 if ((fSize % kSizeOfPtr) != 0 && !fClass->IsSyntheticPair()) {; 3156 fSize = fSize - (fSize % kSizeOfPtr) + kSizeOfPtr;; 3157 }; 3158}; 3159 ; 3160////////////////////////////////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocke",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:127517,Integrability,depend,dependencies,127517,"may be forced to be a multiple of 8 bytes; 3146 fSize = element ? element->GetOffset() + element->GetSize() : 0;; 3147 if (fNVirtualInfoLoc > 0 && (fVirtualInfoLoc[0]+sizeof(TStreamerInfo*)) >= (ULong_t)fSize) {; 3148 fSize = fVirtualInfoLoc[0] + sizeof(TStreamerInfo*);; 3149 }; 3150 ; 3151 // On some platform and in some case of layout non-basic data types needs; 3152 // to be aligned. So let's be on the safe side and align on the size of; 3153 // the pointers. (Question: is that the right thing on x32 ABI ?); 3154 constexpr size_t kSizeOfPtr = sizeof(void*);; 3155 if ((fSize % kSizeOfPtr) != 0 && !fClass->IsSyntheticPair()) {; 3156 fSize = fSize - (fSize % kSizeOfPtr) + kSizeOfPtr;; 3157 }; 3158}; 3159 ; 3160////////////////////////////////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocked.; 3185 (cindex->fArray[fNumber] && !force) || // Streamer info is already marked, and",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131071,Integrability,rout,routine,131071,"lock; 3230 // forcing to prevent infinite recursion.; 3231 cindex->fArray[fNumber] = 2;; 3232 // Signal the file that the marked streamer info list has changed.; 3233 cindex->fArray[0] = 1;; 3234 // Recursively mark the streamer infos for; 3235 // all of our elements.; 3236 TIter next(fElements);; 3237 TStreamerElement* element = (TStreamerElement*) next();; 3238 for (; element; element = (TStreamerElement*) next()) {; 3239 if (element->IsTransient()) continue;; 3240 TClass* cl = element->GetClassPointer();; 3241 if (cl); 3242 recurseIntoContent(cl);; 3243 }; 3244 ; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// Assuming that obj points to (the part of) an object that is of the; 3249/// type described by this streamerInfo, return the actual type of the; 3250/// object (i.e. the type described by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 327",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:171219,Integrability,rout,routine,171219,"ment = (TStreamerElement*) fElements->FindObject(base->GetName());; 4240 if (!base_cl || !base_element) {; 4241 continue;; 4242 }; 4243 base_offset = base_element->GetOffset();; 4244 element = ((TStreamerInfo*)base_cl->GetStreamerInfo())->GetStreamerElement(datamember, local_offset);; 4245 if (element) {; 4246 offset = base_offset + local_offset;; 4247 return element;; 4248 }; 4249 }; 4250 } else {; 4251 // Our class's dictionary is not loaded. Search through the base class streamer elements.; 4252 TIter next(fElements);; 4253 TStreamerElement* curelem = 0;; 4254 while ((curelem = (TStreamerElement*) next())) {; 4255 if (curelem->InheritsFrom(TStreamerBase::Class())) {; 4256 TClass* baseClass = curelem->GetClassPointer();; 4257 if (!baseClass) {; 4258 continue;; 4259 }; 4260 Int_t base_offset = curelem->GetOffset();; 4261 Int_t local_offset = 0;; 4262 TStreamerInfo *baseInfo;; 4263 if (baseClass->Property() & kIsAbstract) {; 4264 baseInfo = (TStreamerInfo*)baseClass->GetStreamerInfoAbstractEmulated();; 4265 } else {; 4266 baseInfo = (TStreamerInfo*)baseClass->GetStreamerInfo();; 4267 }; 4268 if (baseInfo) element = baseInfo->GetStreamerElement(datamember, local_offset);; 4269 if (element) {; 4270 offset = base_offset + local_offset;; 4271 return element;; 4272 }; 4273 }; 4274 }; 4275 }; 4276 return 0;; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// <b>Obsolete</b>: this routine is obsolete and should not longer be used.; 4281///; 4282/// TStreamerInfo holds two types of data structures; 4283/// - TObjArray* fElements; containing the list of all TStreamerElement; 4284/// objects for this class version.; 4285/// - ULong_t* fElem; containing the preprocessed information; 4286/// by TStreamerInfo::Compile In case consecutive data members; 4287/// are of the same type, the Compile function declares the consecutive; 4288/// elements as one single element in fElems.; 4289///; 4290/// Example with the class TAttLin",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233413,Integrability,rout,routine,233413,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:238050,Integrability,rout,routines,238050,"ion TDataType.h:31; kCharStar@ kCharStarDefinition TDataType.h:34; kChar_t@ kChar_tDefinition TDataType.h:29; kUChar_t@ kUChar_tDefinition TDataType.h:29; kUInt_t@ kUInt_tDefinition TDataType.h:30; kFloat16_t@ kFloat16_tDefinition TDataType.h:33; kOther_t@ kOther_tDefinition TDataType.h:32; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; kIsUnionMember@ kIsUnionMemberDefinition TDictionary.h:74; kIsAbstract@ kIsAbstractDefinition TDictionary.h:71; kIsStatic@ kIsStaticDefinition TDictionary.h:80; kMaxLenconst Int_t kMaxLenDefinition TDirectory.cxx:34; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; kErrorconstexpr Int_t kErrorDefinition TError.h:47; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; TFile.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cindexOption_t Option_t cindexDefinition TGWin32VirtualXProxy.cxx:50; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:266692,Integrability,message,message,266692,"TObjArray::IsEmptyBool_t IsEmpty() const overrideDefinition TObjArray.h:65; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Classstatic TClass * Class(); TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constTh",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:267286,Integrability,message,message,267286,"er of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRealDataThe TRealData class manages the effectiv",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:267422,Integrability,message,message,267422,"amevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturn",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:268015,Integrability,message,message,268015,"ion TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::GetDataMemberTDataMember * GetDataMember() constDefinition TRealData.h:53; TRealData::GetStreamerTMemberStreamer * GetStreamer() constReturn the associate streamer object.Definition TRealData.cxx:115; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::IsObjectBool_t IsObject() constDefinition TRealData.h:56; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificialDefinition TStreamerElement.h:449; TStreamerArtificial::SetReadFuncvoid SetReadFunc(ROOT::TSchemaRule::ReadFuncPt",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:283182,Integrability,rout,routine,283182,":Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::SetClassvoid SetClass(TClass *cl) ove",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:292626,Integrability,interface,interface,292626,"(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Destructorvirtual void Destructor(void *p, Bool_t dtorOnly=kFALSE) constExecute the container destructor.Definition TVirtualCollectionProxy.h:144; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::kCustomAlloc@ kCustomAllocThe collection has a custom allocator.Definition TVirtualCollectionProxy.h:71; TVirtualCollectionProxy::kIsEmulated@ kIsEmulatedDefinition TVirtualCollectionProxy.h:67; TVirtualCollectionProxy::Clearvirtual void Clear(const char *opt="""")=0Clear the container.; TVirtualCollectionProxy::Newvirtual void * New() con",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:14287,Modifiability,variab,variables,14287,"s; 382 // element from being inserted into the compiled info.; 383 element->SetType(TVirtualStreamerInfo::kNoType);; 384 }; 385 if (!isTransient && !clm->IsLoaded() && !(isCollection || isString)) {; 386 // Don't complain about the base classes of collections nor of; 387 // std::string.; 388 Warning(""Build"", ""%s: base class %s has no streamer or dictionary it will not be saved"", GetName(), clm->GetName());; 389 }; 390 }; 391 }; 392 if (element) {; 393 fElements->Add(element);; 394 }; 395 } // end of base class loop; 396 }; 397 ; 398 //; 399 // Iterate over data members.; 400 //; 401 ; 402 Int_t dsize;; 403 TDataMember* dm = 0;; 404 std::string typeNameBuf;; 405 std::string trueTypeNameBuf;; 406 TIter nextd(fClass->GetListOfDataMembers());; 407 while ((dm = (TDataMember*) nextd())) {; 408 if (fClass->GetClassVersion() == 0) {; 409 continue;; 410 }; 411 if (!dm->IsPersistent()) {; 412 continue;; 413 }; 414 if (dm->Property() & kIsUnionMember) {; 415 continue;; 416 }; 417 TMemberStreamer* streamer = 0;; 418 Int_t offset = GetDataMemberOffset(dm, streamer);; 419 if (offset == kMissing) {; 420 continue;; 421 }; 422 TStreamerElement* element = 0;; 423 dsize = 0;; 424 ; 425 // Save some useful variables; 426 const char* dmName = dm->GetName();; 427 const char* dmTitle = dm->GetTitle();; 428 const char* dmType = dm->GetTypeName();; 429 const char* dmFull = dm->GetTrueTypeName(); // Used to be GetFullTypeName ...; 430 Bool_t dmIsPtr = dm->IsaPointer();; 431 TDataType* dt(nullptr);; 432 Int_t ndim = dm->GetArrayDim();; 433 std::array<Int_t, 5> maxIndices; // 5 is the maximum supported in TStreamerElement::SetMaxIndex; 434 Bool_t isStdArray(kFALSE);; 435 ; 436 // Let's treat the unique_ptr case; 437 bool nameChanged;; 438 trueTypeNameBuf = typeNameBuf = TClassEdit::GetNameForIO(dmFull, TClassEdit::EModType::kNone, &nameChanged);; 439 if (nameChanged) {; 440 if (trueTypeNameBuf.back() == '*') {; 441 dmIsPtr = true;; 442 typeNameBuf.pop_back();; 443 while(typeNameBuf.back() == '*",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:22940,Modifiability,variab,variable,22940,"nt_t i = 0; i < ndim; ++i) {; 609 auto maxIndex = 0;; 610 if (isStdArray) maxIndex = maxIndices[i];; 611 else maxIndex = dm->GetMaxIndex(i);; 612 element->SetMaxIndex(i, maxIndex);; 613 }; 614 element->SetArrayDim(ndim);; 615 // If the datamember was a int[4] this is 4, if double[3][2] 3*2=6; 616 Int_t narr = element->GetArrayLength();; 617 if (!narr) {; 618 narr = 1;; 619 }; 620 element->SetSize(dsize*narr);; 621 element->SetStreamer(streamer);; 622 if (!streamer) {; 623 Int_t k = element->GetType();; 624 if (k == kStreamer) {; 625 // if ((k == kSTL) || (k == kSTL + kOffsetL) || (k == kStreamer) || (k == kStreamLoop)); 626 // This is odd. Either we need to update the doc for TVirtualStreamerInfo::kNoType; 627 // or change this value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 T",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:140847,Modifiability,variab,variable,140847,"; defMod = kTRUE; };; 3465 const char *ename = element->GetName();; 3466 const char *colon2 = strstr(ename,""::"");; 3467 if (colon2) ename = colon2+2;; 3468 if(element->GetArrayLength() <= 1) {; 3469 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3470 } else {; 3471 fprintf(file,"" memset(modrhs.%s,0,%d);\n"",ename,element->GetSize());; 3472 }; 3473 } else {; 3474 const char *ename = element->GetName();; 3475 if (element->GetType() == kCharStar) {; 3476 if (!defMod) {; 3477 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3478 };; 3479 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3480 } else if (TVirtualStreamerInfo::kOffsetP <= element->GetType() && element->GetType() < TVirtualStreamerInfo::kObject ) {; 3481 if (!defMod) {; 3482 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3483 };; 3484 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3485 } else if (element->GetArrayLength() > 1) {; 3486 // FIXME: Need to add support for variable length array.; 3487 if (element->GetArrayDim() == 1) {; 3488 fprintf(file,"" for (Int_t i=0;i<%d;i++) %s[i] = rhs.%s[i];\n"",element->GetArrayLength(),ename,ename);; 3489 } else if (element->GetArrayDim() >= 2) {; 3490 fprintf(file,"" for (Int_t i=0;i<%d;i++) reinterpret_cast<%s *>(%s"", element->GetArrayLength(), element->GetTypeName(), ename);; 3491 fprintf(file,"")[i] = reinterpret_cast<%s const *>(rhs.%s)[i];\n"", element->GetTypeName(), ename);; 3492 }; 3493 } else if (element->GetType() == TVirtualStreamerInfo::kSTLp) {; 3494 if (!defMod) { fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE; };; 3495 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3496 } else if (element->GetType() == TVirtualStreamerInfo::kSTL) {; 3497 if (!defMod) {; 3498 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3499 }; 3500 TClass *cle = element->Ge",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:179026,Modifiability,variab,variable,179026,"nt_t); 4416 case (unsigned)kOffsetP + kULong_t: READ_ARRAY(ULong_t); 4417#if defined(_MSC_VER) && (_MSC_VER <= 1200); 4418 case (unsigned)kOffsetP + kULong64_t: READ_ARRAY(Long64_t); 4419#else; 4420 case (unsigned)kOffsetP + kULong64_t: READ_ARRAY(ULong64_t); 4421#endif; 4422 ; 4423 // array counter //[n]; 4424 case kCounter: {Int_t *val = (Int_t*)ladd; return T(*val);}; 4425 }; 4426 return 0;; 4427}; 4428 ; 4429 ; 4430 ; 4431template Double_t TStreamerInfo::GetTypedValue(char *pointer, Int_t i, Int_t j, Int_t len) const;; 4432template Long64_t TStreamerInfo::GetTypedValue(char *pointer, Int_t i, Int_t j, Int_t len) const;; 4433template LongDouble_t TStreamerInfo::GetTypedValue(char *pointer, Int_t i, Int_t j, Int_t len) const;; 4434 ; 4435////////////////////////////////////////////////////////////////////////////////; 4436/// Return value of element i in object at pointer.; 4437/// The function may be called in two ways:; 4438/// - method1 len < 0: i is assumed to be the TStreamerElement number i in StreamerInfo; 4439/// - method2 len >= 0: i is the type, address of variable is directly pointer.; 4440 ; 4441template <typename T>; 4442T TStreamerInfo::GetTypedValue(char *pointer, Int_t i, Int_t j, Int_t len) const; 4443{; 4444 char *ladd;; 4445 Int_t atype;; 4446 if (len >= 0) {; 4447 ladd = pointer;; 4448 atype = i;; 4449 } else {; 4450 if (i < 0) return 0;; 4451 ladd = pointer + fCompFull[i]->fOffset;; 4452 atype = fCompFull[i]->fNewType;; 4453 len = fCompFull[i]->fElem->GetArrayLength();; 4454 if (atype == kSTL) {; 4455 TClass *newClass = fCompFull[i]->fElem->GetNewClass();; 4456 if (newClass == 0) {; 4457 newClass = fCompFull[i]->fElem->GetClassPointer();; 4458 }; 4459 TClass *innerClass = newClass->GetCollectionProxy()->GetValueClass();; 4460 if (innerClass) {; 4461 return 0; // We don't know which member of the class we would want.; 4462 } else {; 4463 TVirtualCollectionProxy *proxy = newClass->GetCollectionProxy();; 4464 // EDataType is a subset of TStreamerI",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:205049,Modifiability,variab,variable,205049,"19 }; 5120 DestructorImpl(p, dtorOnly);; 5121}; 5122 ; 5123////////////////////////////////////////////////////////////////////////////////; 5124/// Destroy an array of emulated objects, with optional delete.; 5125 ; 5126void TStreamerInfo::DeleteArray(void* ary, Bool_t dtorOnly); 5127{; 5128 // Do nothing if passed a null pointer.; 5129 if (ary == 0) return;; 5130 ; 5131 //???FIX ME: What about varying length arrays?; 5132 ; 5133 Long_t* r = (Long_t*) ary;; 5134 Long_t arrayLen = r[-1];; 5135 Long_t size = r[-2];; 5136 char* memBegin = (char*) &r[-2];; 5137 ; 5138 char* p = ((char*) ary) + ((arrayLen - 1) * size);; 5139 for (Long_t cnt = 0; cnt < arrayLen; ++cnt, p -= size) {; 5140 // Destroy each element, but do not delete it.; 5141 Destructor(p, kTRUE);; 5142 } // for arrayItemSize; 5143 ; 5144 if (!dtorOnly) {; 5145 delete[] memBegin;; 5146 }; 5147}; 5148 ; 5149////////////////////////////////////////////////////////////////////////////////; 5150/// print value of element i in object at pointer; 5151/// The function may be called in two ways:; 5152/// -method1 len < 0; 5153/// i is assumed to be the TStreamerElement number i in StreamerInfo; 5154/// -method2 len >= 0; 5155/// i is the type; 5156/// address of variable is directly pointer.; 5157/// len is the number of elements to be printed starting at pointer.; 5158 ; 5159void TStreamerInfo::PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax) const; 5160{; 5161 char *ladd;; 5162 Int_t atype,aleng;; 5163 printf("" %-15s = "",name);; 5164 ; 5165 TStreamerElement * aElement = 0;; 5166 Int_t *count = 0;; 5167 if (len >= 0) {; 5168 ladd = pointer;; 5169 atype = i;; 5170 aleng = len;; 5171 } else {; 5172 if (i < 0) {; 5173 if (pointer==0) {; 5174 printf(""NULL\n"");; 5175 } else {; 5176 const static TClassRef stringClass(""string"");; 5177 if (fClass == stringClass) {; 5178 std::string *st = (std::string*)(pointer);; 5179 printf(""%s\n"",st->c_str());; 5180 } else if (fClass == TString::Class()) {; ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:215114,Modifiability,variab,variable,215114,"file) {; 5380 // If the value of the atomic is kFALSE (equal to expected), change its value; 5381 // to kTRUE and return true. Leave it as it is otherwise and return false.; 5382 static std::atomic<Bool_t> onlyonce(kFALSE);; 5383 Bool_t expected = kFALSE;; 5384 if (onlyonce.compare_exchange_strong(expected,kTRUE)) {; 5385 Warning(""TagFile"",""This function is deprecated, use TBuffer::TagStreamerInfo instead"");; 5386 }; 5387 TArrayC *cindex = file->GetClassIndex();; 5388 Int_t nindex = cindex->GetSize();; 5389 if (fNumber < 0 || fNumber >= nindex) {; 5390 Error(""TagFile"",""StreamerInfo: %s number: %d out of range[0,%d] in file: %s"",; 5391 GetName(),fNumber,nindex,file->GetName());; 5392 return;; 5393 }; 5394 if (cindex->fArray[fNumber] == 0) {; 5395 cindex->fArray[0] = 1;; 5396 cindex->fArray[fNumber] = 1;; 5397 }; 5398 }; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402 ; 5403#ifdef DOLOOP; 5404#undef DOLOOP; 5405#endif; 5406#define DOLOOP for (k = 0, pointer = arr[0]; k < narr; pointer = arr[++k]); 5407 ; 5408namespace {; 5409 static void PrintCR(int j,Int_t aleng, UInt_t ltype); 5410 {; 5411 if (j == aleng-1) printf(""\n"");; 5412 else {; 5413 printf("", "");; 5414 if (j%ltype == ltype-1) printf(""\n "");; 5415 }; 5416 }; 5417}; 5418 ; 5419////////////////////////////////////////////////////////////////////////////////; 5420/// print value of element in object at pointer, type atype, leng aleng or *count; 5421/// The function may be called in two ways:; 5422/// -method1 len < 0; 5423/// i is assumed to be the TStreamerElement number i in StreamerInfo; 5424/// -method2 len >= 0; 5425/// i is the type; 5426/// address of variable is directly pointer.; 5427/// len is the number of elements to be printed starting at pointer.; 5428 ; 5429void TStreamerInfo::PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count); 5430{; 5431 int j;; 5432 ; 5433 //assert(!((kOffsetP + kChar) <= atype &&",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:253168,Modifiability,inherit,inherits,253168,"TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:6014; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClass::kLatestCheckSum@ kLatestCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TC",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:267132,Modifiability,inherit,inherits,267132,"TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:5927,Performance,load,loaded,5927,"reamerInfo object.; 176 ; 177TStreamerInfo::TStreamerInfo(TClass *cl); 178: TVirtualStreamerInfo(cl); 179{; 180 fgCount++;; 181 fNumber = fgCount;; 182 fClass = cl;; 183 fElements = new TObjArray();; 184 fComp = 0;; 185 fCompFull = 0;; 186 fCompOpt = 0;; 187 fCheckSum = 0;; 188 fNdata = 0;; 189 fNfulldata= 0;; 190 fNslots = 0;; 191 fSize = 0;; 192 fClassVersion = fClass->GetClassVersion();; 193 fOnFileClassVersion = 0;; 194 fOldVersion = Class()->GetClassVersion();; 195 fNVirtualInfoLoc = 0;; 196 fVirtualInfoLoc = 0;; 197 ; 198 fReadObjectWise = 0;; 199 fReadMemberWise = 0;; 200 fReadMemberWiseVecPtr = 0;; 201 fReadText = 0;; 202 fWriteObjectWise = 0;; 203 fWriteMemberWise = 0;; 204 fWriteMemberWiseVecPtr = 0;; 205 fWriteText = 0;; 206}; 207 ; 208////////////////////////////////////////////////////////////////////////////////; 209/// TStreamerInfo dtor.; 210 ; 211TStreamerInfo::~TStreamerInfo(); 212{; 213 // Note: If a StreamerInfo is loaded from a file and is the same information; 214 // as an existing one, it is assigned the same ""unique id"" and we need to double; 215 // check before removing it from the global list.; 216 if (fNumber >=0 && gROOT->GetListOfStreamerInfo()->GetSize() > fNumber; 217 && gROOT->GetListOfStreamerInfo()->At(fNumber) == this); 218 gROOT->GetListOfStreamerInfo()->RemoveAt(fNumber);; 219 ; 220 delete [] fComp; fComp = 0;; 221 delete [] fCompFull; fCompFull = 0;; 222 delete [] fCompOpt; fCompOpt = 0;; 223 delete [] fVirtualInfoLoc; fVirtualInfoLoc =0;; 224 ; 225 delete fReadObjectWise;; 226 delete fReadMemberWise;; 227 delete fReadMemberWiseVecPtr;; 228 delete fReadText;; 229 delete fWriteObjectWise;; 230 delete fWriteMemberWise;; 231 delete fWriteMemberWiseVecPtr;; 232 delete fWriteText;; 233 ; 234 if (!fElements) return;; 235 fElements->Delete();; 236 delete fElements; fElements=0;; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Makes sure kBuildOldUsed set once Build or BuildOld fini",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:22889,Performance,optimiz,optimized,22889,"nt_t i = 0; i < ndim; ++i) {; 609 auto maxIndex = 0;; 610 if (isStdArray) maxIndex = maxIndices[i];; 611 else maxIndex = dm->GetMaxIndex(i);; 612 element->SetMaxIndex(i, maxIndex);; 613 }; 614 element->SetArrayDim(ndim);; 615 // If the datamember was a int[4] this is 4, if double[3][2] 3*2=6; 616 Int_t narr = element->GetArrayLength();; 617 if (!narr) {; 618 narr = 1;; 619 }; 620 element->SetSize(dsize*narr);; 621 element->SetStreamer(streamer);; 622 if (!streamer) {; 623 Int_t k = element->GetType();; 624 if (k == kStreamer) {; 625 // if ((k == kSTL) || (k == kSTL + kOffsetL) || (k == kStreamer) || (k == kStreamLoop)); 626 // This is odd. Either we need to update the doc for TVirtualStreamerInfo::kNoType; 627 // or change this value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 T",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23154,Performance,cache,cached,23154,"617 if (!narr) {; 618 narr = 1;; 619 }; 620 element->SetSize(dsize*narr);; 621 element->SetStreamer(streamer);; 622 if (!streamer) {; 623 Int_t k = element->GetType();; 624 if (k == kStreamer) {; 625 // if ((k == kSTL) || (k == kSTL + kOffsetL) || (k == kStreamer) || (k == kStreamLoop)); 626 // This is odd. Either we need to update the doc for TVirtualStreamerInfo::kNoType; 627 // or change this value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = wr",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23600,Performance,cache,cached,23600,"is value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23833,Performance,cache,cached,23833,"is value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:24283,Performance,cache,cached,24283,"w */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStrea",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:24330,Performance,cache,cached,24330,"w */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStrea",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:24350,Performance,cache,cached,24350,"w */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStrea",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:26755,Performance,load,load,26755,"nt;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by TFile::ReadStreamerInfo.; 728 ; 729void TStreamerInfo::BuildCheck(TFile *file /* = 0 */, Bool_t load /* = kTRUE */); 730{; 731 R__LOCKGUARD(gInterpreterMutex);; 732 ; 733 fClass = TClass::GetClass(GetName(), load);; 734 if (!fClass) {; 735 // fClassVersion should have been a Version_t and/or Version_t; 736 // should have been an Int_t. Changing the on-file format; 737 // of the StreamerInfo is 'hard' (for forward compatibility), so; 738 // leave it as is for now.; 739 fClass = new TClass(GetName(), (Version_t)fClassVersion);; 740 ; 741 // Case of a custom collection (the user provided a CollectionProxy; 742 // for a class that is not an STL collection).; 743 if (GetElements()->GetEntriesFast() == 1) {; 744 TObject *element = GetElements()->UncheckedAt(0);; 745 Bool_t isstl = element && strcmp(""This"",element->GetName())==0;; 746 if (isstl) {; 747 if (element->GetTitle()[0] == '<') {; 748 // We know the content.; 749 TString content = element->GetTitle();; 750 Int_t level = 1;; 751 for(Int_t c = 1; c < content.Length(); ++c) {; 752 if (content[c] == '<') ++level;; 753 else if (content[c] == '>') --level;; 754 if (level == 0) {; 755 content.Remove(c+1);; 756 break;;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:26867,Performance,load,load,26867,"nt;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by TFile::ReadStreamerInfo.; 728 ; 729void TStreamerInfo::BuildCheck(TFile *file /* = 0 */, Bool_t load /* = kTRUE */); 730{; 731 R__LOCKGUARD(gInterpreterMutex);; 732 ; 733 fClass = TClass::GetClass(GetName(), load);; 734 if (!fClass) {; 735 // fClassVersion should have been a Version_t and/or Version_t; 736 // should have been an Int_t. Changing the on-file format; 737 // of the StreamerInfo is 'hard' (for forward compatibility), so; 738 // leave it as is for now.; 739 fClass = new TClass(GetName(), (Version_t)fClassVersion);; 740 ; 741 // Case of a custom collection (the user provided a CollectionProxy; 742 // for a class that is not an STL collection).; 743 if (GetElements()->GetEntriesFast() == 1) {; 744 TObject *element = GetElements()->UncheckedAt(0);; 745 Bool_t isstl = element && strcmp(""This"",element->GetName())==0;; 746 if (isstl) {; 747 if (element->GetTitle()[0] == '<') {; 748 // We know the content.; 749 TString content = element->GetTitle();; 750 Int_t level = 1;; 751 for(Int_t c = 1; c < content.Length(); ++c) {; 752 if (content[c] == '<') ++level;; 753 else if (content[c] == '>') --level;; 754 if (level == 0) {; 755 content.Remove(c+1);; 756 break;;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:39543,Performance,load,loaded,39543,"2 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i < nel; ++i) {; 1039 e1 = (TStreamerElement*) fElements->UncheckedAt(i);; 1040 e2 = (TStreamerElement*) elems->At(i);; 1041 if (!e1 || !e2) {; 1042 continue;; 1043 }; 1044 if (strlen(e1->GetTitle()) != strlen(e2->GetTitle())) {; 1045 e2->SetTitle(e1->GetTitle());; 1046 }; 1047 }; 1048 ; 1049 done = kTRUE;; 1050 } else {; 1051 fClass->RemoveStreamerInfo(fClassVersion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The St",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:39730,Performance,load,load,39730,"i = 0; i < nel; ++i) {; 1039 e1 = (TStreamerElement*) fElements->UncheckedAt(i);; 1040 e2 = (TStreamerElement*) elems->At(i);; 1041 if (!e1 || !e2) {; 1042 continue;; 1043 }; 1044 if (strlen(e1->GetTitle()) != strlen(e2->GetTitle())) {; 1045 e2->SetTitle(e1->GetTitle());; 1046 }; 1047 }; 1048 ; 1049 done = kTRUE;; 1050 } else {; 1051 fClass->RemoveStreamerInfo(fClassVersion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) mig",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40147,Performance,load,loaded,40147,"ion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existi",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40292,Performance,load,load,40292,"\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the versi",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40619,Performance,load,loaded,40619,"non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 };",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:41660,Performance,load,loaded,41660,"%d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 }; 1097 } else {; 1098 if (done) {; 1099 Warning(""BuildCheck"", ""\n\; 1100 The StreamerInfo for version %d of class %s\n\; 1101 has a different checksum than the previously loaded StreamerInfo.\n\; 1102 Reading objects of type %s\n\; 1103 (and potentially other files) might not work correctly.\n\; 1104 Most likely the version number of the class was not properly\n\; 1105 updated [See ClassDef(%s,%d)]."",; 1106 fClassVersion, GetName(), GetName(), GetName(), fClassVersion);; 1107 } else {; 1108 Warning(""BuildCheck"", ""\n\; 1109 The StreamerInfo does not match existing one (%s:%d)\n\; 1110 The existing one has not been used yet and will be discarded.\n\; 1111 Reading should work properly, however writing object of\n\; 1112 type %s will not work properly. Most likely the version number\n\; 1113 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1114 GetName(), fClassVersion, GetName(), GetName(), fClassVersion);; 1115 }; 1116 }; 1117 }; 1118 CompareContent(0,info,kTRUE,kTRUE,file);; 1119 fClass->SetBit(TClass::kWarned)",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:42675,Performance,load,loaded,42675,"not work correctly.\n\; 1104 Most likely the version number of the class was not properly\n\; 1105 updated [See ClassDef(%s,%d)]."",; 1106 fClassVersion, GetName(), GetName(), GetName(), fClassVersion);; 1107 } else {; 1108 Warning(""BuildCheck"", ""\n\; 1109 The StreamerInfo does not match existing one (%s:%d)\n\; 1110 The existing one has not been used yet and will be discarded.\n\; 1111 Reading should work properly, however writing object of\n\; 1112 type %s will not work properly. Most likely the version number\n\; 1113 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1114 GetName(), fClassVersion, GetName(), GetName(), fClassVersion);; 1115 }; 1116 }; 1117 }; 1118 CompareContent(0,info,kTRUE,kTRUE,file);; 1119 fClass->SetBit(TClass::kWarned);; 1120 }; 1121 if (done) {; 1122 return;; 1123 }; 1124 }; 1125 // The slot was free, however it might still be reserved for the current; 1126 // loaded version of the class; 1127 if (fClass->IsLoaded(); 1128 && fClass->HasDataMemberInfo(); 1129 && (fClassVersion != 0) // We don't care about transient classes; 1130 && (fClassVersion == fClass->GetClassVersion()); 1131 && (fCheckSum != fClass->GetCheckSum())) {; 1132 ; 1133 // If the old TStreamerInfo matches the in-memory one when we either; 1134 // - ignore the members of type enum; 1135 // or; 1136 // - ignore the comments annotation (//[xyz]); 1137 // we can accept the old TStreamerInfo.; 1138 ; 1139 if (!fClass->MatchLegacyCheckSum(fCheckSum)) {; 1140 ; 1141 Bool_t warn = !fClass->TestBit(TClass::kWarned);; 1142 if (warn) {; 1143 warn = !CompareContent(fClass,0,kFALSE,kFALSE,file);; 1144 }; 1145#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 1146 if (warn && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 1147 && fClass->GetListOfDataMembers()->GetEntries() != 0); 1148 {; 1149 // In some instances of old files (v5.17 and less), some StreamerInfo for; 1150 // an abstract class where not written correctly, and add no; 1151 // ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58956,Performance,load,load,58956,"t)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollec",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:59605,Performance,load,load,59605,"h()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...; 1578 // It actually happens in the case where one of the member is an; 1579 // enum that is part of dictionary payload that is not yet; 1580 // auto-loaded.",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:60620,Performance,load,loaded,60620,"ame);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...; 1578 // It actually happens in the case where one of the member is an; 1579 // enum that is part of dictionary payload that is not yet; 1580 // auto-loaded.; 1581 return nullptr;; 1582 }; 1583 TVirtualStreamerInfo *info = current->GetValueClass()->GetStreamerInfo();; 1584 if (info->GetElements()->GetEntriesFast() != 2) {; 1585 return oldClass;; 1586 }; 1587 TStreamerElement *f = (TStreamerElement*) info->GetElements()->At(0);; 1588 TStreamerElement *s = (TStreamerElement*) info->GetElements()->At(1);; 1589 ; 1590 // Since we do not create TClass for pair of unknown types, old->GetValueClass can; 1591 // be nullptr even-though the type used be known. An example of such change; 1592 // is `RooExpensiveObjectCache::ExpensiveObject` which used to be recorded; 1593 // as `ExpensiveObject` in the name of the map ... making it unknown; 1594 // (and this is precisely the type of change we are trying to handle here/below!); 1595 info = old->GetValueClass() ? old->GetValueClass()->GetStreamerInfo() : nullptr;; 1596 assert(!info || info->GetElements()->GetEntriesFast() ==",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:69644,Performance,load,loaded,69644,"84 TStreamerInfo *infoalloc = 0;; 1785 ; 1786 //---------------------------------------------------------------------------; 1787 // Get schema rules for this class; 1788 /////////////////////////////////////////////////////////////////////////////; 1789 ; 1790 ROOT::TSchemaRuleSet::TMatches rules;; 1791 const ROOT::TSchemaRuleSet* ruleSet = fClass->GetSchemaRules();; 1792 ; 1793 if (ruleSet) rules = ruleSet->FindRules( GetName(), fOnFileClassVersion, fCheckSum );; 1794 ; 1795 Bool_t shouldHaveInfoLoc = fClass->GetState() == TClass::kEmulated && !TClassEdit::IsStdClass(fClass->GetName());; 1796 Int_t virtualInfoLocAlloc = 0;; 1797 fNVirtualInfoLoc = 0;; 1798 delete [] fVirtualInfoLoc;; 1799 fVirtualInfoLoc = 0;; 1800 ; 1801 while ((element = (TStreamerElement*) next())) {; 1802 if (element->IsA()==TStreamerArtificial::Class(); 1803 || element->TestBit(TStreamerElement::kCache) ); 1804 {; 1805 // Prevent BuildOld from modifying existing ArtificialElement (We need to review when and why BuildOld; 1806 // needs to be re-run; it might be needed if the 'current' class change (for example from being an onfile; 1807 // version to being a version loaded from a shared library) and we thus may have to remove the artificial; 1808 // element at the beginning of BuildOld); 1809 ; 1810 continue;; 1811 };; 1812 ; 1813 element->SetNewType(element->GetType());; 1814 if (element->IsBase()) {; 1815 //---------------------------------------------------------------------; 1816 // Dealing with nonSTL bases; 1817 ///////////////////////////////////////////////////////////////////////; 1818 ; 1819 if (element->IsA() == TStreamerBase::Class()) {; 1820 TStreamerBase* base = (TStreamerBase*) element;; 1821#if defined(PROPER_IMPLEMEMANTION_OF_BASE_CLASS_RENAMING); 1822 TClassRef baseclass = fClass->GetBaseClass( base->GetName() );; 1823#else; 1824 // Currently the base class renaming does not work, so we use the old; 1825 // version of the code which essentially disable the next if(!baseclass .",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:81720,Performance,load,loaded,81720,"Object(element->GetName());; 2075 if (dm && dm->IsPersistent()) {; 2076 fClass->BuildRealData();; 2077 streamer = 0;; 2078 offset = GetDataMemberOffset(dm, streamer);; 2079 element->SetOffset(offset);; 2080 element->Init(this);; 2081 ; 2082 // Treat unique pointers and std arrays; 2083 dmType = dm->GetTypeName();; 2084 dmIsPtr = dm->IsaPointer();; 2085 Bool_t nameChanged;; 2086 typeNameBuf = TClassEdit::GetNameForIO(dmType, TClassEdit::EModType::kNone, &nameChanged);; 2087 if (nameChanged) {; 2088 if (typeNameBuf.back() == '*') {; 2089 dmIsPtr = true;; 2090 typeNameBuf.pop_back();; 2091 while(typeNameBuf.back() == '*') typeNameBuf.pop_back();; 2092 }; 2093 dmType = typeNameBuf.c_str();; 2094 }; 2095 if ((isStdArray = TClassEdit::IsStdArray(dmType))){ // We tackle the std array case; 2096 TClassEdit::GetStdArrayProperties(dmType,; 2097 typeNameBuf,; 2098 maxIndices,; 2099 ndim);; 2100 dmType = typeNameBuf.c_str();; 2101 dt = gROOT->GetType(dmType);; 2102 }; 2103 ; 2104 // We have a loaded class, let's make sure that if we have a collection; 2105 // it is also loaded.; 2106 TString dmClassName = TClassEdit::ShortType(dmType,TClassEdit::kDropStlDefault).c_str();; 2107 dmClassName = dmClassName.Strip(TString::kTrailing, '*');; 2108 if (dmClassName.Index(""const "")==0) dmClassName.Remove(0,6);; 2109 TClass *elemDm = ! (dt || dm->IsBasic()) ? TClass::GetClass(dmClassName.Data()) : 0;; 2110 if (elemDm && elemDm->GetCollectionProxy(); 2111 && !elemDm->IsLoaded(); 2112 && elemDm->GetCollectionProxy()->GetCollectionType() != ROOT::kSTLvector) {; 2113 Error(""BuildOld"",""The class \""%s\"" is compiled and for its data member \""%s\"", we do not have a dictionary for the collection \""%s\"", we will not be able to read or write this data member."",GetName(),dm->GetName(),elemDm->GetName());; 2114 offset = kMissing;; 2115 element->SetOffset(kMissing);; 2116 element->SetNewType(TVirtualStreamerInfo::kNoType);; 2117 }; 2118 element->SetStreamer(streamer);; 2119 int narr = element->GetArrayL",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:81799,Performance,load,loaded,81799,"Object(element->GetName());; 2075 if (dm && dm->IsPersistent()) {; 2076 fClass->BuildRealData();; 2077 streamer = 0;; 2078 offset = GetDataMemberOffset(dm, streamer);; 2079 element->SetOffset(offset);; 2080 element->Init(this);; 2081 ; 2082 // Treat unique pointers and std arrays; 2083 dmType = dm->GetTypeName();; 2084 dmIsPtr = dm->IsaPointer();; 2085 Bool_t nameChanged;; 2086 typeNameBuf = TClassEdit::GetNameForIO(dmType, TClassEdit::EModType::kNone, &nameChanged);; 2087 if (nameChanged) {; 2088 if (typeNameBuf.back() == '*') {; 2089 dmIsPtr = true;; 2090 typeNameBuf.pop_back();; 2091 while(typeNameBuf.back() == '*') typeNameBuf.pop_back();; 2092 }; 2093 dmType = typeNameBuf.c_str();; 2094 }; 2095 if ((isStdArray = TClassEdit::IsStdArray(dmType))){ // We tackle the std array case; 2096 TClassEdit::GetStdArrayProperties(dmType,; 2097 typeNameBuf,; 2098 maxIndices,; 2099 ndim);; 2100 dmType = typeNameBuf.c_str();; 2101 dt = gROOT->GetType(dmType);; 2102 }; 2103 ; 2104 // We have a loaded class, let's make sure that if we have a collection; 2105 // it is also loaded.; 2106 TString dmClassName = TClassEdit::ShortType(dmType,TClassEdit::kDropStlDefault).c_str();; 2107 dmClassName = dmClassName.Strip(TString::kTrailing, '*');; 2108 if (dmClassName.Index(""const "")==0) dmClassName.Remove(0,6);; 2109 TClass *elemDm = ! (dt || dm->IsBasic()) ? TClass::GetClass(dmClassName.Data()) : 0;; 2110 if (elemDm && elemDm->GetCollectionProxy(); 2111 && !elemDm->IsLoaded(); 2112 && elemDm->GetCollectionProxy()->GetCollectionType() != ROOT::kSTLvector) {; 2113 Error(""BuildOld"",""The class \""%s\"" is compiled and for its data member \""%s\"", we do not have a dictionary for the collection \""%s\"", we will not be able to read or write this data member."",GetName(),dm->GetName(),elemDm->GetName());; 2114 offset = kMissing;; 2115 element->SetOffset(kMissing);; 2116 element->SetNewType(TVirtualStreamerInfo::kNoType);; 2117 }; 2118 element->SetStreamer(streamer);; 2119 int narr = element->GetArrayL",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:85378,Performance,load,loaded,85378,"ly crash."");; 2154 element->SetOffset(0);; 2155 element->Init(this);; 2156 dmType = element->GetTypeName();; 2157 dmIsPtr = false;; 2158 }; 2159 }; 2160 } // Class corresponding to StreamerInfo is emulated or not.; 2161 ; 2162 // Now let's deal with Schema evolution; 2163 Int_t newType = -1;; 2164 TClassRef newClass;; 2165 ; 2166 if (dm && dm->IsPersistent()) {; 2167 auto theType = isStdArray ? dt : dm->GetDataType();; 2168 if (theType) {; 2169 Bool_t isArray = isStdArray || element->GetArrayLength() >= 1;; 2170 Bool_t hasCount = element->HasCounter();; 2171 // data member is a basic type; 2172 if ((fClass == TObject::Class()) && !strcmp(dm->GetName(), ""fBits"")) {; 2173 //printf(""found fBits, changing dtype from %d to 15\n"", dtype);; 2174 newType = kBits;; 2175 } else {; 2176 // All the values of EDataType have the same semantic in EReadWrite; 2177 newType = (EReadWrite)theType->GetType();; 2178 }; 2179 if ((newType == ::kChar_t) && dmIsPtr && !isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 //",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:87540,Performance,load,load,87540,"etName(), dm ? dm->GetFullTypeName() : TDataType::GetTypeName((EDataType)newType), newType);; 2227 }; 2228 }; 2229 } else if (newClass.GetClass()) {; 2230 // Sometime BuildOld is called again.; 2231 // In that case we might already have fix up the streamer element.; 2232 // So we need to go back to the original information!; 2233 newClass.Reset();; 2234 TClass* oldClass = TClass::GetClass(TClassEdit::ShortType(element->GetTypeName(), TClassEdit::kDropTrailStar).c_str());; 2235 if (oldClass == newClass.GetClass()) {; 2236 // Nothing to do, also in the unique_ptr case :); 2237 } else if (ClassWasMovedToNamespace(oldClass, newClass.GetClass())) {; 2238 Int_t oldv;; 2239 if (0 != (oldv = ImportStreamerInfo(oldClass, newClass.GetClass()))) {; 2240 Warning(""BuildOld"", ""Can not properly load the TStreamerInfo from %s into %s due to a conflict for the class version %d"", oldClass->GetName(), newClass->GetName(), oldv);; 2241 } else {; 2242 element->SetTypeName(newClass->GetName());; 2243 if (gDebug > 0) {; 2244 Warning(""BuildOld"", ""element: %s::%s %s has new type %s"", GetName(), element->GetTypeName(), element->GetName(), newClass->GetName());; 2245 }; 2246 }; 2247 } else if (oldClass == TClonesArray::Class()) {; 2248 if (ContainerMatchTClonesArray(newClass.GetClass())) {; 2249 Int_t elemType = element->GetType();; 2250 Bool_t isPrealloc = (elemType == kObjectp) || (elemType == kAnyp) || (elemType == (kObjectp + kOffsetL)) || (elemType == (kAnyp + kOffsetL));; 2251 element->Update(oldClass, newClass.GetClass());; 2252 TVirtualCollectionProxy *cp = newClass->GetCollectionProxy();; 2253 TConvertClonesArrayToProxy *ms = new TConvertClonesArrayToProxy(cp, element->IsaPointer(), isPrealloc);; 2254 element->SetStreamer(ms);; 2255 ; 2256 // When the type is kObject, the TObject::Streamer is used instead; 2257 // of the TStreamerElement's streamer. So let force the usage; 2258 // of our streamer; 2259 if (element->GetType() == kObject) {; 2260 element->SetNewType(kAny);; 2261 elemen",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:100824,Performance,cache,cached,100824,"; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2515 ; 2516 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 2517 R__TObjArray_InsertBefore( fElements, copy, element );; 2518 next(); // move the cursor passed the insert object.; 2519 copy->SetBit(TStreamerElement::kRepeat);; 2520 element = copy;; 2521 ; 2522 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 2523 } else {; 2524 // If the element is just cached and not repeat, we need to inject an element; 2525 // to insure the writing.; 2526 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 2527 R__TObjArray_InsertAfter( fElements, writecopy, element );; 2528 next(); // move the cursor passed the insert object.; 2529 writecopy->SetBit(TStreamerElement::kWrite);; 2530 writecopy->SetNewType( writecopy->GetType() );; 2531 writecopy->SetOffset(element->GetOffset());; 2532 }; 2533 element->SetBit(TStreamerElement::kCache);; 2534 element->SetNewType( element->GetType() );; 2535 element->SetOffset(infoalloc ? infoalloc->GetOffset(element->GetName()) : 0);; 2536 } else if (rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2537 // The data member exist in the onfile StreamerInfo and there is a rule; 2538 // that has the same member 'only' has a target ... so this means we are; 2539 // asked to ignore the input data ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:117964,Performance,load,loaded,117964,"ass %s read from %s%s\n""; 2945 "" has the same version (=%d) as the active class but a different checksum.\n""; 2946 "" You should update the version to ClassDef(%s,%d).\n""; 2947 "" The objects on this file might not be readable because:\n""; 2948 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 2949 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2950 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetClassVersion(),; 2951 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 2952 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2953 otherBase->SetErrorMessage(msg);; 2954 ; 2955 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBaseClass->GetCheckSum()) {; 2956 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 2957 if (!localBaseInfo) {; 2958 // We are likely in the situation where the base class comes after the derived; 2959 // class in the TFile's list of StreamerInfo, so it has not yet been loaded,; 2960 // let's see if it is there.; 2961 const TList *list = file->GetStreamerInfoCache();; 2962 localBaseInfo = list ? (TStreamerInfo*)list->FindObject(localBase->GetName()) : 0;; 2963 }; 2964 if (!localBaseInfo) {; 2965 TString msg;; 2966 msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:165937,Performance,load,loaded,165937,");; 4097 }; 4098 }; 4099 fprintf(fp,""\n"");; 4100 ; 4101 TString sourcename; sourcename.Form( ""%s/%sProjectSource.cxx"", dirname, gSystem->BaseName(dirname) );; 4102 FILE *sfp = fopen( sourcename.Data(), ""a"" );; 4103 if (sfp) {; 4104 GenerateDeclaration(fp, sfp, subClasses);; 4105 } else {; 4106 Error(""GenerateHeaderFile"",""Could not open %s for appending"",sourcename.Data());; 4107 }; 4108 TMakeProject::GeneratePostDeclaration(fp, this, inclist);; 4109 ; 4110 fprintf(fp,""#endif\n"");; 4111 ; 4112 delete [] inclist;; 4113 fclose(fp);; 4114 if (sfp) fclose(sfp);; 4115 return 1;; 4116}; 4117 ; 4118////////////////////////////////////////////////////////////////////////////////; 4119/// Compute data member offset.; 4120/// Return pointer to the Streamer function if one exists; 4121 ; 4122Int_t TStreamerInfo::GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const; 4123{; 4124 TIter nextr(fClass->GetListOfRealData());; 4125 char dmbracket[256];; 4126 snprintf(dmbracket,255,""%s["",dm->GetName());; 4127 Int_t offset = kMissing;; 4128 if (!fClass->IsLoaded()) {; 4129 // If the 'class' is not loaded, we do not have a TClass bootstrap and thus; 4130 // the 'RealData' might not have enough information because of the lack; 4131 // of proper ShowMember implementation.; 4132 if (! (dm->Property() & kIsStatic) ) {; 4133 // Give an offset only to non-static members.; 4134 offset = dm->GetOffset();; 4135 }; 4136 }; 4137 TRealData *rdm;; 4138 while ((rdm = (TRealData*)nextr())) {; 4139 char *rdmc = (char*)rdm->GetName();; 4140 //next statement required in case a class and one of its parent class; 4141 //have data members with the same name; 4142 if (dm->IsaPointer() && rdmc[0] == '*') rdmc++;; 4143 ; 4144 if (rdm->GetDataMember() != dm) continue;; 4145 if (strcmp(rdmc,dm->GetName()) == 0) {; 4146 offset = rdm->GetThisOffset();; 4147 streamer = rdm->GetStreamer();; 4148 break;; 4149 }; 4150 if (strcmp(rdm->GetName(),dm->GetName()) == 0) {; 4151 if (rdm->IsObject()) {; 4152 o",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:169367,Performance,load,loaded,169367,"2 ; 4203////////////////////////////////////////////////////////////////////////////////; 4204/// Return the StreamerElement of ""datamember"" inside our; 4205/// class or any of its base classes.; 4206///; 4207/// The offset information; 4208/// contained in the StreamerElement is related to its immediately; 4209/// containing class, so we return in 'offset' the offset inside; 4210/// our class.; 4211 ; 4212TStreamerElement* TStreamerInfo::GetStreamerElement(const char* datamember, Int_t& offset) const; 4213{; 4214 if (!fElements) {; 4215 return 0;; 4216 }; 4217 ; 4218 // Look first at the data members and base classes; 4219 // of our class.; 4220 TStreamerElement* element = (TStreamerElement*) fElements->FindObject(datamember);; 4221 if (element) {; 4222 offset = element->GetOffset();; 4223 return element;; 4224 }; 4225 ; 4226 // Not found, so now try the data members and base classes; 4227 // of the base classes of our class.; 4228 if (fClass->HasDataMemberInfo()) {; 4229 // Our class has a dictionary loaded, use it to search the base classes.; 4230 TStreamerElement* base_element = 0;; 4231 TBaseClass* base = 0;; 4232 TClass* base_cl = 0;; 4233 Int_t base_offset = 0;; 4234 Int_t local_offset = 0;; 4235 TIter nextb(fClass->GetListOfBases());; 4236 // Iterate on list of base classes.; 4237 while ((base = (TBaseClass*) nextb())) {; 4238 base_cl = TClass::GetClass(base->GetName());; 4239 base_element = (TStreamerElement*) fElements->FindObject(base->GetName());; 4240 if (!base_cl || !base_element) {; 4241 continue;; 4242 }; 4243 base_offset = base_element->GetOffset();; 4244 element = ((TStreamerInfo*)base_cl->GetStreamerInfo())->GetStreamerElement(datamember, local_offset);; 4245 if (element) {; 4246 offset = base_offset + local_offset;; 4247 return element;; 4248 }; 4249 }; 4250 } else {; 4251 // Our class's dictionary is not loaded. Search through the base class streamer elements.; 4252 TIter next(fElements);; 4253 TStreamerElement* curelem = 0;; 4254 while ((curele",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:170206,Performance,load,loaded,170206,"first at the data members and base classes; 4219 // of our class.; 4220 TStreamerElement* element = (TStreamerElement*) fElements->FindObject(datamember);; 4221 if (element) {; 4222 offset = element->GetOffset();; 4223 return element;; 4224 }; 4225 ; 4226 // Not found, so now try the data members and base classes; 4227 // of the base classes of our class.; 4228 if (fClass->HasDataMemberInfo()) {; 4229 // Our class has a dictionary loaded, use it to search the base classes.; 4230 TStreamerElement* base_element = 0;; 4231 TBaseClass* base = 0;; 4232 TClass* base_cl = 0;; 4233 Int_t base_offset = 0;; 4234 Int_t local_offset = 0;; 4235 TIter nextb(fClass->GetListOfBases());; 4236 // Iterate on list of base classes.; 4237 while ((base = (TBaseClass*) nextb())) {; 4238 base_cl = TClass::GetClass(base->GetName());; 4239 base_element = (TStreamerElement*) fElements->FindObject(base->GetName());; 4240 if (!base_cl || !base_element) {; 4241 continue;; 4242 }; 4243 base_offset = base_element->GetOffset();; 4244 element = ((TStreamerInfo*)base_cl->GetStreamerInfo())->GetStreamerElement(datamember, local_offset);; 4245 if (element) {; 4246 offset = base_offset + local_offset;; 4247 return element;; 4248 }; 4249 }; 4250 } else {; 4251 // Our class's dictionary is not loaded. Search through the base class streamer elements.; 4252 TIter next(fElements);; 4253 TStreamerElement* curelem = 0;; 4254 while ((curelem = (TStreamerElement*) next())) {; 4255 if (curelem->InheritsFrom(TStreamerBase::Class())) {; 4256 TClass* baseClass = curelem->GetClassPointer();; 4257 if (!baseClass) {; 4258 continue;; 4259 }; 4260 Int_t base_offset = curelem->GetOffset();; 4261 Int_t local_offset = 0;; 4262 TStreamerInfo *baseInfo;; 4263 if (baseClass->Property() & kIsAbstract) {; 4264 baseInfo = (TStreamerInfo*)baseClass->GetStreamerInfoAbstractEmulated();; 4265 } else {; 4266 baseInfo = (TStreamerInfo*)baseClass->GetStreamerInfo();; 4267 }; 4268 if (baseInfo) element = baseInfo->GetStreamerElement(datame",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:187088,Performance,cache,cached,187088,"k(newel);; 4612 } else {; 4613 toAdd.reserve(rule->GetTarget()->GetEntriesFast());; 4614 TObjString * objstr = (TObjString*)(rule->GetTarget()->At(0));; 4615 if (objstr) {; 4616 TString newName = objstr->String();; 4617 TString realDataName;; 4618 if ( TDataMember* dm = fClass->GetDataMember( newName ) ) {; 4619 TRealData::GetName(realDataName,dm);; 4620 newel = new TStreamerArtificial(realDataName,"""",; 4621 fClass->GetDataMemberOffset(newName),; 4622 TStreamerInfo::kArtificial,; 4623 fClass->GetDataMember( newName )->GetTypeName());; 4624 newel->SetReadFunc( rule->GetReadFunctionPointer() );; 4625 newel->SetReadRawFunc( rule->GetReadRawFunctionPointer() );; 4626 toAdd.push_back(newel);; 4627 } else {; 4628 // This would be a completely new member (so it would need to be cached); 4629 // TOBEDONE; 4630 }; 4631 for(Int_t other = 1; other < rule->GetTarget()->GetEntriesFast(); ++other) {; 4632 objstr = (TObjString*)(rule->GetTarget()->At(other));; 4633 if (objstr) {; 4634 newName = objstr->String();; 4635 if ( TDataMember* dm = fClass->GetDataMember( newName ) ) {; 4636 TRealData::GetName(realDataName,dm);; 4637 newel = new TStreamerArtificial(realDataName,"""",; 4638 fClass->GetDataMemberOffset(newName),; 4639 TStreamerInfo::kArtificial,; 4640 fClass->GetDataMember( newName )->GetTypeName());; 4641 toAdd.push_back(newel);; 4642 }; 4643 }; 4644 }; 4645 } // For each target of the rule; 4646 }; 4647 // Now find we with need to add them; 4648 TIter s_iter(rule->GetSource());; 4649 Int_t loc = -1;; 4650 while( TObjString *s = (TObjString*)s_iter() ) {; 4651 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4652 if (s->String() == fElements->UncheckedAt(i)->GetName()) {; 4653 if (loc == -1 || (i+1)>loc) {; 4654 loc = i+1;; 4655 }; 4656 }; 4657 }; 4658 }; 4659 if (loc == -1) {; 4660 // Verify if the last one is not 'skipped'.; 4661 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4662 if (((TStreamerElement *)fElements->UncheckedAt(i))->Ge",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:188905,Performance,optimiz,optimized,188905," 4649 Int_t loc = -1;; 4650 while( TObjString *s = (TObjString*)s_iter() ) {; 4651 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4652 if (s->String() == fElements->UncheckedAt(i)->GetName()) {; 4653 if (loc == -1 || (i+1)>loc) {; 4654 loc = i+1;; 4655 }; 4656 }; 4657 }; 4658 }; 4659 if (loc == -1) {; 4660 // Verify if the last one is not 'skipped'.; 4661 for(Int_t i = fElements->GetLast(); i >= 0 && (i+1) >= loc; --i) {; 4662 if (((TStreamerElement *)fElements->UncheckedAt(i))->GetNewType() !=; 4663 TVirtualStreamerInfo::kUnsupportedConversion) {; 4664 break;; 4665 }; 4666 loc = i;; 4667 }; 4668 }; 4669 if (loc == -1) {; 4670 for(auto &el : toAdd) {; 4671 fElements->Add(el);; 4672 }; 4673 } else {; 4674 R__TObjArray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:190526,Performance,optimiz,optimized,190526,"701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 475",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:190797,Performance,optimiz,optimized,190797,"701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 475",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:190976,Performance,optimiz,optimized,190976,"701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 475",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:191007,Performance,optimiz,optimized,191007,"701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 475",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:191116,Performance,optimiz,optimized,191116,"= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:191461,Performance,optimiz,optimized,191461,"LSE;; 4724 for (Int_t i=0,j=0;i < fNdata;++i,++j) {; 4725 TStreamerElement *element = (TStreamerElement*)fCompOpt[i]->fElem;; 4726 TString sequenceType;; 4727 element->GetSequenceType(sequenceType);; 4728 // by definition of the loop (i+1) <= fNdata; 4729 optimized = TStreamerInfo::kOffsetL < fCompOpt[i]->fType && fCompOpt[i]->fType < TStreamerInfo::kOffsetP && fCompOpt[i]->fLength > fCompOpt[i]->fElem->GetArrayLength();; 4730 if (optimized) {; 4731 // This was optimized.; 4732 if (sequenceType.Length() != 0) {; 4733 sequenceType += ',';; 4734 }; 4735 sequenceType += ""optimized"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762 }; 4763}; 4764 ; 4765////////////////////////////////////////////////////////////////////////////////; 4766/// An emulated object is created at address obj, if obj is null we; 4767/// allocate memory for the object.; 4768 ; 4769void* TStreamerInfo::New(void *obj); 4770{; 4771 //???FIX ME: What about varying length array elements?; 4772 ; 4773 char* p = (char*) obj;; 4774 ; 4775 TIter next(fElements);; 4776 ; 4777 if (!p) {; 4778 // Alloc",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:226152,Performance,cache,cached,226152,"5610 static TClassRef stringClass(""string"");; 5611 if (ladd && aElement->GetClass() == stringClass) {; 5612 std::string *st = (std::string*)(ladd);; 5613 printf(""%s"",st->c_str());; 5614 } else {; 5615 printf(""(%s*)0x%zx"",aElement->GetClass()->GetName(),(size_t)(ladd));; 5616 }; 5617 } else {; 5618 printf(""(unknown_type*)0x%zx"",(size_t)(ladd));; 5619 }; 5620 break;; 5621 }; 5622 }; 5623}; 5624 ; 5625////////////////////////////////////////////////////////////////////////////////; 5626///function called by the TClass constructor when replacing an emulated class; 5627///by the real class; 5628 ; 5629void TStreamerInfo::Update(const TClass *oldcl, TClass *newcl); 5630{; 5631 TStreamerElement *element;; 5632 TIter nextElement(GetElements());; 5633 while ((element = (TStreamerElement*)nextElement())) {; 5634 element->Update(oldcl,newcl);; 5635 }; 5636 for (Int_t i=0;i < fNslots;i++) {; 5637 fComp[i].Update(oldcl,newcl);; 5638 }; 5639}; 5640 ; 5641////////////////////////////////////////////////////////////////////////////////; 5642/// Update the TClass pointer cached in this object.; 5643 ; 5644void TStreamerInfo::TCompInfo::Update(const TClass *oldcl, TClass *newcl); 5645{; 5646 if (fType != -1) {; 5647 if (fClass == oldcl || strcmp(fClassName, newcl->GetName()) == 0); 5648 fClass = newcl;; 5649 else if (fClass == 0 && TClassTable::GetDict(fClassName)); 5650 fClass = TClass::GetClass(fClassName);; 5651 }; 5652}; 5653 ; 5654////////////////////////////////////////////////////////////////////////////////; 5655/// Generate emulated collection proxy for a given class.; 5656 ; 5657TVirtualCollectionProxy*; 5658TStreamerInfo::GenEmulatedProxy(const char* class_name, Bool_t silent); 5659{; 5660 return TCollectionProxyFactory::GenEmulatedProxy(class_name, silent);; 5661}; 5662 ; 5663////////////////////////////////////////////////////////////////////////////////; 5664/// Generate emulated class streamer for a given collection class.; 5665 ; 5666TClassStreamer*; 5667TStreamerInfo",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233349,Performance,load,loading,233349,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:246913,Performance,load,load,246913,"l the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::HasRuleWithSourceClassBool_t HasRuleWithSourceClass(const TString &source) constReturn True if we have any rule whose source class is 'source'.Definition TSchemaRuleSet.cxx:199; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::GetTargetconst TObjArray * GetTarget() constGet the target data members of this rule (i.e. the in memory data member).Definition TSchemaRule.cxx:520; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetDeltaInt_t GetDelta()Get offset from ""this"" to part of base class.Definition TBaseClass.cxx:75; TBaseClass::IsSTLContainerROOT::ESTLType IsSTLContainer()Return which type (if any) of STL container the data member is.Definition TBaseClass.cxx:101; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ClassBeginvirtual void ClassBegin(const TClass *, Version_t=-1)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMem",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:247702,Performance,cache,cacheReuse,247702,"BaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ClassBeginvirtual void ClassBegin(const TClass *, Version_t=-1)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::WriteObjectAnyvirtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMembervirtual void ClassMember(const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0; TBuffer::GetVersionOwnervirtual Int_t GetVersionOwner() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassRef::Resetvoid Reset()Definition TClassRef.h:67; TClassStreamerDefinition TClassStreamer.h:26; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:252221,Performance,load,load,252221,"cally generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:600",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255893,Performance,load,load,255893,"ForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmulatedProxystatic TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)Generate emulated collection proxy for a given class.Definition TCollectionProxyFactory.cxx:63; TCollectionProxyFactory::GenEmulatedClassStreamerstatic TClassStreamer * GenEmulatedClassStreamer(const char *class_name, Bool_t silent)Generate emulated class streamer for a given collection class.Definition TCollectionProxyFactory.cxx:71; TCollectionProxyFactory::GenExplicitProxystatic Proxy_t * GenExplicitProxy(const ::ROOT::TCollectionProxyInfo &info, TClass *cl)Generate proxy from static functions.Definition TCollectionProxyFactory.cxx:90; TCollectionProxyFactory::GenExplicitClassStreamerstatic TClassStreamer * GenExplicitCl",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:260916,Performance,cache,cached,260916,"eTString GetTypeName()Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".Definition TDataType.cxx:149; TDataType::GetDataTypestatic TDataType * GetDataType(EDataType type)Given a EDataType type, get the TDataType* that represents it.Definition TDataType.cxx:451; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetClassIndexTArrayC * GetClassIndex() constDefinition TFile.h:226; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TMakeProject::GetHeaderNamestatic TString GetHeaderName(const char *name, const TList *extrainfos, Bool_t includeNested=kFALSE)Return the header name containing the description of name.Definition TMakeProject.cxx:87; TMakeProject::GenerateForwardDeclarationstatic UInt_t GenerateForwardDeclaration(FILE *fp, const char *clname, char *inclist, Bool_t implementEmptyClass, Bool_t needGenericTemplate, const TList *extrainfos)Insert a (complete) forward declaration for the class 'clname'.Defini",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:274754,Performance,cache,cached,274754," element represent a base class.Definition TStreamerElement.cxx:431; TStreamerElement::SetOffsetvirtual void SetOffset(Int_t offset)Definition TStreamerElement.h:136; TStreamerElement::Classstatic TClass * Class(); TStreamerElement::kWholeObject@ kWholeObjectDefinition TStreamerElement.h:82; TStreamerElement::kWrite@ kWriteDefinition TStreamerElement.h:80; TStreamerElement::kRepeat@ kRepeatDefinition TStreamerElement.h:78; TStreamerElement::kCache@ kCacheDefinition TStreamerElement.h:77; TStreamerElement::kDoNotDelete@ kDoNotDeleteDefinition TStreamerElement.h:81; TStreamerElement::SetNewTypevirtual void SetNewType(Int_t dtype)Definition TStreamerElement.h:140; TStreamerElement::SetMaxIndexvirtual void SetMaxIndex(Int_t dim, Int_t max)set maximum index for array with dimension dimDefinition TStreamerElement.cxx:490; TStreamerElement::HasCountervirtual Bool_t HasCounter() constDefinition TStreamerElement.h:129; TStreamerElement::GetSequenceTypevoid GetSequenceType(TString &type) constFill type with the string representation of sequence information including 'cached',...Definition TStreamerElement.cxx:356; TStreamerInfoActions::TActionSequence::fActionsActionContainer_t fActionsDefinition TStreamerInfoActions.h:212; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fElemTStreamerElement * fElemNot Owned.Definition TStreamerInfo.h:51; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:275019,Performance,cache,cached,275019,"StreamerElement::kWrite@ kWriteDefinition TStreamerElement.h:80; TStreamerElement::kRepeat@ kRepeatDefinition TStreamerElement.h:78; TStreamerElement::kCache@ kCacheDefinition TStreamerElement.h:77; TStreamerElement::kDoNotDelete@ kDoNotDeleteDefinition TStreamerElement.h:81; TStreamerElement::SetNewTypevirtual void SetNewType(Int_t dtype)Definition TStreamerElement.h:140; TStreamerElement::SetMaxIndexvirtual void SetMaxIndex(Int_t dim, Int_t max)set maximum index for array with dimension dimDefinition TStreamerElement.cxx:490; TStreamerElement::HasCountervirtual Bool_t HasCounter() constDefinition TStreamerElement.h:129; TStreamerElement::GetSequenceTypevoid GetSequenceType(TString &type) constFill type with the string representation of sequence information including 'cached',...Definition TStreamerElement.cxx:356; TStreamerInfoActions::TActionSequence::fActionsActionContainer_t fActionsDefinition TStreamerInfoActions.h:212; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fElemTStreamerElement * fElemNot Owned.Definition TStreamerInfo.h:51; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo::fLengthInt_t fLengthDefinition TStreamerInfo.h:50; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::fNVirtualInfoLocInt_t fNVirtualInfoLoc! Number of virtual info location to update.Definition TStreamerInfo.h:102; TStreamerInfo::fOnFileClas",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:282080,Performance,optimiz,optimized,282080,"Only=kFALSE) overrideDestroy an array of emulated objects, with optional delete.Definition TStreamerInfo.cxx:5126; TStreamerInfo::BuildForBool_t BuildFor(const TClass *cl) overrideCheck if we can build this for foreign class - do we have some rules to do that.Definition TStreamerInfo.cxx:1291; TStreamerInfo::Buildvoid Build(Bool_t isTransient=kFALSE) overrideBuild the I/O data structure for the current class version.Definition TStreamerInfo.cxx:263; TStreamerInfo::BuildOldvoid BuildOld() overriderebuild the TStreamerInfo structureDefinition TStreamerInfo.cxx:1705; TStreamerInfo::fReadMemberWiseTStreamerInfoActions::TActionSequence * fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInf",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:287942,Performance,load,load,287942,"ent *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::NewArrayvoid * NewArray(Long_t nElements, void *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::CompareContentBool_t CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) overrideReturn True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.Definition TStreamerInfo.cxx:2854; TStreamerInfo::fWriteMemberWiseTStreamerInfoActions::TActionSequence * fWriteMemberWise! List of write action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:109; TStreamerInfo::fNslotsInt_t fNslots!total number of slots in fComp.Definition TStreamerInfo.h:95; TStreamerInfo::ForceWriteInfovoid ForceWriteInfo(TFile *file, Bool_t force=kFALSE) overrideRecursively mark streamer infos for writing to a file.Definition TStreamerInfo.cxx:3172; TStreamerInfo::fOldVersionVersion_t fOldVersion! Version of the TStreamerInfo object read from the fileDefinition TStreamerInfo.h:101; TSt",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:294650,Performance,optimiz,optimizedDefinition,294650," void * New() constConstruct a new container object and return its address.Definition TVirtualCollectionProxy.h:111; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::Atvirtual void * At(UInt_t idx)=0Return the address of the value at index idx; TVirtualCollectionProxy::GetCollectionTypevirtual Int_t GetCollectionType() const =0Return the type of the proxied collection (see enumeration TClassEdit::ESTLType); TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::fIsBuiltBool_t fIsBuilttrue if the StreamerInfo has been optimizedDefinition TVirtualStreamerInfo.h:48; TVirtualStreamerInfo::ForceWriteInfovirtual void ForceWriteInfo(TFile *file, Bool_t force=kFALSE)=0; TVirtualStreamerInfo::IsCompiledBool_t IsCompiled() constDefinition TVirtualStreamerInfo.h:173; TVirtualStreamerInfo::fIsCompiledstd::atomic< Bool_t > fIsCompiledtrue if the StreamerInfo has been 'built' (i.e. has all the StreamerElements it should have)Definition TVirtualStreamerInfo.h:49; TVirtualStreamerInfo::GetElementCounterStartstatic const char * GetElementCounterStart(const char *dmTitle)Given a comment/title declaring an array counter, for example:Definition TVirtualStreamerInfo.cxx:99; TVirtualStreamerInfo::EReadWriteEReadWriteEReadWrite Enumerator.Definition TVirtualStreamerInfo.h:116; TVirtualStreamerInfo::kStreamer@ kStreamerDefinition TVirtualStreamerInfo.h:130; TVirtualStreamerInfo::kULong64@ kULong64Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kObjectp@ kObjectpDefinition TVirtualStreame",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:8271,Safety,avoid,avoid,8271," fInfo->SetBit(TStreamerInfo::kBuildRunning);; 247 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 248 }; 249 ~TPreventRecursiveBuildGuard() {; 250 fInfo->ResetBit(TStreamerInfo::kBuildOldUsed);; 251 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 252 }; 253 TStreamerInfo* fInfo;; 254 };; 255 ; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Build the I/O data structure for the current class version.; 260///; 261/// A list of TStreamerElement derived classes is built by scanning; 262/// one by one the list of data members of the analyzed class.; 263void TStreamerInfo::Build(Bool_t isTransient); 264{; 265 // Did another thread already do the work?; 266 if (fIsCompiled) return;; 267 ; 268 R__LOCKGUARD(gInterpreterMutex);; 269 ; 270 // Did another thread already do the work while we were waiting ..; 271 if (fIsCompiled) return;; 272 ; 273 // Has Build already been run?; 274 if (fIsBuilt) return;; 275 ; 276 // Are we recursing on ourself?; 277 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 278 ; 279 // This is used to avoid unwanted recursive call to Build or BuildOld.; 280 TPreventRecursiveBuildGuard buildGuard(this);; 281 ; 282 if (fClass->GetCollectionProxy()) {; 283 TVirtualCollectionProxy *proxy = fClass->GetCollectionProxy();; 284 TString title;; 285 if (proxy->GetValueClass()) {; 286 title.Form(""<%s%s> Used to call the proper TStreamerInfo case"",proxy->GetValueClass()->GetName(),proxy->HasPointers() ? ""*"" : """");; 287 } else {; 288 title .Form(""<%s%s> Used to call the proper TStreamerInfo case"",TDataType::GetTypeName(proxy->GetType()),proxy->HasPointers() ? ""*"" : """");; 289 }; 290 TStreamerElement* element = new TStreamerSTL(""This"", title.Data(), 0, fClass->GetName(), *proxy, 0);; 291 fElements->Add(element);; 292 Compile();; 293 fCheckSum = fClass->GetCheckSum();; 294 fIsBuilt = kTRUE;; 295 return;; 296 }; 297 ; 298 // Warn on read/write of RVec (see 6.24 release notes); 299 if (strncmp(GetName(), ""ROOT::V",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:25054,Safety,avoid,avoid,25054," (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetClassVersion()));; 673 if (!infoalloc) {; 674 if (!isTransient); 675 Error(""Build"",""Could you create a TStreamerInfo for %s\n"",TString::Format(""%s@@%d"",GetName(),GetClassVersion()).Data());; 676 } else {; 677 // Tell clone we should rerun BuildOld; 678 infoalloc->SetBit(kBuildOldUsed,false);; 679 // Temporarily mark it as built to avoid the BuildCheck from removing; 680 // Technically we only need to do this for the 'current' StreamerInfo; 681 fIsBuilt = kTRUE;; 682 infoalloc->BuildCheck();; 683 infoalloc->BuildOld();; 684 fIsBuilt = kFALSE;; 685 TClass *allocClass = infoalloc->GetClass();; 686 ; 687 {; 688 TIter next(fElements);; 689 TStreamerElement* element;; 690 while ((element = (TStreamerElement*) next())) {; 691 if (element->TestBit(TStreamerElement::kRepeat) && element->IsaPointer()) {; 692 TStreamerElement *other = (TStreamerElement*) infoalloc->GetElements()->FindObject(element->GetName());; 693 if (other) {; 694 other->SetBit(TStreamerElement::kDoNotDelete);; 695 }; 696 }; 697 }; 698 infoalloc->GetElements()->Compress();; 699 }; 700 {; 701 TIter next(fElements);; 702 TStreamerElement* element;; 703 while ((element = (TStreamerElement*) next())) {; 704 if (element->TestBit(TStreamerElement::kCache)) {; 705 element->SetOffset(infoalloc->GetOffset(element->GetName()));; 706 }; 707 }; 708 }; 709 ; 710 TStreamerElement *el = new TStreamerArtificial(""@@alloc"","""", 0, TStreamerInfo::kCacheNew, allocClass->GetName());; 711 R__TObjArray_InsertAt( fElements, el, 0 );; 712 ; 713 el = new TStreamerArtificial(""@@dealloc"","""", 0, TStreamerInfo::kCacheDelete, allocClass->GetName());; 714 fElements->Add( el );; 715 }; 716 }; 717 ; 718 //; 719 // Make a more compact version.; 720 //; 721 Compile();; 722 fIsBuilt = kTRUE;; 723}; 724 ; 725////////////////////////////////////////////////////////////////////////////////; 726/// Check if built and consistent with the class dictionary.; 727/// This method is called by ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:65799,Safety,avoid,avoid,65799,"lternate(context, inside[1], newName);; 1671 ; 1672 if (altcl) {; 1673 std::string alternate = inside[0];; 1674 alternate.append(""<"");; 1675 alternate.append(newName);; 1676 // We are intentionally dropping any further arguments,; 1677 // they would be using the wrong typename and would also be; 1678 // somewhat superflous since this is for the old layout.; 1679 if (alternate[alternate.length()-1]=='>') {; 1680 alternate.append("" "");; 1681 }; 1682 alternate.append("">"");; 1683 return TClass::GetClass(alternate.c_str(),true,true);; 1684 }; 1685 }; 1686 return 0;; 1687 }; 1688 ; 1689 // Makes sure kBuildOldUsed set once BuildOld finishes; 1690 struct TBuildOldGuard {; 1691 TBuildOldGuard(TStreamerInfo* info): fInfo(info) {; 1692 fInfo->SetBit(TStreamerInfo::kBuildRunning);; 1693 }; 1694 ~TBuildOldGuard() {; 1695 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 1696 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 1697 }; 1698 TStreamerInfo* fInfo;; 1699 };; 1700}; 1701 ; 1702////////////////////////////////////////////////////////////////////////////////; 1703/// rebuild the TStreamerInfo structure; 1704 ; 1705void TStreamerInfo::BuildOld(); 1706{; 1707 R__LOCKGUARD(gInterpreterMutex);; 1708 ; 1709 if ( TestBit(kBuildOldUsed) ) return;; 1710 ; 1711 // Are we recursing on ourself?; 1712 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 1713 ; 1714 // This is used to avoid unwanted recursive call to Build and make sure; 1715 // that we record the execution of BuildOld.; 1716 TBuildOldGuard buildOldGuard(this);; 1717 ; 1718 if (gDebug > 0) {; 1719 printf(""\n====>Rebuilding TStreamerInfo for class: %s, version: %d\n"", GetName(), fClassVersion);; 1720 }; 1721 ; 1722 Bool_t wasCompiled = IsCompiled();; 1723 ; 1724 if (fClass->GetClassVersion() == fClassVersion) {; 1725 if (!fClass->HasInterpreterInfo() || fClass->GetCollectionType() || TClassEdit::IsSTLBitset(GetName())); 1726 {; 1727 // Handle emulated classes and STL containers specially.; 1728 // in this case BuildRealData w",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:85889,Safety,sanity check,sanity check,85889,"ly crash."");; 2154 element->SetOffset(0);; 2155 element->Init(this);; 2156 dmType = element->GetTypeName();; 2157 dmIsPtr = false;; 2158 }; 2159 }; 2160 } // Class corresponding to StreamerInfo is emulated or not.; 2161 ; 2162 // Now let's deal with Schema evolution; 2163 Int_t newType = -1;; 2164 TClassRef newClass;; 2165 ; 2166 if (dm && dm->IsPersistent()) {; 2167 auto theType = isStdArray ? dt : dm->GetDataType();; 2168 if (theType) {; 2169 Bool_t isArray = isStdArray || element->GetArrayLength() >= 1;; 2170 Bool_t hasCount = element->HasCounter();; 2171 // data member is a basic type; 2172 if ((fClass == TObject::Class()) && !strcmp(dm->GetName(), ""fBits"")) {; 2173 //printf(""found fBits, changing dtype from %d to 15\n"", dtype);; 2174 newType = kBits;; 2175 } else {; 2176 // All the values of EDataType have the same semantic in EReadWrite; 2177 newType = (EReadWrite)theType->GetType();; 2178 }; 2179 if ((newType == ::kChar_t) && dmIsPtr && !isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 //",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:86116,Safety,sanity check,sanity check,86116,"isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 // sanity check.; 2210 newType = -1;; 2211 }; 2212 }; 2213 }; 2214 }; 2215 }; 2216 ; 2217 if (newType > 0) {; 2218 // Case of a numerical type; 2219 if (element->GetType() >= TStreamerInfo::kObject) {; 2220 // Old type was not a numerical type.; 2221 element->SetNewType(TVirtualStreamerInfo::kUnsupportedConversion);; 2222 } else if (element->GetType() != newType) {; 2223 element->SetNewType(newType);; 2224 if (gDebug > 0) {; 2225 // coverity[mixed_enums] - All the values of EDataType have the same semantic in EReadWrite; 2226 Info(""BuildOld"", ""element: %s %s::%s has new type: %s/%d"", element->GetTypeName(), GetName(), element->GetName(), dm ? dm->GetFullTypeName() : TDataType::GetTypeName((EDataType)newType), newType);; 2227 }; 2228 }; 2229 } else if (newClass.GetClass()) {; 2230 // Sometime BuildOld is called again.; 2231 // In that case we might already have fix up the streamer element.; 2232 // So we need to go back to the original information!",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:99050,Safety,avoid,avoid,99050,"issing;; 2465 element->SetOffset(kMissing);; 2466 }; 2467 ; 2468 if (offset != kMissing && fClass->GetState() <= TClass::kEmulated && !fClass->fIsSyntheticPair) {; 2469 // Note the initialization in this case are; 2470 // delayed until __after__ the schema evolution; 2471 // section, just in case the info has changed.; 2472 ; 2473 // The class is NOT known to Cling, i.e. is emulated,; 2474 // and we need to use the calculated offset.; 2475 ; 2476 Int_t asize;; 2477 if (element->GetType() == TStreamerInfo::kSTL &&; 2478 strcmp(element->GetName(),""This"") == 0 &&; 2479 strcmp(element->GetTypeName(),GetName()) == 0 &&; 2480 !fClass->GetCollectionProxy()) {; 2481 // Humm .. we are missing the collection Proxy; 2482 // for a proxied (custom) collection ... avoid; 2483 // an infinite recursion and take a wild guess; 2484 asize = sizeof(std::vector<int>);; 2485 } else {; 2486 // Regular case; 2487 asize = element->GetSize();; 2488 }; 2489 // align the non-basic data types (required on alpha and IRIX!!); 2490 if ((offset % kSizeOfPtr) != 0) {; 2491 offset = offset - (offset % kSizeOfPtr) + kSizeOfPtr;; 2492 }; 2493 element->SetOffset(offset);; 2494 offset += asize;; 2495 }; 2496 ; 2497 if (!wasCompiled && rules) {; 2498 if (rules.HasRuleWithSource( element->GetName(), kTRUE ) ) {; 2499 ; 2500 if (allocClass == 0) {; 2501 infoalloc = (TStreamerInfo *)Clone(TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()));; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.Has",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:126912,Safety,safe,safe,126912,"//////////////////////////////////////////////////////////////////; 3132/// Compute total size of all persistent elements of the class; 3133 ; 3134void TStreamerInfo::ComputeSize(); 3135{; 3136 if (this == fClass->GetCurrentStreamerInfo()) {; 3137 if (fClass->GetState() >= TClass::kInterpreted || fClass->fIsSyntheticPair) {; 3138 fSize = fClass->GetClassSize();; 3139 return;; 3140 }; 3141 }; 3142 ; 3143 TStreamerElement *element = (TStreamerElement*)fElements->Last();; 3144 //faster and more precise to use last element offset +size; 3145 //on 64 bit machines, offset may be forced to be a multiple of 8 bytes; 3146 fSize = element ? element->GetOffset() + element->GetSize() : 0;; 3147 if (fNVirtualInfoLoc > 0 && (fVirtualInfoLoc[0]+sizeof(TStreamerInfo*)) >= (ULong_t)fSize) {; 3148 fSize = fVirtualInfoLoc[0] + sizeof(TStreamerInfo*);; 3149 }; 3150 ; 3151 // On some platform and in some case of layout non-basic data types needs; 3152 // to be aligned. So let's be on the safe side and align on the size of; 3153 // the pointers. (Question: is that the right thing on x32 ABI ?); 3154 constexpr size_t kSizeOfPtr = sizeof(void*);; 3155 if ((fSize % kSizeOfPtr) != 0 && !fClass->IsSyntheticPair()) {; 3156 fSize = fSize - (fSize % kSizeOfPtr) + kSizeOfPtr;; 3157 }; 3158}; 3159 ; 3160////////////////////////////////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:128183,Safety,avoid,avoid,128183,"//////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocked.; 3185 (cindex->fArray[fNumber] && !force) || // Streamer info is already marked, and not forcing, or; 3186 (cindex->fArray[fNumber] > 1) // == 2 means ignore forcing to prevent infinite recursion.; 3187 ) {; 3188 return;; 3189 }; 3190 ; 3191 auto recurseIntoContent = [file, force](TClass *contentClass); 3192 {; 3193 TVirtualStreamerInfo* si = 0;; 3194 if (contentClass->Property() & kIsAbstract) {; 3195 // If the class of the element is abstract, register the; 3196 // TStreamerInfo only if it has already been built.; 3197 // Otherwise call cl->GetStreamerInfo() would generate an; 3198 // incorrect StreamerInfo.; 3199 si = contentClass->GetCurrentStreamerInfo();; 3200 } else {; 3201 si = contentClass->GetStreamerInfo();; 3202 }; 3203 if (si) {; 3204 si->ForceWriteInfo(file, force);; 3205 }; 3206 };; 3207 ; 3208 // We do ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:143628,Safety,risk,risk,143628,"ement->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 3529 } else {; 3530 if (element->GetArrayLength() <= 1) {; 3531 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3532 else fprintf(file,"" , "");; 3533 if (R__IsUniquePtr(element)) {; 3534 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s.release() )\n"",element->GetName(),protoname.Data(),element->GetName());; 3535 } else {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetNa",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:143674,Safety,avoid,avoid,143674,"ement->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 3529 } else {; 3530 if (element->GetArrayLength() <= 1) {; 3531 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3532 else fprintf(file,"" , "");; 3533 if (R__IsUniquePtr(element)) {; 3534 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s.release() )\n"",element->GetName(),protoname.Data(),element->GetName());; 3535 } else {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetNa",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:144239,Safety,risk,risk,144239,"se {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetName(),protoname.Data(),element->GetName());; 3568 } else {; 3569 fprintf(file, "" %s = (const_cast<%s &>( rhs ).%s);\n"",element->GetName(),protoname.Data(),element->GetName());; 3570 }; 3571 }; 3572 }; 3573 }; 3574 ; 3575 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3576 ; 3577 fprintf(file, "" return *this;\n"");; 3578}; 3579 ; 3580////////////////////////////////////////////////////////////////////////////////; 3581 ; 3582static void R__WriteDestructorBody(FILE *file, TIter &next); 3583{; 3584 TStreamerElement *e",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:144285,Safety,avoid,avoid,144285,"se {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetName(),protoname.Data(),element->GetName());; 3568 } else {; 3569 fprintf(file, "" %s = (const_cast<%s &>( rhs ).%s);\n"",element->GetName(),protoname.Data(),element->GetName());; 3570 }; 3571 }; 3572 }; 3573 }; 3574 ; 3575 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3576 ; 3577 fprintf(file, "" return *this;\n"");; 3578}; 3579 ; 3580////////////////////////////////////////////////////////////////////////////////; 3581 ; 3582static void R__WriteDestructorBody(FILE *file, TIter &next); 3583{; 3584 TStreamerElement *e",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:195490,Safety,avoid,avoid,195490,"823 // If the option ""->"" is given in the data member comment field; 4824 // it is assumed that the object exists before reading data in,; 4825 // so we create an object.; 4826 if (cle != TClonesArray::Class()) {; 4827 void** r = (void**) eaddr;; 4828 *r = cle->New();; 4829 } else {; 4830 // In the case of a TClonesArray, the class name of; 4831 // the contained objects must be specified in the; 4832 // data member comment in this format:; 4833 // TClonesArray* myVar; //->(className); 4834 const char* title = element->GetTitle();; 4835 const char* bracket1 = strrchr(title, '(');; 4836 const char* bracket2 = strrchr(title, ')');; 4837 if (bracket1 && bracket2 && (bracket2 != (bracket1 + 1))) {; 4838 Int_t len = bracket2 - (bracket1 + 1);; 4839 char* clonesClass = new char[len+1];; 4840 clonesClass[0] = '\0';; 4841 strncat(clonesClass, bracket1 + 1, len);; 4842 void** r = (void**) eaddr;; 4843 *r = (void*) new TClonesArray(clonesClass);; 4844 delete[] clonesClass;; 4845 } else {; 4846 //Warning(""New"", ""No class name found for TClonesArray initializer in data member comment (expected \""//->(className)\"""");; 4847 void** r = (void**) eaddr;; 4848 *r = (void*) new TClonesArray();; 4849 }; 4850 }; 4851 }; 4852 break;; 4853 ; 4854 case kBase:; 4855 {; 4856 if (cle->Property() & kIsAbstract) {; 4857 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 4858 if (einfo) einfo->New(eaddr);; 4859 } else {; 4860 cle->New(eaddr);; 4861 }; 4862 break;; 4863 }; 4864 case kObject:; 4865 case kAny:; 4866 case kTObject:; 4867 case kTString:; 4868 case kTNamed:; 4869 {; 4870 cle->New(eaddr);; 4871 }; 4872 break;; 4873 ; 4874 case kSTL:; 4875 {; 4876 if (strcmp(element->GetName(),""This"")==0 &&; 4877 !cle->GetCollectionProxy()) {; 4878 // missing information, avoid infinite loop; 4879 // by doing nothing ....; 4880 } else {; 4881 if (cle->GetCollectionProxy()); 4882 cle->GetCollectionProxy()->New(eaddr);; 4883 else; 4884 cle->New(eaddr);; 4885 }; 4886 }; 4887 break;; 4888 ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201664,Safety,avoid,avoid,201664," {; 5024 // Destroy an array of pointers to not-pre-allocated objects.; 5025 Int_t len = ele->GetArrayLength();; 5026 if (!len) {; 5027 len = 1;; 5028 }; 5029 void** r = (void**) eaddr;; 5030 for (Int_t j = len - 1; j >= 0; --j) {; 5031 if (r[j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:23867,Security,inject,inject,23867,"is value.; 628 element->SetType(TVirtualStreamerInfo::kNoType);; 629 }; 630 }; 631 ; 632 if ( !wasCompiled && (rules && rules.HasRuleWithSource( element->GetName(), kTRUE )) ) {; 633 needAllocClass = kTRUE;; 634 ; 635 // If this is optimized to re-use TStreamerElement(s) in case of variable renaming,; 636 // then we must revisit the code in TBranchElement::InitInfo that recalculate the; 637 // fID (i.e. the index of the TStreamerElement to be used for streaming).; 638 ; 639 TStreamerElement *cached = element;; 640 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 641 if (element->GetNewType()>0 /* intentionally not including base class for now */; 642 && rules && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ); 643 {; 644 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 645 fElements->Add(copy);; 646 copy->SetBit(TStreamerElement::kRepeat);; 647 cached = copy;; 648 ; 649 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 650 } else {; 651 // If the element is just cached and not repeat, we need to inject an element; 652 // to insure the writing.; 653 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 654 fElements->Add(element);; 655 writecopy->SetBit(TStreamerElement::kWrite);; 656 writecopy->SetNewType( writecopy->GetType() );; 657 writecopy->SetOffset( element->GetOffset() );; 658 // Put the write element after the read element (that does caching).; 659 element = writecopy;; 660 }; 661 cached->SetBit(TStreamerElement::kCache);; 662 cached->SetNewType( cached->GetType() );; 663 }; 664 ; 665 fElements->Add(element);; 666 } // end of member loop; 667 ; 668 // Now add artificial TStreamerElement (i.e. rules that creates new members or set transient members).; 669 InsertArtificialElements(rules);; 670 ; 671 if (needAllocClass) {; 672 TStreamerInfo *infoalloc",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:33581,Security,checksum,checksum,33581,"ALSE;; 876 ; 877 } else if (fClass->IsLoaded() /* implied: && fClass->IsForeign() */ ) {; 878 // We are in the case of a Foreign class with no specified; 879 // class version.; 880 ; 881 searchOnChecksum = kTRUE;; 882 ; 883 }; 884 else {; 885 // We are in the case of an 'emulated' class.; 886 ; 887 if (fOnFileClassVersion >= 2 && !isStdPair) {; 888 // The class version was specified when the object was; 889 // written; 890 ; 891 searchOnChecksum = kFALSE;; 892 ; 893 } else {; 894 // The class version was not specified when the object was; 895 // written OR it was specified to be 1.; 896 ; 897 searchOnChecksum = kTRUE;; 898 ; 899 TStreamerInfo* v1 = (TStreamerInfo*) array->At(1);; 900 if (v1) {; 901 if (fCheckSum != v1->GetCheckSum()) {; 902 fClassVersion = array->GetLast() + 1;; 903 }; 904 }; 905 }; 906 }; 907 ; 908 if (!searchOnChecksum) {; 909 if (fClassVersion < (array->GetEntriesFast() - 1)) {; 910 info = (TStreamerInfo*) array->At(fClassVersion);; 911 }; 912 } else {; 913 Int_t ninfos = array->GetEntriesFast() - 1;; 914 for (Int_t i = -1; i < ninfos; ++i) {; 915 info = (TStreamerInfo*) array->UncheckedAt(i);; 916 if (!info) {; 917 continue;; 918 }; 919 if (fCheckSum == info->GetCheckSum() && (info->GetOnFileClassVersion()==1 || info->GetOnFileClassVersion()==0)) {; 920 // We must match on the same checksum, an existing TStreamerInfo; 921 // for one of the 'unversioned' class layout (i.e. version was 1).; 922 fClassVersion = i;; 923 break;; 924 }; 925 info = 0;; 926 }; 927 if (info==0) {; 928 // Find an empty slot.; 929 ninfos = array->GetEntriesFast() - 1;; 930 Int_t slot = 1; // Start of Class version 1.; 931 while ((slot < ninfos) && (array->UncheckedAt(slot) != 0)) {; 932 ++slot;; 933 }; 934 fClassVersion = slot;; 935 }; 936 }; 937 ; 938 // NOTE: Should we check if the already existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the clas",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:34687,Security,checksum,checksum,34687,"assVersion()==0)) {; 920 // We must match on the same checksum, an existing TStreamerInfo; 921 // for one of the 'unversioned' class layout (i.e. version was 1).; 922 fClassVersion = i;; 923 break;; 924 }; 925 info = 0;; 926 }; 927 if (info==0) {; 928 // Find an empty slot.; 929 ninfos = array->GetEntriesFast() - 1;; 930 Int_t slot = 1; // Start of Class version 1.; 931 while ((slot < ninfos) && (array->UncheckedAt(slot) != 0)) {; 932 ++slot;; 933 }; 934 fClassVersion = slot;; 935 }; 936 }; 937 ; 938 // NOTE: Should we check if the already existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSu",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:34718,Security,checksum,checksum,34718,"assVersion()==0)) {; 920 // We must match on the same checksum, an existing TStreamerInfo; 921 // for one of the 'unversioned' class layout (i.e. version was 1).; 922 fClassVersion = i;; 923 break;; 924 }; 925 info = 0;; 926 }; 927 if (info==0) {; 928 // Find an empty slot.; 929 ninfos = array->GetEntriesFast() - 1;; 930 Int_t slot = 1; // Start of Class version 1.; 931 while ((slot < ninfos) && (array->UncheckedAt(slot) != 0)) {; 932 ++slot;; 933 }; 934 fClassVersion = slot;; 935 }; 936 }; 937 ; 938 // NOTE: Should we check if the already existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSu",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35345,Security,checksum,checksum,35345,"dy existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_C",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35454,Security,checksum,checksum,35454,"UE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the da",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:36596,Security,checksum,checksum,36596,"GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behavi",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37082,Security,checksum,checksum,37082,"KWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(T",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37108,Security,checksum,checksum,37108,"KWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(T",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37648,Security,checksum,checksum,37648,"n one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37759,Security,checksum,checksum,37759,"hether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 1027 match = kTRUE;; 1028 }; 1029 }; 1030 }; 1031 if (info->IsBuilt()) {; 1032 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:40590,Security,checksum,checksum,40590,"non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetName());; 1067 } else {; 1068 Warning(""BuildCheck"", ""\n\; 1069 The class %s transitioned from not having a specified class version\n\; 1070 to having a specified class version (the current class version is %d).\n\; 1071 However too many different non-versioned layouts of the class have been\n\; 1072 loaded so far. This prevent the proper reading of objects written with\n\; 1073 the class layout version %d.\n\; 1074 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1075 GetName(),fClass->GetClassVersion(),fClassVersion);; 1076 }; 1077 } else {; 1078 if (file) {; 1079 if (done) {; 1080 Warning(""BuildCheck"", ""\n\; 1081 The StreamerInfo for version %d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 };",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:41631,Security,checksum,checksum,41631,"%d of class %s read from the file %s\n\; 1082 has a different checksum than the previously loaded StreamerInfo.\n\; 1083 Reading objects of type %s from the file %s \n\; 1084 (and potentially other files) might not work correctly.\n\; 1085 Most likely the version number of the class was not properly\n\; 1086 updated [See ClassDef(%s,%d)]."",; 1087 fClassVersion, GetName(), file->GetName(), GetName(), file->GetName(), GetName(), fClassVersion);; 1088 } else {; 1089 Warning(""BuildCheck"", ""\n\; 1090 The StreamerInfo from %s does not match existing one (%s:%d)\n\; 1091 The existing one has not been used yet and will be discarded.\n\; 1092 Reading the file %s will work properly, however writing object of\n\; 1093 type %s will not work properly. Most likely the version number\n\; 1094 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1095 file->GetName(), GetName(), fClassVersion,file->GetName(),GetName(), GetName(), fClassVersion);; 1096 }; 1097 } else {; 1098 if (done) {; 1099 Warning(""BuildCheck"", ""\n\; 1100 The StreamerInfo for version %d of class %s\n\; 1101 has a different checksum than the previously loaded StreamerInfo.\n\; 1102 Reading objects of type %s\n\; 1103 (and potentially other files) might not work correctly.\n\; 1104 Most likely the version number of the class was not properly\n\; 1105 updated [See ClassDef(%s,%d)]."",; 1106 fClassVersion, GetName(), GetName(), GetName(), fClassVersion);; 1107 } else {; 1108 Warning(""BuildCheck"", ""\n\; 1109 The StreamerInfo does not match existing one (%s:%d)\n\; 1110 The existing one has not been used yet and will be discarded.\n\; 1111 Reading should work properly, however writing object of\n\; 1112 type %s will not work properly. Most likely the version number\n\; 1113 of the class was not properly updated [See ClassDef(%s,%d)]."",; 1114 GetName(), fClassVersion, GetName(), GetName(), fClassVersion);; 1115 }; 1116 }; 1117 }; 1118 CompareContent(0,info,kTRUE,kTRUE,file);; 1119 fClass->SetBit(TClass::kWarned)",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:43971,Security,checksum,checksum,43971," old TStreamerInfo matches the in-memory one when we either; 1134 // - ignore the members of type enum; 1135 // or; 1136 // - ignore the comments annotation (//[xyz]); 1137 // we can accept the old TStreamerInfo.; 1138 ; 1139 if (!fClass->MatchLegacyCheckSum(fCheckSum)) {; 1140 ; 1141 Bool_t warn = !fClass->TestBit(TClass::kWarned);; 1142 if (warn) {; 1143 warn = !CompareContent(fClass,0,kFALSE,kFALSE,file);; 1144 }; 1145#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 1146 if (warn && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 1147 && fClass->GetListOfDataMembers()->GetEntries() != 0); 1148 {; 1149 // In some instances of old files (v5.17 and less), some StreamerInfo for; 1150 // an abstract class where not written correctly, and add no; 1151 // data member listed. If in addition one of the data member; 1152 // was declared using a typedef _and_ the current class definition; 1153 // uses a different typedef, we are unable to recalculate the; 1154 // checksum as it was, because the information is missing from; 1155 // the StreamerInfo, and for the same reason CompareContent can; 1156 // not know whether this is okay or not ...; 1157 //; 1158 // Since this is such an unlikely scenario, let's complain; 1159 // about it anyway (The class layout *may* have changed, we; 1160 // don't know).; 1161 ; 1162 // if (this has only base classes) {; 1163 // warn = kFALSE;; 1164 // }; 1165 }; 1166#endif // TEST_FOR_BACKWARD_COMPATIBILITY; 1167 if (warn && (fOldVersion <= 2)) {; 1168 // Names of STL base classes was modified in vers==3. Allocators removed; 1169 //; 1170 TIter nextBC(fClass->GetListOfBases());; 1171 TBaseClass* bc = 0;; 1172 while ((bc = (TBaseClass*) nextBC())) {; 1173 if (bc->GetClassPointer()->GetCollectionType()) {; 1174 warn = kFALSE;; 1175 }; 1176 }; 1177 }; 1178 if (warn) {; 1179 if (file) {; 1180 Warning(""BuildCheck"", ""\n\; 1181 The StreamerInfo of class %s read from file %s\n\; 1182 has the same version (=%d) as the ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:44994,Security,checksum,checksum,44994,"sted. If in addition one of the data member; 1152 // was declared using a typedef _and_ the current class definition; 1153 // uses a different typedef, we are unable to recalculate the; 1154 // checksum as it was, because the information is missing from; 1155 // the StreamerInfo, and for the same reason CompareContent can; 1156 // not know whether this is okay or not ...; 1157 //; 1158 // Since this is such an unlikely scenario, let's complain; 1159 // about it anyway (The class layout *may* have changed, we; 1160 // don't know).; 1161 ; 1162 // if (this has only base classes) {; 1163 // warn = kFALSE;; 1164 // }; 1165 }; 1166#endif // TEST_FOR_BACKWARD_COMPATIBILITY; 1167 if (warn && (fOldVersion <= 2)) {; 1168 // Names of STL base classes was modified in vers==3. Allocators removed; 1169 //; 1170 TIter nextBC(fClass->GetListOfBases());; 1171 TBaseClass* bc = 0;; 1172 while ((bc = (TBaseClass*) nextBC())) {; 1173 if (bc->GetClassPointer()->GetCollectionType()) {; 1174 warn = kFALSE;; 1175 }; 1176 }; 1177 }; 1178 if (warn) {; 1179 if (file) {; 1180 Warning(""BuildCheck"", ""\n\; 1181 The StreamerInfo of class %s read from file %s\n\; 1182 has the same version (=%d) as the active class but a different checksum.\n\; 1183 You should update the version to ClassDef(%s,%d).\n\; 1184 Do not try to write objects with the current class definition,\n\; 1185 the files will not be readable.\n"", GetName(), file->GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1186 } else {; 1187 Warning(""BuildCheck"", ""\n\; 1188 The StreamerInfo of class %s \n\; 1189 has the same version (=%d) as the active class but a different checksum.\n\; 1190 You should update the version to ClassDef(%s,%d).\n\; 1191 Do not try to write objects with the current class definition,\n\; 1192 the files will not be readable.\n"", GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1193 }; 1194 CompareContent(fClass,0,kTRUE,kTRUE,file);; 1195 fClass->SetBit(TClass::kWarned);; 1196 }; 1197 } else {; 1198 ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:45410,Security,checksum,checksum,45410,"// don't know).; 1161 ; 1162 // if (this has only base classes) {; 1163 // warn = kFALSE;; 1164 // }; 1165 }; 1166#endif // TEST_FOR_BACKWARD_COMPATIBILITY; 1167 if (warn && (fOldVersion <= 2)) {; 1168 // Names of STL base classes was modified in vers==3. Allocators removed; 1169 //; 1170 TIter nextBC(fClass->GetListOfBases());; 1171 TBaseClass* bc = 0;; 1172 while ((bc = (TBaseClass*) nextBC())) {; 1173 if (bc->GetClassPointer()->GetCollectionType()) {; 1174 warn = kFALSE;; 1175 }; 1176 }; 1177 }; 1178 if (warn) {; 1179 if (file) {; 1180 Warning(""BuildCheck"", ""\n\; 1181 The StreamerInfo of class %s read from file %s\n\; 1182 has the same version (=%d) as the active class but a different checksum.\n\; 1183 You should update the version to ClassDef(%s,%d).\n\; 1184 Do not try to write objects with the current class definition,\n\; 1185 the files will not be readable.\n"", GetName(), file->GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1186 } else {; 1187 Warning(""BuildCheck"", ""\n\; 1188 The StreamerInfo of class %s \n\; 1189 has the same version (=%d) as the active class but a different checksum.\n\; 1190 You should update the version to ClassDef(%s,%d).\n\; 1191 Do not try to write objects with the current class definition,\n\; 1192 the files will not be readable.\n"", GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1193 }; 1194 CompareContent(fClass,0,kTRUE,kTRUE,file);; 1195 fClass->SetBit(TClass::kWarned);; 1196 }; 1197 } else {; 1198 if (!fClass->IsVersioned()) {; 1199 Fatal(""BuildCheck"", ""\n\; 1200 The StreamerInfo of unversioned class %s \n\; 1201 has the same version (=%d) as the active class but an old checksum.\n\; 1202 This should not happen. An assert will follow.\n"", GetName(), fClassVersion);; 1203 }; 1204 }; 1205 }; 1206 if (!fClass->IsLoaded() && this->fOnFileClassVersion>1); 1207 {; 1208 ROOT::ResetClassVersion(fClass,(const char*)-1, this->fClassVersion);; 1209 }; 1210 }; 1211 // FIXME: This code can never execute because Build() ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:45954,Security,checksum,checksum,45954,"1175 }; 1176 }; 1177 }; 1178 if (warn) {; 1179 if (file) {; 1180 Warning(""BuildCheck"", ""\n\; 1181 The StreamerInfo of class %s read from file %s\n\; 1182 has the same version (=%d) as the active class but a different checksum.\n\; 1183 You should update the version to ClassDef(%s,%d).\n\; 1184 Do not try to write objects with the current class definition,\n\; 1185 the files will not be readable.\n"", GetName(), file->GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1186 } else {; 1187 Warning(""BuildCheck"", ""\n\; 1188 The StreamerInfo of class %s \n\; 1189 has the same version (=%d) as the active class but a different checksum.\n\; 1190 You should update the version to ClassDef(%s,%d).\n\; 1191 Do not try to write objects with the current class definition,\n\; 1192 the files will not be readable.\n"", GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1193 }; 1194 CompareContent(fClass,0,kTRUE,kTRUE,file);; 1195 fClass->SetBit(TClass::kWarned);; 1196 }; 1197 } else {; 1198 if (!fClass->IsVersioned()) {; 1199 Fatal(""BuildCheck"", ""\n\; 1200 The StreamerInfo of unversioned class %s \n\; 1201 has the same version (=%d) as the active class but an old checksum.\n\; 1202 This should not happen. An assert will follow.\n"", GetName(), fClassVersion);; 1203 }; 1204 }; 1205 }; 1206 if (!fClass->IsLoaded() && this->fOnFileClassVersion>1); 1207 {; 1208 ROOT::ResetClassVersion(fClass,(const char*)-1, this->fClassVersion);; 1209 }; 1210 }; 1211 // FIXME: This code can never execute because Build() calls; 1212 // TStreamerElement::Class()->IgnoreTObjectStreamer(); 1213 // so our bits are never saved to the file.; 1214 if (TestBit(kIgnoreTObjectStreamer)) {; 1215 fClass->IgnoreTObjectStreamer();; 1216 }; 1217 if ((fClassVersion < -1) || (fClassVersion > 65000)) {; 1218 printf(""ERROR reading TStreamerInfo: %s fClassVersion=%d\n"", GetName(), fClassVersion);; 1219 SetBit(kCanDelete);; 1220 fNumber = -1;; 1221 return;; 1222 }; 1223 ; 1224 if (!fClass->TestBit(TClass::kWarned",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:100858,Security,inject,inject,100858,"; 2502 if (!infoalloc) {; 2503 Error(""BuildOld"",""Unable to create the StreamerInfo for %s."",TString::Format(""%s@@%d"",GetName(),GetOnFileClassVersion()).Data());; 2504 } else {; 2505 infoalloc->SetBit(kBuildOldUsed,false);; 2506 infoalloc->BuildCheck();; 2507 infoalloc->BuildOld();; 2508 allocClass = infoalloc->GetClass();; 2509 }; 2510 }; 2511 ; 2512 // Now that we are caching the unconverted element, we do not assign it to the real type even if we could have!; 2513 if (element->GetNewType()>0 /* intentionally not including base class for now */; 2514 && !rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2515 ; 2516 TStreamerElement *copy = (TStreamerElement*)element->Clone();; 2517 R__TObjArray_InsertBefore( fElements, copy, element );; 2518 next(); // move the cursor passed the insert object.; 2519 copy->SetBit(TStreamerElement::kRepeat);; 2520 element = copy;; 2521 ; 2522 // Warning(""BuildOld"",""%s::%s is not set from the version %d of %s (You must add a rule for it)\n"",GetName(), element->GetName(), GetClassVersion(), GetName() );; 2523 } else {; 2524 // If the element is just cached and not repeat, we need to inject an element; 2525 // to insure the writing.; 2526 TStreamerElement *writecopy = (TStreamerElement*)element->Clone();; 2527 R__TObjArray_InsertAfter( fElements, writecopy, element );; 2528 next(); // move the cursor passed the insert object.; 2529 writecopy->SetBit(TStreamerElement::kWrite);; 2530 writecopy->SetNewType( writecopy->GetType() );; 2531 writecopy->SetOffset(element->GetOffset());; 2532 }; 2533 element->SetBit(TStreamerElement::kCache);; 2534 element->SetNewType( element->GetType() );; 2535 element->SetOffset(infoalloc ? infoalloc->GetOffset(element->GetName()) : 0);; 2536 } else if (rules.HasRuleWithTarget( element->GetName(), kTRUE ) ) {; 2537 // The data member exist in the onfile StreamerInfo and there is a rule; 2538 // that has the same member 'only' has a target ... so this means we are; 2539 // asked to ignore the input data ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:116792,Security,checksum,checksum,116792," '%s' has a base class (%s) that the in-memory layout version %d does not have"",; 2926 GetClassVersion(), GetName(), localClass.Data(), GetClassVersion());; 2927 } else {; 2928 Warning(""CompareContent"",; 2929 ""One base class of the on-file layout version %d and of the in memory layout version %d for '%s' is different: '%s' vs '%s'"",; 2930 GetClassVersion(), GetClassVersion(), GetName(), localClass.Data(), otherClass.Data());; 2931 }; 2932 }; 2933 if (!complete) return kFALSE;; 2934 result = result && kFALSE;; 2935 }; 2936 if (cl) {; 2937 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2938 if (!localBase) continue;; 2939 // We already have localBaseClass == otherBaseClass; 2940 TClass *otherBaseClass = localBase->GetClassPointer();; 2941 if (!otherBaseClass) continue;; 2942 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBaseClass->GetClassVersion()) {; 2943 TString msg;; 2944 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2945 "" has the same version (=%d) as the active class but a different checksum.\n""; 2946 "" You should update the version to ClassDef(%s,%d).\n""; 2947 "" The objects on this file might not be readable because:\n""; 2948 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 2949 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2950 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetClassVersion(),; 2951 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 2952 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2953 otherBase->SetErrorMessage(msg);; 2954 ; 2955 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBaseClass->GetCheckSum()) {; 2956 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindSt",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:118314,Security,checksum,checksum,118314,"->GetClassVersion(),; 2951 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 2952 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2953 otherBase->SetErrorMessage(msg);; 2954 ; 2955 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBaseClass->GetCheckSum()) {; 2956 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 2957 if (!localBaseInfo) {; 2958 // We are likely in the situation where the base class comes after the derived; 2959 // class in the TFile's list of StreamerInfo, so it has not yet been loaded,; 2960 // let's see if it is there.; 2961 const TList *list = file->GetStreamerInfoCache();; 2962 localBaseInfo = list ? (TStreamerInfo*)list->FindObject(localBase->GetName()) : 0;; 2963 }; 2964 if (!localBaseInfo) {; 2965 TString msg;; 2966 msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the che",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:119016,Security,checksum,checksum,119016," been loaded,; 2960 // let's see if it is there.; 2961 const TList *list = file->GetStreamerInfoCache();; 2962 localBaseInfo = list ? (TStreamerInfo*)list->FindObject(localBase->GetName()) : 0;; 2963 }; 2964 if (!localBaseInfo) {; 2965 TString msg;; 2966 msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !other",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:119239,Security,checksum,checksum,119239,"msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !otherBase) continue;; 2996 ; 2997 // We already have localBaseClass == otherBaseClass; 2998 TClass *otherBaseClass = localBase->GetClassPointer();; 2999 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBase->GetBaseVersion()) {; 3000 TSt",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:119298,Security,checksum,checksum,119298,"msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974 continue;; 2975 }; 2976 if (localBaseInfo->CompareContent(otherBaseClass,0,kFALSE,kFALSE,file) ) {; 2977 // They are equivalent, no problem.; 2978 continue;; 2979 }; 2980 TString msg;; 2981 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 2982 "" has the same version (=%d) as the active class but a different checksum.\n""; 2983 "" You should update the version to ClassDef(%s,%d).\n""; 2984 "" The objects on this file might not be readable because:\n""; 2985 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !otherBase) continue;; 2996 ; 2997 // We already have localBaseClass == otherBaseClass; 2998 TClass *otherBaseClass = localBase->GetClassPointer();; 2999 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBase->GetBaseVersion()) {; 3000 TSt",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:120359,Security,checksum,checksum,120359,"cksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !otherBase) continue;; 2996 ; 2997 // We already have localBaseClass == otherBaseClass; 2998 TClass *otherBaseClass = localBase->GetClassPointer();; 2999 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBase->GetBaseVersion()) {; 3000 TString msg;; 3001 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3002 "" has the same version (=%d) as the active class but a different checksum.\n""; 3003 "" You should update the version to ClassDef(%s,%d).\n""; 3004 "" The objects on this file might not be readable because:\n""; 3005 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 3006 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3007 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseVersion(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStream",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:121679,Security,checksum,checksum,121679,"on %d recorded the version number %d for this base class (%s)."",; 3006 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3007 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseVersion(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStreamerInfo(otherBase->GetBaseCheckSum());; 3015 if (localBaseInfo == otherBaseInfo ||; 3016 localBaseInfo->CompareContent(0,otherBaseInfo,kFALSE,kFALSE,file) ) {; 3017 // They are equivalent, no problem.; 3018 continue;; 3019 }; 3020 TString msg;; 3021 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3022 "" has the same version (=%d) as the active class but a different checksum.\n""; 3023 "" You should update the version to ClassDef(%s,%d).\n""; 3024 "" The objects on this file might not be readable because:\n""; 3025 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 3026 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3027 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseCheckSum(),; 3028 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 3029 otherBase->SetErrorMessage(msg);; 3030 }; 3031 }; 3032 }; 3033 if (!result && !complete) {; 3034 return result;; 3035 }; 3036 // Next the datamembers; 3037 done = kFALSE;; 3038 next.Reset();; 3039 infonext.Reset();; 3040 ; 3041 TMemberInfo local(GetClass());; 3042 TMemberInfo other(cl ? cl : info->GetClass());; 3043 while(!done) {; 30",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:121902,Security,checksum,checksum,121902,"on(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStreamerInfo(otherBase->GetBaseCheckSum());; 3015 if (localBaseInfo == otherBaseInfo ||; 3016 localBaseInfo->CompareContent(0,otherBaseInfo,kFALSE,kFALSE,file) ) {; 3017 // They are equivalent, no problem.; 3018 continue;; 3019 }; 3020 TString msg;; 3021 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3022 "" has the same version (=%d) as the active class but a different checksum.\n""; 3023 "" You should update the version to ClassDef(%s,%d).\n""; 3024 "" The objects on this file might not be readable because:\n""; 3025 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 3026 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3027 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseCheckSum(),; 3028 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 3029 otherBase->SetErrorMessage(msg);; 3030 }; 3031 }; 3032 }; 3033 if (!result && !complete) {; 3034 return result;; 3035 }; 3036 // Next the datamembers; 3037 done = kFALSE;; 3038 next.Reset();; 3039 infonext.Reset();; 3040 ; 3041 TMemberInfo local(GetClass());; 3042 TMemberInfo other(cl ? cl : info->GetClass());; 3043 while(!done) {; 3044 local.Clear();; 3045 other.Clear();; 3046 el = (TStreamerElement*)next();; 3047 while (el && (el->IsBase() || el->IsA() == TStreamerArtificial::Class())) {; 3048 el = (TStreamerElement*)next();; 3049 }; 3050 if (el) {; 3051 local.SetName( el->GetName() ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:121961,Security,checksum,checksum,121961,"on(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStreamerInfo(otherBase->GetBaseCheckSum());; 3015 if (localBaseInfo == otherBaseInfo ||; 3016 localBaseInfo->CompareContent(0,otherBaseInfo,kFALSE,kFALSE,file) ) {; 3017 // They are equivalent, no problem.; 3018 continue;; 3019 }; 3020 TString msg;; 3021 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3022 "" has the same version (=%d) as the active class but a different checksum.\n""; 3023 "" You should update the version to ClassDef(%s,%d).\n""; 3024 "" The objects on this file might not be readable because:\n""; 3025 "" The in-memory layout version %d for class '%s' has a base class (%s) with checksum %x but the on-file layout version %d recorded the checksum value %x for this base class (%s)."",; 3026 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3027 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseCheckSum(),; 3028 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 3029 otherBase->SetErrorMessage(msg);; 3030 }; 3031 }; 3032 }; 3033 if (!result && !complete) {; 3034 return result;; 3035 }; 3036 // Next the datamembers; 3037 done = kFALSE;; 3038 next.Reset();; 3039 infonext.Reset();; 3040 ; 3041 TMemberInfo local(GetClass());; 3042 TMemberInfo other(cl ? cl : info->GetClass());; 3043 while(!done) {; 3044 local.Clear();; 3045 other.Clear();; 3046 el = (TStreamerElement*)next();; 3047 while (el && (el->IsBase() || el->IsA() == TStreamerArtificial::Class())) {; 3048 el = (TStreamerElement*)next();; 3049 }; 3050 if (el) {; 3051 local.SetName( el->GetName() ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131640,Security,checksum,checksum,131640," next();; 3238 for (; element; element = (TStreamerElement*) next()) {; 3239 if (element->IsTransient()) continue;; 3240 TClass* cl = element->GetClassPointer();; 3241 if (cl); 3242 recurseIntoContent(cl);; 3243 }; 3244 ; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// Assuming that obj points to (the part of) an object that is of the; 3249/// type described by this streamerInfo, return the actual type of the; 3250/// object (i.e. the type described by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131682,Security,checksum,checksum,131682," next();; 3238 for (; element; element = (TStreamerElement*) next()) {; 3239 if (element->IsTransient()) continue;; 3240 TClass* cl = element->GetClassPointer();; 3241 if (cl); 3242 recurseIntoContent(cl);; 3243 }; 3244 ; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// Assuming that obj points to (the part of) an object that is of the; 3249/// type described by this streamerInfo, return the actual type of the; 3250/// object (i.e. the type described by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131728,Security,checksum,checksum,131728," next();; 3238 for (; element; element = (TStreamerElement*) next()) {; 3239 if (element->IsTransient()) continue;; 3240 TClass* cl = element->GetClassPointer();; 3241 if (cl); 3242 recurseIntoContent(cl);; 3243 }; 3244 ; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// Assuming that obj points to (the part of) an object that is of the; 3249/// type described by this streamerInfo, return the actual type of the; 3250/// object (i.e. the type described by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131821,Security,checksum,checksum,131821,"cribed by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131915,Security,checksum,checksum,131915,"cribed by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:132133,Security,checksum,checksum,132133,"cribed by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:132545,Security,checksum,checksum,132545,"//////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility and should both return the same values.; 3294/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 3295/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 3296/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 3297 ; 3298UInt_t TStreamerInfo::GetCheckSum(TClass::ECheckSum code) const; 3299{; 3300 // kCurrentCheckSum (0) should be kept for backward compatibility, to be; 3301 // able to use the inequality checks, we need to set the code to the largest; 3302 // value.; 3303 if (code == TClass::kCurrentCheckSum) code = TClass::kLatestCh",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:132586,Security,checksum,checksum,132586,"//////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility and should both return the same values.; 3294/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 3295/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 3296/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 3297 ; 3298UInt_t TStreamerInfo::GetCheckSum(TClass::ECheckSum code) const; 3299{; 3300 // kCurrentCheckSum (0) should be kept for backward compatibility, to be; 3301 // able to use the inequality checks, we need to set the code to the largest; 3302 // value.; 3303 if (code == TClass::kCurrentCheckSum) code = TClass::kLatestCh",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:172755,Security,access,access,172755,"ass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; 4293/// StreamerInfo for class: TAttLine, version=1; 4294/// short fLineColor offset= 4 type= 2 line color; 4295/// short fLineStyle offset= 6 type= 2 line style; 4296/// short fLineWidth offset= 8 type= 2 line width; 4297/// i= 0, fLineColor type= 22, offset= 4, len=3, method=0; 4298/// ~~~; 4299/// For I/O implementations (eg. XML) , one has to know the original name; 4300/// of the data member. This function can be used to return a pointer; 4301/// to the original TStreamerElement object corresponding to the j-th; 4302/// element of a compressed array in fElems.; 4303/// Parameters description:; 4304/// - i: the serial number in array fElem; 4305/// - j: the element number in the array of consecutive types; 4306/// In the above example the class TAttLine has 3 consecutive data members; 4307/// of the same type ""short"". Compile makes one single array of 3 elements.; 4308/// To access the TStreamerElement for the second element; 4309/// of this array, one can call:; 4310/// ~~~{.cpp}; 4311/// auto el = GetStreamerElementReal(0,1);; 4312/// auto membername = el->GetName();; 4313/// ~~~; 4314/// This function is typically called from TBuffer, TXmlBuffer.; 4315 ; 4316TStreamerElement* TStreamerInfo::GetStreamerElementReal(Int_t i, Int_t j) const; 4317{; 4318 ::Obsolete(""TStreamerInfo::GetStreamerElementReal"", ""v5-34-20"", ""v6-00-02"");; 4319 ; 4320 if (i < 0 || i >= fNdata) return 0;; 4321 if (j < 0) return 0;; 4322 if (!fElements) return 0;; 4323 TStreamerElement *se = (TStreamerElement*)fCompOpt[i]->fElem;; 4324 if (!se) return 0;; 4325 Int_t nelems = fElements->GetEntriesFast();; 4326 for (Int_t ise=0;ise < nelems;ise++) {; 4327 if (se != (TStreamerElement*)fElements->UncheckedAt(ise)) continue;; 4328 if (ise+j >= nelems) return 0;; 4329 return (TStreamerElement*)fElements->UncheckedAt(ise+j);; 4330 }; 4331 return 0;; 4332}; 4333 ; 4334//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:189183,Security,checksum,checksum,189183,"ray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:189331,Security,checksum,checksum,189331,"ray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:189515,Security,checksum,checksum,189515,"ray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:189629,Security,checksum,checksum,189629,"ray_InsertAt(fElements, toAdd, loc);; 4675 }; 4676 } // None of the target of the rule are on file.; 4677}; 4678 ; 4679////////////////////////////////////////////////////////////////////////////////; 4680/// List the TStreamerElement list and also the precomputed tables; 4681/// if option contains the string ""incOrig"", also prints the original; 4682/// (non-optimized elements in the list of compiled elements.; 4683 ; 4684void TStreamerInfo::ls(Option_t *option) const; 4685{; 4686 if (fClass && (fName != fClass->GetName())) {; 4687 if (fClass->IsVersioned()) {; 4688 Printf(""\nStreamerInfo for conversion to %s from: %s, version=%d, checksum=0x%x"",fClass->GetName(),GetName(),fClassVersion,GetCheckSum());; 4689 } else {; 4690 Printf(""\nStreamerInfo for conversion to %s from: %s, checksum=0x%x"",fClass->GetName(),GetName(),GetCheckSum());; 4691 }; 4692 } else {; 4693 if (!fClass || fClass->IsVersioned()) {; 4694 Printf(""\nStreamerInfo for class: %s, version=%d, checksum=0x%x"",GetName(),fClassVersion,GetCheckSum());; 4695 } else {; 4696 Printf(""\nStreamerInfo for class: %s, checksum=0x%x"",GetName(),GetCheckSum());; 4697 }; 4698 }; 4699 ; 4700 if (fElements) {; 4701 TIter next(fElements);; 4702 TObject *obj;; 4703 while ((obj = next())); 4704 obj->ls(option);; 4705 }; 4706 if (strstr(option,""full"") != 0) {; 4707 for (Int_t i=0; i < fNfulldata; ++i) {; 4708 TStreamerElement *element = (TStreamerElement*)fCompFull[i]->fElem;; 4709 TString sequenceType;; 4710 element->GetSequenceType(sequenceType);; 4711 // by definition of the loop (i+1) <= fNdata; 4712 if (sequenceType.Length()) {; 4713 sequenceType.Prepend("" ["");; 4714 sequenceType += ""]"";; 4715 }; 4716 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4717 i,element->GetName(),fCompFull[i]->fType,fCompFull[i]->fOffset,fCompFull[i]->fLength,fCompFull[i]->fMethod,; 4718 sequenceType.Data());; 4719 }; 4720 ; 4721 } else {; 4722 Bool_t wantOrig = strstr(option,""incOrig"") != 0;; 4723 Bool_t optimized = kFALSE;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:248720,Security,hash,hash,248720,"const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMembervirtual void ClassMember(const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0; TBuffer::GetVersionOwnervirtual Int_t GetVersionOwner() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassRef::Resetvoid Reset()Definition TClassRef.h:67; TClassStreamerDefinition TClassStreamer.h:26; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::GetStreamerInfoAbstractEmulat",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:251764,Security,checksum,checksum,251764,"lShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:251798,Security,checksum,checksum,251798,"lShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:251840,Security,checksum,checksum,251840,"lShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255180,Security,checksum,checksum,255180,"s.h:110; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmu",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255263,Security,checksum,checksum,255263,"s.h:110; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmu",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:255403,Security,checksum,checksum,255403,"oxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::Classstatic TClass * Class(); TCollectionProxyFactory::GenEmulatedProxystatic TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)Generate emulated collection proxy for a given class.Definition TCollectionProxyFactory.cxx:63; TCollectionProxyFactory::GenEmul",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:263144,Security,access,accessing,263144,"enerateIncludeForTemplatestatic UInt_t GenerateIncludeForTemplate(FILE *fp, const char *clname, char *inclist, Bool_t forward, const TList *extrainfos)Add to the header file, the #include needed for the argument of this template.Definition TMakeProject.cxx:455; TMakeProject::GeneratePostDeclarationstatic void GeneratePostDeclaration(FILE *fp, const TVirtualStreamerInfo *info, char *inclist)Add to the header file anything that need to appear after the class declaration (this includes some #...Definition TMakeProject.cxx:608; TMakeProject::GenerateClassPrefixstatic UInt_t GenerateClassPrefix(FILE *fp, const char *clname, Bool_t top, TString &protoname, UInt_t *numberOfClasses, Int_t implementEmptyClass=kFALSE, Bool_t needGenericTemplate=kFALSE)Write the start of the class (forward) declaration.Definition TMakeProject.cxx:163; TMakeProject::UpdateAssociativeToVectorstatic TString UpdateAssociativeToVector(const char *name)Definition TMakeProject.cxx:659; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::GetParentconst char * GetParent() constDefinition TMemberInspector.cxx:75; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberInspector::InspectMembervoid InspectMember(const T &obj, const char *name, Bool_t isTransient)Definition TMemberInspector.h:63; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overr",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:283498,Security,checksum,checksum,283498,"ionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointing to (belongs to)Definition TStreamerInfo.cxx:5254; TStreamerInfo::fCheckSumUInt_t fCheckSumChecksum of original class.Definition TStreamerInfo.h:88; TStreamerInfo::Streamervoid Streamer(TBuffer &) overrideStream an object of class TStreamerInfo.Definition TStreamerInfo.cxx:5266; TStreamerInfo::GetSizeElementsInt_t GetSize",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:283532,Security,checksum,checksum,283532,"ionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointing to (belongs to)Definition TStreamerInfo.cxx:5254; TStreamerInfo::fCheckSumUInt_t fCheckSumChecksum of original class.Definition TStreamerInfo.h:88; TStreamerInfo::Streamervoid Streamer(TBuffer &) overrideStream an object of class TStreamerInfo.Definition TStreamerInfo.cxx:5266; TStreamerInfo::GetSizeElementsInt_t GetSize",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:283574,Security,checksum,checksum,283574,"ionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointing to (belongs to)Definition TStreamerInfo.cxx:5254; TStreamerInfo::fCheckSumUInt_t fCheckSumChecksum of original class.Definition TStreamerInfo.h:88; TStreamerInfo::Streamervoid Streamer(TBuffer &) overrideStream an object of class TStreamerInfo.Definition TStreamerInfo.cxx:5266; TStreamerInfo::GetSizeElementsInt_t GetSize",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35216,Testability,test,test,35216,"dy existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_C",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35263,Testability,test,test,35263,"dy existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_C",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35467,Testability,test,test,35467,"UE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the da",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35870,Testability,test,test,35870,"es not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37517,Testability,test,test,37517,"n one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37565,Testability,test,test,37565,"n one of the data member; 984 // was declared using a typedef _and_ the current class definition; 985 // uses a different typedef, we are unable to recalculate the; 986 // checksum as it was, because the information is missing from; 987 // the StreamerInfo, and for the same reason CompareContent can; 988 // not know whether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:37772,Testability,test,test,37772,"hether this is okay or not ...; 989 //; 990 // Since this is such an unlikely scenario, let's complain; 991 // about it anyway (The class layout *may* have changed, we; 992 // don't know).; 993 ; 994 // if (this has only base classes) {; 995 // match = kTRUE;; 996 // }; 997 }; 998#endif; 999 } else {; 1000 // The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.; 1001 ; 1002 match = kFALSE;; 1003 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 1004 ; 1005 // In the case where the read-in TStreamerInfo does not; 1006 // match in the 'current' in memory TStreamerInfo for; 1007 // a non foreign class (we can not get here if this is; 1008 // a foreign class so we do not need to test it),; 1009 // we need to add this one more test since the CINT behaviour; 1010 // with enums changed over time, so verify the checksum ignoring; 1011 // members of type enum. We also used to not count the //[xyz] comment; 1012 // in the checksum, so test for that too.; 1013 if (fCheckSum == info->GetCheckSum(TClass::kCurrentCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 1027 match = kTRUE;; 1028 }; 1029 }; 1030 }; 1031 if (info->IsBuilt()) {; 1032 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:38302,Testability,test,test,38302,"ntCheckSum); 1014 || info->MatchLegacyCheckSum(fCheckSum); 1015 || GetCheckSum(TClass::kCurrentCheckSum) == info->fCheckSum; 1016 || MatchLegacyCheckSum(info->GetCheckSum()); 1017 || GetCheckSum(TClass::kCurrentCheckSum) == info->GetCheckSum(TClass::kCurrentCheckSum)); 1018 {; 1019 match = kTRUE;; 1020 }; 1021 if (fOldVersion <= 2) {; 1022 // Names of STL base classes was modified in vers==3. Allocators removed; 1023 // (We could be more specific (see test for the same case below); 1024 match = kTRUE;; 1025 }; 1026 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 1027 match = kTRUE;; 1028 }; 1029 }; 1030 }; 1031 if (info->IsBuilt()) {; 1032 SetBit(kCanDelete);; 1033 fNumber = info->GetNumber();; 1034 Int_t nel = fElements->GetEntriesFast();; 1035 TObjArray* elems = info->GetElements();; 1036 TStreamerElement* e1 = 0;; 1037 TStreamerElement* e2 = 0;; 1038 for (Int_t i = 0; i < nel; ++i) {; 1039 e1 = (TStreamerElement*) fElements->UncheckedAt(i);; 1040 e2 = (TStreamerElement*) elems->At(i);; 1041 if (!e1 || !e2) {; 1042 continue;; 1043 }; 1044 if (strlen(e1->GetTitle()) != strlen(e2->GetTitle())) {; 1045 e2->SetTitle(e1->GetTitle());; 1046 }; 1047 }; 1048 ; 1049 done = kTRUE;; 1050 } else {; 1051 fClass->RemoveStreamerInfo(fClassVersion);; 1052 info = 0;; 1053 }; 1054 TString origin;; 1055 if (!match && !fClass->TestBit(TClass::kWarned)) {; 1056 if (oldIsNonVersioned) {; 1057 if (file) {; 1058 Warning(""BuildCheck"", ""\n\; 1059 The class %s transitioned from not having a specified class version\n\; 1060 to having a specified class version (the current class version is %d).\n\; 1061 However too many different non-versioned layouts of the class have been\n\; 1062 loaded so far. This prevent the proper reading of objects written with\n\; 1063 the class layout version %d, in particular from the file:\n\; 1064 %s.\n\; 1065 To work around this issue, load fewer 'old' files in the same ROOT session."",; 1066 GetName(),fClass->GetClassVersion(),fClassVersion,file->GetN",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:46000,Testability,assert,assert,46000," 1183 You should update the version to ClassDef(%s,%d).\n\; 1184 Do not try to write objects with the current class definition,\n\; 1185 the files will not be readable.\n"", GetName(), file->GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1186 } else {; 1187 Warning(""BuildCheck"", ""\n\; 1188 The StreamerInfo of class %s \n\; 1189 has the same version (=%d) as the active class but a different checksum.\n\; 1190 You should update the version to ClassDef(%s,%d).\n\; 1191 Do not try to write objects with the current class definition,\n\; 1192 the files will not be readable.\n"", GetName(), fClassVersion, GetName(), fClassVersion + 1);; 1193 }; 1194 CompareContent(fClass,0,kTRUE,kTRUE,file);; 1195 fClass->SetBit(TClass::kWarned);; 1196 }; 1197 } else {; 1198 if (!fClass->IsVersioned()) {; 1199 Fatal(""BuildCheck"", ""\n\; 1200 The StreamerInfo of unversioned class %s \n\; 1201 has the same version (=%d) as the active class but an old checksum.\n\; 1202 This should not happen. An assert will follow.\n"", GetName(), fClassVersion);; 1203 }; 1204 }; 1205 }; 1206 if (!fClass->IsLoaded() && this->fOnFileClassVersion>1); 1207 {; 1208 ROOT::ResetClassVersion(fClass,(const char*)-1, this->fClassVersion);; 1209 }; 1210 }; 1211 // FIXME: This code can never execute because Build() calls; 1212 // TStreamerElement::Class()->IgnoreTObjectStreamer(); 1213 // so our bits are never saved to the file.; 1214 if (TestBit(kIgnoreTObjectStreamer)) {; 1215 fClass->IgnoreTObjectStreamer();; 1216 }; 1217 if ((fClassVersion < -1) || (fClassVersion > 65000)) {; 1218 printf(""ERROR reading TStreamerInfo: %s fClassVersion=%d\n"", GetName(), fClassVersion);; 1219 SetBit(kCanDelete);; 1220 fNumber = -1;; 1221 return;; 1222 }; 1223 ; 1224 if (!fClass->TestBit(TClass::kWarned); 1225 && fClass->GetState() >= TClass::kInterpreted; 1226 && GetCheckSum() != fClass->GetCheckSum(); 1227 && fClassVersion == fClass->GetClassVersion()) {; 1228 // We got here, thus we are a perfect alias for the current streamer",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:59918,Testability,assert,assert,59918,"_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...; 1578 // It actually happens in the case where one of the member is an; 1579 // enum that is part of dictionary payload that is not yet; 1580 // auto-loaded.; 1581 return nullptr;; 1582 }; 1583 TVirtualStreamerInfo *info = current->GetValueClass()->GetStreamerInfo();; 1584 if (info->GetElements()->GetEntriesFast() != 2) {; 1585 return oldClass;; 1586 }; 1587 TStreamerElement *f = (TStreamerElement*) info->GetElements()->At(0);; 1588 TStreamerElement *s = (TStreamerElement*) info->GetElements()->At(1);; 1589 ; 1590 // Since we do not create TClass for pair of unknown types, old->GetValueClass can; 1591 // be nullptr even-though the ty",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:61492,Testability,assert,assert,61492,"erElement*) info->GetElements()->At(0);; 1588 TStreamerElement *s = (TStreamerElement*) info->GetElements()->At(1);; 1589 ; 1590 // Since we do not create TClass for pair of unknown types, old->GetValueClass can; 1591 // be nullptr even-though the type used be known. An example of such change; 1592 // is `RooExpensiveObjectCache::ExpensiveObject` which used to be recorded; 1593 // as `ExpensiveObject` in the name of the map ... making it unknown; 1594 // (and this is precisely the type of change we are trying to handle here/below!); 1595 info = old->GetValueClass() ? old->GetValueClass()->GetStreamerInfo() : nullptr;; 1596 assert(!info || info->GetElements()->GetEntriesFast() == 2);; 1597 TStreamerElement *of = info ? (TStreamerElement*) info->GetElements()->At(0) : nullptr;; 1598 TStreamerElement *os = info ? (TStreamerElement*) info->GetElements()->At(1) : nullptr;; 1599 ; 1600 TClass *firstNewCl = f ? f->GetClass() : 0;; 1601 TClass *secondNewCl = s ? s->GetClass() : 0;; 1602 ; 1603 TClass *firstOldCl = of ? of->GetClass() : 0;; 1604 TClass *secondOldCl = os ? os->GetClass() : 0;; 1605 ; 1606 if ((firstNewCl && !firstOldCl) || (secondNewCl && !secondOldCl)); 1607 {; 1608 std::vector<std::string> inside;; 1609 int nestedLoc;; 1610 TClassEdit::GetSplit( oldClass->GetName(), inside, nestedLoc, TClassEdit::kLong64 );; 1611 ; 1612 TClass *firstAltCl = firstOldCl;; 1613 TClass *secondAltCl = secondOldCl;; 1614 std::string firstNewName;; 1615 std::string secondNewName;; 1616 if (!info && !firstOldCl) {; 1617 firstOldCl = TClass::GetClass(inside[1].c_str(), kTRUE, kTRUE);; 1618 }; 1619 if (!info && !secondOldCl) {; 1620 secondOldCl = TClass::GetClass(inside[2].c_str(), kTRUE, kTRUE);; 1621 }; 1622 if (firstNewCl && !firstOldCl) {; 1623 firstAltCl = FindAlternate(context, inside[1], firstNewName);; 1624 } else if (firstAltCl) {; 1625 firstNewName = firstAltCl->GetName();; 1626 } else {; 1627 firstNewName = inside[1];; 1628 }; 1629 if (secondNewCl && !secondOldCl) {; 1630 s",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:128140,Testability,test,test,128140,"//////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocked.; 3185 (cindex->fArray[fNumber] && !force) || // Streamer info is already marked, and not forcing, or; 3186 (cindex->fArray[fNumber] > 1) // == 2 means ignore forcing to prevent infinite recursion.; 3187 ) {; 3188 return;; 3189 }; 3190 ; 3191 auto recurseIntoContent = [file, force](TClass *contentClass); 3192 {; 3193 TVirtualStreamerInfo* si = 0;; 3194 if (contentClass->Property() & kIsAbstract) {; 3195 // If the class of the element is abstract, register the; 3196 // TStreamerInfo only if it has already been built.; 3197 // Otherwise call cl->GetStreamerInfo() would generate an; 3198 // incorrect StreamerInfo.; 3199 si = contentClass->GetCurrentStreamerInfo();; 3200 } else {; 3201 si = contentClass->GetStreamerInfo();; 3202 }; 3203 if (si) {; 3204 si->ForceWriteInfo(file, force);; 3205 }; 3206 };; 3207 ; 3208 // We do ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:128151,Testability,test,testing,128151,"//////////////////////////////////////////////////////; 3161/// Recursively mark streamer infos for writing to a file.; 3162///; 3163/// Will force this TStreamerInfo to the file and also; 3164/// all the dependencies.; 3165/// If argument force > 0 the loop on class dependencies is forced.; 3166/// This function is called when streaming a class that contains; 3167/// a null pointer. In this case, the TStreamerInfo for the class; 3168/// with the null pointer must be written to the file and also all; 3169/// the TStreamerInfo of all the classes referenced by the class.; 3170/// We must be given a file to write to.; 3171 ; 3172void TStreamerInfo::ForceWriteInfo(TFile* file, Bool_t force); 3173{; 3174 if (!file || fNumber < 0) {; 3175 return;; 3176 }; 3177 // Get the given file's list of streamer infos marked for writing.; 3178 TArrayC* cindex = file->GetClassIndex();; 3179 //the test below testing fArray[fNumber]>1 is to avoid a recursivity; 3180 //problem in some cases like:; 3181 // class aProblemChild: public TNamed {; 3182 // aProblemChild *canBeNull;; 3183 // };; 3184 if ( // -- Done if already marked, and we are not forcing, or forcing is blocked.; 3185 (cindex->fArray[fNumber] && !force) || // Streamer info is already marked, and not forcing, or; 3186 (cindex->fArray[fNumber] > 1) // == 2 means ignore forcing to prevent infinite recursion.; 3187 ) {; 3188 return;; 3189 }; 3190 ; 3191 auto recurseIntoContent = [file, force](TClass *contentClass); 3192 {; 3193 TVirtualStreamerInfo* si = 0;; 3194 if (contentClass->Property() & kIsAbstract) {; 3195 // If the class of the element is abstract, register the; 3196 // TStreamerInfo only if it has already been built.; 3197 // Otherwise call cl->GetStreamerInfo() would generate an; 3198 // incorrect StreamerInfo.; 3199 si = contentClass->GetCurrentStreamerInfo();; 3200 } else {; 3201 si = contentClass->GetStreamerInfo();; 3202 }; 3203 if (si) {; 3204 si->ForceWriteInfo(file, force);; 3205 }; 3206 };; 3207 ; 3208 // We do ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:215379,Testability,assert,assert,215379,,MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:58440,Usability,clear,clear,58440,"lection.; 1494 // i.e. they contains the exact same type.; 1495 ; 1496 TVirtualCollectionProxy *oldProxy = oldClass->GetCollectionProxy();; 1497 TVirtualCollectionProxy *newProxy = newClass->GetCollectionProxy();; 1498 ; 1499 if (oldProxy->GetValueClass() == 0 && newProxy->GetValueClass() == 0; 1500 && (oldProxy->GetType() == kULong_t || oldProxy->GetType() == kULong64_t); 1501 && (newProxy->GetType() == kULong_t || newProxy->GetType() == kULong64_t )) {; 1502 // We have compatibles collections (they have the same content)!; 1503 return (oldClass->GetCollectionType() == newClass->GetCollectionType());; 1504 }; 1505 return kFALSE;; 1506 }; 1507 ; 1508 TClass *FindAlternate(TClass *context, const std::string &i_name, std::string& newName); 1509 {; 1510 // Return a class whose has the name as oldClass and can be found; 1511 // within the scope of the class 'context'.; 1512 ; 1513 // First strip any 'const ' prefix or trailing '*'.; 1514 std::string name(i_name);; 1515 newName.clear();; 1516 if (name.compare(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alter",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:59457,Usability,clear,clear,59457,"re(0,6,""const "")==0) {; 1517 newName = ""const "";; 1518 name.erase(0,6);; 1519 }; 1520 std::string suffix;; 1521 UInt_t nstars = 0;; 1522 while(name[name.length()-nstars-1]=='*') {; 1523 ++nstars;; 1524 suffix.append(""*"");; 1525 }; 1526 if (nstars) {; 1527 name.erase(name.length()-nstars,nstars);; 1528 }; 1529 ; 1530 std::string alternate(context->GetName());; 1531 alternate.append(""::"");; 1532 alternate.append(name);; 1533 ; 1534 TClass *altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1535 if (altcl) {; 1536 newName.append(altcl->GetName());; 1537 newName.append(suffix);; 1538 return altcl;; 1539 }; 1540 ; 1541 size_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...;",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:59781,Usability,clear,clear,59781,"_t ctxt_cursor = strlen(context->GetName());; 1542 for (size_t level = 0; ctxt_cursor != 0; --ctxt_cursor) {; 1543 switch (context->GetName()[ctxt_cursor]) {; 1544 case '<': --level; break;; 1545 case '>': ++level; break;; 1546 case ':': if (level == 0) {; 1547 // we encountered a scope not within a template; 1548 // parameter.; 1549 alternate.clear();; 1550 alternate.append(context->GetName(),ctxt_cursor+1);; 1551 alternate.append(name);; 1552 altcl = TClass::GetClass(alternate.c_str(),/*load=*/ false,true);; 1553 if (altcl) {; 1554 newName.append(altcl->GetName());; 1555 newName.append(suffix);; 1556 return altcl;; 1557 }; 1558 }; 1559 }; 1560 }; 1561 newName.clear();; 1562 return 0;; 1563 }; 1564 ; 1565 TClass *FixCollectionV5(TClass *context, TClass *oldClass, TClass *newClass); 1566 {; 1567 assert(oldClass->GetCollectionProxy() && newClass->GetCollectionProxy());; 1568 ; 1569 TVirtualCollectionProxy *old = oldClass->GetCollectionProxy();; 1570 TVirtualCollectionProxy *current = newClass->GetCollectionProxy();; 1571 Int_t stlkind = old->GetCollectionType();; 1572 ; 1573 if (stlkind == ROOT::kSTLmap || stlkind == ROOT::kSTLmultimap) {; 1574 ; 1575 if (current->GetValueClass() == nullptr) {; 1576 // This should really never happen (the content of map should always; 1577 // be a pair and thus have a TClass ... so let's just give up ...; 1578 // It actually happens in the case where one of the member is an; 1579 // enum that is part of dictionary payload that is not yet; 1580 // auto-loaded.; 1581 return nullptr;; 1582 }; 1583 TVirtualStreamerInfo *info = current->GetValueClass()->GetStreamerInfo();; 1584 if (info->GetElements()->GetEntriesFast() != 2) {; 1585 return oldClass;; 1586 }; 1587 TStreamerElement *f = (TStreamerElement*) info->GetElements()->At(0);; 1588 TStreamerElement *s = (TStreamerElement*) info->GetElements()->At(1);; 1589 ; 1590 // Since we do not create TClass for pair of unknown types, old->GetValueClass can; 1591 // be nullptr even-though the ty",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105421,Usability,clear,clear,105421,"Name());; 2606 fElements->Add( el );; 2607 }; 2608 ; 2609 Compile();; 2610}; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105483,Usability,clear,clear,105483,"; 2610}; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEd",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105557,Usability,clear,clear,105557,"//////////////////////////////////////; 2613/// If opt contains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit:",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105607,Usability,clear,clear,105607,"ntains 'built', reset this StreamerInfo as if Build or BuildOld; 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105671,Usability,clear,clear,105671," 2614/// was never called on it (useful to force their re-running).; 2615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["")",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105735,Usability,clear,clear,105735,"615 ; 2616void TStreamerInfo::Clear(Option_t *option); 2617{; 2618 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 ",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105811,Usability,clear,clear,105811,"18 TString opt = option;; 2619 opt.ToLower();; 2620 ; 2621 if (opt.Contains(""build"")) {; 2622 R__LOCKGUARD(gInterpreterMutex);; 2623 ; 2624 delete [] fComp; fComp = 0;; 2625 delete [] fCompFull; fCompFull= 0;; 2626 delete [] fCompOpt; fCompOpt = 0;; 2627 ; 2628 fNdata = 0;; 2629 fNfulldata = 0;; 2630 fNslots= 0;; 2631 fSize = 0;; 2632 ; 2633 ResetIsCompiled();; 2634 ResetBit(kBuildOldUsed);; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:105863,Usability,clear,clear,105863,");; 2635 ; 2636 TIter next(fElements);; 2637 while (auto element = (TStreamerElement*)next()) {; 2638 element->SetOffset(0);; 2639 }; 2640 ; 2641 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 2642 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 2643 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 2644 if (fReadText) fReadText->fActions.clear();; 2645 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 2646 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 2647 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 2648 if (fWriteText) fWriteText->fActions.clear();; 2649 }; 2650}; 2651 ; 2652namespace {; 2653 // TMemberInfo; 2654 // Local helper class to be able to compare data member represented by; 2655 // 2 distinct TStreamerInfos; 2656 class TMemberInfo {; 2657 public:; 2658 TClass *fParent;; 2659 TString fName;; 2660 TString fClassName;; 2661 TString fComment;; 2662 Int_t fDataType;; 2663 ; 2664 TMemberInfo(TClass *parent) : fParent(parent) {};; 2665 ; 2666 void SetDataType(Int_t datatype) {; 2667 fDataType = datatype;; 2668 }; 2669 ; 2670 void SetName(const char *name) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left);; 2683 }; 2684 }; 2685 }; 2686 void Clear() {; 2687 fName.Clear();; 2688 fClassName.Clear();; 2689 fComment.Clear();; 2690 }; 2691 /* Hide this not yet used implementation to suppress warnings message; 2692 from icc 11; 2693 Bool_t operator==(const TMemberInfo &other) {; 2694 return fName==other.fName; 2695 && fClassName == other.fClassName; 2696 && fComment == other.fComment;; 2697 }; 2",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:107395,Usability,simpl,simple,107395,"me) {; 2671 fName = name;; 2672 }; 2673 void SetClassName(const char *name) {; 2674 fClassName = TClassEdit::ResolveTypedef(TClassEdit::ShortType( name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd ).c_str(),kTRUE);; 2675 }; 2676 void SetComment(const char *title) {; 2677 const char *left = strstr(title,""["");; 2678 if (left) {; 2679 const char *right = strstr(left,""]"");; 2680 if (right) {; 2681 ++left;; 2682 fComment.Append(left,right-left);; 2683 }; 2684 }; 2685 }; 2686 void Clear() {; 2687 fName.Clear();; 2688 fClassName.Clear();; 2689 fComment.Clear();; 2690 }; 2691 /* Hide this not yet used implementation to suppress warnings message; 2692 from icc 11; 2693 Bool_t operator==(const TMemberInfo &other) {; 2694 return fName==other.fName; 2695 && fClassName == other.fClassName; 2696 && fComment == other.fComment;; 2697 }; 2698 */; 2699 Bool_t operator!=(const TMemberInfo &other) {; 2700 if (fName != other.fName) return kTRUE;; 2701 if (fDataType < TStreamerInfo::kObject) {; 2702 // For simple type, let compare the data type; 2703 if (fDataType != other.fDataType) {; 2704 if ( (fDataType == 4 && other.fDataType == 16); 2705 || (fDataType == 16 && other.fDataType == 4) ) {; 2706 // long and 'long long' have the same file format; 2707 } else if ( (fDataType == 14 && other.fDataType == 17); 2708 || (fDataType == 17 && other.fDataType == 14) ) {; 2709 // unsigned long and 'unsigned long long' have the same file format; 2710 } else if ( (fDataType == 3 && other.fDataType == 6); 2711 ||(fDataType == 6 && other.fDataType == 3) ){; 2712 // Int_t and kCounter. As the switch from Int_t (3) to; 2713 // kCounter (6) might be triggered by a derived class using; 2714 // the field as an array size, the class itself has no; 2715 // control on what the field type really use.; 2716 } else {; 2717 return kTRUE;; 2718 }; 2719 }; 2720 } else if (fClassName != other.fClassName) {; 2721 if ( (fClassName == ""long"" && (other.fClassName == ""long long"" || other.fClassName == ""Long64_t""))",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:141953,Usability,clear,clear,141953,"hs.%s[i];\n"",element->GetArrayLength(),ename,ename);; 3489 } else if (element->GetArrayDim() >= 2) {; 3490 fprintf(file,"" for (Int_t i=0;i<%d;i++) reinterpret_cast<%s *>(%s"", element->GetArrayLength(), element->GetTypeName(), ename);; 3491 fprintf(file,"")[i] = reinterpret_cast<%s const *>(rhs.%s)[i];\n"", element->GetTypeName(), ename);; 3492 }; 3493 } else if (element->GetType() == TVirtualStreamerInfo::kSTLp) {; 3494 if (!defMod) { fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE; };; 3495 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3496 } else if (element->GetType() == TVirtualStreamerInfo::kSTL) {; 3497 if (!defMod) {; 3498 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3499 }; 3500 TClass *cle = element->GetClassPointer();; 3501 TVirtualCollectionProxy *proxy = cle ? element->GetClassPointer()->GetCollectionProxy() : 0;; 3502 std::string method_name = ""clear"";; 3503 if (!element->TestBit(TStreamerElement::kDoNotDelete) && proxy && (((TStreamerSTL*)element)->GetSTLtype() == ROOT::kSTLbitset)) {; 3504 method_name = ""reset"";; 3505 }; 3506 if (element->IsBase()) {; 3507 fprintf(file,"" modrhs.%s();\n"", method_name.c_str());; 3508 } else {; 3509 fprintf(file,"" modrhs.%s.%s();\n"",ename, method_name.c_str());; 3510 }; 3511 }; 3512 }; 3513 }; 3514}; 3515 ; 3516////////////////////////////////////////////////////////////////////////////////; 3517/// Write down the body of the 'move' constructor.; 3518 ; 3519static void R__WriteMoveConstructorBody(FILE *file, const TString &protoname, TIter &next); 3520{; 3521 TStreamerElement *element = 0;; 3522 next.Reset();; 3523 Bool_t atstart = kTRUE;; 3524 while ((element = (TStreamerElement*)next())) {; 3525 if (element->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 35",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201950,Usability,clear,clear,201950,"j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r = eaddr + (size * (len - 1));; 5082 for (Int_t j = len - 1; j >= 0; --j, r -= size) {; 5083 cle->Destructor(r, kTRUE);; 5084 }; 5085 }; 5086 } // iter over elements; 5087 ; 5088 if (!dtorOnly) {; 5089 delete[] p;; 5090 }; 5091}; 5092 ; 5093///",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:201966,Usability,clear,clear,201966,"j]) {; 5032 cle->Destructor(r[j]);; 5033 r[j] = 0;; 5034 }; 5035 }; 5036 }; 5037 ; 5038 if (etype == kBase) {; 5039 if (cle->Property() & kIsAbstract) {; 5040 TVirtualStreamerInfo *einfo = cle->GetStreamerInfoAbstractEmulated();; 5041 if (einfo) einfo->Destructor(eaddr, kTRUE);; 5042 } else {; 5043 cle->Destructor(eaddr, kTRUE);; 5044 }; 5045 }; 5046 ; 5047 if (etype == kObject || etype == kAny ||; 5048 etype == kTObject || etype == kTString || etype == kTNamed) {; 5049 // A data member is destroyed, but not deleted.; 5050 cle->Destructor(eaddr, kTRUE);; 5051 }; 5052 ; 5053 if (etype == kSTL) {; 5054 // A data member is destroyed, but not deleted.; 5055 TVirtualCollectionProxy *pr = cle->GetCollectionProxy();; 5056 if (!pr) {; 5057 if (strcmp(ele->GetName(),""This"")==0) {; 5058 // missing information, avoid infinite loop; 5059 // by doing nothing ....; 5060 } else {; 5061 cle->Destructor(eaddr, kTRUE);; 5062 }; 5063 } else {; 5064 if (ele->TestBit(TStreamerElement::kDoNotDelete)) {; 5065 TVirtualCollectionProxy::TPushPop env(cle->GetCollectionProxy(), eaddr); // used for both this 'clear' and the 'clear' inside destructor.; 5066 cle->GetCollectionProxy()->Clear(); // empty the collection without deleting the pointer; 5067 pr->Destructor(eaddr, kTRUE);; 5068 } else {; 5069 pr->Destructor(eaddr, kTRUE);; 5070 }; 5071 }; 5072 }; 5073 ; 5074 if (etype == kObject + kOffsetL || etype == kAny + kOffsetL ||; 5075 etype == kTObject + kOffsetL || etype == kTString + kOffsetL ||; 5076 etype == kTNamed + kOffsetL || etype == kSTL + kOffsetL) {; 5077 // For a data member which is an array of objects, we; 5078 // destroy the objects, but do not delete them.; 5079 Int_t len = ele->GetArrayLength();; 5080 Int_t size = cle->Size();; 5081 char* r = eaddr + (size * (len - 1));; 5082 for (Int_t j = len - 1; j >= 0; --j, r -= size) {; 5083 cle->Destructor(r, kTRUE);; 5084 }; 5085 }; 5086 } // iter over elements; 5087 ; 5088 if (!dtorOnly) {; 5089 delete[] p;; 5090 }; 5091}; 5092 ; 5093///",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:233532,Usability,undo,undo,233532,"me.c_str());; 5793 i->SetClass(nullptr);; 5794 i->GetElements()->Delete();; 5795 TStreamerElement *fel = R__CreateEmulatedElement(""first"", firstname, 0, silent);; 5796 Int_t size = 0;; 5797 if (fel) {; 5798 i->GetElements()->Add( fel );; 5799 ; 5800 size = fel->GetSize();; 5801 Int_t sp = sizeof(void *);; 5802 //align the non-basic data types (required on alpha and IRIX!!); 5803 if (size%sp != 0) size = size - size%sp + sp;; 5804 } else {; 5805 delete i;; 5806 return 0;; 5807 }; 5808 if (hint_pair_offset); 5809 size = hint_pair_offset;; 5810 TStreamerElement *second = R__CreateEmulatedElement(""second"", secondname, size, silent);; 5811 if (second) {; 5812 i->GetElements()->Add( second );; 5813 } else {; 5814 delete i;; 5815 return 0;; 5816 }; 5817 Int_t oldlevel = gErrorIgnoreLevel;; 5818 // Hide the warning about the missing pair dictionary.; 5819 gErrorIgnoreLevel = kError;; 5820 i->BuildCheck(nullptr, kFALSE); // Skipping the loading part (it would leads to infinite recursion on this very routine); 5821 gErrorIgnoreLevel = oldlevel;; 5822 // In the state emulated, BuildOld would recalculate the offset and undo the offset update.; 5823 // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; 5824 // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).; 5825 if (hint_pair_size) {; 5826 i->GetClass()->SetClassSize(hint_pair_size);; 5827 i->GetClass()->fIsSyntheticPair = kTRUE;; 5828 }; 5829 ; 5830 i->BuildOld();; 5831 ; 5832 if (hint_pair_size); 5833 i->GetClass()->SetClassSize(hint_pair_size);; 5834 return i;; 5835}; 5836 ; 5837TVirtualStreamerInfo *TStreamerInfo::GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size); 5838{; 5839 const static int pairlen = strlen(""pair<"");; 5840 if (pairclassname.compare(0, pairlen, ""pair<"") != 0) {; 5841 if (!silent); 5842 Error(""GenerateI",MatchSource.WIKI,doc/master/TStreamerInfo_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:14165,Availability,avail,available,14165," vers) override { fClassVersion = vers; }; 221 void SetOnFileClassVersion(Int_t vers) { fOnFileClassVersion = vers; }; 222 void TagFile(TFile *fFile) override;; 223private:; 224 // Try to remove those functions from the public interface.; 225 Int_t WriteBuffer(TBuffer &b, char *pointer, Int_t first);; 226 Int_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset);; 227 Int_t WriteBufferSTL (TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc);; 228 Int_t WriteBufferSTLPtrs( TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t first, Int_t eoffset);; 229public:; 230 void Update(const TClass *oldClass, TClass *newClass) override;; 231 ; 232 /// \brief Generate the TClass and TStreamerInfo for the requested pair.; 233 /// This creates a TVirtualStreamerInfo for the pair and trigger the BuildCheck/Old to; 234 /// provokes the creation of the corresponding TClass. This relies on the dictionary for; 235 /// std::pair<const int, int> to already exist (or the interpreter information being available); 236 /// as it is used as a template.; 237 /// \note The returned object is owned by the caller.; 238 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 239 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &firstname, const std::string &secondname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 240 ; 241 TVirtualCollectionProxy *GenEmulatedProxy(const char* class_name, Bool_t silent) override;; 242 TClassStreamer *GenEmulatedClassStreamer(const char* class_name, Bool_t silent) override;; 243 TVirtualCollectionProxy *GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 244 TClassStreamer *GenExplicitClassStreamer(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 245 ; 246 static TStreamerElement *GetCurrentElement();; 247 ; 248public:; 249 // For ac",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:3663,Deployability,update,update,3663,"r; 73 {; 74 public:; 75 TPointerCollectionAdapter( TVirtualCollectionProxy *proxy ):; 76 fProxy( proxy ) {}; 77 ; 78 char* operator[]( UInt_t idx ) const; 79 {; 80 char **el = (char**)fProxy->At(idx);; 81 return *el;; 82 }; 83 private:; 84 TVirtualCollectionProxy *fProxy;; 85 };; 86 ; 87private:; 88 UInt_t fCheckSum; ///<Checksum of original class; 89 Int_t fClassVersion; ///<Class version identifier; 90 Int_t fOnFileClassVersion;///<!Class version identifier as stored on file.; 91 Int_t fNumber; ///<!Unique identifier; 92 Int_t fSize; ///<!size of the persistent class; 93 Int_t fNdata; ///<!number of optimized elements; 94 Int_t fNfulldata; ///<!number of elements; 95 Int_t fNslots; ///<!total number of slots in fComp.; 96 TCompInfo *fComp; ///<![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; 97 TCompInfo **fCompOpt; ///<![fNdata]; 98 TCompInfo **fCompFull; ///<![fElements->GetEntries()]; 99 TClass *fClass; ///<!pointer to class; 100 TObjArray *fElements; ///<Array of TStreamerElements; 101 Version_t fOldVersion; ///<! Version of the TStreamerInfo object read from the file; 102 Int_t fNVirtualInfoLoc; ///<! Number of virtual info location to update.; 103 ULong_t *fVirtualInfoLoc; ///<![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); 104 TStreamerInfoActions::TActionSequence *fReadObjectWise; ///<! List of read action resulting from the compilation.; 105 TStreamerInfoActions::TActionSequence *fReadMemberWise; ///<! List of read action resulting from the compilation for use in member wise streaming.; 106 TStreamerInfoActions::TActionSequence *fReadMemberWiseVecPtr; ///<! List of read action resulting from the compilation for use in member wise streaming.; 107 TStreamerInfoActions::TActionSequence *fReadText; ///<! List of text read action resulting from the compilation, used for JSON.; 108 TStreamerInfoActions::TActionSequence *fWriteObjectWise; ///<! List of write action resulting from the co",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:22526,Deployability,update,update,22526,"rInfo.h:54; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::~TCompInfo~TCompInfo()Definition TStreamerInfo.h:59; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo::fLengthInt_t fLengthDefinition TStreamerInfo.h:50; TStreamerInfo::TPointerCollectionAdapterDefinition TStreamerInfo.h:73; TStreamerInfo::TPointerCollectionAdapter::operator[]char * operator[](UInt_t idx) constDefinition TStreamerInfo.h:78; TStreamerInfo::TPointerCollectionAdapter::fProxyTVirtualCollectionProxy * fProxyDefinition TStreamerInfo.h:84; TStreamerInfo::TPointerCollectionAdapter::TPointerCollectionAdapterTPointerCollectionAdapter(TVirtualCollectionProxy *proxy)Definition TStreamerInfo.h:75; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::fNVirtualInfoLocInt_t fNVirtualInfoLoc! Number of virtual info location to update.Definition TStreamerInfo.h:102; TStreamerInfo::fOnFileClassVersionInt_t fOnFileClassVersion!Class version identifier as stored on file.Definition TStreamerInfo.h:90; TStreamerInfo::GetSizeInt_t GetSize() const overrideReturn total size of all persistent elements of the class (with offsets).Definition TStreamerInfo.cxx:4183; TStreamerInfo::GetClassVersionInt_t GetClassVersion() const overrideDefinition TStreamerInfo.h:161; TStreamerInfo::Destructorvoid Destructor(void *p, Bool_t dtorOnly=kFALSE) overrideEmulated destructor for this class.Definition TStreamerInfo.cxx:5100; TStreamerInfo::ReadBufferSTLInt_t ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7=kTRUE)The STL vector/list is deserialized from the buffer b.Definition TStreamerInfoReadBuffer.cxx:1737; TStreamerInfo::AddWriteActionvoid AddWriteAction(TStreamerInfoActions::TActionSequence *writeSequence, Int_t index, TCompInfo *compinfo)Defi",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:31737,Energy Efficiency,allocate,allocate,31737,"n member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetReadObjectWiseActionsTStreamerInfoActions::TActionSequence * GetReadObjectWiseActions()Definition TStreamerInfo.h:168; TStreamerInfo::GetOldVersionVersion_t GetOldVersion() const overrideDefinition TStreamerInfo.h:181; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::ReadBufferConvInt_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Convert elements of a TClonesArray.Definition TStreamerInfoReadBuffer.cxx:568; TStreamerInfo::GetElemTStreamerElement * GetElem(Int_t id) const overrideDefinition TStreamerInfo.h:164; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetElementOffsetInt_t GetElementOffset(Int_t id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssumi",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:39048,Energy Efficiency,allocate,allocate,39048,"treamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::fSizeInt_t fSize!size of the persistent classDefinition TStreamerInfo.h:92; TStreamerInfo::GetTypedValueAuxstatic T GetTypedValueAux(Int_t type, void *ladd, int k, Int_t len)Get the value from inside a collection.Definition TStreamerInfo.cxx:4338; TStreamerInfo::GenerateDeclarationvoid GenerateDeclaration(FILE *fp, FILE *sfp, const TList *subClasses, Bool_t top=kTRUE)Write the Declaration of class.Definition TStreamerInfo.cxx:3668; TStreamerInfo::PrintValueAuxstatic void PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::GetMethodULongptr_t GetMethod(Int_t id) constDefinition TStreamerInfo.h:177; TStreamerInfo::NewArrayvoid * NewArray(Long_t nElements, void *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if ",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:13353,Integrability,interface,interface,13353,"ol_t MatchLegacyCheckSum(UInt_t checksum) const;; 198 TVirtualStreamerInfo *NewInfo(TClass *cl) override { return new TStreamerInfo(cl); }; 199 void *New(void *obj = nullptr) override;; 200 void *NewArray(Long_t nElements, void* ary = nullptr) override;; 201 void Destructor(void* p, Bool_t dtorOnly = kFALSE) override;; 202 void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) override;; 203 void PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;; 204 void PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 205 void PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 206 ; 207 template <class T>; 208 Int_t ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr=1,Int_t eoffset=0,Int_t mode=0);; 209 template <class T>; 210 Int_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 211 template <class T>; 212 Int_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 213 template <class T>; 214 Int_t ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 215 ; 216 Int_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset);; 217 Int_t ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE );; 218 void SetCheckSum(UInt_t checksum) override { fCheckSum = checksum; }; 219 void SetClass(TClass *cl) override;; 220 void SetClassVersion(Int_t vers) override { fClassVersion = vers; }; 221 void SetOnFileClassVersion(Int_t vers) { fOnFileClassVersion = vers; }; 222 void TagFile(TFile *fFile) override;; 223private:; 224 // Try to remove those functions from the public interface.",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:33132,Integrability,rout,routine,33132,"n for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetElementOffsetInt_t GetElementOffset(Int_t id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::ReadBufferClonesInt_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Read for TClonesArray.Definition TStreamerInfoReadBuffer.cxx:1749; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::SetClassVersionvoid SetClassVersion(Int_t vers) overrideDefinition TStreamerInfo.h:220; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetReadTextActionsTStreamerInfoActions::TActionSequence * GetReadTextActions()Definition TStreamerInfo",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:43609,Integrability,interface,interface,43609,"x:850; TStreamerInfo::fVirtualInfoLocULong_t * fVirtualInfoLoc![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated)Definition TStreamerInfo.h:103; TStreamerInfo::Updatevoid Update(const TClass *oldClass, TClass *newClass) overridefunction called by the TClass constructor when replacing an emulated class by the real classDefinition TStreamerInfo.cxx:5629; TStreamerInfo::GetReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Bool_t forCollection)Definition TStreamerInfo.h:167; TStreamerInfo::PrintValueClonesvoid PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) constPrint value of element i in a TClonesArray.Definition TStreamerInfo.cxx:5204; TStreamerInfo::GetValueClonesDouble_t GetValueClones(TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) constDefinition TStreamerInfo.h:193; TStreamerInfo::GetValueDouble_t GetValue(char *pointer, Int_t i, Int_t j, Int_t len) constDefinition TStreamerInfo.h:192; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::Atvirtual void * At(UInt_t idx)=0Return the address of the value at index idx; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; double; int; unsigned int; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TStreamerInfoActionsDefinition TBuffer.h:39. ioioincTStreamerInfo.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:37 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:1349,Performance,cache,cache,1349,"utors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TStreamerInfo; 13#define ROOT_TStreamerInfo; 14 ; 15#include <atomic>; 16#include <vector>; 17 ; 18#include ""TVirtualStreamerInfo.h""; 19 ; 20#include ""TVirtualCollectionProxy.h""; 21 ; 22#include ""TObjArray.h""; 23 ; 24 ; 25class TFile;; 26class TClass;; 27class TClonesArray;; 28class TDataMember;; 29class TMemberStreamer;; 30class TStreamerElement;; 31class TStreamerBasicType;; 32class TClassStreamer;; 33class TVirtualArray;; 34namespace ROOT { namespace Detail { class TCollectionProxyInfo; } }; 35namespace ROOT { class TSchemaRule; }; 36 ; 37namespace TStreamerInfoActions { class TActionSequence; }; 38 ; 39class TStreamerInfo : public TVirtualStreamerInfo {; 40 ; 41 class TCompInfo {; 42 // Class used to cache information (see fComp); 43 private:; 44 // TCompInfo(const TCompInfo&) = default;; 45 // TCompInfo& operator=(const TCompInfo&) = default;; 46 public:; 47 Int_t fType;; 48 Int_t fNewType;; 49 Int_t fOffset;; 50 Int_t fLength;; 51 TStreamerElement *fElem; ///< Not Owned; 52 ULongptr_t fMethod;; 53 TClass *fClass; ///< Not Owned; 54 TClass *fNewClass; ///< Not Owned; 55 TString fClassName;; 56 TMemberStreamer *fStreamer; ///< Not Owned; 57 TCompInfo() : fType(-1), fNewType(0), fOffset(0), fLength(0), fElem(nullptr), fMethod(0),; 58 fClass(nullptr), fNewClass(nullptr), fClassName(), fStreamer(nullptr) {}; 59 ~TCompInfo() {}; 60 void Update(const TClass *oldcl, TClass *newcl);; 61 };; 62 friend class TStreamerInfoActions::TActionSequence;; 63 ; 64public:; 65 // make the opaque pointer public.; 66 typedef TCompInfo TCompInfo_t;; 67 ; 68protected:; 69 //---------------------------------------------------------------------------; 70 // Adapter class used to handle streaming collection of pointers; 71 //---------------------------------------------------------------------------; 72 class TPointerCollectionAdapter; 73 {; 74 public:; ",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:3086,Performance,optimiz,optimized,3086,::TActionSequence;; 63 ; 64public:; 65 // make the opaque pointer public.; 66 typedef TCompInfo TCompInfo_t;; 67 ; 68protected:; 69 //---------------------------------------------------------------------------; 70 // Adapter class used to handle streaming collection of pointers; 71 //---------------------------------------------------------------------------; 72 class TPointerCollectionAdapter; 73 {; 74 public:; 75 TPointerCollectionAdapter( TVirtualCollectionProxy *proxy ):; 76 fProxy( proxy ) {}; 77 ; 78 char* operator[]( UInt_t idx ) const; 79 {; 80 char **el = (char**)fProxy->At(idx);; 81 return *el;; 82 }; 83 private:; 84 TVirtualCollectionProxy *fProxy;; 85 };; 86 ; 87private:; 88 UInt_t fCheckSum; ///<Checksum of original class; 89 Int_t fClassVersion; ///<Class version identifier; 90 Int_t fOnFileClassVersion;///<!Class version identifier as stored on file.; 91 Int_t fNumber; ///<!Unique identifier; 92 Int_t fSize; ///<!size of the persistent class; 93 Int_t fNdata; ///<!number of optimized elements; 94 Int_t fNfulldata; ///<!number of elements; 95 Int_t fNslots; ///<!total number of slots in fComp.; 96 TCompInfo *fComp; ///<![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; 97 TCompInfo **fCompOpt; ///<![fNdata]; 98 TCompInfo **fCompFull; ///<![fElements->GetEntries()]; 99 TClass *fClass; ///<!pointer to class; 100 TObjArray *fElements; ///<Array of TStreamerElements; 101 Version_t fOldVersion; ///<! Version of the TStreamerInfo object read from the file; 102 Int_t fNVirtualInfoLoc; ///<! Number of virtual info location to update.; 103 ULong_t *fVirtualInfoLoc; ///<![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); 104 TStreamerInfoActions::TActionSequence *fReadObjectWise; ///<! List of read action resulting from the compilation.; 105 TStreamerInfoActions::TActionSequence *fReadMemberWise; ///<! List of read action resulting from the compilation for use in member wise streaming.; 106 TS,MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:6925,Performance,load,load,6925,"teSequence, Int_t index, TCompInfo *compinfo);; 132 ; 133public:; 134 ; 135 /// Status bits; 136 /// See TVirtualStreamerInfo::EStatusBits for the values.; 137 ; 138 /// EReadWrite Enumerator; 139 /// See TVirtualStreamerInfo::EReadWrite for documentation and values.; 140 ; 141 TStreamerInfo();; 142 TStreamerInfo(TClass *cl);; 143 ~TStreamerInfo() override;; 144 void Build(Bool_t isTransient = kFALSE) override;; 145 void BuildCheck(TFile *file = nullptr, Bool_t load = kTRUE) override;; 146 void BuildEmulated(TFile *file) override;; 147 void BuildOld() override;; 148 Bool_t BuildFor( const TClass *cl ) override;; 149 void CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const override;; 150 void Clear(Option_t * = """") override;; 151 TObject *Clone(const char *newname = """") const override;; 152 Bool_t CompareContent(TClass *cl,TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) override;; 153 void Compile() override;; 154 void ComputeSize();; 155 void ForceWriteInfo(TFile *file, Bool_t force = kFALSE) override;; 156 Int_t GenerateHeaderFile(const char *dirname, const TList *subClasses = nullptr, const TList *extrainfos = nullptr) override;; 157 TClass *GetActualClass(const void *obj) const override;; 158 TClass *GetClass() const override { return fClass; }; 159 UInt_t GetCheckSum() const override { return fCheckSum; }; 160 UInt_t GetCheckSum(TClass::ECheckSum code) const;; 161 Int_t GetClassVersion() const override { return fClassVersion; }; 162 Int_t GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const;; 163 TObjArray *GetElements() const override {return fElements;}; 164 TStreamerElement *GetElem(Int_t id) const override { return fComp[id].fElem; } // Return the element for the list of optimized elements (max GetNdata()); 165 TStreamerElement *GetElement(Int_t id) const override {return (TStreamerElement*)fElements->At(id);} // Return the element for the complete list of elements (max GetElements()->Ge",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:8239,Performance,optimiz,optimized,8239,"Sum; }; 160 UInt_t GetCheckSum(TClass::ECheckSum code) const;; 161 Int_t GetClassVersion() const override { return fClassVersion; }; 162 Int_t GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const;; 163 TObjArray *GetElements() const override {return fElements;}; 164 TStreamerElement *GetElem(Int_t id) const override { return fComp[id].fElem; } // Return the element for the list of optimized elements (max GetNdata()); 165 TStreamerElement *GetElement(Int_t id) const override {return (TStreamerElement*)fElements->At(id);} // Return the element for the complete list of elements (max GetElements()->GetEntries()); 166 Int_t GetElementOffset(Int_t id) const override {return fCompFull[id]->fOffset;}; 167 TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Bool_t forCollection) { return forCollection ? fReadMemberWiseVecPtr : fReadMemberWise; }; 168 TStreamerInfoActions::TActionSequence *GetReadObjectWiseActions() { return fReadObjectWise; }; 169 TStreamerInfoActions::TActionSequence *GetReadTextActions() { return fReadText; }; 170 TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions(Bool_t forCollection) { return forCollection ? fWriteMemberWiseVecPtr : fWriteMemberWise; }; 171 TStreamerInfoActions::TActionSequence *GetWriteObjectWiseActions() { return fWriteObjectWise; }; 172 TStreamerInfoActions::TActionSequence *GetWriteTextActions() { return fWriteText; }; 173 Int_t GetNdata() const {return fNdata;}; 174 Int_t GetNelement() const { return fElements->GetEntriesFast(); }; 175 Int_t GetNumber() const override { return fNumber; }; 176 Int_t GetLength(Int_t id) const {return fComp[id].fLength;}; 177 ULongptr_t GetMethod(Int_t id) const {return fComp[id].fMethod;}; 178 Int_t GetNewType(Int_t id) const {return fComp[id].fNewType;}; 179 Int_t GetOffset(const char *) const override;; 180 Int_t GetOffset(Int_t id) const override {return fComp[id].fOffset;}; 181 Version_t GetOldVersion() const override {return fOldVersion;}; 182 Int_t GetO",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:20905,Performance,cache,cached,20905,"Member.h:31; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TStreamerBasicTypeDefinition TStreamerElement.h:269; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfo::TCompInfoDefinition TStreamerInfo.h:41; TStreamerInfo::TCompInfo::TCompInfoTCompInfo()Definition TStreamerInfo.h:57; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fStreamerTMemberStreamer * fStreamerNot Owned.Definition TStreamerInfo.h:56; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fElemTStreamerElement * fElemNot Owned.Definition TStreamerInfo.h:51; TStreamerInfo::TCompInfo::fNewClassTClass * fNewClassNot Owned.Definition TStreamerInfo.h:54; TStreamerInfo::TCompInfo::fClassNameTString fClassNameDefinition TStreamerInfo.h:55; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::~TCompInfo~TCompInfo()Definition TStreamerInfo.h:59; TStreamerInfo::TCompInfo::fNewTypeInt_t fNewTypeDefinition TStreamerInfo.h:48; TStreamerInfo::TCompInfo::fLengthInt_t fLen",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:31568,Performance,optimiz,optimized,31568,"mberWiseTStreamerInfoActions::TActionSequence * fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:105; TStreamerInfo::GetReadObjectWiseActionsTStreamerInfoActions::TActionSequence * GetReadObjectWiseActions()Definition TStreamerInfo.h:168; TStreamerInfo::GetOldVersionVersion_t GetOldVersion() const overrideDefinition TStreamerInfo.h:181; TStreamerInfo::GetTypeInt_t GetType(Int_t id) constDefinition TStreamerInfo.h:187; TStreamerInfo::ReadBufferConvInt_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Convert elements of a TClonesArray.Definition TStreamerInfoReadBuffer.cxx:568; TStreamerInfo::GetElemTStreamerElement * GetElem(Int_t id) const overrideDefinition TStreamerInfo.h:164; TStreamerInfo::fClassVersionInt_t fClassVersionClass version identifier.Definition TStreamerInfo.h:89; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::Newvoid * New(void *obj=nullptr) overrideAn emulated object is created at address obj, if obj is null we allocate memory for the object.Definition TStreamerInfo.cxx:4769; TStreamerInfo::TStreamerInfoTStreamerInfo()Status bits See TVirtualStreamerInfo::EStatusBits for the values.Definition TStreamerInfo.cxx:145; TStreamerInfo::fReadMemberWiseVecPtrTStreamerInfoActions::TActionSequence * fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:106; TStreamerInfo::fReadObjectWiseTStreamerInfoActions::TActionSequence * fReadObjectWise! List of read action resulting from the compilation.Definition TStreamerInfo.h:104; TStreamerInfo::GetElementOffsetInt_t GetElementOffset(Int_t id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerI",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:39950,Performance,load,load,39950,"d *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::GetWriteObjectWiseActionsTStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions()Definition TStreamerInfo.h:171; TStreamerInfo::CompareContentBool_t CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) overrideReturn True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.Definition TStreamerInfo.cxx:2854; TStreamerInfo::ReadBufferSkipInt_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Skip an element.Definition TStreamerInfoReadBuffer.cxx:182; TStreamerInfo::fWriteMemberWiseTStreamerInfoActions::TActionSequence * fWriteMemberWise! List of write action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:109; TStreamerInfo::fNslotsInt_t fNslots!total num",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:11394,Security,checksum,checksum,11394,"t_t eoffset) const;; 190 template <typename T> T GetTypedValueSTL(TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;; 191 template <typename T> T GetTypedValueSTLP(TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;; 192 Double_t GetValue(char *pointer, Int_t i, Int_t j, Int_t len) const { return GetTypedValue<Double_t>(pointer, i, j, len); }; 193 Double_t GetValueClones(TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }; 194 Double_t GetValueSTL(TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }; 195 Double_t GetValueSTLP(TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }; 196 void ls(Option_t *option="""") const override;; 197 Bool_t MatchLegacyCheckSum(UInt_t checksum) const;; 198 TVirtualStreamerInfo *NewInfo(TClass *cl) override { return new TStreamerInfo(cl); }; 199 void *New(void *obj = nullptr) override;; 200 void *NewArray(Long_t nElements, void* ary = nullptr) override;; 201 void Destructor(void* p, Bool_t dtorOnly = kFALSE) override;; 202 void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) override;; 203 void PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;; 204 void PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 205 void PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 206 ; 207 template <class T>; 208 Int_t ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr=1,Int_t eoffset=0,Int_t mode=0);; 209 template <class T>; 210 Int_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerE",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:13009,Security,checksum,checksum,13009,"ol_t MatchLegacyCheckSum(UInt_t checksum) const;; 198 TVirtualStreamerInfo *NewInfo(TClass *cl) override { return new TStreamerInfo(cl); }; 199 void *New(void *obj = nullptr) override;; 200 void *NewArray(Long_t nElements, void* ary = nullptr) override;; 201 void Destructor(void* p, Bool_t dtorOnly = kFALSE) override;; 202 void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) override;; 203 void PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;; 204 void PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 205 void PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 206 ; 207 template <class T>; 208 Int_t ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr=1,Int_t eoffset=0,Int_t mode=0);; 209 template <class T>; 210 Int_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 211 template <class T>; 212 Int_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 213 template <class T>; 214 Int_t ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 215 ; 216 Int_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset);; 217 Int_t ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE );; 218 void SetCheckSum(UInt_t checksum) override { fCheckSum = checksum; }; 219 void SetClass(TClass *cl) override;; 220 void SetClassVersion(Int_t vers) override { fClassVersion = vers; }; 221 void SetOnFileClassVersion(Int_t vers) { fOnFileClassVersion = vers; }; 222 void TagFile(TFile *fFile) override;; 223private:; 224 // Try to remove those functions from the public interface.",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:13042,Security,checksum,checksum,13042,"ol_t MatchLegacyCheckSum(UInt_t checksum) const;; 198 TVirtualStreamerInfo *NewInfo(TClass *cl) override { return new TStreamerInfo(cl); }; 199 void *New(void *obj = nullptr) override;; 200 void *NewArray(Long_t nElements, void* ary = nullptr) override;; 201 void Destructor(void* p, Bool_t dtorOnly = kFALSE) override;; 202 void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) override;; 203 void PrintValue(const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;; 204 void PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 205 void PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;; 206 ; 207 template <class T>; 208 Int_t ReadBuffer(TBuffer &b, const T &arrptr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr=1,Int_t eoffset=0,Int_t mode=0);; 209 template <class T>; 210 Int_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 211 template <class T>; 212 Int_t ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo,Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 213 template <class T>; 214 Int_t ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset);; 215 ; 216 Int_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset);; 217 Int_t ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE );; 218 void SetCheckSum(UInt_t checksum) override { fCheckSum = checksum; }; 219 void SetClass(TClass *cl) override;; 220 void SetClassVersion(Int_t vers) override { fClassVersion = vers; }; 221 void SetOnFileClassVersion(Int_t vers) { fOnFileClassVersion = vers; }; 222 void TagFile(TFile *fFile) override;; 223private:; 224 // Try to remove those functions from the public interface.",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:15125,Security,access,access,15125,"offset);; 229public:; 230 void Update(const TClass *oldClass, TClass *newClass) override;; 231 ; 232 /// \brief Generate the TClass and TStreamerInfo for the requested pair.; 233 /// This creates a TVirtualStreamerInfo for the pair and trigger the BuildCheck/Old to; 234 /// provokes the creation of the corresponding TClass. This relies on the dictionary for; 235 /// std::pair<const int, int> to already exist (or the interpreter information being available); 236 /// as it is used as a template.; 237 /// \note The returned object is owned by the caller.; 238 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &pairclassname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 239 TVirtualStreamerInfo *GenerateInfoForPair(const std::string &firstname, const std::string &secondname, bool silent, size_t hint_pair_offset, size_t hint_pair_size) override;; 240 ; 241 TVirtualCollectionProxy *GenEmulatedProxy(const char* class_name, Bool_t silent) override;; 242 TClassStreamer *GenEmulatedClassStreamer(const char* class_name, Bool_t silent) override;; 243 TVirtualCollectionProxy *GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 244 TClassStreamer *GenExplicitClassStreamer(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl) override;; 245 ; 246 static TStreamerElement *GetCurrentElement();; 247 ; 248public:; 249 // For access by the StreamerInfoActions.; 250 template <class T>; 251 Int_t WriteBufferAux (TBuffer &b, const T &arr, TCompInfo *const*const compinfo, Int_t first, Int_t last, Int_t narr,Int_t eoffset,Int_t mode);; 252 ; 253 //WARNING this class version must be the same as TVirtualStreamerInfo; 254 ClassDefOverride(TStreamerInfo,9) //Streamer information for one class version; 255};; 256 ; 257 ; 258#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; ULong_t",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:20094,Security,access,accessing,20094,"ributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TObjArray.h; TVirtualCollectionProxy.h; TVirtualStreamerInfo.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TStreamerBasicTypeDefinition TStreamerElement.h:269; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfo::TCompInfoDefinition TStreamerInfo.h:41; TStreamerInfo::TCompInfo::TCompInfoTCompInfo()Definition TStreamerInfo.h:57; TStreamerInfo::TCompInfo::Updatevoid Update(const TClass *oldcl, TClass *newcl)Update the TClass pointer cached in this object.Definition TStreamerInfo.cxx:5644; TStreamerInfo::TCompInfo::fTypeInt_t fTypeDefinition TStreamerInfo.h:47; TStreamerInfo::TCompInfo::fClassTClass * fClassNot Owne",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:33369,Security,checksum,checksum,33369,"id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::ReadBufferClonesInt_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Read for TClonesArray.Definition TStreamerInfoReadBuffer.cxx:1749; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::SetClassVersionvoid SetClassVersion(Int_t vers) overrideDefinition TStreamerInfo.h:220; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetReadTextActionsTStreamerInfoActions::TActionSequence * GetReadTextActions()Definition TStreamerInfo.h:169; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::GetOffsetInt_t GetOffset(Int_t id) const overrideDefinition TStreamerInfo.h:180; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointin",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:33403,Security,checksum,checksum,33403,"id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::ReadBufferClonesInt_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Read for TClonesArray.Definition TStreamerInfoReadBuffer.cxx:1749; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::SetClassVersionvoid SetClassVersion(Int_t vers) overrideDefinition TStreamerInfo.h:220; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetReadTextActionsTStreamerInfoActions::TActionSequence * GetReadTextActions()Definition TStreamerInfo.h:169; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::GetOffsetInt_t GetOffset(Int_t id) const overrideDefinition TStreamerInfo.h:180; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointin",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:33445,Security,checksum,checksum,33445,"id) const overrideDefinition TStreamerInfo.h:166; TStreamerInfo::GetLengthInt_t GetLength(Int_t id) constDefinition TStreamerInfo.h:176; TStreamerInfo::TStreamerInfoTStreamerInfo(const TStreamerInfo &)=delete; TStreamerInfo::GetActualClassTClass * GetActualClass(const void *obj) const overrideAssuming that obj points to (the part of) an object that is of the type described by this streamerInf...Definition TStreamerInfo.cxx:3255; TStreamerInfo::ReadBufferClonesInt_t ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Read for TClonesArray.Definition TStreamerInfoReadBuffer.cxx:1749; TStreamerInfo::GetStreamerElementRealTStreamerElement * GetStreamerElementReal(Int_t i, Int_t j) constObsolete: this routine is obsolete and should not longer be used.Definition TStreamerInfo.cxx:4316; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TStreamerInfo.cxx:3270; TStreamerInfo::~TStreamerInfo~TStreamerInfo() overrideTStreamerInfo dtor.Definition TStreamerInfo.cxx:211; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::SetClassVersionvoid SetClassVersion(Int_t vers) overrideDefinition TStreamerInfo.h:220; TStreamerInfo::TagFilevoid TagFile(TFile *fFile) overrideMark the classindex of the current file as using this TStreamerInfo.Definition TStreamerInfo.cxx:5377; TStreamerInfo::GetReadTextActionsTStreamerInfoActions::TActionSequence * GetReadTextActions()Definition TStreamerInfo.h:169; TStreamerInfo::GetNewTypeInt_t GetNewType(Int_t id) constDefinition TStreamerInfo.h:178; TStreamerInfo::GetOffsetInt_t GetOffset(Int_t id) const overrideDefinition TStreamerInfo.h:180; TStreamerInfo::SetClassvoid SetClass(TClass *cl) overrideReplace the TClass this streamerInfo is pointin",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:37926,Security,checksum,checksum,37926,"teBuffer.cxx:863; TStreamerInfo::fWriteObjectWiseTStreamerInfoActions::TActionSequence * fWriteObjectWise! List of write action resulting from the compilation.Definition TStreamerInfo.h:108; TStreamerInfo::ReadBufferArtificialInt_t ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Handle Artificial StreamerElement.Definition TStreamerInfoReadBuffer.cxx:526; TStreamerInfo::CallShowMembersvoid CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient) const overrideEmulated a call ShowMembers() on the obj of this class type, passing insp and parent.Definition TStreamerInfo.cxx:2752; TStreamerInfo::SetOnFileClassVersionvoid SetOnFileClassVersion(Int_t vers)Definition TStreamerInfo.h:221; TStreamerInfo::Clearvoid Clear(Option_t *="""") overrideIf opt contains 'built', reset this StreamerInfo as if Build or BuildOld was never called on it (usef...Definition TStreamerInfo.cxx:2616; TStreamerInfo::SetCheckSumvoid SetCheckSum(UInt_t checksum) overrideDefinition TStreamerInfo.h:218; TStreamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::fSizeInt_t fSize!size of the persistent classDefinition TStreamerInfo.h:92; TStreamerInfo::GetTypedValueAuxstatic T GetTypedValueAux(Int_t type, void *ladd, int k, Int_t len)Get the value from inside a collection.Definition TStreamerInfo.cxx:4338; TStreamerInfo::GenerateDeclarationvoid GenerateDeclaration(FILE *fp, FILE *sfp, const TList *subClasses, Bool_t top=kTRUE)Write the Declaration of class.Definition TStreamerInfo.cxx:3668; TStreamerInfo::PrintValueAuxstatic void PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::GetMethodULongptr_t GetMethod(Int_t id) constDefinition TStreamerInfo.h:177; TStreamerInfo::NewArrayvoid *",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TStreamerInfo_8h_source.html:43479,Security,access,access,43479,"x:850; TStreamerInfo::fVirtualInfoLocULong_t * fVirtualInfoLoc![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated)Definition TStreamerInfo.h:103; TStreamerInfo::Updatevoid Update(const TClass *oldClass, TClass *newClass) overridefunction called by the TClass constructor when replacing an emulated class by the real classDefinition TStreamerInfo.cxx:5629; TStreamerInfo::GetReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Bool_t forCollection)Definition TStreamerInfo.h:167; TStreamerInfo::PrintValueClonesvoid PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) constPrint value of element i in a TClonesArray.Definition TStreamerInfo.cxx:5204; TStreamerInfo::GetValueClonesDouble_t GetValueClones(TClonesArray *clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) constDefinition TStreamerInfo.h:193; TStreamerInfo::GetValueDouble_t GetValue(char *pointer, Int_t i, Int_t j, Int_t len) constDefinition TStreamerInfo.h:192; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::Atvirtual void * At(UInt_t idx)=0Return the address of the value at index idx; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; double; int; unsigned int; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TStreamerInfoActionsDefinition TBuffer.h:39. ioioincTStreamerInfo.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:37 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TStreamerInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html
https://root.cern/doc/master/TString_8cxx.html:4599,Availability,down,down,4599,"c from escchar and copy to dst. ; . Variables; const UInt_tkHashShift = 5; . Macro Definition Documentation. BIG_CONSTANT. #define BIG_CONSTANT; (; ; x); (x##LLU). Definition at line 726 of file TString.cxx. ROTL64. #define ROTL64; (; ; x, . ; y. ); rotl64(x,y). Definition at line 725 of file TString.cxx. Function Documentation. Compress(). char * Compress ; (; const char *; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Format(). static char * Format ; (; const char *; format, . va_list; ap. ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. Hash(). UInt_t Hash ; (; const char *; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Mash(). static void Mash ; (; UInt_t &; hash, . UInt_t; chars. ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. MemIsEqual(). static int MemIsEqual ; (; const char *; p, . const char *; q, . Ssiz_t; n. ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. operator+() [1/5]. TString operator+ ; (; char; c, . const TString &; s. ). Add string to char.",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:4664,Availability,down,downstream,4664,"c from escchar and copy to dst. ; . Variables; const UInt_tkHashShift = 5; . Macro Definition Documentation. BIG_CONSTANT. #define BIG_CONSTANT; (; ; x); (x##LLU). Definition at line 726 of file TString.cxx. ROTL64. #define ROTL64; (; ; x, . ; y. ); rotl64(x,y). Definition at line 725 of file TString.cxx. Function Documentation. Compress(). char * Compress ; (; const char *; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Format(). static char * Format ; (; const char *; format, . va_list; ap. ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. Hash(). UInt_t Hash ; (; const char *; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Mash(). static void Mash ; (; UInt_t &; hash, . UInt_t; chars. ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. MemIsEqual(). static int MemIsEqual ; (; const char *; p, . const char *; q, . Ssiz_t; n. ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. operator+() [1/5]. TString operator+ ; (; char; c, . const TString &; s. ). Add string to char.",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:7633,Availability,error,error,7633,"char *; s2. ). Compare TString with a char *. ; Definition at line 1482 of file TString.cxx. operator==() [2/4]. Bool_t operator== ; (; const TSubString &; s1, . const TSubString &; s2. ). Compare two sub-strings. ; Definition at line 1731 of file TString.cxx. operator==() [3/4]. Bool_t operator== ; (; const TSubString &; ss, . const char *; cs. ). Compare sub-string to char *. ; Definition at line 1707 of file TString.cxx. operator==() [4/4]. Bool_t operator== ; (; const TSubString &; ss, . const TString &; s. ). Compare sub-string to string. ; Definition at line 1721 of file TString.cxx. operator>>(). TBuffer & operator>> ; (; TBuffer &; buf, . TString *&; s. ). Read string from TBuffer. Function declared in ClassDef. ; Definition at line 1461 of file TString.cxx. Printf(). void Printf ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer and prints the string. ; Appends a newline. If gPrintViaErrorHandler is true it will print via the currently active ROOT error handler. ; Definition at line 2503 of file TString.cxx. rotl64(). uint64_t rotl64 ; (; uint64_t; x, . int8_t; r. ). inline . Definition at line 720 of file TString.cxx. SlowFormat(). static char * SlowFormat ; (; const char *; format, . va_list; ap, . int; hint. ). static . Format a string in a formatting buffer (using a printf style format descriptor). ; Definition at line 2394 of file TString.cxx. StrDup(). char * StrDup ; (; const char *; str). Duplicate the string str. ; The returned string has to be deleted by the user. ; Definition at line 2557 of file TString.cxx. Strip(). char * Strip ; (; const char *; s, . char; c. ). Strip leading and trailing c (blanks by default) from a string. ; The returned string has to be deleted by the user. ; Definition at line 2521 of file TString.cxx. SwapInt(). static UInt_t SwapInt ; (; UInt_t; x). inlinestatic . Definition at line 556 of file TString.cxx. ToLower(). TString ToLower ; ",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:625,Integrability,depend,dependency,625,". ROOT: core/base/src/TString.cxx File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces |; Macros |; Functions |; Variables ; TString.cxx File Reference. #include <ROOT/RConfig.hxx>; #include <stdlib.h>; #include <ctype.h>; #include <list>; #include <algorithm>; #include ""Varargs.h""; #include ""strlcpy.h""; #include ""TString.h""; #include ""TBuffer.h""; #include ""TError.h""; #include ""Bytes.h""; #include ""TClass.h""; #include ""TMD5.h""; #include ""TObjArray.h""; #include ""TObjString.h""; #include ""TVirtualMutex.h""; #include ""ThreadLocalStorage.h""; #include <stdint.h>. Include dependency graph for TString.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Macros; #defineBIG_CONSTANT(x)(x##LLU); ; #defineROTL64(x, y)rotl64(x,y); . Functions; char *Compress (const char *str); Remove all blanks from the string str. ; ; intEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Escape specchars in src with escchar and copy to dst. ; ; char *Form (const char *fmt,...); Formats a string in a circular formatting buffer. ; ; static char *Format (const char *format, va_list ap); Format a string in a circular formatting buffer (using a printf style format descriptor). ; ; UInt_tHash (const char *str); Return a case-sensitive hash value (endian independent). ; ; static voidMash (UInt_t &hash, UInt_t chars); Utility used by Hash(). ; ; static intMemIsEqual (const char *p, const char *q, Ssiz_t n); Returns false if strings are not equal. ; ; TStringoperator+ (char c, const TString &s); Add string to char. ; ; TStringoperator+ (const char *cs, const TString &s); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s, char c)",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:1557,Security,hash,hash,1557,"e ""TVirtualMutex.h""; #include ""ThreadLocalStorage.h""; #include <stdint.h>. Include dependency graph for TString.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Macros; #defineBIG_CONSTANT(x)(x##LLU); ; #defineROTL64(x, y)rotl64(x,y); . Functions; char *Compress (const char *str); Remove all blanks from the string str. ; ; intEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Escape specchars in src with escchar and copy to dst. ; ; char *Form (const char *fmt,...); Formats a string in a circular formatting buffer. ; ; static char *Format (const char *format, va_list ap); Format a string in a circular formatting buffer (using a printf style format descriptor). ; ; UInt_tHash (const char *str); Return a case-sensitive hash value (endian independent). ; ; static voidMash (UInt_t &hash, UInt_t chars); Utility used by Hash(). ; ; static intMemIsEqual (const char *p, const char *q, Ssiz_t n); Returns false if strings are not equal. ; ; TStringoperator+ (char c, const TString &s); Add string to char. ; ; TStringoperator+ (const char *cs, const TString &s); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s, char c); Add char to string. ; ; TStringoperator+ (const TString &s, const char *cs); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s1, const TString &s2); Use the special concatenation constructor. ; ; TBuffer &operator<< (TBuffer &buf, const TString *s); Write TString or derived to TBuffer. ; ; Bool_toperator== (const TString &s1, const char *s2); Compare TString with a char *. ; ; Bool_toperator== (const TSubString &s1, const TSubString &s2); Compare two sub-strings. ; ; Bool_toperator== ",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:1621,Security,hash,hash,1621,"pendency graph for TString.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Macros; #defineBIG_CONSTANT(x)(x##LLU); ; #defineROTL64(x, y)rotl64(x,y); . Functions; char *Compress (const char *str); Remove all blanks from the string str. ; ; intEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Escape specchars in src with escchar and copy to dst. ; ; char *Form (const char *fmt,...); Formats a string in a circular formatting buffer. ; ; static char *Format (const char *format, va_list ap); Format a string in a circular formatting buffer (using a printf style format descriptor). ; ; UInt_tHash (const char *str); Return a case-sensitive hash value (endian independent). ; ; static voidMash (UInt_t &hash, UInt_t chars); Utility used by Hash(). ; ; static intMemIsEqual (const char *p, const char *q, Ssiz_t n); Returns false if strings are not equal. ; ; TStringoperator+ (char c, const TString &s); Add string to char. ; ; TStringoperator+ (const char *cs, const TString &s); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s, char c); Add char to string. ; ; TStringoperator+ (const TString &s, const char *cs); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s1, const TString &s2); Use the special concatenation constructor. ; ; TBuffer &operator<< (TBuffer &buf, const TString *s); Write TString or derived to TBuffer. ; ; Bool_toperator== (const TString &s1, const char *s2); Compare TString with a char *. ; ; Bool_toperator== (const TSubString &s1, const TSubString &s2); Compare two sub-strings. ; ; Bool_toperator== (const TSubString &ss, const char *cs); Compare sub-string to char *. ; ; Bool_tope",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:5087,Security,hash,hash,5087,"deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Format(). static char * Format ; (; const char *; format, . va_list; ap. ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. Hash(). UInt_t Hash ; (; const char *; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Mash(). static void Mash ; (; UInt_t &; hash, . UInt_t; chars. ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. MemIsEqual(). static int MemIsEqual ; (; const char *; p, . const char *; q, . Ssiz_t; n. ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. operator+() [1/5]. TString operator+ ; (; char; c, . const TString &; s. ). Add string to char. ; Definition at line 1557 of file TString.cxx. operator+() [2/5]. TString operator+ ; (; const char *; cs, . const TString &; s. ). Use the special concatenation constructor. ; Definition at line 1533 of file TString.cxx. operator+() [3/5]. TString operator+ ; (; const TString &; s, . char; c. ). Add char to string. ; Definition at line 1549 of file TString.cxx. operator+() [4/5]. TString operator+ ; (; const TString &; s, . const char *; cs. ). Use the s",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx.html:5209,Security,hash,hash,5209,"har *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Format(). static char * Format ; (; const char *; format, . va_list; ap. ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. Hash(). UInt_t Hash ; (; const char *; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Mash(). static void Mash ; (; UInt_t &; hash, . UInt_t; chars. ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. MemIsEqual(). static int MemIsEqual ; (; const char *; p, . const char *; q, . Ssiz_t; n. ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. operator+() [1/5]. TString operator+ ; (; char; c, . const TString &; s. ). Add string to char. ; Definition at line 1557 of file TString.cxx. operator+() [2/5]. TString operator+ ; (; const char *; cs, . const TString &; s. ). Use the special concatenation constructor. ; Definition at line 1533 of file TString.cxx. operator+() [3/5]. TString operator+ ; (; const TString &; s, . char; c. ). Add char to string. ; Definition at line 1549 of file TString.cxx. operator+() [4/5]. TString operator+ ; (; const TString &; s, . const char *; cs. ). Use the special concatenation constructor. ; Definition at line 1525 of file TString.cxx. operator+() [5/5]. TSt",MatchSource.WIKI,doc/master/TString_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx.html
https://root.cern/doc/master/TString_8cxx_source.html:54285,Availability,error,error,54285,"tor==(const TSubString &s1, const TSubString &s2); 1732{; 1733 if (s1.IsNull()) return s2.IsNull();; 1734 if (s1.fExtent != s2.fExtent) return kFALSE;; 1735 return !memcmp(s1.fStr.Data()+s1.fBegin, s2.fStr.Data()+s2.fBegin,; 1736 s1.fExtent);; 1737}; 1738 ; 1739////////////////////////////////////////////////////////////////////////////////; 1740/// Convert sub-string to lower-case.; 1741 ; 1742void TSubString::ToLower(); 1743{; 1744 if (!IsNull()) { // Ignore null substrings; 1745 char *p = fStr.GetPointer() + fBegin;; 1746 Ssiz_t n = fExtent;; 1747 while (n--) { *p = tolower((unsigned char)*p); p++;}; 1748 }; 1749}; 1750 ; 1751////////////////////////////////////////////////////////////////////////////////; 1752/// Convert sub-string to upper-case.; 1753 ; 1754void TSubString::ToUpper(); 1755{; 1756 if (!IsNull()) { // Ignore null substrings; 1757 char *p = fStr.GetPointer() + fBegin;; 1758 Ssiz_t n = fExtent;; 1759 while (n--) { *p = toupper((unsigned char)*p); p++;}; 1760 }; 1761}; 1762 ; 1763////////////////////////////////////////////////////////////////////////////////; 1764/// Output error message.; 1765 ; 1766void TSubString::SubStringError(Ssiz_t sr, Ssiz_t start, Ssiz_t n) const; 1767{; 1768 Error(""TSubString::SubStringError"",; 1769 ""out of bounds: start = %d, n = %d, sr = %d"", start, n, sr);; 1770}; 1771 ; 1772////////////////////////////////////////////////////////////////////////////////; 1773/// Check to make sure a sub-string index is in range.; 1774 ; 1775void TSubString::AssertElement(Ssiz_t i) const; 1776{; 1777 if (i == kNPOS || i >= Length()); 1778 Error(""TSubString::AssertElement"",; 1779 ""out of bounds: i = %d, Length = %d"", i, Length());; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Returns true if all characters in string are ascii.; 1784 ; 1785Bool_t TString::IsAscii() const; 1786{; 1787 const char *cp = Data();; 1788 for (Ssiz_t i = 0; i < Length(); ++i); 1789 if (cp[i] & ~0x7F)",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:65478,Availability,error,error,65478,"62 if (comma > -1) {; 2063 //replace comma with decimal point; 2064 tmp.Replace(comma, 1, ""."");; 2065 }; 2066 //no whitespace ?; 2067 if (end == -1) return atof(tmp.Data());; 2068 //remove whitespace; 2069 Int_t start = 0;; 2070 TString tmp2;; 2071 while (end > -1) {; 2072 tmp2 += tmp(start, end-start);; 2073 start = end+1; end = tmp.Index("" "", start);; 2074 }; 2075 end = tmp.Length();; 2076 tmp2 += tmp(start, end-start);; 2077 return atof(tmp2.Data());; 2078}; 2079 ; 2080////////////////////////////////////////////////////////////////////////////////; 2081/// Converts an Int_t to a TString with respect to the base specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:66615,Availability,error,error,66615,"e base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/ito",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:67648,Availability,error,error,67648," 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Th",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:68798,Availability,error,error,68798," valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t bas",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:79884,Availability,down,down,79884,"51 ; 2452 if (gBfree == nullptr) {; 2453 gBfree = gFormbuf;; 2454 gEndbuf = &gFormbuf[cb_size-1];; 2455 }; 2456 char *buf = gBfree;; 2457 ; 2458 if (buf+fld_size > gEndbuf); 2459 buf = gFormbuf;; 2460 ; 2461 va_list sap;; 2462 R__VA_COPY(sap, ap);; 2463 ; 2464 int n = vsnprintf(buf, fld_size, format, ap);; 2465 // old vsnprintf's return -1 if string is truncated new ones return; 2466 // total number of characters that would have been written; 2467 if (n == -1 || n >= fld_size) {; 2468 va_end(ap);; 2469 R__VA_COPY(ap, sap);; 2470 buf = SlowFormat(format, ap, n);; 2471 va_end(sap);; 2472 va_end(ap);; 2473 return buf;; 2474 }; 2475 ; 2476 va_end(sap);; 2477 ; 2478 gBfree = buf+n+1;; 2479 return buf;; 2480}; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Formats a string in a circular formatting buffer. Removes the need to; 2484/// create and delete short lived strings. Don't pass Form() pointers; 2485/// from user code down to ROOT functions as the circular buffer may; 2486/// be overwritten downstream. Use Form() results immediately or use; 2487/// TString::Format() instead.; 2488 ; 2489char *Form(const char *va_(fmt), ...); 2490{; 2491 va_list ap;; 2492 va_start(ap,va_(fmt));; 2493 char *b = Format(va_(fmt), ap);; 2494 va_end(ap);; 2495 return b;; 2496}; 2497 ; 2498////////////////////////////////////////////////////////////////////////////////; 2499/// Formats a string in a circular formatting buffer and prints the string.; 2500/// Appends a newline. If gPrintViaErrorHandler is true it will print via the; 2501/// currently active ROOT error handler.; 2502 ; 2503void Printf(const char *va_(fmt), ...); 2504{; 2505 va_list ap;; 2506 va_start(ap,va_(fmt));; 2507 if (gPrintViaErrorHandler); 2508 ErrorHandler(kPrint, nullptr, va_(fmt), ap);; 2509 else {; 2510 char *b = Format(va_(fmt), ap);; 2511 printf(""%s\n"", b);; 2512 fflush(stdout);; 2513 }; 2514 va_end(ap);; 2515}; 2516 ; 2517///////////////////////////////////////",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:79958,Availability,down,downstream,79958,"51 ; 2452 if (gBfree == nullptr) {; 2453 gBfree = gFormbuf;; 2454 gEndbuf = &gFormbuf[cb_size-1];; 2455 }; 2456 char *buf = gBfree;; 2457 ; 2458 if (buf+fld_size > gEndbuf); 2459 buf = gFormbuf;; 2460 ; 2461 va_list sap;; 2462 R__VA_COPY(sap, ap);; 2463 ; 2464 int n = vsnprintf(buf, fld_size, format, ap);; 2465 // old vsnprintf's return -1 if string is truncated new ones return; 2466 // total number of characters that would have been written; 2467 if (n == -1 || n >= fld_size) {; 2468 va_end(ap);; 2469 R__VA_COPY(ap, sap);; 2470 buf = SlowFormat(format, ap, n);; 2471 va_end(sap);; 2472 va_end(ap);; 2473 return buf;; 2474 }; 2475 ; 2476 va_end(sap);; 2477 ; 2478 gBfree = buf+n+1;; 2479 return buf;; 2480}; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Formats a string in a circular formatting buffer. Removes the need to; 2484/// create and delete short lived strings. Don't pass Form() pointers; 2485/// from user code down to ROOT functions as the circular buffer may; 2486/// be overwritten downstream. Use Form() results immediately or use; 2487/// TString::Format() instead.; 2488 ; 2489char *Form(const char *va_(fmt), ...); 2490{; 2491 va_list ap;; 2492 va_start(ap,va_(fmt));; 2493 char *b = Format(va_(fmt), ap);; 2494 va_end(ap);; 2495 return b;; 2496}; 2497 ; 2498////////////////////////////////////////////////////////////////////////////////; 2499/// Formats a string in a circular formatting buffer and prints the string.; 2500/// Appends a newline. If gPrintViaErrorHandler is true it will print via the; 2501/// currently active ROOT error handler.; 2502 ; 2503void Printf(const char *va_(fmt), ...); 2504{; 2505 va_list ap;; 2506 va_start(ap,va_(fmt));; 2507 if (gPrintViaErrorHandler); 2508 ErrorHandler(kPrint, nullptr, va_(fmt), ap);; 2509 else {; 2510 char *b = Format(va_(fmt), ap);; 2511 printf(""%s\n"", b);; 2512 fflush(stdout);; 2513 }; 2514 va_end(ap);; 2515}; 2516 ; 2517///////////////////////////////////////",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:80515,Availability,error,error,80515,"nd(sap);; 2472 va_end(ap);; 2473 return buf;; 2474 }; 2475 ; 2476 va_end(sap);; 2477 ; 2478 gBfree = buf+n+1;; 2479 return buf;; 2480}; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Formats a string in a circular formatting buffer. Removes the need to; 2484/// create and delete short lived strings. Don't pass Form() pointers; 2485/// from user code down to ROOT functions as the circular buffer may; 2486/// be overwritten downstream. Use Form() results immediately or use; 2487/// TString::Format() instead.; 2488 ; 2489char *Form(const char *va_(fmt), ...); 2490{; 2491 va_list ap;; 2492 va_start(ap,va_(fmt));; 2493 char *b = Format(va_(fmt), ap);; 2494 va_end(ap);; 2495 return b;; 2496}; 2497 ; 2498////////////////////////////////////////////////////////////////////////////////; 2499/// Formats a string in a circular formatting buffer and prints the string.; 2500/// Appends a newline. If gPrintViaErrorHandler is true it will print via the; 2501/// currently active ROOT error handler.; 2502 ; 2503void Printf(const char *va_(fmt), ...); 2504{; 2505 va_list ap;; 2506 va_start(ap,va_(fmt));; 2507 if (gPrintViaErrorHandler); 2508 ErrorHandler(kPrint, nullptr, va_(fmt), ap);; 2509 else {; 2510 char *b = Format(va_(fmt), ap);; 2511 printf(""%s\n"", b);; 2512 fflush(stdout);; 2513 }; 2514 va_end(ap);; 2515}; 2516 ; 2517////////////////////////////////////////////////////////////////////////////////; 2518/// Strip leading and trailing c (blanks by default) from a string.; 2519/// The returned string has to be deleted by the user.; 2520 ; 2521char *Strip(const char *s, char c); 2522{; 2523 if (!s) return nullptr;; 2524 ; 2525 int l = strlen(s);; 2526 char *buf = new char[l+1];; 2527 ; 2528 if (l == 0) {; 2529 *buf = '\0';; 2530 return buf;; 2531 }; 2532 ; 2533 // get rid of leading c's; 2534 const char *t1 = s;; 2535 while (*t1 == c); 2536 t1++;; 2537 ; 2538 // get rid of trailing c's; 2539 const char *t2 = s + l - 1;; 2540 wh",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:86975,Availability,error,error,86975,":104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; kBitsPerByteconstexpr ULong_t kBitsPerByteDefinition RtypesCore.h:116; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; ULongptr_tunsigned long ULongptr_tDefinition RtypesCore.h:76; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualVie",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:87124,Availability,error,error,87124,"define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; kBitsPerByteconstexpr ULong_t kBitsPerByteDefinition RtypesCore.h:116; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; ULongptr_tunsigned long ULongptr_tDefinition RtypesCore.h:76; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; dat",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:87170,Availability,error,error,87170,"r_tunsigned char UChar_tDefinition RtypesCore.h:38; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; kBitsPerByteconstexpr ULong_t kBitsPerByteDefinition RtypesCore.h:116; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; ULongptr_tunsigned long ULongptr_tDefinition RtypesCore.h:76; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:87301,Availability,error,error,87301,"itsPerByteDefinition RtypesCore.h:116; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; ULongptr_tunsigned long ULongptr_tDefinition RtypesCore.h:76; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t O",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:87795,Availability,error,error,87795,"es.h:382; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t U",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:106876,Availability,error,error,106876,"mats a string using a printf style format descriptor.Definition TString.cxx:2310; TString::GetPointerchar * GetPointer()Definition TString.h:256; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TString::Recommendstatic Ssiz_t Recommend(Ssiz_t s)Definition TString.h:234; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::TSubStringTSubString(const TString &s, Ssiz_t start, Ssiz_t len)Private constructor.Definition TString.cxx:1631; TSubString::operator=TSubString & operator=(const char *s)Assign char* to sub-string.Definition TString.cxx:1696; TSubString::IsNullBool_t IsNull() constDefinition TString.h:129; TSubString::ToUppervoid ToUpper()Convert sub-string to upper-case.Definition TString.cxx:1754; TSubString::fStrTString & fStrDefinition TString.h:95; TSubString::SubStringErrorvoid SubStringError(Ssiz_t, Ssiz_t, Ssiz_t) constOutput error message.Definition TString.cxx:1766; TSubString::fBeginSsiz_t fBeginDefinition TString.h:96; TSubString::operator[]char & operator[](Ssiz_t i)Return character at pos i from sub-string. Check validity of i.Definition TString.cxx:1668; TSubString::fExtentSsiz_t fExtentDefinition TString.h:97; TSubString::AssertElementvoid AssertElement(Ssiz_t i) constCheck to make sure a sub-string index is in range.Definition TString.cxx:1775; TSubString::ToLowervoid ToLower()Convert sub-string to lower-case.Definition TString.cxx:1742; TSubString::Dataconst char * Data() constDefinition TString.h:736; TSubString::operator()char & operator()(Ssiz_t i)Return character at pos i from sub-string. No check on i.Definition TString.cxx:1677; TSubString::LengthSsiz_t Length() constDefinition TString.h:122; bool; double; int; unsigned int; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definit",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:7970,Energy Efficiency,allocate,allocated,7970,"; 246}; 247 ; 248////////////////////////////////////////////////////////////////////////////////; 249/// Delete a TString.; 250 ; 251TString::~TString(); 252{; 253 UnLink();; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Private member function returning an empty string representation of; 258/// size capacity and containing nchar characters.; 259/// \warning If nchar > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 260 ; 261char *TString::Init(Ssiz_t capacity, Ssiz_t nchar); 262{; 263 if (capacity < 0) {; 264 Error(""TString::Init"", ""Negative length!"");; 265 capacity = 0;; 266 }; 267 if (nchar < 0) {; 268 Error(""*TString::Init"", ""Negative length!"");; 269 nchar = 0;; 270 }; 271 if (nchar > capacity) {; 272 Error(""TString::Init"", ""capacity is smaller than nchar (%d > %d)"", nchar, capacity);; 273 nchar = capacity;; 274 }; 275 if (capacity > MaxSize()) {; 276 Fatal(""TString::Init"", ""capacity too large (%d, max = %d)"", capacity, MaxSize());; 277 capacity = MaxSize();; 278 if (nchar > capacity); 279 nchar = capacity;; 280 }; 281 ; 282 char *data;; 283 if (capacity < kMinCap) {; 284 SetShortSize(nchar);; 285 data = GetShortPointer();; 286 } else {; 287 Ssiz_t cap = Recommend(capacity);; 288 data = new char[cap+1];; 289 SetLongCap(cap+1);; 290 SetLongSize(nchar);; 291 SetLongPointer(data);; 292 }; 293 data[nchar] = 0; // terminating null; 294 ; 295 return data;; 296}; 297 ; 298////////////////////////////////////////////////////////////////////////////////; 299/// Assign character c to TString.; 300 ; 301TString& TString::operator=(char c); 302{; 303 if (!c) {; 304 UnLink();; 305 Zero();; 306 return *this;; 307 }; 308 return Replace(0, Length(), &c, 1);; 309}; 310 ; 311////////////////////////////////////////////////////////////////////////////////; 312/// Assign string cs to TString.; 313 ; 314TString& TString::operator=(const char *cs); 315{; 316 if (!cs || !*cs) {; 317 UnLink();; 318 Z",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:37982,Energy Efficiency,allocate,allocated,37982,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:38043,Energy Efficiency,allocate,allocated,38043,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:39149,Energy Efficiency,allocate,allocated,39149," {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity();; 1290 char *data, *p = GetPointer();; 1291 ; 1292 if (capac - tot < 0) {; 1293 Ssiz_t cap = Recommend(tot);; 1294 data = new char[cap+1];; 1295 memcpy(data, p, len);; 1296 UnLink();; 1297 SetLongCap(cap+1);; 1298 SetLongSize(len);; 1299 SetLongPointer(data);; 1300 data[len] = 0;; 1301 }; 1302}; 1303 ; 1304////////////////////////////////////////////////////////////////////////////////; 1305// ROOT I/O; 1306 ; 1307////////////////////////////////////////////////////////////////////////////////; 1308/// Copy string into I/O buffer.; 1309 ; 1310void TString::FillBuffer(char *&buffer) const; 1311{; 1312 UChar_t nwh;; 1313 Int_t nchars = Length();; 1314 ; 1315 if (nchars > 254) {; 1316 nwh = 255;; 1317 tobuf(buffer, nwh);; 1318 tobuf(buffer, nchars);; 1319 } else {; 1320 nwh = UChar_t(nchars);; 1321 tobuf(buffer, nwh);; 1322 }; 1323 const char *data = GetPointer();; 1324 for (int i = 0; i < nchars; i++) buffer[i] = data[i];; 1325 buffer += nchars;; 1326}; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Re",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:65072,Energy Efficiency,adapt,adapted,65072,"; 2052/// ~~~; 2053 ; 2054Double_t TString::Atof() const; 2055{; 2056 //look for a comma and some whitespace; 2057 Int_t comma = Index("","");; 2058 Int_t end = Index("" "");; 2059 //if no commas & no whitespace in string, just use atof(); 2060 if (comma == -1 && end == -1) return atof(Data());; 2061 TString tmp = *this;; 2062 if (comma > -1) {; 2063 //replace comma with decimal point; 2064 tmp.Replace(comma, 1, ""."");; 2065 }; 2066 //no whitespace ?; 2067 if (end == -1) return atof(tmp.Data());; 2068 //remove whitespace; 2069 Int_t start = 0;; 2070 TString tmp2;; 2071 while (end > -1) {; 2072 tmp2 += tmp(start, end-start);; 2073 start = end+1; end = tmp.Index("" "", start);; 2074 }; 2075 end = tmp.Length();; 2076 tmp2 += tmp(start, end-start);; 2077 return atof(tmp2.Data());; 2078}; 2079 ; 2080////////////////////////////////////////////////////////////////////////////////; 2081/// Converts an Int_t to a TString with respect to the base specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quot",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:65836,Energy Efficiency,allocate,allocate,65836,"specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=k",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:66519,Energy Efficiency,adapt,adapted,66519,"ng.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:66975,Energy Efficiency,allocate,allocate,66975,"7 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:67543,Energy Efficiency,adapt,adapted,67543,"rom versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166//",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:68010,Energy Efficiency,allocate,allocate,68010,"2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:68702,Energy Efficiency,adapt,adapted,68702,"144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:69163,Energy Efficiency,allocate,allocate,69163,"the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); 2195{; 2196 TString s_out = ""!"" ; // return value in case of issue; 2197 // checking base range; 2198 if (base_in < 2 || base_in > 36 || base_out < 2 || base_out > 36) {; 2199 Error(""TString::BaseConvert"", ""only bases 2-36 are supported (base_in=%d, base_out=%d)."", base_in, base_out);; 2200 return (s_out);; 2201 }; 2202 // cleaning s_in; 2203 TString s_in_ = s_in;; 2204 Bool_t isSigned = kFALSE;; 2205 if (s_in_[0] == '-') {; 2206 isSigned = kTRUE;; 2207 s_in_.Rem",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:94367,Energy Efficiency,allocate,allocated,94367," in src from escchar and copy to dst.Definition TString.cxx:2617; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *str)Duplicate the string str.Definition TString.cxx:2557; EscCharint EscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Escape specchars in src with escchar and copy to dst.Definition TString.cxx:2593; TVirtualMutex.h; ThreadLocalStorage.h; Varargs.h; R__VA_COPY#define R__VA_COPY(to, from)Definition Varargs.h:48; va_#define va_(arg)Definition Varargs.h:35; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25537,Integrability,depend,depending,25537," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:54291,Integrability,message,message,54291,"tor==(const TSubString &s1, const TSubString &s2); 1732{; 1733 if (s1.IsNull()) return s2.IsNull();; 1734 if (s1.fExtent != s2.fExtent) return kFALSE;; 1735 return !memcmp(s1.fStr.Data()+s1.fBegin, s2.fStr.Data()+s2.fBegin,; 1736 s1.fExtent);; 1737}; 1738 ; 1739////////////////////////////////////////////////////////////////////////////////; 1740/// Convert sub-string to lower-case.; 1741 ; 1742void TSubString::ToLower(); 1743{; 1744 if (!IsNull()) { // Ignore null substrings; 1745 char *p = fStr.GetPointer() + fBegin;; 1746 Ssiz_t n = fExtent;; 1747 while (n--) { *p = tolower((unsigned char)*p); p++;}; 1748 }; 1749}; 1750 ; 1751////////////////////////////////////////////////////////////////////////////////; 1752/// Convert sub-string to upper-case.; 1753 ; 1754void TSubString::ToUpper(); 1755{; 1756 if (!IsNull()) { // Ignore null substrings; 1757 char *p = fStr.GetPointer() + fBegin;; 1758 Ssiz_t n = fExtent;; 1759 while (n--) { *p = toupper((unsigned char)*p); p++;}; 1760 }; 1761}; 1762 ; 1763////////////////////////////////////////////////////////////////////////////////; 1764/// Output error message.; 1765 ; 1766void TSubString::SubStringError(Ssiz_t sr, Ssiz_t start, Ssiz_t n) const; 1767{; 1768 Error(""TSubString::SubStringError"",; 1769 ""out of bounds: start = %d, n = %d, sr = %d"", start, n, sr);; 1770}; 1771 ; 1772////////////////////////////////////////////////////////////////////////////////; 1773/// Check to make sure a sub-string index is in range.; 1774 ; 1775void TSubString::AssertElement(Ssiz_t i) const; 1776{; 1777 if (i == kNPOS || i >= Length()); 1778 Error(""TSubString::AssertElement"",; 1779 ""out of bounds: i = %d, Length = %d"", i, Length());; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Returns true if all characters in string are ascii.; 1784 ; 1785Bool_t TString::IsAscii() const; 1786{; 1787 const char *cp = Data();; 1788 for (Ssiz_t i = 0; i < Length(); ++i); 1789 if (cp[i] & ~0x7F)",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:94690,Integrability,message,message-digest,94690,"*specchars, char escchar)Escape specchars in src with escchar and copy to dst.Definition TString.cxx:2593; TVirtualMutex.h; ThreadLocalStorage.h; Varargs.h; R__VA_COPY#define R__VA_COPY(to, from)Definition Varargs.h:48; va_#define va_(arg)Definition Varargs.h:35; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::CopyTString Copy() constCopy a string.Definition TString.cxx:529; TString::UItoastatic TString UItoa(UInt_t value, Int_t base)Converts a UInt_t (twice the range of an Int_t) to a TS",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:94787,Integrability,message,message,94787,"String.cxx:2593; TVirtualMutex.h; ThreadLocalStorage.h; Varargs.h; R__VA_COPY#define R__VA_COPY(to, from)Definition Varargs.h:48; va_#define va_(arg)Definition Varargs.h:35; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::CopyTString Copy() constCopy a string.Definition TString.cxx:529; TString::UItoastatic TString UItoa(UInt_t value, Int_t base)Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36...Definition TString.cxx:2119; TString::Len",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:95050,Integrability,message,message-digest,95050,"t classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::CopyTString Copy() constCopy a string.Definition TString.cxx:529; TString::UItoastatic TString UItoa(UInt_t value, Int_t base)Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36...Definition TString.cxx:2119; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::TSubStringfriend class TSubStringDefinition TString.h:142; TString::LLtoastatic TString LLtoa(Long64_t value, Int_t base)Converts a Long64_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2144;",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:95092,Integrability,message,message,95092,"t classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::CopyTString Copy() constCopy a string.Definition TString.cxx:529; TString::UItoastatic TString UItoa(UInt_t value, Int_t base)Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36...Definition TString.cxx:2119; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::TSubStringfriend class TSubStringDefinition TString.h:142; TString::LLtoastatic TString LLtoa(Long64_t value, Int_t base)Converts a Long64_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2144;",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:106882,Integrability,message,message,106882,"mats a string using a printf style format descriptor.Definition TString.cxx:2310; TString::GetPointerchar * GetPointer()Definition TString.h:256; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TString::Recommendstatic Ssiz_t Recommend(Ssiz_t s)Definition TString.h:234; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::TSubStringTSubString(const TString &s, Ssiz_t start, Ssiz_t len)Private constructor.Definition TString.cxx:1631; TSubString::operator=TSubString & operator=(const char *s)Assign char* to sub-string.Definition TString.cxx:1696; TSubString::IsNullBool_t IsNull() constDefinition TString.h:129; TSubString::ToUppervoid ToUpper()Convert sub-string to upper-case.Definition TString.cxx:1754; TSubString::fStrTString & fStrDefinition TString.h:95; TSubString::SubStringErrorvoid SubStringError(Ssiz_t, Ssiz_t, Ssiz_t) constOutput error message.Definition TString.cxx:1766; TSubString::fBeginSsiz_t fBeginDefinition TString.h:96; TSubString::operator[]char & operator[](Ssiz_t i)Return character at pos i from sub-string. Check validity of i.Definition TString.cxx:1668; TSubString::fExtentSsiz_t fExtentDefinition TString.h:97; TSubString::AssertElementvoid AssertElement(Ssiz_t i) constCheck to make sure a sub-string index is in range.Definition TString.cxx:1775; TSubString::ToLowervoid ToLower()Convert sub-string to lower-case.Definition TString.cxx:1742; TSubString::Dataconst char * Data() constDefinition TString.h:736; TSubString::operator()char & operator()(Ssiz_t i)Return character at pos i from sub-string. No check on i.Definition TString.cxx:1677; TSubString::LengthSsiz_t Length() constDefinition TString.h:122; bool; double; int; unsigned int; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definit",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:2445,Modifiability,variab,variable,2445,"#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Create TString able to contain ic characters.; 94 ; 95TString::TString(Ssiz_t ic); 96{; 97 Init(ic, 0);; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Create TString and initialize it with string cs.; 102 ; 103TString::TString(const char *cs); 104{; 105 if (cs) {; 106 Ssiz_t n = strlen(cs);; 107 char *d",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:65043,Modifiability,enhance,enhanced,65043,"; 2052/// ~~~; 2053 ; 2054Double_t TString::Atof() const; 2055{; 2056 //look for a comma and some whitespace; 2057 Int_t comma = Index("","");; 2058 Int_t end = Index("" "");; 2059 //if no commas & no whitespace in string, just use atof(); 2060 if (comma == -1 && end == -1) return atof(Data());; 2061 TString tmp = *this;; 2062 if (comma > -1) {; 2063 //replace comma with decimal point; 2064 tmp.Replace(comma, 1, ""."");; 2065 }; 2066 //no whitespace ?; 2067 if (end == -1) return atof(tmp.Data());; 2068 //remove whitespace; 2069 Int_t start = 0;; 2070 TString tmp2;; 2071 while (end > -1) {; 2072 tmp2 += tmp(start, end-start);; 2073 start = end+1; end = tmp.Index("" "", start);; 2074 }; 2075 end = tmp.Length();; 2076 tmp2 += tmp(start, end-start);; 2077 return atof(tmp2.Data());; 2078}; 2079 ; 2080////////////////////////////////////////////////////////////////////////////////; 2081/// Converts an Int_t to a TString with respect to the base specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quot",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:65072,Modifiability,adapt,adapted,65072,"; 2052/// ~~~; 2053 ; 2054Double_t TString::Atof() const; 2055{; 2056 //look for a comma and some whitespace; 2057 Int_t comma = Index("","");; 2058 Int_t end = Index("" "");; 2059 //if no commas & no whitespace in string, just use atof(); 2060 if (comma == -1 && end == -1) return atof(Data());; 2061 TString tmp = *this;; 2062 if (comma > -1) {; 2063 //replace comma with decimal point; 2064 tmp.Replace(comma, 1, ""."");; 2065 }; 2066 //no whitespace ?; 2067 if (end == -1) return atof(tmp.Data());; 2068 //remove whitespace; 2069 Int_t start = 0;; 2070 TString tmp2;; 2071 while (end > -1) {; 2072 tmp2 += tmp(start, end-start);; 2073 start = end+1; end = tmp.Index("" "", start);; 2074 }; 2075 end = tmp.Length();; 2076 tmp2 += tmp(start, end-start);; 2077 return atof(tmp2.Data());; 2078}; 2079 ; 2080////////////////////////////////////////////////////////////////////////////////; 2081/// Converts an Int_t to a TString with respect to the base specified (2-36).; 2082/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2083/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2084/// Usage: the following statement produce the same output, namely ""1111""; 2085/// ~~~ {.cpp}; 2086/// std::cout << TString::Itoa(15,2) ;; 2087/// std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; 2088/// std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; 2089/// ~~~; 2090/// In case of error returns the ""!"" string.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quot",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:66481,Modifiability,enhance,enhanced,66481,"ng.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:66519,Modifiability,adapt,adapted,66519,"ng.; 2091 ; 2092TString TString::Itoa(Int_t value, Int_t base); 2093{; 2094 std::string buf;; 2095 // check that the base if valid; 2096 if (base < 2 || base > 36) {; 2097 Error(""TString::Itoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base) ;; 2098 return (TString(""!""));; 2099 }; 2100 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2101 Int_t quotient = value;; 2102 // Translating number to string with base:; 2103 do {; 2104 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2105 quotient /= base;; 2106 } while (quotient);; 2107 // Append the negative sign; 2108 if (value < 0) buf += '-';; 2109 std::reverse(buf.begin(), buf.end());; 2110 return (TString(buf.data()));; 2111}; 2112 ; 2113////////////////////////////////////////////////////////////////////////////////; 2114/// Converts a UInt_t (twice the range of an Int_t) to a TString with respect; 2115/// to the base specified (2-36). Thus it is an enhanced version of sprintf; 2116/// (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:67514,Modifiability,enhance,enhanced,67514,"rom versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166//",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:67543,Modifiability,adapt,adapted,67543,"rom versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2117/// In case of error returns the ""!"" string.; 2118 ; 2119TString TString::UItoa(UInt_t value, Int_t base); 2120{; 2121 std::string buf;; 2122 // check that the base if valid; 2123 if (base < 2 || base > 36) {; 2124 Error(""TString::UItoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2125 return (TString(""!""));; 2126 }; 2127 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2128 UInt_t quotient = value;; 2129 // Translating number to string with base:; 2130 do {; 2131 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2132 quotient /= base;; 2133 } while (quotient);; 2134 std::reverse(buf.begin(), buf.end());; 2135 return (TString(buf.data()));; 2136}; 2137 ; 2138////////////////////////////////////////////////////////////////////////////////; 2139/// Converts a Long64_t to a TString with respect to the base specified (2-36).; 2140/// Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; 2141/// http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2142/// In case of error returns the ""!"" string.; 2143 ; 2144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166//",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:68664,Modifiability,enhance,enhanced,68664,"144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:68702,Modifiability,adapt,adapted,68702,"144TString TString::LLtoa(Long64_t value, Int_t base); 2145{; 2146 std::string buf;; 2147 // check that the base if valid; 2148 if (base < 2 || base > 36) {; 2149 Error(""TString::LLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2150 return (TString(""!""));; 2151 }; 2152 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2153 Long64_t quotient = value;; 2154 // Translating number to string with base:; 2155 do {; 2156 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ TMath::Abs(quotient % base) ];; 2157 quotient /= base;; 2158 } while (quotient);; 2159 // Append the negative sign; 2160 if (value < 0) buf += '-';; 2161 std::reverse(buf.begin(), buf.end());; 2162 return (TString(buf.data()));; 2163}; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Converts a ULong64_t (twice the range of an Long64_t) to a TString with; 2167/// respect to the base specified (2-36). Thus it is an enhanced version of; 2168/// sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; 2169/// In case of error returns the ""!"" string.; 2170 ; 2171TString TString::ULLtoa(ULong64_t value, Int_t base); 2172{; 2173 std::string buf;; 2174 // check that the base if valid; 2175 if (base < 2 || base > 36) {; 2176 Error(""TString::ULLtoa"", ""base %d is not supported. Supported bases are {2,3,...,36}."",base);; 2177 return (TString(""!""));; 2178 }; 2179 buf.reserve(35); // Pre-allocate enough space (35=kMaxDigits); 2180 ULong64_t quotient = value;; 2181 // Translating number to string with base:; 2182 do {; 2183 buf += ""0123456789abcdefghijklmnopqrstuvwxyz""[ quotient % base ];; 2184 quotient /= base;; 2185 } while (quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:20091,Performance,optimiz,optimized,20091,"; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 70",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:20597,Performance,optimiz,optimized,20597,"st unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:20715,Performance,perform,performance,20715,"////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r ); 721 {; 722 return (x << r) | (x >> (64 - r));; 723 }; 724 ; 725#define ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !d",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:2122,Safety,avoid,avoid,2122,"ing class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Crea",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:38010,Safety,abort,abort,38010,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:38304,Safety,abort,abort,38304,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:38422,Safety,avoid,avoid,38422,"ap, 2 * oldCap)) : ms - 1;; 1229 return cap;; 1230}; 1231 ; 1232////////////////////////////////////////////////////////////////////////////////; 1233/// Clear string without changing its capacity.; 1234 ; 1235void TString::Clear(); 1236{; 1237 Clobber(Capacity());; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Clear string and make sure it has a capacity of nc.; 1242/// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); 1243/// elements are allocated if Fatal does not abort; 1244/// \return Resulting allocated capacity (after clamping, if needed); 1245 ; 1246Ssiz_t TString::Clobber(Ssiz_t nc); 1247{; 1248 if (nc > MaxSize()) {; 1249 Fatal(""TString::Clobber"", ""capacity too large (%d, max = %d)"", nc, MaxSize());; 1250 // In the rare case where Fatal does not abort, we erase, clamp and continue; 1251 UnLink();; 1252 Zero();; 1253 nc = MaxSize(); // Clamping after deleting to avoid corruption; 1254 }; 1255 ; 1256 if (nc < kMinCap) {; 1257 UnLink();; 1258 Zero();; 1259 } else {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity()",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:49478,Safety,detect,detected,49478,"-32-00"");; 1596 return 15;; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Set default resize increment for all TStrings. Default is 16.; 1601 ; 1602Ssiz_t TString::ResizeIncrement(Ssiz_t); 1603{; 1604 ::Obsolete(""TString::ResizeIncrement"", ""v5-30-00"", ""v5-32-00"");; 1605 return 16;; 1606}; 1607 ; 1608////////////////////////////////////////////////////////////////////////////////; 1609/// Set maximum space that may be wasted in a string before doing a resize.; 1610/// Default is 15.; 1611 ; 1612Ssiz_t TString::MaxWaste(Ssiz_t); 1613{; 1614 ::Obsolete(""TString::MaxWaste"", ""v5-30-00"", ""v5-32-00"");; 1615 return 15;; 1616}; 1617 ; 1618/** \class TSubString; 1619A zero length substring is legal. It can start; 1620at any character. It is considered to be ""pointing""; 1621to just before the character.; 1622 ; 1623A ""null"" substring is a zero length substring that; 1624starts with the nonsense index kNPOS. It can; 1625be detected with the member function IsNull().; 1626*/; 1627 ; 1628////////////////////////////////////////////////////////////////////////////////; 1629/// Private constructor.; 1630 ; 1631TSubString::TSubString(const TString &str, Ssiz_t start, Ssiz_t nextent); 1632 : fStr((TString&)str), fBegin(start), fExtent(nextent); 1633{; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return sub-string of string starting at start with length len.; 1638 ; 1639TSubString TString::operator()(Ssiz_t start, Ssiz_t len) const; 1640{; 1641 if (start < Length() && len > 0) {; 1642 if (start+len > Length()); 1643 len = Length() - start;; 1644 } else {; 1645 start = kNPOS;; 1646 len = 0;; 1647 }; 1648 return TSubString(*this, start, len);; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Returns a substring matching ""pattern"", or the null substring; 1653/// if there is no such match. It would be nice if",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:70387,Safety,avoid,avoid,70387,"(quotient);; 2186 std::reverse(buf.begin(), buf.end());; 2187 return (TString(buf.data()));; 2188}; 2189 ; 2190////////////////////////////////////////////////////////////////////////////////; 2191/// Converts string from base base_in to base base_out. Supported bases; 2192/// are 2-36. At most 64 bit data can be converted.; 2193 ; 2194TString TString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); 2195{; 2196 TString s_out = ""!"" ; // return value in case of issue; 2197 // checking base range; 2198 if (base_in < 2 || base_in > 36 || base_out < 2 || base_out > 36) {; 2199 Error(""TString::BaseConvert"", ""only bases 2-36 are supported (base_in=%d, base_out=%d)."", base_in, base_out);; 2200 return (s_out);; 2201 }; 2202 // cleaning s_in; 2203 TString s_in_ = s_in;; 2204 Bool_t isSigned = kFALSE;; 2205 if (s_in_[0] == '-') {; 2206 isSigned = kTRUE;; 2207 s_in_.Remove(0, 1);; 2208 }; 2209 if (!isSigned && s_in_[0] == '+') s_in_.Remove(0, 1); // !isSigned to avoid strings beginning with ""-+""; 2210 if (base_in == 16 && s_in_.BeginsWith(""0x"")) s_in_.Remove(0, 2); // removing hex prefix if any; 2211 s_in_ = TString(s_in_.Strip(TString::kLeading, '0')); // removing leading zeros (necessary for length comparison below); 2212 if (!s_in_.Length()) s_in_ += '0';; 2213 // checking s_in_ is expressed in the mentioned base; 2214 if (!s_in_.IsInBaseN(base_in)) {; 2215 Error(""TString::BaseConvert"", ""s_in=\""%s\"" is not in base %d"", s_in.Data(), base_in);; 2216 return (s_out);; 2217 }; 2218 // checking s_in <= 64 bits; 2219 TString s_max = TString::ULLtoa(18446744073709551615ULL, base_in);; 2220 if (s_in_.Length() > s_max.Length()) {; 2221 // string comparison (s_in_>s_max) does not take care of length; 2222 Error(""TString::BaseConvert"", ""s_in=\""%s\"" > %s = 2^64-1 in base %d."", s_in.Data(), s_max.Data(), base_in);; 2223 return (s_out);; 2224 } else if (s_in_.Length() == s_max.Length()) {; 2225 // if ( s_in_.Length() < s_max.Length() ) everything's fine; 2226 s_in_.ToLower(",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:74376,Safety,abort,abort,74376,"+it) {; 2293#endif; 2294 Int_t stop = *it;; 2295 if (stop - 1 >= start + 1) {; 2296 TString tok = (*this)(start+1, stop-start-1);; 2297 TObjString *objstr = new TObjString(tok);; 2298 arr->Add(objstr);; 2299 }; 2300 start = stop;; 2301 }; 2302 ; 2303 return arr;; 2304}; 2305 ; 2306////////////////////////////////////////////////////////////////////////////////; 2307/// Formats a string using a printf style format descriptor.; 2308/// Existing string contents will be overwritten.; 2309 ; 2310void TString::FormImp(const char *fmt, va_list ap); 2311{; 2312 Ssiz_t buflen = 20 + 20 * strlen(fmt); // pick a number, any strictly positive number; 2313 buflen = Clobber(buflen); // Update buflen, as Clobber clamps length to MaxSize (if Fatal does not abort); 2314 ; 2315 va_list sap;; 2316 R__VA_COPY(sap, ap);; 2317 ; 2318 int n, vc = 0;; 2319again:; 2320 n = vsnprintf(GetPointer(), buflen, fmt, ap);; 2321 // old vsnprintf's return -1 if string is truncated new ones return; 2322 // total number of characters that would have been written; 2323 if (n == -1 || n >= buflen) {; 2324 if (n == -1); 2325 buflen *= 2;; 2326 else; 2327 buflen = n+1;; 2328 buflen = Clobber(buflen);; 2329 va_end(ap);; 2330 R__VA_COPY(ap, sap);; 2331 vc = 1;; 2332 goto again;; 2333 }; 2334 va_end(sap);; 2335 if (vc); 2336 va_end(ap);; 2337 ; 2338 SetSize(strlen(Data()));; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342/// Formats a string using a printf style format descriptor.; 2343/// Existing string contents will be overwritten.; 2344/// See also the static version TString::Format; 2345/// ~~~ {.cpp}; 2346/// TString formatted;; 2347/// formatted.Form(""%s in <%s>: %s"", type, location, msg);; 2348///; 2349/// lines.emplace_back(TString::Format(""Welcome to ROOT %s%%shttp://root.cern"",; 2350/// gROOT->GetVersion()));; 2351/// ~~~; 2352///; 2353/// Note: this is not to be confused with ::Format and ::Form (in the global namespace); 2354/// which return",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:87810,Safety,abort,abort,87810,"tor<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kPrintconstexpr Int_t kPrintDefinition TError.h:44; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefin",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:820,Security,access,accessed,820,". ROOT: core/base/src/TString.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TString.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 04/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TString; 13\ingroup Base; 14 ; 15Basic string class.; 16 ; 17Cannot be stored in a TCollection... use TObjString instead.; 18 ; 19The underlying string is stored as a char* that can be accessed via; 20TString::Data().; 21TString provides Short String Optimization (SSO) so that short; 22strings (<15 on 64-bit and <11 on 32-bit) are contained in the; 23TString internal data structure without the need for mallocing the; 24required space.; 25 ; 26Substring operations are provided by the TSubString class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLO",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:2107,Security,hash,hash,2107,"ing class, which; 27holds a reference to the original string and its data, along with; 28the offset and length of the substring. To retrieve the substring; 29as a TString, construct a TString from it, eg:; 30~~~ {.cpp}; 31 root [0] TString s(""hello world""); 32 root [1] TString s2( s(0,5) ); 33 root [2] s2; 34 (class TString)""hello""; 35~~~; 36*/; 37 ; 38#include <ROOT/RConfig.hxx>; 39#include <stdlib.h>; 40#include <ctype.h>; 41#include <list>; 42#include <algorithm>; 43 ; 44#include ""Varargs.h""; 45#include ""strlcpy.h""; 46#include ""TString.h""; 47#include ""TBuffer.h""; 48#include ""TError.h""; 49#include ""Bytes.h""; 50#include ""TClass.h""; 51#include ""TMD5.h""; 52#include ""TObjArray.h""; 53#include ""TObjString.h""; 54#include ""TVirtualMutex.h""; 55#include ""ThreadLocalStorage.h""; 56 ; 57#if defined(R__WIN32); 58#define strtoull _strtoui64; 59#endif; 60 ; 61#ifdef R__GLOBALSTL; 62namespace std { using ::list; }; 63#endif; 64 ; 65ClassImp(TString);; 66 ; 67// Amount to shift hash values to avoid clustering; 68const UInt_t kHashShift = 5;; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71//; 72// In what follows, fCap is the length of the underlying representation; 73// vector. Hence, the capacity for a null terminated string held in this; 74// vector is fCap-1. The variable fSize is the length of the held; 75// string, excluding the terminating null.; 76//; 77// The algorithms make no assumptions about whether internal strings; 78// hold embedded nulls. However, they do assume that any string; 79// passed in as an argument that does not have a length count is null; 80// terminated and therefore has no embedded nulls.; 81//; 82// The internal string is always null terminated.; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// TString default ctor.; 86 ; 87TString::TString(); 88{; 89 Zero();; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Crea",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:16803,Security,hash,hash,16803,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:16834,Security,hash,hash,16834,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:16857,Security,hash,hash,16857,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:16885,Security,hash,hash,16885,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:17069,Security,hash,hash,17069,"rst(char c) const; 539{; 540 const char *f = strchr(Data(), c);; 541 return f ? f - Data() : kNPOS;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////////; 545/// Find first occurrence of a character in cs.; 546 ; 547Ssiz_t TString::First(const char *cs) const; 548{; 549 const char *f = strpbrk(Data(), cs);; 550 return f ? f - Data() : kNPOS;; 551}; 552 ; 553#ifndef R__BYTESWAP; 554////////////////////////////////////////////////////////////////////////////////; 555 ; 556inline static UInt_t SwapInt(UInt_t x); 557{; 558 return (((x & 0x000000ffU) << 24) | ((x & 0x0000ff00U) << 8) |; 559 ((x & 0x00ff0000U) >> 8) | ((x & 0xff000000U) >> 24));; 560}; 561#endif; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Utility used by Hash().; 565 ; 566inline static void Mash(UInt_t& hash, UInt_t chars); 567{; 568 hash = (chars ^; 569 ((hash << kHashShift) |; 570 (hash >> (kBitsPerByte*sizeof(UInt_t) - kHashShift))));; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Return a case-sensitive hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:18538,Security,hash,hash,18538,"hash value (endian independent).; 575 ; 576UInt_t Hash(const char *str); 577{; 578 UInt_t len = str ? strlen(str) : 0;; 579 UInt_t hv = len; // Mix in the string length.; 580 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 581 ; 582 if (((ULongptr_t)str)%sizeof(UInt_t) == 0) {; 583 // str is word aligned; 584 const UInt_t *p = (const UInt_t*)str;; 585 ; 586 while (i--) {; 587#ifndef R__BYTESWAP; 588 UInt_t h = *p++;; 589 Mash(hv, SwapInt(h));; 590#else; 591 Mash(hv, *p++); // XOR in the characters.; 592#endif; 593 }; 594 ; 595 // XOR in any remaining characters:; 596 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 597 UInt_t h = 0;; 598 const char* c = (const char*)p;; 599 while (i--); 600 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 601 Mash(hv, h);; 602 }; 603 } else {; 604 // str is not word aligned; 605 UInt_t h;; 606 const unsigned char *p = (const unsigned char*)str;; 607 ; 608 while (i--) {; 609 memcpy(&h, p, sizeof(UInt_t));; 610#ifndef R__BYTESWAP; 611 Mash(hv, SwapInt(h));; 612#else; 613 Mash(hv, h);; 614#endif; 615 p += sizeof(UInt_t);; 616 }; 617 ; 618 // XOR in any remaining characters:; 619 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 620 h = 0;; 621 const char* c = (const char*)p;; 622 while (i--); 623 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 624 Mash(hv, h);; 625 }; 626 }; 627 return hv;; 628}; 629 ; 630////////////////////////////////////////////////////////////////////////////////; 631/// Return a case-sensitive hash value (endian independent).; 632 ; 633UInt_t TString::HashCase() const; 634{; 635 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 636 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 637 const UInt_t *p = (const UInt_t*)Data();; 638 {; 639 while (i--) {; 640#ifndef R__BYTESWAP; 641 UInt_t h = *p++;; 642 Mash(hv, SwapInt(h)); // XOR in the characters.; 643#else; 644 Mash(hv, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:19383,Security,hash,hash,19383,"; 619 if ((i = len*sizeof(char)%sizeof(UInt_t)) != 0) {; 620 h = 0;; 621 const char* c = (const char*)p;; 622 while (i--); 623 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 624 Mash(hv, h);; 625 }; 626 }; 627 return hv;; 628}; 629 ; 630////////////////////////////////////////////////////////////////////////////////; 631/// Return a case-sensitive hash value (endian independent).; 632 ; 633UInt_t TString::HashCase() const; 634{; 635 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 636 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 637 const UInt_t *p = (const UInt_t*)Data();; 638 {; 639 while (i--) {; 640#ifndef R__BYTESWAP; 641 UInt_t h = *p++;; 642 Mash(hv, SwapInt(h)); // XOR in the characters.; 643#else; 644 Mash(hv, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(UInt_t)) != 0) {; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We us",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:19805,Security,hash,hash,19805,"g length.; 636 UInt_t i = hv*sizeof(char)/sizeof(UInt_t);; 637 const UInt_t *p = (const UInt_t*)Data();; 638 {; 639 while (i--) {; 640#ifndef R__BYTESWAP; 641 UInt_t h = *p++;; 642 Mash(hv, SwapInt(h)); // XOR in the characters.; 643#else; 644 Mash(hv, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(UInt_t)) != 0) {; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and r",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:20002,Security,hash,hash,20002,"v, *p++); // XOR in the characters.; 645#endif; 646 }; 647 }; 648 // XOR in any remaining characters:; 649 if ((i = Length()*sizeof(char)%sizeof(UInt_t)) != 0) {; 650 UInt_t h = 0;; 651 const char* c = (const char*)p;; 652 while (i--); 653 h = ((h << kBitsPerByte*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and mac",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:20160,Security,hash,hash,20160,"te*sizeof(char)) | *c++);; 654 Mash(hv, h);; 655 }; 656 return hv;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Return a case-insensitive hash value (endian independent).; 661 ; 662UInt_t TString::HashFoldCase() const; 663{; 664 UInt_t hv = (UInt_t)Length(); // Mix in the string length.; 665 UInt_t i = hv;; 666 const unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_V",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:22216,Security,hash,hash,22216," && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r ); 721 {; 722 return (x << r) | (x >> (64 - r));; 723 }; 724 ; 725#define ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !defined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uin",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:22593,Security,hash,hashed,22593," && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r ); 721 {; 722 return (x << r) | (x >> (64 - r));; 723 }; 724 ; 725#define ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !defined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uin",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:22642,Security,hash,hash,22642,"fine ROTL64(x,y) rotl64(x,y); 726#define BIG_CONSTANT(x) (x##LLU); 727#endif // !defined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uint64_t h1 = seed;; 767 uint64_t h2 = seed;; 768 ; 769 uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);; 770 uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);; 771 ; 772 //----------; 773 // body; 774 ; 775 const uint64_t * blocks = (const uint64_t *)(data);; 776 ; 777 for(int i = 0; i < nblocks; i++); 778 {; 779 uint64_t k1 = getblock(blocks,i*2+0);; 780 uint64_t k2 = getblock(blocks,i*2+1);; 781 ; 782 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 783 ; 784 h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;; 785 ; 786 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 787 ; 788 h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;; ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:22687,Security,hash,hash,22687,"ined(_MSC_VER); 728 ; 729namespace {; 730 ; 731 /////////////////////////////////////////////////////////////////////////////; 732 /// Block read - if your platform needs to do endian-swapping or can only; 733 /// handle aligned reads, do the conversion here; 734 ; 735 R__ALWAYS_INLINE uint64_t getblock(const uint64_t* p, int i); 736 {; 737 return p[i];; 738 }; 739 ; 740 /////////////////////////////////////////////////////////////////////////////; 741 /// Finalization mix - force all bits of a hash block to avalanche; 742 ; 743 R__ALWAYS_INLINE uint64_t fmix(uint64_t k); 744 {; 745 k ^= k >> 33;; 746 k *= BIG_CONSTANT(0xff51afd7ed558ccd);; 747 k ^= k >> 33;; 748 k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);; 749 k ^= k >> 33;; 750 ; 751 return k;; 752 }; 753 ; 754 /////////////////////////////////////////////////////////////////////////////; 755 /// ""key"" is input to be hashed.; 756 /// ""len"" is the number of bytes to hash starting at ""key"".; 757 /// ""seed"" is a hash seed, ""out"" is a buffer (128 bytes) that will receive; 758 /// the results.; 759 ; 760 static void MurmurHash3_x64_128(const void * key, const int len,; 761 const uint32_t seed, uint64_t out[2] ); 762 {; 763 const uint8_t * data = (const uint8_t*)key;; 764 const int nblocks = len / 16;; 765 ; 766 uint64_t h1 = seed;; 767 uint64_t h2 = seed;; 768 ; 769 uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);; 770 uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);; 771 ; 772 //----------; 773 // body; 774 ; 775 const uint64_t * blocks = (const uint64_t *)(data);; 776 ; 777 for(int i = 0; i < nblocks; i++); 778 {; 779 uint64_t k1 = getblock(blocks,i*2+0);; 780 uint64_t k2 = getblock(blocks,i*2+1);; 781 ; 782 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 783 ; 784 h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;; 785 ; 786 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 787 ; 788 h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;; 789 }; 790 ; 791 //----------; 792 // tail; 793 ; 794 const uint8_t * tail = (const",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25244,Security,hash,hash,25244,"< nblocks; i++); 778 {; 779 uint64_t k1 = getblock(blocks,i*2+0);; 780 uint64_t k2 = getblock(blocks,i*2+1);; 781 ; 782 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 783 ; 784 h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;; 785 ; 786 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 787 ; 788 h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;; 789 }; 790 ; 791 //----------; 792 // tail; 793 ; 794 const uint8_t * tail = (const uint8_t*)(data + nblocks*16);; 795 ; 796 uint64_t k1 = 0;; 797 uint64_t k2 = 0;; 798 ; 799 switch(len & 15) {; 800 case 15: k2 ^= uint64_t(tail[14]) << 48; // fall through; 801 case 14: k2 ^= uint64_t(tail[13]) << 40; // fall through; 802 case 13: k2 ^= uint64_t(tail[12]) << 32; // fall through; 803 case 12: k2 ^= uint64_t(tail[11]) << 24; // fall through; 804 case 11: k2 ^= uint64_t(tail[10]) << 16; // fall through; 805 case 10: k2 ^= uint64_t(tail[ 9]) << 8; // fall through; 806 case 9: k2 ^= uint64_t(tail[ 8]) << 0;; 807 k2 *= c2; k2 = ROTL64(k2,33); k2 *= c1; h2 ^= k2;; 808 // fall through; 809 case 8: k1 ^= uint64_t(tail[ 7]) << 56; // fall through; 810 case 7: k1 ^= uint64_t(tail[ 6]) << 48; // fall through; 811 case 6: k1 ^= uint64_t(tail[ 5]) << 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string.",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25521,Security,hash,hash,25521," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25630,Security,hash,hashes,25630," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25959,Security,hash,hash,25959,"////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^= ctxt[i] << (i * 8);; 875 }; 876 }; 877 }; 878 return ret;; 879 }; 880}; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Returns false if strings are not equal.; 884 ; 885static int MemIsEqual(const char *p, const char *q, Ssiz_t n); 886{; 887 while (n--); 888 {; 889 if (tolower((unsigned char)*p) != tolower((unsigned char)*q)); 890 return kFALSE;; 891 p++; q++;; 892 }; 893 return kTRUE;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Search for a string in the TString. Plen is the length of pattern,; 898/// startIndex is the index from which to start and cmp selects the type; 899/// of case-comp",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:47477,Security,access,access,47477,"544}; 1545 ; 1546////////////////////////////////////////////////////////////////////////////////; 1547/// Add char to string.; 1548 ; 1549TString operator+(const TString &s, char c); 1550{; 1551 return TString(s.Data(), s.Length(), &c, 1);; 1552}; 1553 ; 1554////////////////////////////////////////////////////////////////////////////////; 1555/// Add string to char.; 1556 ; 1557TString operator+(char c, const TString &s); 1558{; 1559 return TString(&c, 1, s.Data(), s.Length());; 1560}; 1561 ; 1562////////////////////////////////////////////////////////////////////////////////; 1563// Static Member Functions; 1564// The static data members access; 1565 ; 1566////////////////////////////////////////////////////////////////////////////////; 1567 ; 1568Ssiz_t TString::GetInitialCapacity(); 1569{; 1570 ::Obsolete(""TString::GetInitialCapacity"", ""v5-30-00"", ""v5-32-00"");; 1571 return 15;; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575 ; 1576Ssiz_t TString::GetResizeIncrement(); 1577{; 1578 ::Obsolete(""TString::GetResizeIncrement"", ""v5-30-00"", ""v5-32-00"");; 1579 return 16;; 1580}; 1581 ; 1582////////////////////////////////////////////////////////////////////////////////; 1583 ; 1584Ssiz_t TString::GetMaxWaste(); 1585{; 1586 ::Obsolete(""TString::GetMaxWaste"", ""v5-30-00"", ""v5-32-00"");; 1587 return 15;; 1588}; 1589 ; 1590////////////////////////////////////////////////////////////////////////////////; 1591/// Set default initial capacity for all TStrings. Default is 15.; 1592 ; 1593Ssiz_t TString::InitialCapacity(Ssiz_t); 1594{; 1595 ::Obsolete(""TString::InitialCapacity"", ""v5-30-00"", ""v5-32-00"");; 1596 return 15;; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Set default resize increment for all TStrings. Default is 16.; 1601 ; 1602Ssiz_t TString::ResizeIncrement(Ssiz_t); 1603{; 1604 ::Obsolete(""TString::ResizeIncrement"", ""v5-30-00"", ""v5-32-00"");; 1605 retur",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:92576,Security,hash,hash,92576,"qfloat * qDefinition THbookFile.cxx:89; TMD5.h; TObjArray.h; TObjString.h; kHashShiftconst UInt_t kHashShiftDefinition TString.cxx:68; rotl64uint64_t rotl64(uint64_t x, int8_t r)Definition TString.cxx:720; ToLowerTString ToLower(const TString &str)Return a lower-case version of str.Definition TString.cxx:1497; operator+TString operator+(const TString &s, const char *cs)Use the special concatenation constructor.Definition TString.cxx:1525; ROTL64#define ROTL64(x, y)Definition TString.cxx:725; MemIsEqualstatic int MemIsEqual(const char *p, const char *q, Ssiz_t n)Returns false if strings are not equal.Definition TString.cxx:885; operator>>TBuffer & operator>>(TBuffer &buf, TString *&s)Read string from TBuffer. Function declared in ClassDef.Definition TString.cxx:1461; BIG_CONSTANT#define BIG_CONSTANT(x)Definition TString.cxx:726; operator==Bool_t operator==(const TString &s1, const char *s2)Compare TString with a char *.Definition TString.cxx:1482; HashUInt_t Hash(const char *str)Return a case-sensitive hash value (endian independent).Definition TString.cxx:576; SlowFormatstatic char * SlowFormat(const char *format, va_list ap, int hint)Format a string in a formatting buffer (using a printf style format descriptor).Definition TString.cxx:2394; ToUpperTString ToUpper(const TString &str)Return an upper-case version of str.Definition TString.cxx:1511; SwapIntstatic UInt_t SwapInt(UInt_t x)Definition TString.cxx:556; Mashstatic void Mash(UInt_t &hash, UInt_t chars)Utility used by Hash().Definition TString.cxx:566; TString.h; Compresschar * Compress(const char *str)Remove all blanks from the string str.Definition TString.cxx:2572; UnEscCharint UnEscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Un-escape specchars in src from escchar and copy to dst.Definition TString.cxx:2617; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:93023,Security,hash,hash,93023," y)Definition TString.cxx:725; MemIsEqualstatic int MemIsEqual(const char *p, const char *q, Ssiz_t n)Returns false if strings are not equal.Definition TString.cxx:885; operator>>TBuffer & operator>>(TBuffer &buf, TString *&s)Read string from TBuffer. Function declared in ClassDef.Definition TString.cxx:1461; BIG_CONSTANT#define BIG_CONSTANT(x)Definition TString.cxx:726; operator==Bool_t operator==(const TString &s1, const char *s2)Compare TString with a char *.Definition TString.cxx:1482; HashUInt_t Hash(const char *str)Return a case-sensitive hash value (endian independent).Definition TString.cxx:576; SlowFormatstatic char * SlowFormat(const char *format, va_list ap, int hint)Format a string in a formatting buffer (using a printf style format descriptor).Definition TString.cxx:2394; ToUpperTString ToUpper(const TString &str)Return an upper-case version of str.Definition TString.cxx:1511; SwapIntstatic UInt_t SwapInt(UInt_t x)Definition TString.cxx:556; Mashstatic void Mash(UInt_t &hash, UInt_t chars)Utility used by Hash().Definition TString.cxx:566; TString.h; Compresschar * Compress(const char *str)Remove all blanks from the string str.Definition TString.cxx:2572; UnEscCharint UnEscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Un-escape specchars in src from escchar and copy to dst.Definition TString.cxx:2617; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *str)Duplicate the string str.Definition TString.cxx:2557; EscCharint EscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Escape specchars in src with escchar and copy to dst.Definition TString.cxx:2593; TVirtualMutex.h; ThreadLocalStorage.h; Varargs.h; R__VA_COPY#define R__VA_COPY(to, from)Definition Varargs.h:48; va_#define va_(arg)Definition Varargs.h:35; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; T",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:99268,Security,hash,hash,99268,"ing matching ""pattern"", or the null substring if there is no such match.Definition TString.cxx:1657; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReadStringstatic TString * ReadString(TBuffer &b, const TClass *clReq)Read TString object from buffer.Definition TString.cxx:1362; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::MaybeRegexpBool_t MaybeRegexp() constReturns true if string contains one of the regexp characters ""^$.[]*+?"".Definition TString.cxx:952; TString::ResizeIncrementstatic Ssiz_t ResizeIncrement(Ssiz_t ri=16)Set default resize increment for all TStrings. Default is 16.Definition TString.cxx:1602; TString::HashCaseUInt_t HashCase() constReturn a case-sensitive hash value (endian independent).Definition TString.cxx:633; TString::IsOctBool_t IsOct() constReturns true if all characters in string are octal digits (0-7).Definition TString.cxx:1924; TString::~TStringvirtual ~TString()Delete a TString.Definition TString.cxx:251; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::GetMaxWastestatic Ssiz_t GetMaxWaste()Definition TString.cxx:1584; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276;",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:100661,Security,hash,hash,100661,"GetMaxWaste()Definition TString.cxx:1584; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276; TString::kLeading@ kLeadingDefinition TString.h:276; TString::kTrailing@ kTrailingDefinition TString.h:276; TString::ECaseCompareECaseCompareDefinition TString.h:277; TString::kExact@ kExactDefinition TString.h:277; TString::IsAlphaBool_t IsAlpha() constReturns true if all characters in string are alphabetic.Definition TString.cxx:1798; TString::HashFoldCaseUInt_t HashFoldCase() constReturn a case-insensitive hash value (endian independent).Definition TString.cxx:662; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsAsciiBool_t IsAscii() constReturns true if all characters in string are ascii.Definition TString.cxx:1785; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::GetResizeIncrementstatic Ssiz_t GetResizeIncrement()Definition TString.cxx:1576; TString::SetLongCapvoid SetLongCap(Ssiz_t s)Definition TString.h:249; TString::kAlignment@ kAlignmentDefinition TString.h:232; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::IsBinBool_t IsBin() constReturns true ",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:102408,Security,hash,hash,102408,"x:1576; TString::SetLongCapvoid SetLongCap(Ssiz_t s)Definition TString.h:249; TString::kAlignment@ kAlignmentDefinition TString.h:232; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::IsBinBool_t IsBin() constReturns true if all characters in string are binary digits (0,1).Definition TString.cxx:1908; TString::UnLinkvoid UnLink() constDefinition TString.h:263; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::BaseConvertstatic TString BaseConvert(const TString &s_in, Int_t base_in, Int_t base_out)Converts string from base base_in to base base_out.Definition TString.cxx:2194; TString::ULLtoastatic TString ULLtoa(ULong64_t value, Int_t base)Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified...Definition TString.cxx:2171; TString::CountCharInt_t CountChar(Int_t c) constReturn number of times character c occurs in the string.Definition TString.cxx:515; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::WriteStringstatic void WriteString(TBuffer &b, const TString *a)Write TString object to buffer.Definition TString.cxx:1428; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::operator=TString & operator=(char s)Assign character c to TString.Definition TString.cxx:301; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::InitialCapacitystatic Ssiz_t InitialCapacity(Ssiz_t ic=15)Set default initial capacity for all TStrings. Default is 15.Definition TString.cxx:1593; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::GetShortPointerchar * GetShortPointer()Definition TString.h:254; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::IsInBaseNBool_t IsInBaseN(Int_t base) constReturns true if all characters in string are expr",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:58309,Testability,test,test,58309,"56/// ~~~; 1857 ; 1858Bool_t TString::IsFloat() const; 1859{; 1860 //we first check if we have an integer, in this case, IsDigit() will be true straight away; 1861 if (IsDigit()) return kTRUE;; 1862 ; 1863 TString tmp = *this;; 1864 //now we look for occurrences of '.', ',', e', 'E', '+', '-' and replace each; 1865 //with ' ', if it is a floating point, IsDigit() will then return kTRUE; 1866 ; 1867 tmp.ToLower();; 1868 Ssiz_t pos = tmp.First('.');; 1869 if (pos != kNPOS) tmp.Replace(pos, 1, "" "", 1);; 1870 pos = tmp.First(',');; 1871 if (pos != kNPOS) tmp.Replace(pos, 1, "" "", 1);; 1872 pos = tmp.Index(""e-"");; 1873 if (pos >= 1) tmp.Replace(pos, 2, "" "", 1);; 1874 pos = tmp.Index(""e+"");; 1875 if (pos >= 1) tmp.Replace(pos, 2, "" "", 1);; 1876 pos = tmp.Index(""e"");; 1877 if (pos >= 1) tmp.Replace(pos, 1, "" "", 1);; 1878 pos = tmp.First('-');; 1879 if (pos == 0) tmp.Replace(pos, 1, "" "", 1);; 1880 pos = tmp.First('+');; 1881 if (pos == 0) tmp.Replace(pos, 1, "" "", 1);; 1882 ; 1883 //test if it is now uniquely composed of numbers; 1884 return tmp.IsDigit();; 1885}; 1886 ; 1887////////////////////////////////////////////////////////////////////////////////; 1888/// Returns true if all characters in string are hexadecimal digits; 1889/// (0-9,a-f,A-F). Returns false in case string length is 0 or string; 1890/// contains other characters.; 1891 ; 1892Bool_t TString::IsHex() const; 1893{; 1894 const char *cp = Data();; 1895 Ssiz_t len = Length();; 1896 if (len == 0) return kFALSE;; 1897 for (Ssiz_t i = 0; i < len; ++i); 1898 if (!isxdigit(cp[i])); 1899 return kFALSE;; 1900 return kTRUE;; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Returns true if all characters in string are binary digits (0,1).; 1905/// Returns false in case string length is 0 or string contains other; 1906/// characters.; 1907 ; 1908Bool_t TString::IsBin() const; 1909{; 1910 const char *cp = Data();; 1911 Ssiz_t len = Length();; 1912 if (len == 0) r",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25591,Usability,simpl,simple,25591," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8cxx_source.html:25941,Usability,simpl,simple,25941,"////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^= ctxt[i] << (i * 8);; 875 }; 876 }; 877 }; 878 return ret;; 879 }; 880}; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Returns false if strings are not equal.; 884 ; 885static int MemIsEqual(const char *p, const char *q, Ssiz_t n); 886{; 887 while (n--); 888 {; 889 if (tolower((unsigned char)*p) != tolower((unsigned char)*q)); 890 return kFALSE;; 891 p++; q++;; 892 }; 893 return kTRUE;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Search for a string in the TString. Plen is the length of pattern,; 898/// startIndex is the index from which to start and cmp selects the type; 899/// of case-comp",MatchSource.WIKI,doc/master/TString_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html
https://root.cern/doc/master/TString_8h.html:6143,Availability,down,down,6143,"m a string. ; ; TStringToLower (const TString &s); Return a lower-case version of str. ; ; TStringToUpper (const TString &s); Return an upper-case version of str. ; ; intUnEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Un-escape specchars in src from escchar and copy to dst. ; . Function Documentation. Compress(). char * Compress ; (; const char *; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Hash() [1/3]. UInt_t Hash ; (; const char *; s). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Hash() [2/3]. UInt_t Hash ; (; const TString &; s). inline . Definition at line 494 of file TString.h. Hash() [3/3]. UInt_t Hash ; (; const TString *; s). inline . Definition at line 495 of file TString.h. operator!=() [1/8]. Bool_t operator!= ; (; const char *; s1, . const TString &; s2. ). inline . Definition at line 807 of file TString.h. operator!=() [2/8]. Bool_t operator!= ; (; const char *; s1, . const TSubString &; s2. ). inline . Definition at line 844 of file TString.h. operator!=() [3/8]. Bool_t operator!= ; (; const TString &; s1, . const char *; s2. ). inline . Definition at line 789 of file TString.h. operator!=() [4/8]. Bool_t ",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h.html:6208,Availability,down,downstream,6208,"m a string. ; ; TStringToLower (const TString &s); Return a lower-case version of str. ; ; TStringToUpper (const TString &s); Return an upper-case version of str. ; ; intUnEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Un-escape specchars in src from escchar and copy to dst. ; . Function Documentation. Compress(). char * Compress ; (; const char *; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Hash() [1/3]. UInt_t Hash ; (; const char *; s). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Hash() [2/3]. UInt_t Hash ; (; const TString &; s). inline . Definition at line 494 of file TString.h. Hash() [3/3]. UInt_t Hash ; (; const TString *; s). inline . Definition at line 495 of file TString.h. operator!=() [1/8]. Bool_t operator!= ; (; const char *; s1, . const TString &; s2. ). inline . Definition at line 807 of file TString.h. operator!=() [2/8]. Bool_t operator!= ; (; const char *; s1, . const TSubString &; s2. ). inline . Definition at line 844 of file TString.h. operator!=() [3/8]. Bool_t operator!= ; (; const TString &; s1, . const char *; s2. ). inline . Definition at line 789 of file TString.h. operator!=() [4/8]. Bool_t ",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h.html:14113,Availability,error,error,14113,"ing.h. operator>=() [1/3]. Bool_t operator>= ; (; const char *; s1, . const TString &; s2. ). inline . Definition at line 819 of file TString.h. operator>=() [2/3]. Bool_t operator>= ; (; const TString &; s1, . const char *; s2. ). inline . Definition at line 801 of file TString.h. operator>=() [3/3]. Bool_t operator>= ; (; const TString &; s1, . const TString &; s2. ). inline . Definition at line 785 of file TString.h. operator>>() [1/2]. std::istream & operator>> ; (; std::istream &; str, . TString &; s. ). Read string from stream. ; Definition at line 169 of file Stringio.cxx. operator>>() [2/2]. TBuffer & operator>> ; (; TBuffer &; buf, . TString *&; sp. ). Read string from TBuffer. Function declared in ClassDef. ; Definition at line 1461 of file TString.cxx. Printf(). void Printf ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer and prints the string. ; Appends a newline. If gPrintViaErrorHandler is true it will print via the currently active ROOT error handler. ; Definition at line 2503 of file TString.cxx. StrDup(). char * StrDup ; (; const char *; str). Duplicate the string str. ; The returned string has to be deleted by the user. ; Definition at line 2557 of file TString.cxx. Strip(). char * Strip ; (; const char *; s, . char; c. ). Strip leading and trailing c (blanks by default) from a string. ; The returned string has to be deleted by the user. ; Definition at line 2521 of file TString.cxx. ToLower(). TString ToLower ; (; const TString &; s). Return a lower-case version of str. ; Definition at line 1497 of file TString.cxx. ToUpper(). TString ToUpper ; (; const TString &; s). Return an upper-case version of str. ; Definition at line 1511 of file TString.cxx. UnEscChar(). int UnEscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Un-escape specchars in src from escchar and copy to dst. ; Definition at line 2617 of file T",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h.html:421,Integrability,depend,dependency,421,". ROOT: core/base/inc/TString.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; TString.h File Reference. #include ""Rtypes.h""; #include ""TMathBase.h""; #include <string_view>; #include ""ROOT/TypeTraits.hxx""; #include ""snprintf.h""; #include <iosfwd>; #include <cstdarg>; #include <cstdio>; #include <cstring>; #include <string>. Include dependency graph for TString.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct TString::LongStr_t; ; struct TString::RawStr_t; ; struct TString::Rep_t; ; struct TString::ShortStr_t; ; class TString; Basic string class. More...; ; class TSubString; A zero length substring is legal. More...; ; union TString::UStr_t; . Namespaces; namespace llvm; . Functions; char *Compress (const char *str); Remove all blanks from the string str. ; ; intEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Escape specchars in src with escchar and copy to dst. ; ; char *Form (const char *fmt,...); Formats a string in a circular formatting buffer. ; ; UInt_tHash (const char *s); Return a case-sensitive hash value (endian independent). ; ; UInt_tHash (const TString &s); ; UInt_tHash (const TString *s); ; Bool_toperator!= (const char *s1, const TString &s2); ; Bool_toperator!= (const char *s1, const TSubString &s2); ; Bool_toperator!= (const TString &s1, const char *s2); ; Bool_toperator!= (const TString &s1, const TString &s2); ; Bool_toperator!= (const TString &s1, const TSubString &s2); ; Bool_toperator!= (const TSubString &s1, const char *s2); ; Bool_toperator!= (const TSubString &s1, const TString &s2); ; Bool_toperator!= (const TSubString &s1, const TSubString &s2); ; TStringoperator+ (char c, const TString &s); Add string to char. ; ; TStringoperator+ (const char *cs, const TString &s); Use the special concatenation constructor. ; ; T",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h.html:1223,Security,hash,hash,1223,"h""; #include ""TMathBase.h""; #include <string_view>; #include ""ROOT/TypeTraits.hxx""; #include ""snprintf.h""; #include <iosfwd>; #include <cstdarg>; #include <cstdio>; #include <cstring>; #include <string>. Include dependency graph for TString.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct TString::LongStr_t; ; struct TString::RawStr_t; ; struct TString::Rep_t; ; struct TString::ShortStr_t; ; class TString; Basic string class. More...; ; class TSubString; A zero length substring is legal. More...; ; union TString::UStr_t; . Namespaces; namespace llvm; . Functions; char *Compress (const char *str); Remove all blanks from the string str. ; ; intEscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar); Escape specchars in src with escchar and copy to dst. ; ; char *Form (const char *fmt,...); Formats a string in a circular formatting buffer. ; ; UInt_tHash (const char *s); Return a case-sensitive hash value (endian independent). ; ; UInt_tHash (const TString &s); ; UInt_tHash (const TString *s); ; Bool_toperator!= (const char *s1, const TString &s2); ; Bool_toperator!= (const char *s1, const TSubString &s2); ; Bool_toperator!= (const TString &s1, const char *s2); ; Bool_toperator!= (const TString &s1, const TString &s2); ; Bool_toperator!= (const TString &s1, const TSubString &s2); ; Bool_toperator!= (const TSubString &s1, const char *s2); ; Bool_toperator!= (const TSubString &s1, const TString &s2); ; Bool_toperator!= (const TSubString &s1, const TSubString &s2); ; TStringoperator+ (char c, const TString &s); Add string to char. ; ; TStringoperator+ (const char *cs, const TString &s); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &s, char c); Add char to string. ; ; TStringoperator+ (const TString &s, const char *cs); Use the special concatenation constructor. ; ; TStringoperator+ (const TString &",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h.html:6408,Security,hash,hash,6408,"scchar); Un-escape specchars in src from escchar and copy to dst. ; . Function Documentation. Compress(). char * Compress ; (; const char *; str). Remove all blanks from the string str. ; The returned string has to be deleted by the user. ; Definition at line 2572 of file TString.cxx. EscChar(). int EscChar ; (; const char *; src, . char *; dst, . int; dstlen, . char *; specchars, . char; escchar. ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. Form(). char * Form ; (; const char *; fmt, . ; .... ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. Hash() [1/3]. UInt_t Hash ; (; const char *; s). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. Hash() [2/3]. UInt_t Hash ; (; const TString &; s). inline . Definition at line 494 of file TString.h. Hash() [3/3]. UInt_t Hash ; (; const TString *; s). inline . Definition at line 495 of file TString.h. operator!=() [1/8]. Bool_t operator!= ; (; const char *; s1, . const TString &; s2. ). inline . Definition at line 807 of file TString.h. operator!=() [2/8]. Bool_t operator!= ; (; const char *; s1, . const TSubString &; s2. ). inline . Definition at line 844 of file TString.h. operator!=() [3/8]. Bool_t operator!= ; (; const TString &; s1, . const char *; s2. ). inline . Definition at line 789 of file TString.h. operator!=() [4/8]. Bool_t operator!= ; (; const TString &; s1, . const TString &; s2. ). inline . Definition at line 773 of file TString.h. operator!=() [5/8]. Bool_t operator!= ; (; const TString &; s1, . const TSubString &; s2. ). inline . Definition at line 841 of fi",MatchSource.WIKI,doc/master/TString_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h.html
https://root.cern/doc/master/TString_8h_source.html:11673,Availability,error,errors,11673,,MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:56355,Availability,error,error,56355,"ion TString.h:651; TString::Recommendstatic Ssiz_t Recommend(Ssiz_t s)Definition TString.h:234; TString::ReadLinestd::istream & ReadLine(std::istream &str, Bool_t skipWhite=kTRUE)Read a line from stream upto newline skipping any whitespace.Definition Stringio.cxx:71; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSubString::operator=TSubString & operator=(const char *s)Assign char* to sub-string.Definition TString.cxx:1696; TSubString::IsNullBool_t IsNull() constDefinition TString.h:129; TSubString::ToUppervoid ToUpper()Convert sub-string to upper-case.Definition TString.cxx:1754; TSubString::fStrTString & fStrDefinition TString.h:95; TSubString::StartSsiz_t Start() constDefinition TString.h:123; TSubString::operator!int operator!() constDefinition TString.h:130; TSubString::SubStringErrorvoid SubStringError(Ssiz_t, Ssiz_t, Ssiz_t) constOutput error message.Definition TString.cxx:1766; TSubString::fBeginSsiz_t fBeginDefinition TString.h:96; TSubString::operator[]char & operator[](Ssiz_t i)Return character at pos i from sub-string. Check validity of i.Definition TString.cxx:1668; TSubString::fExtentSsiz_t fExtentDefinition TString.h:97; TSubString::operator==friend Bool_t operator==(const TSubString &s1, const TSubString &s2)Compare two sub-strings.Definition TString.cxx:1731; TSubString::AssertElementvoid AssertElement(Ssiz_t i) constCheck to make sure a sub-string index is in range.Definition TString.cxx:1775; TSubString::ToLowervoid ToLower()Convert sub-string to lower-case.Definition TString.cxx:1742; TSubString::TSubStringTSubString(const TSubString &s)Definition TString.h:107; TSubString::Dataconst char * Data() constDefinition TString.h:736; TSubString::operator()char & operator()(Ssiz_t i)Return character at pos i from sub-string. No check on i.Definition TString.cxx:1677; TSubStri",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:10915,Integrability,interface,interface,10915,"264 void Zero() {; 265 Ssiz_t (&a)[kNwords] = fRep.fRaw.fWords;; 266 for (UInt_t i = 0; i < kNwords; ++i); 267 a[i] = 0;; 268 }; 269 char *Init(Ssiz_t capacity, Ssiz_t nchar);; 270 void Clone(Ssiz_t nc); // Make self a distinct copy w. capacity nc; 271 void FormImp(const char *fmt, va_list ap);; 272 UInt_t HashCase() const;; 273 UInt_t HashFoldCase() const;; 274 ; 275public:; 276 enum EStripType { kLeading = 0x1, kTrailing = 0x2, kBoth = 0x3 };; 277 enum ECaseCompare { kExact, kIgnoreCase };; 278 static constexpr Ssiz_t kNPOS = ::kNPOS;; 279 using size_type = Ssiz_t;; 280 ; 281 TString(); // Null string; 282 explicit TString(Ssiz_t ic); // Suggested capacity; 283 TString(const TString &s); // Copy constructor; 284 TString(TString &&s) noexcept; // Move constructor; 285 TString(const char *s); // Copy to embedded null; 286 TString(const char *s, Ssiz_t n); // Copy past any embedded nulls; 287 TString(const std::string &s);; 288 TString(char c);; 289 TString(char c, Ssiz_t s);; 290 explicit TString(const std::string_view &sub);; 291 TString(const TSubString &sub);; 292 ; 293 virtual ~TString();; 294 ; 295 // ROOT I/O interface; 296 virtual void FillBuffer(char *&buffer) const;; 297 virtual void ReadBuffer(char *&buffer);; 298 virtual Int_t Sizeof() const;; 299 ; 300 static TString *ReadString(TBuffer &b, const TClass *clReq);; 301 static void WriteString(TBuffer &b, const TString *a);; 302 ; 303 friend TBuffer &operator<<(TBuffer &b, const TString *obj);; 304 ; 305 // C I/O interface; 306 Bool_t Gets(FILE *fp, Bool_t chop=kTRUE);; 307 void Puts(FILE *fp);; 308 ; 309 // Type conversion; 310 operator const char*() const { return GetPointer(); }; 311#if !defined(_MSC_VER) && (!defined(__clang_major__) || __clang_major__ > 5); 312 // Clang 5.0 support for explicit conversion is still inadequate even in c++17 mode.; 313 // (It leads to extraneous ambiguous overload errors); 314 inline explicit operator std::string() const { return std::string(GetPointer(),Length()); }; 315#",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:11279,Integrability,interface,interface,11279,"264 void Zero() {; 265 Ssiz_t (&a)[kNwords] = fRep.fRaw.fWords;; 266 for (UInt_t i = 0; i < kNwords; ++i); 267 a[i] = 0;; 268 }; 269 char *Init(Ssiz_t capacity, Ssiz_t nchar);; 270 void Clone(Ssiz_t nc); // Make self a distinct copy w. capacity nc; 271 void FormImp(const char *fmt, va_list ap);; 272 UInt_t HashCase() const;; 273 UInt_t HashFoldCase() const;; 274 ; 275public:; 276 enum EStripType { kLeading = 0x1, kTrailing = 0x2, kBoth = 0x3 };; 277 enum ECaseCompare { kExact, kIgnoreCase };; 278 static constexpr Ssiz_t kNPOS = ::kNPOS;; 279 using size_type = Ssiz_t;; 280 ; 281 TString(); // Null string; 282 explicit TString(Ssiz_t ic); // Suggested capacity; 283 TString(const TString &s); // Copy constructor; 284 TString(TString &&s) noexcept; // Move constructor; 285 TString(const char *s); // Copy to embedded null; 286 TString(const char *s, Ssiz_t n); // Copy past any embedded nulls; 287 TString(const std::string &s);; 288 TString(char c);; 289 TString(char c, Ssiz_t s);; 290 explicit TString(const std::string_view &sub);; 291 TString(const TSubString &sub);; 292 ; 293 virtual ~TString();; 294 ; 295 // ROOT I/O interface; 296 virtual void FillBuffer(char *&buffer) const;; 297 virtual void ReadBuffer(char *&buffer);; 298 virtual Int_t Sizeof() const;; 299 ; 300 static TString *ReadString(TBuffer &b, const TClass *clReq);; 301 static void WriteString(TBuffer &b, const TString *a);; 302 ; 303 friend TBuffer &operator<<(TBuffer &b, const TString *obj);; 304 ; 305 // C I/O interface; 306 Bool_t Gets(FILE *fp, Bool_t chop=kTRUE);; 307 void Puts(FILE *fp);; 308 ; 309 // Type conversion; 310 operator const char*() const { return GetPointer(); }; 311#if !defined(_MSC_VER) && (!defined(__clang_major__) || __clang_major__ > 5); 312 // Clang 5.0 support for explicit conversion is still inadequate even in c++17 mode.; 313 // (It leads to extraneous ambiguous overload errors); 314 inline explicit operator std::string() const { return std::string(GetPointer(),Length()); }; 315#",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:56361,Integrability,message,message,56361,"ion TString.h:651; TString::Recommendstatic Ssiz_t Recommend(Ssiz_t s)Definition TString.h:234; TString::ReadLinestd::istream & ReadLine(std::istream &str, Bool_t skipWhite=kTRUE)Read a line from stream upto newline skipping any whitespace.Definition Stringio.cxx:71; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSubString::operator=TSubString & operator=(const char *s)Assign char* to sub-string.Definition TString.cxx:1696; TSubString::IsNullBool_t IsNull() constDefinition TString.h:129; TSubString::ToUppervoid ToUpper()Convert sub-string to upper-case.Definition TString.cxx:1754; TSubString::fStrTString & fStrDefinition TString.h:95; TSubString::StartSsiz_t Start() constDefinition TString.h:123; TSubString::operator!int operator!() constDefinition TString.h:130; TSubString::SubStringErrorvoid SubStringError(Ssiz_t, Ssiz_t, Ssiz_t) constOutput error message.Definition TString.cxx:1766; TSubString::fBeginSsiz_t fBeginDefinition TString.h:96; TSubString::operator[]char & operator[](Ssiz_t i)Return character at pos i from sub-string. Check validity of i.Definition TString.cxx:1668; TSubString::fExtentSsiz_t fExtentDefinition TString.h:97; TSubString::operator==friend Bool_t operator==(const TSubString &s1, const TSubString &s2)Compare two sub-strings.Definition TString.cxx:1731; TSubString::AssertElementvoid AssertElement(Ssiz_t i) constCheck to make sure a sub-string index is in range.Definition TString.cxx:1775; TSubString::ToLowervoid ToLower()Convert sub-string to lower-case.Definition TString.cxx:1742; TSubString::TSubStringTSubString(const TSubString &s)Definition TString.h:107; TSubString::Dataconst char * Data() constDefinition TString.h:736; TSubString::operator()char & operator()(Ssiz_t i)Return character at pos i from sub-string. No check on i.Definition TString.cxx:1677; TSubStri",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:57418,Integrability,interface,interface,57418,"TSubString::fBeginSsiz_t fBeginDefinition TString.h:96; TSubString::operator[]char & operator[](Ssiz_t i)Return character at pos i from sub-string. Check validity of i.Definition TString.cxx:1668; TSubString::fExtentSsiz_t fExtentDefinition TString.h:97; TSubString::operator==friend Bool_t operator==(const TSubString &s1, const TSubString &s2)Compare two sub-strings.Definition TString.cxx:1731; TSubString::AssertElementvoid AssertElement(Ssiz_t i) constCheck to make sure a sub-string index is in range.Definition TString.cxx:1775; TSubString::ToLowervoid ToLower()Convert sub-string to lower-case.Definition TString.cxx:1742; TSubString::TSubStringTSubString(const TSubString &s)Definition TString.h:107; TSubString::Dataconst char * Data() constDefinition TString.h:736; TSubString::operator()char & operator()(Ssiz_t i)Return character at pos i from sub-string. No check on i.Definition TString.cxx:1677; TSubString::LengthSsiz_t Length() constDefinition TString.h:122; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; Swap#define Swap(a, b)Definition geom.c:201; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; llvmDefinition TString.h:847; TString::LongStr_tDefinition TString.h:189; TString::LongStr_t::fSizeSsiz_t fSizeDefinition TString.h:191; TString::LongStr_t::fDatachar * fDataDefinition TString.h:192; TString::LongStr_t::fCapSsiz_t fCapDefinition TString.h:190; TString::RawStr_tDefinition TString.h:209; TString::RawStr_t::fWordsSsiz_t fWords[kNwords]Definition TString.h:210; TString::Rep_tDefinition TString.h:214; TString::Rep_t::fRawRawStr_t fRawDefinition TString.h:219; TString::Rep_t::fShortShortStr_t fShortDefinition TString.h:218; TString::Rep_t::fLongLongStr_t fLongDefinition TString.h:217; TString::Short",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:4570,Safety,detect,detecting,4570,,MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:19087,Security,hash,hash,19087,"stream &ReadString(std::istream &str); // Read to EOF or null character; 430 std::istream &ReadToDelim(std::istream &str, char delim = '\n'); // Read to EOF or delimitor; 431 std::istream &ReadToken(std::istream &str); // Read separated by white space; 432 TString &Remove(Ssiz_t pos); // Remove pos to end of string; 433 TString &Remove(Ssiz_t pos, Ssiz_t n); // Remove n chars starting at pos; 434 TString &Remove(EStripType s, char c); // Like Strip() but changing string directly; 435 TString &Replace(Ssiz_t pos, Ssiz_t n, const char *s);; 436 TString &Replace(Ssiz_t pos, Ssiz_t n, const char *s, Ssiz_t ns);; 437 TString &Replace(Ssiz_t pos, Ssiz_t n, const TString &s);; 438 TString &Replace(Ssiz_t pos, Ssiz_t n1, const TString &s, Ssiz_t n2);; 439 TString &ReplaceAll(const TString &s1, const TString &s2); // Find&Replace all s1 with s2 if any; 440 TString &ReplaceAll(const TString &s1, const char *s2); // Find&Replace all s1 with s2 if any; 441 TString &ReplaceAll(const char *s1, const TString &s2); // Find&Replace all s1 with s2 if any; 442 TString &ReplaceAll(const char *s1, const char *s2); // Find&Replace all s1 with s2 if any; 443 TString &ReplaceAll(const char *s1, Ssiz_t ls1, const char *s2, Ssiz_t ls2); // Find&Replace all s1 with s2 if any; 444 TString &ReplaceSpecialCppChars();; 445 void Resize(Ssiz_t n); // Truncate or add blanks as necessary; 446 TSubString Strip(EStripType s = kTrailing, char c = ' ') const;; 447 TString &Swap(TString &other); // Swap the contents of this and other without reallocation; 448 void ToLower(); // Change self to lower-case; 449 void ToUpper(); // Change self to upper-case; 450 TObjArray *Tokenize(const TString &delim) const;; 451 Bool_t Tokenize(TString &tok, Ssiz_t &from, const char *delim = "" "") const;; 452 std::string_view View() const { return std::string_view(GetPointer(),Length()); }; 453 ; 454 // Static member functions; 455 static UInt_t Hash(const void *txt, Int_t ntxt); // Calculates hash index from any char string.",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:47029,Security,hash,hash,47029,"onst char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReadStringstatic TString * ReadString(TBuffer &b, const TClass *clReq)Read TString object from buffer.Definition TString.cxx:1362; TString::EqualToBool_t EqualTo(const char *cs, ECaseCompare cmp=kExact) constDefinition TString.h:645; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ChopTString & Chop()Definition TString.h:691; TString::MaybeRegexpBool_t MaybeRegexp() constReturns true if string contains one of the regexp characters ""^$.[]*+?"".Definition TString.cxx:952; TString::ResizeIncrementstatic Ssiz_t ResizeIncrement(Ssiz_t ri=16)Set default resize increment for all TStrings. Default is 16.Definition TString.cxx:1602; TString::HashCaseUInt_t HashCase() constReturn a case-sensitive hash value (endian independent).Definition TString.cxx:633; TString::IsOctBool_t IsOct() constReturns true if all characters in string are octal digits (0-7).Definition TString.cxx:1924; TString::~TStringvirtual ~TString()Delete a TString.Definition TString.cxx:251; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::GetMaxWastestatic Ssiz_t GetMaxWaste()Definition TString.cxx:1584; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276;",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:48528,Security,hash,hash,48528," TString &s2)Definition TString.h:704; TString::AdjustCapacitystatic Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap)Calculate a nice capacity greater than or equal to newCap.Definition TString.cxx:1220; TString::MD5TString MD5() constReturn the MD5 digest for this string, in a string representation.Definition TString.cxx:940; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::EStripTypeEStripTypeDefinition TString.h:276; TString::kLeading@ kLeadingDefinition TString.h:276; TString::kTrailing@ kTrailingDefinition TString.h:276; TString::kBoth@ kBothDefinition TString.h:276; TString::ECaseCompareECaseCompareDefinition TString.h:277; TString::kIgnoreCase@ kIgnoreCaseDefinition TString.h:277; TString::kExact@ kExactDefinition TString.h:277; TString::IsAlphaBool_t IsAlpha() constReturns true if all characters in string are alphabetic.Definition TString.cxx:1798; TString::HashFoldCaseUInt_t HashFoldCase() constReturn a case-insensitive hash value (endian independent).Definition TString.cxx:662; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsAsciiBool_t IsAscii() constReturns true if all characters in string are ascii.Definition TString.cxx:1785; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::GetResizeIncrementstatic Ssiz_t GetResizeIncrement()Definition TString.cxx:1576; TString::Putsvoid Puts(FILE *fp)Write string to the stream.Definition Stringio.cxx:229; TString::SetLongCapvoid SetLongCap(Ssiz_t s)Definition TString.h:249; TString::operator+friend TString operator+(const TString &s1, const TString &s2)Use the spe",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TString_8h_source.html:50758,Security,hash,hash,50758,"ar *cs)Definition TString.h:673; TString::SwapTString & Swap(TString &other)Definition TString.h:716; TString::IsBinBool_t IsBin() constReturns true if all characters in string are binary digits (0,1).Definition TString.cxx:1908; TString::UnLinkvoid UnLink() constDefinition TString.h:263; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::BaseConvertstatic TString BaseConvert(const TString &s_in, Int_t base_in, Int_t base_out)Converts string from base base_in to base base_out.Definition TString.cxx:2194; TString::ULLtoastatic TString ULLtoa(ULong64_t value, Int_t base)Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified...Definition TString.cxx:2171; TString::CountCharInt_t CountChar(Int_t c) constReturn number of times character c occurs in the string.Definition TString.cxx:515; TString::operator==friend Bool_t operator==(const TString &s1, const TString &s2)Definition TString.h:767; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::WriteStringstatic void WriteString(TBuffer &b, const TString *a)Write TString object to buffer.Definition TString.cxx:1428; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::operator=TString & operator=(char s)Assign character c to TString.Definition TString.cxx:301; TString::ReadFilestd::istream & ReadFile(std::istream &str)Replace string with the contents of strm, stopping at an EOF.Definition Stringio.cxx:29; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::InitialCapacitystatic Ssiz_t InitialCapacity(Ssiz_t ic=15)Set default initial capacity for all TStrings. Default is 15.Definition TString.cxx:1593; TString::GetShortPointerchar * GetShortPointer()Definition TString.h:254; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::IsInBaseNBool_t IsInBaseN(Int_t base) constRet",MatchSource.WIKI,doc/master/TString_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TString_8h_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:11605,Availability,error,error,11605,");; 365 SetPadLeftMargin(0.16);; 366 SetTitleXOffset(1.4);; 367 SetTitleYOffset(1.4);; 368 Int_t font = 42;; 369 Double_t tsize=0.05;; 370 SetTextFont(font);; 371 SetTextSize(tsize);; 372 SetLabelFont(font,""x"");; 373 SetTitleFont(font,""x"");; 374 SetLabelFont(font,""y"");; 375 SetTitleFont(font,""y"");; 376 SetLabelFont(font,""z"");; 377 SetTitleFont(font,""z"");; 378 SetLabelSize(tsize,""x"");; 379 SetTitleSize(tsize,""x"");; 380 SetLabelSize(tsize,""y"");; 381 SetTitleSize(tsize,""y"");; 382 SetLabelSize(tsize,""z"");; 383 SetTitleSize(tsize,""z"");; 384 SetMarkerStyle(20);; 385 SetMarkerSize(1.2);; 386 SetHistLineWidth(2.);; 387 SetLineStyleString(2,""[12 12]"");; 388 SetEndErrorSize(0.); // get rid of error bar caps; 389 SetOptTitle(0);; 390 SetOptStat(0);; 391 SetOptFit(0);; 392 SetPadTickX(1);; 393 SetPadTickY(1);; 394 }; 395 if (strcmp(style_name,""BELLE2"") == 0) {; 396 // use plain black on white colors; 397 Int_t icol=0; // WHITE; 398 SetFrameBorderMode(icol);; 399 SetFrameFillColor(icol);; 400 SetCanvasBorderMode(icol);; 401 SetCanvasColor(icol);; 402 SetPadBorderMode(icol);; 403 SetPadColor(icol);; 404 SetStatColor(icol);; 405 //SetFillColor(icol); // don't use: white fill color for *all* objects; 406 ; 407 // set the paper & margin sizes; 408 SetPaperSize(20,26);; 409 ; 410 // set margin sizes; 411 SetPadTopMargin(0.05);; 412 SetPadRightMargin(0.05);; 413 SetPadBottomMargin(0.16);; 414 SetPadLeftMargin(0.16);; 415 ; 416 // set title offsets (for axis label); 417 SetTitleXOffset(1.0);; 418 SetTitleYOffset(1.0);; 419 ; 420 // use large fonts; 421 //Int_t font=72; // Helvetica italics; 422 Int_t font=42; // Helvetica; 423 Double_t tsize=0.05;; 424 SetTextFont(font);; 425 SetTextSize(tsize);; 426 ; 427 SetLabelFont(font,""x"");; 428 SetTitleFont(font,""x"");; 429 SetLabelFont(font,""y"");; 430 SetTitleFont(font,""y"");; 431 SetLabelFont(font,""z"");; 432 SetTitleFont(font,""z"");; 433 ; 434 SetLabelSize(tsize,""x"");; 435 SetTitleSize(.065,""x"");; 436 SetLabelSize(tsize,""y"");; 437 SetTitleSize(.06",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:13511,Availability,error,error,13511," 421 //Int_t font=72; // Helvetica italics; 422 Int_t font=42; // Helvetica; 423 Double_t tsize=0.05;; 424 SetTextFont(font);; 425 SetTextSize(tsize);; 426 ; 427 SetLabelFont(font,""x"");; 428 SetTitleFont(font,""x"");; 429 SetLabelFont(font,""y"");; 430 SetTitleFont(font,""y"");; 431 SetLabelFont(font,""z"");; 432 SetTitleFont(font,""z"");; 433 ; 434 SetLabelSize(tsize,""x"");; 435 SetTitleSize(.065,""x"");; 436 SetLabelSize(tsize,""y"");; 437 SetTitleSize(.065,""y"");; 438 SetLabelSize(tsize,""z"");; 439 SetTitleSize(.065,""z"");; 440 ; 441 SetTitleOffset(1.1,""x"");; 442 SetTitleOffset(1.1,""y"");; 443 SetTitleOffset(1.1,""z"");; 444 ; 445 SetLabelOffset(0.015,""x"");; 446 SetLabelOffset(0.015,""y"");; 447 SetLabelOffset(0.015,""z"");; 448 ; 449 SetTickLength(0.03,""x"");; 450 SetTickLength(0.02,""y""); // This way we slightly achieve equal length ticks for x and y; 451 ; 452 // use bold lines and markers; 453 SetMarkerStyle(20);; 454 SetMarkerSize(0.9);; 455 SetHistLineWidth(2);; 456 SetLineStyleString(2,""[12 12]""); // postscript dashes; 457 ; 458 // get rid of X error bars; 459 SetErrorX(0.001);; 460 // get rid of error bar caps; 461 SetEndErrorSize(0.);; 462 ; 463 // do not display any of the standard histogram decorations; 464 SetOptTitle(0);; 465 SetOptStat(0);; 466 SetOptFit(0);; 467 ; 468 // put tick marks on top and RHS of plots; 469 SetPadTickX(0);; 470 SetPadTickY(0);; 471 ; 472 SetFrameLineWidth(2);; 473 }; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Destructor.; 478 ; 479TStyle::~TStyle(); 480{; 481 R__LOCKGUARD(gROOTMutex);; 482 gROOT->GetListOfStyles()->Remove(this);; 483 if (gStyle == this) gStyle = (TStyle*)gROOT->GetListOfStyles()->Last();; 484}; 485 ; 486////////////////////////////////////////////////////////////////////////////////; 487/// Copy constructor; 488 ; 489TStyle::TStyle(const TStyle &style) : TNamed(style), TAttLine(style), TAttFill(style), TAttMarker(style), TAttText(style); 490{; 491 style.TStyle::Copy(*this);;",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:13564,Availability,error,error,13564,"424 SetTextFont(font);; 425 SetTextSize(tsize);; 426 ; 427 SetLabelFont(font,""x"");; 428 SetTitleFont(font,""x"");; 429 SetLabelFont(font,""y"");; 430 SetTitleFont(font,""y"");; 431 SetLabelFont(font,""z"");; 432 SetTitleFont(font,""z"");; 433 ; 434 SetLabelSize(tsize,""x"");; 435 SetTitleSize(.065,""x"");; 436 SetLabelSize(tsize,""y"");; 437 SetTitleSize(.065,""y"");; 438 SetLabelSize(tsize,""z"");; 439 SetTitleSize(.065,""z"");; 440 ; 441 SetTitleOffset(1.1,""x"");; 442 SetTitleOffset(1.1,""y"");; 443 SetTitleOffset(1.1,""z"");; 444 ; 445 SetLabelOffset(0.015,""x"");; 446 SetLabelOffset(0.015,""y"");; 447 SetLabelOffset(0.015,""z"");; 448 ; 449 SetTickLength(0.03,""x"");; 450 SetTickLength(0.02,""y""); // This way we slightly achieve equal length ticks for x and y; 451 ; 452 // use bold lines and markers; 453 SetMarkerStyle(20);; 454 SetMarkerSize(0.9);; 455 SetHistLineWidth(2);; 456 SetLineStyleString(2,""[12 12]""); // postscript dashes; 457 ; 458 // get rid of X error bars; 459 SetErrorX(0.001);; 460 // get rid of error bar caps; 461 SetEndErrorSize(0.);; 462 ; 463 // do not display any of the standard histogram decorations; 464 SetOptTitle(0);; 465 SetOptStat(0);; 466 SetOptFit(0);; 467 ; 468 // put tick marks on top and RHS of plots; 469 SetPadTickX(0);; 470 SetPadTickY(0);; 471 ; 472 SetFrameLineWidth(2);; 473 }; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// Destructor.; 478 ; 479TStyle::~TStyle(); 480{; 481 R__LOCKGUARD(gROOTMutex);; 482 gROOT->GetListOfStyles()->Remove(this);; 483 if (gStyle == this) gStyle = (TStyle*)gROOT->GetListOfStyles()->Last();; 484}; 485 ; 486////////////////////////////////////////////////////////////////////////////////; 487/// Copy constructor; 488 ; 489TStyle::TStyle(const TStyle &style) : TNamed(style), TAttLine(style), TAttFill(style), TAttMarker(style), TAttText(style); 490{; 491 style.TStyle::Copy(*this);; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495///",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:42141,Availability,error,error,42141,"y"",""z""), default = ""x""; 1307/// if axis=""xyz"" set all 3 axes; 1308 ; 1309void TStyle::SetNdivisions(Int_t n, Option_t *axis); 1310{; 1311 TString opt = axis;; 1312 opt.ToLower();; 1313 if (opt.Contains(""x"")) fXaxis.SetNdivisions(n);; 1314 if (opt.Contains(""y"")) fYaxis.SetNdivisions(n);; 1315 if (opt.Contains(""z"")) fZaxis.SetNdivisions(n);; 1316}; 1317 ; 1318////////////////////////////////////////////////////////////////////////////////; 1319/// Set color to draw the axis line and tick marks.; 1320/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 1321/// if axis=""xyz"" set all 3 axes; 1322 ; 1323void TStyle::SetAxisColor(Color_t color, Option_t *axis); 1324{; 1325 TString opt = axis;; 1326 opt.ToLower();; 1327 ; 1328 if (opt.Contains(""x"")) fXaxis.SetAxisColor(color);; 1329 if (opt.Contains(""y"")) fYaxis.SetAxisColor(color);; 1330 if (opt.Contains(""z"")) fZaxis.SetAxisColor(color);; 1331}; 1332 ; 1333////////////////////////////////////////////////////////////////////////////////; 1334/// Set the size (in pixels) of the small lines drawn at the; 1335/// end of the error bars (TH1 or TGraphErrors).; 1336///; 1337/// The default value is 2 pixels.; 1338/// Set np=0 to remove these lines; 1339 ; 1340void TStyle::SetEndErrorSize(Float_t np); 1341{; 1342 if (np >= 0) fEndErrorSize = np;; 1343 else fEndErrorSize = 0;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// Define a string to be inserted in the Postscript header.; 1348///; 1349/// The string in header will be added to the Postscript file; 1350/// immediately following the %%Page line; 1351/// For example, this string may contain special Postscript instructions like; 1352/// ~~~ {.cpp}; 1353/// 200 200 translate; 1354/// ~~~; 1355/// the following header string will print the string ""my annotation"" at the; 1356/// bottom left corner of the page (outside the user area); 1357/// ~~~ {.cpp}; 1358/// ""gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 5",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:51518,Availability,error,errors,51518,"d ""DATE"".; 1543/// The DATE attributes can also be edited interactively (position; 1544/// and attributes) via the normal context menu.; 1545 ; 1546void TStyle::SetOptDate(Int_t optdate); 1547{; 1548 fOptDate = optdate;; 1549 Int_t mode = optdate % 10;; 1550 if (mode == 1) {; 1551 SetDateX(0.01);; 1552 SetDateY(0.01);; 1553 fAttDate.SetTextAlign(11);; 1554 }; 1555 if (mode == 2) {; 1556 SetDateX(0.99);; 1557 SetDateY(0.01);; 1558 fAttDate.SetTextAlign(31);; 1559 }; 1560 if (mode == 3) {; 1561 SetDateX(0.99);; 1562 SetDateY(0.99);; 1563 fAttDate.SetTextAlign(33);; 1564 }; 1565}; 1566 ; 1567////////////////////////////////////////////////////////////////////////////////; 1568/// The type of information about fit parameters printed in the histogram; 1569/// statistics box can be selected via the parameter `mode`.; 1570/// The parameter mode can be = `pcev`:; 1571/// - p = 1; print Probability; 1572/// - c = 1; print Chisquare/Number of degrees of freedom; 1573/// - e = 1; print errors (if e=1, v must be 1); 1574/// - v = 1; print name/values of parameters; 1575/// Example: `gStyle->SetOptFit(1011);`; 1576/// print fit probability, parameter names/values and errors.; 1577/// - When ""v""=1 is specified, only the non-fixed parameters are shown.; 1578/// - When ""v""=2 all parameters are shown.; 1579///; 1580/// #### Notes:; 1581///; 1582/// - never call `SetOptFit(000111);` but `SetOptFit(111)`, 000111 will; 1583/// be taken as an octal number !!; 1584/// - `gStyle->SetOptFit(1)` is a shortcut allowing to set the most common; 1585/// case and is equivalent to `gStyle->SetOptFit(111)`; 1586/// - At ROOT startup the option fit is set to `0`. So, to see the fit parameters; 1587/// on all plot resulting from a fit, a call to `gStyle->SetOptFit()` with a; 1588/// non null value should be done. One can put it in the `rootlogon.C` file to; 1589/// always have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;;",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:51701,Availability,error,errors,51701,"d ""DATE"".; 1543/// The DATE attributes can also be edited interactively (position; 1544/// and attributes) via the normal context menu.; 1545 ; 1546void TStyle::SetOptDate(Int_t optdate); 1547{; 1548 fOptDate = optdate;; 1549 Int_t mode = optdate % 10;; 1550 if (mode == 1) {; 1551 SetDateX(0.01);; 1552 SetDateY(0.01);; 1553 fAttDate.SetTextAlign(11);; 1554 }; 1555 if (mode == 2) {; 1556 SetDateX(0.99);; 1557 SetDateY(0.01);; 1558 fAttDate.SetTextAlign(31);; 1559 }; 1560 if (mode == 3) {; 1561 SetDateX(0.99);; 1562 SetDateY(0.99);; 1563 fAttDate.SetTextAlign(33);; 1564 }; 1565}; 1566 ; 1567////////////////////////////////////////////////////////////////////////////////; 1568/// The type of information about fit parameters printed in the histogram; 1569/// statistics box can be selected via the parameter `mode`.; 1570/// The parameter mode can be = `pcev`:; 1571/// - p = 1; print Probability; 1572/// - c = 1; print Chisquare/Number of degrees of freedom; 1573/// - e = 1; print errors (if e=1, v must be 1); 1574/// - v = 1; print name/values of parameters; 1575/// Example: `gStyle->SetOptFit(1011);`; 1576/// print fit probability, parameter names/values and errors.; 1577/// - When ""v""=1 is specified, only the non-fixed parameters are shown.; 1578/// - When ""v""=2 all parameters are shown.; 1579///; 1580/// #### Notes:; 1581///; 1582/// - never call `SetOptFit(000111);` but `SetOptFit(111)`, 000111 will; 1583/// be taken as an octal number !!; 1584/// - `gStyle->SetOptFit(1)` is a shortcut allowing to set the most common; 1585/// case and is equivalent to `gStyle->SetOptFit(111)`; 1586/// - At ROOT startup the option fit is set to `0`. So, to see the fit parameters; 1587/// on all plot resulting from a fit, a call to `gStyle->SetOptFit()` with a; 1588/// non null value should be done. One can put it in the `rootlogon.C` file to; 1589/// always have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;;",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:53123,Availability,error,error,53123,"ays have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;; 1596 if (gPad) {; 1597 TIter next(gPad->GetListOfPrimitives());; 1598 while (auto obj = next()) {; 1599 TObject *stats = obj->FindObject(""stats"");; 1600 if (stats) stats->SetBit(kTakeStyle);; 1601 }; 1602 gPad->Modified(); gPad->Update();; 1603 }; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// The type of information printed in the histogram statistics box; 1608/// can be selected via the parameter mode.; 1609/// The parameter mode can be = `ksiourmen`; 1610/// - k = 1; kurtosis printed; 1611/// - k = 2; kurtosis and kurtosis error printed; 1612/// - s = 1; skewness printed; 1613/// - s = 2; skewness and skewness error printed; 1614/// - i = 1; integral of bins printed; 1615/// - i = 2; integral of bins with option ""width"" printed; 1616/// - o = 1; number of overflows printed; 1617/// - u = 1; number of underflows printed; 1618/// - r = 1; rms printed; 1619/// - r = 2; rms and rms error printed; 1620/// - m = 1; mean value printed; 1621/// - m = 2; mean and mean error values printed; 1622/// - e = 1; number of entries printed; 1623/// - n = 1; name of histogram is printed; 1624///; 1625/// Example: `gStyle->SetOptStat(11);`; 1626/// print only name of histogram and number of entries.; 1627/// `gStyle->SetOptStat(1101);` displays the name of histogram, mean value and RMS.; 1628///; 1629/// #### Notes:; 1630///; 1631/// - never call `SetOptStat(000111);` but `SetOptStat(111)`, 000111 will; 1632/// be taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// o",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:53212,Availability,error,error,53212,"ays have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;; 1596 if (gPad) {; 1597 TIter next(gPad->GetListOfPrimitives());; 1598 while (auto obj = next()) {; 1599 TObject *stats = obj->FindObject(""stats"");; 1600 if (stats) stats->SetBit(kTakeStyle);; 1601 }; 1602 gPad->Modified(); gPad->Update();; 1603 }; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// The type of information printed in the histogram statistics box; 1608/// can be selected via the parameter mode.; 1609/// The parameter mode can be = `ksiourmen`; 1610/// - k = 1; kurtosis printed; 1611/// - k = 2; kurtosis and kurtosis error printed; 1612/// - s = 1; skewness printed; 1613/// - s = 2; skewness and skewness error printed; 1614/// - i = 1; integral of bins printed; 1615/// - i = 2; integral of bins with option ""width"" printed; 1616/// - o = 1; number of overflows printed; 1617/// - u = 1; number of underflows printed; 1618/// - r = 1; rms printed; 1619/// - r = 2; rms and rms error printed; 1620/// - m = 1; mean value printed; 1621/// - m = 2; mean and mean error values printed; 1622/// - e = 1; number of entries printed; 1623/// - n = 1; name of histogram is printed; 1624///; 1625/// Example: `gStyle->SetOptStat(11);`; 1626/// print only name of histogram and number of entries.; 1627/// `gStyle->SetOptStat(1101);` displays the name of histogram, mean value and RMS.; 1628///; 1629/// #### Notes:; 1630///; 1631/// - never call `SetOptStat(000111);` but `SetOptStat(111)`, 000111 will; 1632/// be taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// o",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:53485,Availability,error,error,53485,"ays have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;; 1596 if (gPad) {; 1597 TIter next(gPad->GetListOfPrimitives());; 1598 while (auto obj = next()) {; 1599 TObject *stats = obj->FindObject(""stats"");; 1600 if (stats) stats->SetBit(kTakeStyle);; 1601 }; 1602 gPad->Modified(); gPad->Update();; 1603 }; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// The type of information printed in the histogram statistics box; 1608/// can be selected via the parameter mode.; 1609/// The parameter mode can be = `ksiourmen`; 1610/// - k = 1; kurtosis printed; 1611/// - k = 2; kurtosis and kurtosis error printed; 1612/// - s = 1; skewness printed; 1613/// - s = 2; skewness and skewness error printed; 1614/// - i = 1; integral of bins printed; 1615/// - i = 2; integral of bins with option ""width"" printed; 1616/// - o = 1; number of overflows printed; 1617/// - u = 1; number of underflows printed; 1618/// - r = 1; rms printed; 1619/// - r = 2; rms and rms error printed; 1620/// - m = 1; mean value printed; 1621/// - m = 2; mean and mean error values printed; 1622/// - e = 1; number of entries printed; 1623/// - n = 1; name of histogram is printed; 1624///; 1625/// Example: `gStyle->SetOptStat(11);`; 1626/// print only name of histogram and number of entries.; 1627/// `gStyle->SetOptStat(1101);` displays the name of histogram, mean value and RMS.; 1628///; 1629/// #### Notes:; 1630///; 1631/// - never call `SetOptStat(000111);` but `SetOptStat(111)`, 000111 will; 1632/// be taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// o",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:53568,Availability,error,error,53568,"ays have it.; 1590///; 1591/// see also SetOptStat below.; 1592 ; 1593void TStyle::SetOptFit(Int_t mode); 1594{; 1595 fOptFit = mode;; 1596 if (gPad) {; 1597 TIter next(gPad->GetListOfPrimitives());; 1598 while (auto obj = next()) {; 1599 TObject *stats = obj->FindObject(""stats"");; 1600 if (stats) stats->SetBit(kTakeStyle);; 1601 }; 1602 gPad->Modified(); gPad->Update();; 1603 }; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// The type of information printed in the histogram statistics box; 1608/// can be selected via the parameter mode.; 1609/// The parameter mode can be = `ksiourmen`; 1610/// - k = 1; kurtosis printed; 1611/// - k = 2; kurtosis and kurtosis error printed; 1612/// - s = 1; skewness printed; 1613/// - s = 2; skewness and skewness error printed; 1614/// - i = 1; integral of bins printed; 1615/// - i = 2; integral of bins with option ""width"" printed; 1616/// - o = 1; number of overflows printed; 1617/// - u = 1; number of underflows printed; 1618/// - r = 1; rms printed; 1619/// - r = 2; rms and rms error printed; 1620/// - m = 1; mean value printed; 1621/// - m = 2; mean and mean error values printed; 1622/// - e = 1; number of entries printed; 1623/// - n = 1; name of histogram is printed; 1624///; 1625/// Example: `gStyle->SetOptStat(11);`; 1626/// print only name of histogram and number of entries.; 1627/// `gStyle->SetOptStat(1101);` displays the name of histogram, mean value and RMS.; 1628///; 1629/// #### Notes:; 1630///; 1631/// - never call `SetOptStat(000111);` but `SetOptStat(111)`, 000111 will; 1632/// be taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// o",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:55085,Availability,error,error,55085,"taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// or overflow (100000), the stats box will show all combinations; 1638/// of underflow/overflows and not just one single number!; 1639 ; 1640void TStyle::SetOptStat(Int_t mode); 1641{; 1642 fOptStat = mode;; 1643 if (gPad) {; 1644 TIter next(gPad->GetListOfPrimitives());; 1645 while (auto obj = next()) {; 1646 TObject *stats = obj->FindObject(""stats"");; 1647 if (stats) stats->SetBit(kTakeStyle);; 1648 }; 1649 gPad->Modified(); gPad->Update();; 1650 }; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// The parameter mode can be any combination of kKsSiourRmMen; 1655/// - k : kurtosis printed; 1656/// - K : kurtosis and kurtosis error printed; 1657/// - s : skewness printed; 1658/// - S : skewness and skewness error printed; 1659/// - i : integral of bins printed; 1660/// - I : integral of bins with option ""width"" printed; 1661/// - o : number of overflows printed; 1662/// - u : number of underflows printed; 1663/// - r : rms printed; 1664/// - R : rms and rms error printed; 1665/// - m : mean value printed; 1666/// - M : mean value mean error values printed; 1667/// - e : number of entries printed; 1668/// - n : name of histogram is printed; 1669///; 1670/// Example: `gStyle->SetOptStat(""ne"");`; 1671/// print only name of histogram and number of entries.; 1672///; 1673/// - `gStyle->SetOptStat(""n"")` print only the name of the histogram; 1674/// - `gStyle->SetOptStat(""nemr"")` is the default; 1675 ; 1676void TStyle::SetOptStat(Option_t *stat); 1677{; 1678 Int_t mode = 0;; 1679 ; 1680 TString opt = stat;; 1681 ; 1682 if (opt.Contains(""n"")) mo",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:55168,Availability,error,error,55168,"taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// or overflow (100000), the stats box will show all combinations; 1638/// of underflow/overflows and not just one single number!; 1639 ; 1640void TStyle::SetOptStat(Int_t mode); 1641{; 1642 fOptStat = mode;; 1643 if (gPad) {; 1644 TIter next(gPad->GetListOfPrimitives());; 1645 while (auto obj = next()) {; 1646 TObject *stats = obj->FindObject(""stats"");; 1647 if (stats) stats->SetBit(kTakeStyle);; 1648 }; 1649 gPad->Modified(); gPad->Update();; 1650 }; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// The parameter mode can be any combination of kKsSiourRmMen; 1655/// - k : kurtosis printed; 1656/// - K : kurtosis and kurtosis error printed; 1657/// - s : skewness printed; 1658/// - S : skewness and skewness error printed; 1659/// - i : integral of bins printed; 1660/// - I : integral of bins with option ""width"" printed; 1661/// - o : number of overflows printed; 1662/// - u : number of underflows printed; 1663/// - r : rms printed; 1664/// - R : rms and rms error printed; 1665/// - m : mean value printed; 1666/// - M : mean value mean error values printed; 1667/// - e : number of entries printed; 1668/// - n : name of histogram is printed; 1669///; 1670/// Example: `gStyle->SetOptStat(""ne"");`; 1671/// print only name of histogram and number of entries.; 1672///; 1673/// - `gStyle->SetOptStat(""n"")` print only the name of the histogram; 1674/// - `gStyle->SetOptStat(""nemr"")` is the default; 1675 ; 1676void TStyle::SetOptStat(Option_t *stat); 1677{; 1678 Int_t mode = 0;; 1679 ; 1680 TString opt = stat;; 1681 ; 1682 if (opt.Contains(""n"")) mo",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:55423,Availability,error,error,55423,"taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// or overflow (100000), the stats box will show all combinations; 1638/// of underflow/overflows and not just one single number!; 1639 ; 1640void TStyle::SetOptStat(Int_t mode); 1641{; 1642 fOptStat = mode;; 1643 if (gPad) {; 1644 TIter next(gPad->GetListOfPrimitives());; 1645 while (auto obj = next()) {; 1646 TObject *stats = obj->FindObject(""stats"");; 1647 if (stats) stats->SetBit(kTakeStyle);; 1648 }; 1649 gPad->Modified(); gPad->Update();; 1650 }; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// The parameter mode can be any combination of kKsSiourRmMen; 1655/// - k : kurtosis printed; 1656/// - K : kurtosis and kurtosis error printed; 1657/// - s : skewness printed; 1658/// - S : skewness and skewness error printed; 1659/// - i : integral of bins printed; 1660/// - I : integral of bins with option ""width"" printed; 1661/// - o : number of overflows printed; 1662/// - u : number of underflows printed; 1663/// - r : rms printed; 1664/// - R : rms and rms error printed; 1665/// - m : mean value printed; 1666/// - M : mean value mean error values printed; 1667/// - e : number of entries printed; 1668/// - n : name of histogram is printed; 1669///; 1670/// Example: `gStyle->SetOptStat(""ne"");`; 1671/// print only name of histogram and number of entries.; 1672///; 1673/// - `gStyle->SetOptStat(""n"")` print only the name of the histogram; 1674/// - `gStyle->SetOptStat(""nemr"")` is the default; 1675 ; 1676void TStyle::SetOptStat(Option_t *stat); 1677{; 1678 Int_t mode = 0;; 1679 ; 1680 TString opt = stat;; 1681 ; 1682 if (opt.Contains(""n"")) mo",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:55502,Availability,error,error,55502,"taken as an octal number !!; 1633/// - `SetOptStat(1)` is s shortcut allowing to set the most common case, and is; 1634/// taken as `SetOptStat(1111)` (for backward compatibility with older versions.; 1635/// If you want to print only the name of the histogram call `SetOptStat(1000000001)`.; 1636/// - that in case of 2-D histograms, when selecting just underflow (10000); 1637/// or overflow (100000), the stats box will show all combinations; 1638/// of underflow/overflows and not just one single number!; 1639 ; 1640void TStyle::SetOptStat(Int_t mode); 1641{; 1642 fOptStat = mode;; 1643 if (gPad) {; 1644 TIter next(gPad->GetListOfPrimitives());; 1645 while (auto obj = next()) {; 1646 TObject *stats = obj->FindObject(""stats"");; 1647 if (stats) stats->SetBit(kTakeStyle);; 1648 }; 1649 gPad->Modified(); gPad->Update();; 1650 }; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// The parameter mode can be any combination of kKsSiourRmMen; 1655/// - k : kurtosis printed; 1656/// - K : kurtosis and kurtosis error printed; 1657/// - s : skewness printed; 1658/// - S : skewness and skewness error printed; 1659/// - i : integral of bins printed; 1660/// - I : integral of bins with option ""width"" printed; 1661/// - o : number of overflows printed; 1662/// - u : number of underflows printed; 1663/// - r : rms printed; 1664/// - R : rms and rms error printed; 1665/// - m : mean value printed; 1666/// - M : mean value mean error values printed; 1667/// - e : number of entries printed; 1668/// - n : name of histogram is printed; 1669///; 1670/// Example: `gStyle->SetOptStat(""ne"");`; 1671/// print only name of histogram and number of entries.; 1672///; 1673/// - `gStyle->SetOptStat(""n"")` print only the name of the histogram; 1674/// - `gStyle->SetOptStat(""nemr"")` is the default; 1675 ; 1676void TStyle::SetOptStat(Option_t *stat); 1677{; 1678 Int_t mode = 0;; 1679 ; 1680 TString opt = stat;; 1681 ; 1682 if (opt.Contains(""n"")) mo",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:96834,Availability,error,error,96834,"lue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::SetNameTitlevirtual void SetNameTitle(const char *name, const char *title)Set all the TNamed parameters (name and title).Definition TNamed.cxx:154; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyleTStyle objects may be created to define special styles.Definition TStyle.h:29; TStyle::GetViolinScaledBool_t GetViolinScaled() constDefinition TStyle.h:293; TStyle::GetTimeOffsetDouble_t GetTimeOffset() constDefinition TStyle.h:269; TStyle::GetAxisMaxDigitsInt_t GetAxisMaxDigits() constMethod returns maximum number of digits permitted for the axis labels above which the notation with 1...Definition TStyle.cxx:1157; TStyle::GetOptLogyInt_t GetOptLogy() const",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:102221,Availability,error,error,102221," SetFrameFillColor(Color_t color=1)Definition TStyle.h:372; TStyle::fFrameBorderModeInt_t fFrameBorderModePad frame border mode.Definition TStyle.h:76; TStyle::GetPadTickXInt_t GetPadTickX() constDefinition TStyle.h:217; TStyle::GetTitleColorColor_t GetTitleColor(Option_t *axis=""X"") constReturn title color.Definition TStyle.cxx:1204; TStyle::fHistLineStyleStyle_t fHistLineStyleHistogram line style.Definition TStyle.h:80; TStyle::GetFrameLineColorColor_t GetFrameLineColor() constDefinition TStyle.h:226; TStyle::GetGridStyleStyle_t GetGridStyle() constDefinition TStyle.h:223; TStyle::GetJoinLinePSInt_t GetJoinLinePS() constReturns the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin fo...Definition TStyle.h:287; TStyle::fLegendFillStyleStyle_t fLegendFillStyleLegend fill style.Definition TStyle.h:65; TStyle::SetStatFontvoid SetStatFont(Style_t font=62)Definition TStyle.h:394; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::GetStatFontSizeFloat_t GetStatFontSize() constDefinition TStyle.h:261; TStyle::GetBarOffsetFloat_t GetBarOffset() constDefinition TStyle.h:182; TStyle::GetStatXFloat_t GetStatX() constDefinition TStyle.h:264; TStyle::GetLabelSizeFloat_t GetLabelSize(Option_t *axis=""X"") constReturn label size.Definition TStyle.cxx:1145; TStyle::SetCapLinePSvoid SetCapLinePS(Int_t capline=0)Set the line cap method used for PostScript, PDF and SVG output. See TPostScript::SetLineCap for deta...Definition TStyle.h:307; TStyle::GetPadColorColor_t GetPadColor() constDefinition TStyle.h:208; TStyle::fBarOffsetFloat_t fBarOffsetOffset of bar for graphs.Definition TStyle.h:36; TStyle::GetCandleScaledBool_t GetCandleScaled() constDefinition TStyle.h:292; TStyle::SetPadRightMarginvoid SetPadRightMargin(Float_t margin=0.1)Definition TStyle.h:361; TStyle::GetHistFillStyleStyle_t GetHistFillStyle() c",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:110512,Availability,error,errorx,110512,"le_t GetHatchesSpacing() constDefinition TStyle.h:201; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; TStyle::fStatYFloat_t fStatYY position of top right corner of stat box.Definition TStyle.h:114; TStyle::Copyvoid Copy(TObject &style) const overrideCopy this style.Definition TStyle.cxx:551; TStyle::GetLegendBorderSizeWidth_t GetLegendBorderSize() constDefinition TStyle.h:202; TStyle::fFrameLineStyleStyle_t fFrameLineStylePad frame line style.Definition TStyle.h:73; TStyle::SetStatBorderSizevoid SetStatBorderSize(Width_t size=2)Definition TStyle.h:393; TStyle::GetBarWidthFloat_t GetBarWidth() constDefinition TStyle.h:183; TStyle::fCanvasBorderModeInt_t fCanvasBorderModeCanvas border mode.Definition TStyle.h:87; TStyle::GetCanvasPreferGLBool_t GetCanvasPreferGL() constDefinition TStyle.h:187; TStyle::GetColorModelPSInt_t GetColorModelPS() constDefinition TStyle.h:196; TStyle::SetErrorXvoid SetErrorX(Float_t errorx=0.5)Definition TStyle.h:340; TStyle::GetCanvasDefYInt_t GetCanvasDefY() constDefinition TStyle.h:194; TStyle::SetTitleColorvoid SetTitleColor(Color_t color=1, Option_t *axis=""X"")Definition TStyle.cxx:1754; TStyle::SetNumberContoursvoid SetNumberContours(Int_t number=20)Set the default number of contour levels when drawing 2-d plots.Definition TStyle.cxx:1500; TStyle::Paintvoid Paint(Option_t *option="""") overrideCopy this style to gStyle.Definition TStyle.cxx:1252; TStyle::fTitleXFloat_t fTitleXX position of top left corner of title box.Definition TStyle.h:125; TStyle::fShowToolBarInt_t fShowToolBarShow toolbar.Definition TStyle.h:49; TStyle::SetLabelFontvoid SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition TStyle.cxx:1413; TStyle::fCapLinePSInt_t fCapLinePSDetermines the appearance of line caps on PostScript, PDF and SVG.Definition TStyle.h:137; TStyle::fFuncWidthWidth_t fFuncWidthFunction line width.Definiti",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:113063,Availability,error,error,113063,"TStyle.h:230; TStyle::fHistLineWidthWidth_t fHistLineWidthHistogram line width.Definition TStyle.h:81; TStyle::SetTimeOffsetvoid SetTimeOffset(Double_t toffset)Change the time offset for time plotting.Definition TStyle.cxx:1913; TStyle::fPadGridYBool_t fPadGridYTrue to get the grid along Y.Definition TStyle.h:100; TStyle::SetTitlePSvoid SetTitlePS(const char *pstitle)Define a string to be used in the %Title of the Postscript files.Definition TStyle.cxx:1383; TStyle::fHistFillStyleStyle_t fHistFillStyleHistogram fill style.Definition TStyle.h:79; TStyle::SetHistMinimumZerovoid SetHistMinimumZero(Bool_t zero=kTRUE)If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms is set to 0.Definition TStyle.cxx:1288; TStyle::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::GetStatHFloat_t GetStatH() constDefinition TStyle.h:267; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::fEndErrorSizeFloat_t fEndErrorSizeSize of lines at the end of error bars.Definition TStyle.h:55; TStyle::SetJoinLinePSvoid SetJoinLinePS(Int_t joinline=0)Set the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin for de...Definition TStyle.h:306; TStyle::fIsReadingBool_t fIsReading! Set to FALSE when userclass::UseCurrentStyle is called by the style managerDefinition TStyle.h:139; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::fFrameBorderSizeWidth_t fFrameBorderSizePad frame border size.Definition TStyle.h:75; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::SetTitleXOffsetvoid SetTitleXOffset(Float_t offset=1)Definition TStyle.h:409; TStyle::SetLegendBorderSizevoid SetLegendBorderSize(Width_t size=4)Definition TStyle.h:350; TStyle::GetAttDateTAttText * GetAttDate()Definition TStyle.h:168; TStyle::fTitleTextColorColor_t fTitleTextColorTitle text color.Definition TStyle.h:120; TStyle::GetPadTickYInt_t GetPadTickY(",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:125599,Availability,error,errors,125599,"berOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::fStatHFloat_t fStatHHeight of stat box.Definition TStyle.h:116; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::fStatXFloat_t fStatXX position of top right corner of stat box.Definition TStyle.h:113; TStyle::fCanvasDefYInt_t fCanvasDefYDefault canvas top Y position.Definition TStyle.h:91; TStyle::GetNumberContoursInt_t GetNumberContours() constDefinition TStyle.h:241; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TStyle::fOrthoCameraBool_t fOrthoCameraUse orthographic camera with web display.Definition TStyle.h:150; TStyle::fPadBottomMarginFloat_t fPadBottomMarginPad bottom margin.Definition TStyle.h:95; TStyle::GetPaintTextFormatconst char * GetPaintTextFormat() constDefinition TStyle.h:250; TStyle::GetLineScalePSFloat_t GetLineScalePS() constDefinition TStyle.h:289; TStyle::fErrorXFloat_t fErrorXPer cent of bin width for errors along X.Definition TStyle.h:56; TStyle::SetLabelColorvoid SetLabelColor(Color_t color=1, Option_t *axis=""X"")Set axis labels color.Definition TStyle.cxx:1393; TStyle::SetCandleBoxRangevoid SetCandleBoxRange(Double_t bRange=0.5)By setting box-range for candle plot, one can force the box of the candle-chart to cover that given f...Definition TStyle.cxx:1956; TStyle::GetStatFontStyle_t GetStatFont() constDefinition TStyle.h:260; TStyle::SetLabelSizevoid SetLabelSize(Float_t size=0.04, Option_t *axis=""X"")Set size of axis labels.Definition TStyle.cxx:1444; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TStyle::fLegendBorderSizeWidth_t fLegendBorderSizeLegend box border size.Definition TStyle.h:63; TStyle::fStatWFloat_t fStatWWidth of stat box.Definition TStyle.h:115; TStyle::fYAxisExpYOffsetFloat_t fYAxisExpYOffsetY axis exponent labe",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:96840,Integrability,message,message,96840,"lue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::SetNameTitlevirtual void SetNameTitle(const char *name, const char *title)Set all the TNamed parameters (name and title).Definition TNamed.cxx:154; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyleTStyle objects may be created to define special styles.Definition TStyle.h:29; TStyle::GetViolinScaledBool_t GetViolinScaled() constDefinition TStyle.h:293; TStyle::GetTimeOffsetDouble_t GetTimeOffset() constDefinition TStyle.h:269; TStyle::GetAxisMaxDigitsInt_t GetAxisMaxDigits() constMethod returns maximum number of digits permitted for the axis labels above which the notation with 1...Definition TStyle.cxx:1157; TStyle::GetOptLogyInt_t GetOptLogy() const",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:1591,Modifiability,inherit,inherit,1591,"*********************************************************************/; 11 ; 12#include <cstring>; 13#include <cstdio>; 14#include <cctype>; 15#include <cmath>; 16#include <iostream>; 17#include <fstream>; 18 ; 19#include ""strlcpy.h""; 20#include ""TApplication.h""; 21#include ""TColor.h""; 22#include ""TDatime.h""; 23#include ""TROOT.h""; 24#include ""TStyle.h""; 25#include ""TSystem.h""; 26#include ""TVirtualPad.h""; 27#include ""TVirtualMutex.h""; 28#include ""TEnv.h""; 29 ; 30TStyle *gStyle;; 31const UInt_t kTakeStyle = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:1918,Modifiability,variab,variable,1918,"tem.h""; 26#include ""TVirtualPad.h""; 27#include ""TVirtualMutex.h""; 28#include ""TEnv.h""; 29 ; 30TStyle *gStyle;; 31const UInt_t kTakeStyle = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->SetPadColor(0);; 77 plain->SetCanvasColor(0);; 78 plain->SetTitleColor(0);; 79 plain->SetStatColor(0);; 80```; 81 ; 82You can set the current style with:; 83 ; 84```; 85gROOT->SetStyle(style_name);; 86```; 87 ; 88You can get a pointer to an existing style with:; 89 ; 90```; 91auto style = gROOT->GetStyle(style_name);; 92```; 93 ; 94You can create additional styles with:;",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:4223,Modifiability,extend,extended,4223,"->SetStatX(0.7);; 107 gStyle->SetStatW(0.2);; 108 gStyle->SetLabelOffset(1.2);; 109 gStyle->SetLabelFont(72);; 110```; 111 ; 112Note that when an object is created, its attributes are taken from the current; 113style. For example, you may have created an histogram in a previous session,; 114saved it in a file. Meanwhile, if you have changed the style, the histogram will; 115be drawn with the old attributes. You can force the current style attributes to; 116be set when you read an object from a file by calling:; 117 ; 118```; 119gROOT->ForceStyle();; 120```; 121 ; 122before reading the objects from the file.; 123 ; 124Let's assume you have a canvas or pad with your histogram or any other object,; 125you can force these objects to get the attributes of the current style via:; 126 ; 127```; 128canvas->UseCurrentStyle();; 129```; 130 ; 131The description of the style functions should be clear from the name of the; 132TStyle Setters or Getters. Some functions have an extended description, in particular:; 133 ; 134 - TStyle:SetLabelFont.; 135 - TStyle:SetLineStyleString, to set the format of dashed lines.; 136 - TStyle:SetOptStat.; 137 - TStyle:SetPalette to change the colors palette.; 138 - TStyle:SetTitleOffset.; 139 ; 140*/; 141 ; 142////////////////////////////////////////////////////////////////////////////////; 143/// Default constructor.; 144 ; 145TStyle::TStyle() :TNamed(); 146{; 147 Reset();; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a new TStyle.; 152/// The following names are reserved to create special styles:; 153///; 154/// - `Classic`: Similar to `Default` style set in TStyle::Reset; 155/// - `Plain`: a black&white oriented style; 156/// - `Bold`; 157/// - `Video`; 158/// - `Pub`; 159/// - `Modern`: Used when ROOT starts; 160/// - `ATLAS`: style used by the ATLAS experiment; 161/// - `BELLE2`: style used by the BELLE II experiment; 162/// (see the definition of these styles below).; 163///",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:44938,Performance,scalab,scalable,44938,"pt files.; 1381/// If this string is not defined, ROOT will use the canvas title.; 1382 ; 1383void TStyle::SetTitlePS(const char *pstitle); 1384{; 1385 fTitlePS = pstitle;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Set axis labels color.; 1390/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 1391/// if axis=""xyz"" set all 3 axes; 1392 ; 1393void TStyle::SetLabelColor(Color_t color, Option_t *axis); 1394{; 1395 TString opt = axis;; 1396 opt.ToLower();; 1397 ; 1398 if (opt.Contains(""x"")) fXaxis.SetLabelColor(color);; 1399 if (opt.Contains(""y"")) fYaxis.SetLabelColor(color);; 1400 if (opt.Contains(""z"")) fZaxis.SetLabelColor(color);; 1401}; 1402 ; 1403////////////////////////////////////////////////////////////////////////////////; 1404/// Set font number used to draw axis labels.; 1405/// - font : Text font code = 10*fontnumber + precision; 1406/// - Font numbers must be between 1 and 14; 1407/// - precision = 1 fast hardware fonts (steps in the size); 1408/// - precision = 2 scalable and rotatable hardware fonts; 1409/// The default font number is 62.; 1410/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 1411/// if axis=""xyz"" set all 3 axes; 1412 ; 1413void TStyle::SetLabelFont(Style_t font, Option_t *axis); 1414{; 1415 TString opt = axis;; 1416 opt.ToLower();; 1417 ; 1418 if (opt.Contains(""x"")) fXaxis.SetLabelFont(font);; 1419 if (opt.Contains(""y"")) fYaxis.SetLabelFont(font);; 1420 if (opt.Contains(""z"")) fZaxis.SetLabelFont(font);; 1421}; 1422 ; 1423////////////////////////////////////////////////////////////////////////////////; 1424/// Set offset between axis and axis labels.; 1425/// The offset is expressed as a percent of the pad height.; 1426/// axis specifies which axis (""x"",""y"",""z""), default = ""x""; 1427/// if axis=""xyz"" set all 3 axes; 1428 ; 1429void TStyle::SetLabelOffset(Float_t offset, Option_t *axis); 1430{; 1431 TString opt = axis;; 1432 opt.ToLower();; 1433 ; 1434 if (o",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:1270,Security,access,accessed,1270,"*****************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <cstdio>; 14#include <cctype>; 15#include <cmath>; 16#include <iostream>; 17#include <fstream>; 18 ; 19#include ""strlcpy.h""; 20#include ""TApplication.h""; 21#include ""TColor.h""; 22#include ""TDatime.h""; 23#include ""TROOT.h""; 24#include ""TStyle.h""; 25#include ""TSystem.h""; 26#include ""TVirtualPad.h""; 27#include ""TVirtualMutex.h""; 28#include ""TEnv.h""; 29 ; 30TStyle *gStyle;; 31const UInt_t kTakeStyle = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventi",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:3140,Testability,log,log,3140,"; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->SetPadColor(0);; 77 plain->SetCanvasColor(0);; 78 plain->SetTitleColor(0);; 79 plain->SetStatColor(0);; 80```; 81 ; 82You can set the current style with:; 83 ; 84```; 85gROOT->SetStyle(style_name);; 86```; 87 ; 88You can get a pointer to an existing style with:; 89 ; 90```; 91auto style = gROOT->GetStyle(style_name);; 92```; 93 ; 94You can create additional styles with:; 95 ; 96```; 97 TStyle *st1 = new TStyle(""st1"",""my style"");; 98 st1->Set....; 99 st1->cd(); this becomes now the current style gStyle; 100```; 101 ; 102In your [rootlogon.C](https://root.cern/doc/master/classexamples/startsession.log.html); 103file, you can redefine the default parameters via statements like:; 104 ; 105```; 106 gStyle->SetStatX(0.7);; 107 gStyle->SetStatW(0.2);; 108 gStyle->SetLabelOffset(1.2);; 109 gStyle->SetLabelFont(72);; 110```; 111 ; 112Note that when an object is created, its attributes are taken from the current; 113style. For example, you may have created an histogram in a previous session,; 114saved it in a file. Meanwhile, if you have changed the style, the histogram will; 115be drawn with the old attributes. You can force the current style attributes to; 116be set when you read an object from a file by calling:; 117 ; 118```; 119gROOT->ForceStyle();; 120```; 121 ; 122before reading the objects from the file.; 123 ; 124Let's assume you have a canvas or pad with your histogram or any other object,; 125you can force these objects to get the attributes of the current style via:; 126 ; 127```; 128canvas->UseCurrentStyle();; 129```; 130 ; 131The description of the style functions should be ",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:106373,Testability,log,log,106373,"on TStyle.h:101; TStyle::GetDateXFloat_t GetDateX() constDefinition TStyle.h:197; TStyle::fStatFontStyle_t fStatFontFont style of Stats PaveLabel.Definition TStyle.h:109; TStyle::fLineStyleTString fLineStyle[30]String describing line style i (for postScript)Definition TStyle.h:130; TStyle::SetDateYvoid SetDateY(Float_t y=0.01)Definition TStyle.h:338; TStyle::fGridWidthWidth_t fGridWidthGrid line width.Definition TStyle.h:62; TStyle::fCandleBoxRangeDouble_t fCandleBoxRangeCandle plot, The fraction which is covered by the box (0 < x < 1), default 0.5.Definition TStyle.h:142; TStyle::GetTitleOffsetFloat_t GetTitleOffset(Option_t *axis=""X"") constReturn title offset.Definition TStyle.cxx:1228; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetFrameBorderModevoid SetFrameBorderMode(Int_t mode=1)Definition TStyle.h:378; TStyle::GetTitleFontStyle_t GetTitleFont(Option_t *axis=""X"") constReturn title font.Definition TStyle.cxx:1216; TStyle::fOptLogxInt_t fOptLogxTrue if log scale in X.Definition TStyle.h:39; TStyle::fStripDecimalsBool_t fStripDecimalsStrip decimals in axis labels.Definition TStyle.h:117; TStyle::fHistMinimumZeroBool_t fHistMinimumZeroTrue if default minimum is 0, false if minimum is automatic.Definition TStyle.h:82; TStyle::fLegendFontStyle_t fLegendFontLegend font style.Definition TStyle.h:66; TStyle::SetFuncColorvoid SetFuncColor(Color_t color=1)Definition TStyle.h:367; TStyle::GetHistMinimumZeroBool_t GetHistMinimumZero() constDefinition TStyle.h:237; TStyle::fXaxisTAttAxis fXaxisX axis attributes.Definition TStyle.h:32; TStyle::SetHeaderPSvoid SetHeaderPS(const char *header)Define a string to be inserted in the Postscript header.Definition TStyle.cxx:1362; TStyle::GetStatYFloat_t GetStatY() constDefinition TStyle.h:265; TStyle::fTitleColorColor_t fTitleColorTitle fill area color.Definition TStyle.h:119; TStyle::fJoinLinePSInt_t fJoinLinePSDetermines the appearance of joining lines on PostScript, PDF and SVG.Definit",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:115424,Testability,log,log,115424,"stLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::fHeaderPSTString fHeaderPSUser defined additional Postscript header.Definition TStyle.h:131; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::cdvirtual void cd()Change current style.Definition TStyle.cxx:543; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TStyle::SetLabelOffsetvoid SetLabelOffset(Float_t offset=0.005, Option_t *axis=""X"")Set offset between axis and axis labels.Definition TStyle.cxx:1429; TStyle::fPadColorColor_t fPadColorPad color.Definition TStyle.h:92; TStyle::SetFitFormatvoid SetFitFormat(const char *format=""5.4g"")Definition TStyle.h:301; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TStyle::fDateXFloat_t fDateXX position of the date in the canvas (in NDC)Definition TStyle.h:53; TStyle::fOptLogzInt_t fOptLogzTrue if log scale in z.Definition TStyle.h:41; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::fFitFormatTString fFitFormatPrinting format for fit parameters.Definition TStyle.h:133; TStyle::fPadBorderModeInt_t fPadBorderModePad border mode.Definition TStyle.h:94; TStyle::GetLegendTextSizeDouble_t GetLegendTextSize() constDefinition TStyle.h:206; TStyle::fNumberContoursInt_t fNumberContoursDefault number of contours for 2-d plots.Definition TStyle.h:51; TStyle::SetLineStyleStringvoid SetLineStyleString(Int_t i, const char *text)Set line style string using the PostScript convention.Definition TStyle.cxx:1483; TStyle::GetCandleBoxRangeDouble_t GetCandleBoxRange() constDefinition TStyle.h:291; TStyle::fPadLeftMarginFloat_t fPadLeftMarginPad left margin.Definition TStyle.h:97; TStyle::fTitleYFloat_t fTitleYY position of top left corn",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:123040,Testability,log,log,123040,"::ostream &out, Option_t *="""") overrideSave a main frame widget as a C++ statement(s) on output stream out.Definition TStyle.cxx:2027; TStyle::fCandleScaledBool_t fCandleScaledCandle plot, shall the box-width be scaled to each other by the integral of a box?Definition TStyle.h:143; TStyle::GetTitleHFloat_t GetTitleH() constDefinition TStyle.h:283; TStyle::GetStatStyleStyle_t GetStatStyle() constDefinition TStyle.h:262; TStyle::fStatFontSizeFloat_t fStatFontSizeFont size in pixels for fonts with precision type 3.Definition TStyle.h:110; TStyle::fCanvasPreferGLBool_t fCanvasPreferGLIf true, rendering in canvas is with GL.Definition TStyle.h:84; TStyle::fLegoInnerRFloat_t fLegoInnerRInner radius for cylindrical legos.Definition TStyle.h:129; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::EPaperSizeEPaperSizeDefinition TStyle.h:153; TStyle::kA4@ kA4Definition TStyle.h:153; TStyle::kUSLetter@ kUSLetterDefinition TStyle.h:153; TStyle::fOptLogyInt_t fOptLogyTrue if log scale in y.Definition TStyle.h:40; TStyle::fAxisMaxDigitsInt_t fAxisMaxDigitsNumber of digits above which the 10^N notation is used for axis.Definition TStyle.h:149; TStyle::GetFrameLineStyleStyle_t GetFrameLineStyle() constDefinition TStyle.h:228; TStyle::SetIsReadingvoid SetIsReading(Bool_t reading=kTRUE)Sets the fIsReading member to reading (default=kTRUE).Definition TStyle.cxx:1374; TStyle::GetStatWFloat_t GetStatW() constDefinition TStyle.h:266; TStyle::fGridStyleStyle_t fGridStyleGrid line style.Definition TStyle.h:61; TStyle::fHistFillColorColor_t fHistFillColorHistogram fill color.Definition TStyle.h:77; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetFitFormatconst char * GetFitFormat() constDefinition TStyle.h:199; TStyle::fCanvasDefHInt_t fCanvasDefHDefault canvas height.Definition TStyle.h:88; TStyle::GetCanvasBorderModeInt_t GetCanvasBorderMode() constDefinition TStyle.h:190; TStyle::GetPadBorderModeInt_t GetPadBorderMode() co",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:2048,Usability,simpl,simply,2048,"le = BIT(17);; 32 ; 33ClassImp(TStyle);; 34 ; 35/** \class TStyle; 36\ingroup Base; 37 \ingroup GraphicsAtt; 38 ; 39TStyle objects may be created to define special styles.; 40By default ROOT creates a default style that can be accessed via; 41the gStyle pointer.; 42 ; 43This class includes functions to set some of the following object attributes.; 44 - Canvas; 45 - Pad; 46 - Histogram axis; 47 - Lines; 48 - Fill areas; 49 - Text; 50 - Markers; 51 - Functions; 52 - Histogram Statistics and Titles; 53 ; 54All objects that can be drawn in a pad inherit from one or more attribute classes; 55like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their; 56default attributes are taken from the current style. The current style is an object; 57of the class[TStyle](https://root.cern/doc/master/classTStyle.html) and can be; 58referenced via the global variable `gStyle` (in TStyle.h).; 59 ; 60ROOT provides two styles called ""Default"" and ""Plain"". The ""Default""; 61style is created simply by:; 62 ; 63~~~ {.cpp}; 64 auto default = new TStyle(""Default"",""Default Style"");; 65~~~; 66 ; 67The `Plain` style can be used if you are working on a monochrome display or; 68if you want to get a ""conventional"" Postscript output. These are the instructions; 69in the ROOT constructor to create the `Plain` style.; 70 ; 71```; 72auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; 73 ; 74 plain->SetCanvasBorderMode(0);; 75 plain->SetPadBorderMode(0);; 76 plain->SetPadColor(0);; 77 plain->SetCanvasColor(0);; 78 plain->SetTitleColor(0);; 79 plain->SetStatColor(0);; 80```; 81 ; 82You can set the current style with:; 83 ; 84```; 85gROOT->SetStyle(style_name);; 86```; 87 ; 88You can get a pointer to an existing style with:; 89 ; 90```; 91auto style = gROOT->GetStyle(style_name);; 92```; 93 ; 94You can create additional styles with:; 95 ; 96```; 97 TStyle *st1 = new TStyle(""st1"",""my style"");; 98 st1->Set....; 99 st1->cd(); this becomes now the current style gStyle",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8cxx_source.html:4142,Usability,clear,clear,4142,"t style gStyle; 100```; 101 ; 102In your [rootlogon.C](https://root.cern/doc/master/classexamples/startsession.log.html); 103file, you can redefine the default parameters via statements like:; 104 ; 105```; 106 gStyle->SetStatX(0.7);; 107 gStyle->SetStatW(0.2);; 108 gStyle->SetLabelOffset(1.2);; 109 gStyle->SetLabelFont(72);; 110```; 111 ; 112Note that when an object is created, its attributes are taken from the current; 113style. For example, you may have created an histogram in a previous session,; 114saved it in a file. Meanwhile, if you have changed the style, the histogram will; 115be drawn with the old attributes. You can force the current style attributes to; 116be set when you read an object from a file by calling:; 117 ; 118```; 119gROOT->ForceStyle();; 120```; 121 ; 122before reading the objects from the file.; 123 ; 124Let's assume you have a canvas or pad with your histogram or any other object,; 125you can force these objects to get the attributes of the current style via:; 126 ; 127```; 128canvas->UseCurrentStyle();; 129```; 130 ; 131The description of the style functions should be clear from the name of the; 132TStyle Setters or Getters. Some functions have an extended description, in particular:; 133 ; 134 - TStyle:SetLabelFont.; 135 - TStyle:SetLineStyleString, to set the format of dashed lines.; 136 - TStyle:SetOptStat.; 137 - TStyle:SetPalette to change the colors palette.; 138 - TStyle:SetTitleOffset.; 139 ; 140*/; 141 ; 142////////////////////////////////////////////////////////////////////////////////; 143/// Default constructor.; 144 ; 145TStyle::TStyle() :TNamed(); 146{; 147 Reset();; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a new TStyle.; 152/// The following names are reserved to create special styles:; 153///; 154/// - `Classic`: Similar to `Default` style set in TStyle::Reset; 155/// - `Plain`: a black&white oriented style; 156/// - `Bold`; 157/// - `Video`; 158/// - `Pu",MatchSource.WIKI,doc/master/TStyle_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html
https://root.cern/doc/master/TStyle_8h.html:365,Integrability,depend,dependency,365,". ROOT: core/base/inc/TStyle.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Variables ; TStyle.h File Reference. #include ""TNamed.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TAttText.h""; #include ""TAttAxis.h""; #include ""TColor.h""; #include ""TArrayI.h"". Include dependency graph for TStyle.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class TStyle; TStyle objects may be created to define special styles. More...; . Variables; R__EXTERN TStyle *gStyle; . Variable Documentation. gStyle. R__EXTERN TStyle* gStyle. Definition at line 436 of file TStyle.h. corebaseincTStyle.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TStyle_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h.html
https://root.cern/doc/master/TStyle_8h_source.html:2368,Availability,error,error,2368,"ic TAttLine, public TAttFill, public TAttMarker, public TAttText {; 30 ; 31private:; 32 TAttAxis fXaxis; ///< X axis attributes; 33 TAttAxis fYaxis; ///< Y axis attributes; 34 TAttAxis fZaxis; ///< Z axis attributes; 35 Float_t fBarWidth; ///< Width of bar for graphs; 36 Float_t fBarOffset; ///< Offset of bar for graphs; 37 Int_t fColorModelPS; ///< PostScript color model: 0 = RGB, 1 = CMYK; 38 Int_t fDrawBorder; ///< Flag to draw border(=1) or not (0); 39 Int_t fOptLogx; ///< True if log scale in X; 40 Int_t fOptLogy; ///< True if log scale in y; 41 Int_t fOptLogz; ///< True if log scale in z; 42 Int_t fOptDate; ///< True if date option is selected; 43 Int_t fOptStat; ///< True if option Stat is selected; 44 Int_t fOptTitle; ///< True if option Title is selected; 45 Int_t fOptFile; ///< True if option File is selected; 46 Int_t fOptFit; ///< True if option Fit is selected; 47 Int_t fShowEventStatus; ///< Show event status panel; 48 Int_t fShowEditor; ///< Show pad editor; 49 Int_t fShowToolBar; ///< Show toolbar; 50 ; 51 Int_t fNumberContours; ///< Default number of contours for 2-d plots; 52 TAttText fAttDate; ///< Canvas date attribute; 53 Float_t fDateX; ///< X position of the date in the canvas (in NDC); 54 Float_t fDateY; ///< Y position of the date in the canvas (in NDC); 55 Float_t fEndErrorSize; ///< Size of lines at the end of error bars; 56 Float_t fErrorX; ///< Per cent of bin width for errors along X; 57 Color_t fFuncColor; ///< Function color; 58 Style_t fFuncStyle; ///< Function style; 59 Width_t fFuncWidth; ///< Function line width; 60 Color_t fGridColor; ///< Grid line color (if 0 use axis line color); 61 Style_t fGridStyle; ///< Grid line style; 62 Width_t fGridWidth; ///< Grid line width; 63 Width_t fLegendBorderSize; ///< Legend box border size; 64 Color_t fLegendFillColor; ///< Legend fill color; 65 Style_t fLegendFillStyle; ///< Legend fill style; 66 Style_t fLegendFont; ///< Legend font style; 67 Double_t fLegendTextSize; ///< Legend text size.",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:2431,Availability,error,errors,2431,"ic TAttLine, public TAttFill, public TAttMarker, public TAttText {; 30 ; 31private:; 32 TAttAxis fXaxis; ///< X axis attributes; 33 TAttAxis fYaxis; ///< Y axis attributes; 34 TAttAxis fZaxis; ///< Z axis attributes; 35 Float_t fBarWidth; ///< Width of bar for graphs; 36 Float_t fBarOffset; ///< Offset of bar for graphs; 37 Int_t fColorModelPS; ///< PostScript color model: 0 = RGB, 1 = CMYK; 38 Int_t fDrawBorder; ///< Flag to draw border(=1) or not (0); 39 Int_t fOptLogx; ///< True if log scale in X; 40 Int_t fOptLogy; ///< True if log scale in y; 41 Int_t fOptLogz; ///< True if log scale in z; 42 Int_t fOptDate; ///< True if date option is selected; 43 Int_t fOptStat; ///< True if option Stat is selected; 44 Int_t fOptTitle; ///< True if option Title is selected; 45 Int_t fOptFile; ///< True if option File is selected; 46 Int_t fOptFit; ///< True if option Fit is selected; 47 Int_t fShowEventStatus; ///< Show event status panel; 48 Int_t fShowEditor; ///< Show pad editor; 49 Int_t fShowToolBar; ///< Show toolbar; 50 ; 51 Int_t fNumberContours; ///< Default number of contours for 2-d plots; 52 TAttText fAttDate; ///< Canvas date attribute; 53 Float_t fDateX; ///< X position of the date in the canvas (in NDC); 54 Float_t fDateY; ///< Y position of the date in the canvas (in NDC); 55 Float_t fEndErrorSize; ///< Size of lines at the end of error bars; 56 Float_t fErrorX; ///< Per cent of bin width for errors along X; 57 Color_t fFuncColor; ///< Function color; 58 Style_t fFuncStyle; ///< Function style; 59 Width_t fFuncWidth; ///< Function line width; 60 Color_t fGridColor; ///< Grid line color (if 0 use axis line color); 61 Style_t fGridStyle; ///< Grid line style; 62 Width_t fGridWidth; ///< Grid line width; 63 Width_t fLegendBorderSize; ///< Legend box border size; 64 Color_t fLegendFillColor; ///< Legend fill color; 65 Style_t fLegendFillStyle; ///< Legend fill style; 66 Style_t fLegendFont; ///< Legend font style; 67 Double_t fLegendTextSize; ///< Legend text size.",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:20085,Availability,error,errorx,20085,", Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 void SetCanvasDefW(Int_t w=700) {fCanvasDefW = w;}; 348 void SetCanvasDefX(Int_t topx=10) {fCanvasDefX = topx;}; 349 void SetCanvasDefY(Int_t topy=10) {fCanvasDefY = topy;}; 350 void SetLegendBorderSize(Width_t size=4) {fLegendBorderSize = size;}; 351 void SetLegendFillColor(Color_t color=0) {fLegendFillColor = color;}; 352 void SetLegendFillStyle(Style_t style=1001) {fLegendFillStyle = style;}; 353 void SetLegendFont(Style_t font=62) {fLegendFont = font;}; 354 void SetLegendTextSize(Double_t size=0.)",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:20108,Availability,error,errorx,20108,Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 void SetCanvasDefW(Int_t w=700) {fCanvasDefW = w;}; 348 void SetCanvasDefX(Int_t topx=10) {fCanvasDefX = topx;}; 349 void SetCanvasDefY(Int_t topy=10) {fCanvasDefY = topy;}; 350 void SetLegendBorderSize(Width_t size=4) {fLegendBorderSize = size;}; 351 void SetLegendFillColor(Color_t color=0) {fLegendFillColor = color;}; 352 void SetLegendFillStyle(Style_t style=1001) {fLegendFillStyle = style;}; 353 void SetLegendFont(Style_t font=62) {fLegendFont = font;}; 354 void SetLegendTextSize(Double_t size=0.) {fLegendTextSize = size;}; 355 void SetPadColor(Color_t color=19) {fPadColor = color;}; 356 void SetPadBorderSize(Width_t size=1) {fPadBorderSize = size;}; 357 void SetPadBorderMode(Int_t mode=1) {fPadBorderMode = mode;}; 358 void SetPadBottomMargin(Float_t margin=0.1) {fPadBottomMargin=margin;}; 359 void SetPadTopMargin(Float_t margin=0.1) {fPadTopMargin=margin;}; 360 void SetPadLeftMargin(Float_t margin=0.1) {fPadLeftMargin=margin;}; 361 void SetPadRightMargin(Float_t margin=0.1) {fPadRightMargin=margin;}; 362 void ,MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:37819,Availability,error,error,37819,"7; TStyle::GetPadTickXInt_t GetPadTickX() constDefinition TStyle.h:217; TStyle::GetTitleColorColor_t GetTitleColor(Option_t *axis=""X"") constReturn title color.Definition TStyle.cxx:1204; TStyle::IsReadingBool_t IsReading() constDefinition TStyle.h:296; TStyle::fHistLineStyleStyle_t fHistLineStyleHistogram line style.Definition TStyle.h:80; TStyle::GetFrameLineColorColor_t GetFrameLineColor() constDefinition TStyle.h:226; TStyle::SetTitleYSizevoid SetTitleYSize(Float_t size=0.02)Definition TStyle.h:412; TStyle::GetGridStyleStyle_t GetGridStyle() constDefinition TStyle.h:223; TStyle::GetJoinLinePSInt_t GetJoinLinePS() constReturns the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin fo...Definition TStyle.h:287; TStyle::fLegendFillStyleStyle_t fLegendFillStyleLegend fill style.Definition TStyle.h:65; TStyle::SetStatFontvoid SetStatFont(Style_t font=62)Definition TStyle.h:394; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::GetStatFontSizeFloat_t GetStatFontSize() constDefinition TStyle.h:261; TStyle::GetBarOffsetFloat_t GetBarOffset() constDefinition TStyle.h:182; TStyle::GetStatXFloat_t GetStatX() constDefinition TStyle.h:264; TStyle::GetLabelSizeFloat_t GetLabelSize(Option_t *axis=""X"") constReturn label size.Definition TStyle.cxx:1145; TStyle::SetStatStylevoid SetStatStyle(Style_t style=1001)Definition TStyle.h:392; TStyle::SetCapLinePSvoid SetCapLinePS(Int_t capline=0)Set the line cap method used for PostScript, PDF and SVG output. See TPostScript::SetLineCap for deta...Definition TStyle.h:307; TStyle::GetPadColorColor_t GetPadColor() constDefinition TStyle.h:208; TStyle::fBarOffsetFloat_t fBarOffsetOffset of bar for graphs.Definition TStyle.h:36; TStyle::SetHistLineStylevoid SetHistLineStyle(Style_t styl=0)Definition TStyle.h:382; TStyle::GetCandleScaledBool_t GetCandleScaled() constD",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:47364,Availability,error,errorx,47364,"or::SetPalette.Definition TStyle.cxx:1888; TStyle::fStatYFloat_t fStatYY position of top right corner of stat box.Definition TStyle.h:114; TStyle::Copyvoid Copy(TObject &style) const overrideCopy this style.Definition TStyle.cxx:551; TStyle::GetLegendBorderSizeWidth_t GetLegendBorderSize() constDefinition TStyle.h:202; TStyle::fFrameLineStyleStyle_t fFrameLineStylePad frame line style.Definition TStyle.h:73; TStyle::SetStatBorderSizevoid SetStatBorderSize(Width_t size=2)Definition TStyle.h:393; TStyle::GetBarWidthFloat_t GetBarWidth() constDefinition TStyle.h:183; TStyle::fCanvasBorderModeInt_t fCanvasBorderModeCanvas border mode.Definition TStyle.h:87; TStyle::GetCanvasPreferGLBool_t GetCanvasPreferGL() constDefinition TStyle.h:187; TStyle::SetGridColorvoid SetGridColor(Color_t color=0)Definition TStyle.h:370; TStyle::GetColorModelPSInt_t GetColorModelPS() constDefinition TStyle.h:196; TStyle::SetGridStylevoid SetGridStyle(Style_t style=3)Definition TStyle.h:369; TStyle::SetErrorXvoid SetErrorX(Float_t errorx=0.5)Definition TStyle.h:340; TStyle::GetCanvasDefYInt_t GetCanvasDefY() constDefinition TStyle.h:194; TStyle::SetTitleColorvoid SetTitleColor(Color_t color=1, Option_t *axis=""X"")Definition TStyle.cxx:1754; TStyle::SetNumberContoursvoid SetNumberContours(Int_t number=20)Set the default number of contour levels when drawing 2-d plots.Definition TStyle.cxx:1500; TStyle::Paintvoid Paint(Option_t *option="""") overrideCopy this style to gStyle.Definition TStyle.cxx:1252; TStyle::fTitleXFloat_t fTitleXX position of top left corner of title box.Definition TStyle.h:125; TStyle::fShowToolBarInt_t fShowToolBarShow toolbar.Definition TStyle.h:49; TStyle::SetLabelFontvoid SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition TStyle.cxx:1413; TStyle::fCapLinePSInt_t fCapLinePSDetermines the appearance of line caps on PostScript, PDF and SVG.Definition TStyle.h:137; TStyle::fFuncWidthWidth_t fFuncWidthFunction line width.Definiti",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:50330,Availability,error,error,50330,"nition TStyle.h:81; TStyle::SetTimeOffsetvoid SetTimeOffset(Double_t toffset)Change the time offset for time plotting.Definition TStyle.cxx:1913; TStyle::fPadGridYBool_t fPadGridYTrue to get the grid along Y.Definition TStyle.h:100; TStyle::SetTitlePSvoid SetTitlePS(const char *pstitle)Define a string to be used in the %Title of the Postscript files.Definition TStyle.cxx:1383; TStyle::fHistFillStyleStyle_t fHistFillStyleHistogram fill style.Definition TStyle.h:79; TStyle::SetHistMinimumZerovoid SetHistMinimumZero(Bool_t zero=kTRUE)If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms is set to 0.Definition TStyle.cxx:1288; TStyle::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::GetStatHFloat_t GetStatH() constDefinition TStyle.h:267; TStyle::GetShowEventStatusInt_t GetShowEventStatus() constDefinition TStyle.h:252; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::fEndErrorSizeFloat_t fEndErrorSizeSize of lines at the end of error bars.Definition TStyle.h:55; TStyle::SetStatHvoid SetStatH(Float_t h=0.1)Definition TStyle.h:400; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; TStyle::GetTitleYSizeFloat_t GetTitleYSize() constDefinition TStyle.h:279; TStyle::SetOptLogyvoid SetOptLogy(Int_t logy=1)Definition TStyle.h:330; TStyle::SetJoinLinePSvoid SetJoinLinePS(Int_t joinline=0)Set the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin for de...Definition TStyle.h:306; TStyle::fIsReadingBool_t fIsReading! Set to FALSE when userclass::UseCurrentStyle is called by the style managerDefinition TStyle.h:139; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetOptFileInt_t GetOptFile() constDefinition TStyle.h:243; TStyle::fFrameBorderSizeWidth_t fFrameBorderSizePad frame border size.Definition TStyle.h:75; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::SetT",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:65063,Availability,error,errors,65063,"tte.Definition TStyle.cxx:1175; TStyle::fStatHFloat_t fStatHHeight of stat box.Definition TStyle.h:116; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::fStatXFloat_t fStatXX position of top right corner of stat box.Definition TStyle.h:113; TStyle::SetTitleXSizevoid SetTitleXSize(Float_t size=0.02)Definition TStyle.h:410; TStyle::fCanvasDefYInt_t fCanvasDefYDefault canvas top Y position.Definition TStyle.h:91; TStyle::GetNumberContoursInt_t GetNumberContours() constDefinition TStyle.h:241; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TStyle::fOrthoCameraBool_t fOrthoCameraUse orthographic camera with web display.Definition TStyle.h:150; TStyle::fPadBottomMarginFloat_t fPadBottomMarginPad bottom margin.Definition TStyle.h:95; TStyle::GetPaintTextFormatconst char * GetPaintTextFormat() constDefinition TStyle.h:250; TStyle::GetLineScalePSFloat_t GetLineScalePS() constDefinition TStyle.h:289; TStyle::fErrorXFloat_t fErrorXPer cent of bin width for errors along X.Definition TStyle.h:56; TStyle::SetLabelColorvoid SetLabelColor(Color_t color=1, Option_t *axis=""X"")Set axis labels color.Definition TStyle.cxx:1393; TStyle::SetCandleBoxRangevoid SetCandleBoxRange(Double_t bRange=0.5)By setting box-range for candle plot, one can force the box of the candle-chart to cover that given f...Definition TStyle.cxx:1956; TStyle::GetStatFontStyle_t GetStatFont() constDefinition TStyle.h:260; TStyle::SetLabelSizevoid SetLabelSize(Float_t size=0.04, Option_t *axis=""X"")Set size of axis labels.Definition TStyle.cxx:1444; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TStyle::fLegendBorderSizeWidth_t fLegendBorderSizeLegend box border size.Definition TStyle.h:63; TStyle::fStatWFloat_t fStatWWidth of stat box.Definition TStyle.h:115; TStyle::fYAxisExpYOffsetFloat_t fYAxisExpYOffsetY axis exponent labe",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:1499,Testability,log,log,1499,"h""; 25#endif; 26 ; 27class TBrowser;; 28 ; 29class TStyle : public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText {; 30 ; 31private:; 32 TAttAxis fXaxis; ///< X axis attributes; 33 TAttAxis fYaxis; ///< Y axis attributes; 34 TAttAxis fZaxis; ///< Z axis attributes; 35 Float_t fBarWidth; ///< Width of bar for graphs; 36 Float_t fBarOffset; ///< Offset of bar for graphs; 37 Int_t fColorModelPS; ///< PostScript color model: 0 = RGB, 1 = CMYK; 38 Int_t fDrawBorder; ///< Flag to draw border(=1) or not (0); 39 Int_t fOptLogx; ///< True if log scale in X; 40 Int_t fOptLogy; ///< True if log scale in y; 41 Int_t fOptLogz; ///< True if log scale in z; 42 Int_t fOptDate; ///< True if date option is selected; 43 Int_t fOptStat; ///< True if option Stat is selected; 44 Int_t fOptTitle; ///< True if option Title is selected; 45 Int_t fOptFile; ///< True if option File is selected; 46 Int_t fOptFit; ///< True if option Fit is selected; 47 Int_t fShowEventStatus; ///< Show event status panel; 48 Int_t fShowEditor; ///< Show pad editor; 49 I",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:1547,Testability,log,log,1547,"h""; 25#endif; 26 ; 27class TBrowser;; 28 ; 29class TStyle : public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText {; 30 ; 31private:; 32 TAttAxis fXaxis; ///< X axis attributes; 33 TAttAxis fYaxis; ///< Y axis attributes; 34 TAttAxis fZaxis; ///< Z axis attributes; 35 Float_t fBarWidth; ///< Width of bar for graphs; 36 Float_t fBarOffset; ///< Offset of bar for graphs; 37 Int_t fColorModelPS; ///< PostScript color model: 0 = RGB, 1 = CMYK; 38 Int_t fDrawBorder; ///< Flag to draw border(=1) or not (0); 39 Int_t fOptLogx; ///< True if log scale in X; 40 Int_t fOptLogy; ///< True if log scale in y; 41 Int_t fOptLogz; ///< True if log scale in z; 42 Int_t fOptDate; ///< True if date option is selected; 43 Int_t fOptStat; ///< True if option Stat is selected; 44 Int_t fOptTitle; ///< True if option Title is selected; 45 Int_t fOptFile; ///< True if option File is selected; 46 Int_t fOptFit; ///< True if option Fit is selected; 47 Int_t fShowEventStatus; ///< Show event status panel; 48 Int_t fShowEditor; ///< Show pad editor; 49 I",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:1595,Testability,log,log,1595,"h""; 25#endif; 26 ; 27class TBrowser;; 28 ; 29class TStyle : public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText {; 30 ; 31private:; 32 TAttAxis fXaxis; ///< X axis attributes; 33 TAttAxis fYaxis; ///< Y axis attributes; 34 TAttAxis fZaxis; ///< Z axis attributes; 35 Float_t fBarWidth; ///< Width of bar for graphs; 36 Float_t fBarOffset; ///< Offset of bar for graphs; 37 Int_t fColorModelPS; ///< PostScript color model: 0 = RGB, 1 = CMYK; 38 Int_t fDrawBorder; ///< Flag to draw border(=1) or not (0); 39 Int_t fOptLogx; ///< True if log scale in X; 40 Int_t fOptLogy; ///< True if log scale in y; 41 Int_t fOptLogz; ///< True if log scale in z; 42 Int_t fOptDate; ///< True if date option is selected; 43 Int_t fOptStat; ///< True if option Stat is selected; 44 Int_t fOptTitle; ///< True if option Title is selected; 45 Int_t fOptFile; ///< True if option File is selected; 46 Int_t fOptFit; ///< True if option Fit is selected; 47 Int_t fShowEventStatus; ///< Show event status panel; 48 Int_t fShowEditor; ///< Show pad editor; 49 I",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19521,Testability,log,logx,19521,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19541,Testability,log,logx,19541,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19575,Testability,log,logy,19575,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19595,Testability,log,logy,19595,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19629,Testability,log,logz,19629,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:19649,Testability,log,logz,19649,"315 void SetLabelSize(Float_t size=0.04, Option_t *axis=""X"");; 316 void SetLegoInnerR(Float_t rad=0.5) {fLegoInnerR = rad;}; 317 void SetScreenFactor(Float_t factor=1) {fScreenFactor = factor;}; 318 void SetTickLength(Float_t length=0.03, Option_t *axis=""X"");; 319 void SetTitleColor(Color_t color=1, Option_t *axis=""X""); //set axis title color or pad title color; 320 void SetTitleFont(Style_t font=62, Option_t *axis=""X""); //set axis title font or pad title font; 321 void SetTitleOffset(Float_t offset=1, Option_t *axis=""X""); //set axis title offset; 322 void SetTitleSize(Float_t size=0.02, Option_t *axis=""X""); //set axis title size or pad title size; 323 void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"");; 324 void SetAxisMaxDigits(Int_t maxd=5);; 325 void SetNumberContours(Int_t number=20);; 326 void SetOptDate(Int_t datefl=1);; 327 void SetOptFile(Int_t file=1) {fOptFile = file;}; 328 void SetOptFit(Int_t fit=1);; 329 void SetOptLogx(Int_t logx=1) {fOptLogx = logx;}; 330 void SetOptLogy(Int_t logy=1) {fOptLogy = logy;}; 331 void SetOptLogz(Int_t logz=1) {fOptLogz = logz;}; 332 void SetOptStat(Int_t stat=1);; 333 void SetOptStat(Option_t *stat);; 334 void SetOptTitle(Int_t tit=1) {fOptTitle = tit;}; 335 void SetBarOffset(Float_t baroff=0.5) {fBarOffset = baroff;}; 336 void SetBarWidth(Float_t barwidth=0.5) {fBarWidth = barwidth;}; 337 void SetDateX(Float_t x=0.01) {fDateX = x;}; 338 void SetDateY(Float_t y=0.01) {fDateY = y;}; 339 void SetEndErrorSize(Float_t np=2);; 340 void SetErrorX(Float_t errorx=0.5) {fErrorX = errorx;}; 341 void SetCanvasPreferGL(Bool_t prefer = kTRUE) {fCanvasPreferGL=prefer;}; 342 void SetDrawBorder(Int_t drawborder=1) {fDrawBorder = drawborder;}; 343 void SetCanvasColor(Color_t color=19) {fCanvasColor = color;}; 344 void SetCanvasBorderSize(Width_t size=1) {fCanvasBorderSize = size;}; 345 void SetCanvasBorderMode(Int_t mode=1) {fCanvasBorderMode = mode;}; 346 void SetCanvasDefH(Int_t h=500) {fCanvasDefH = h;}; 347 ",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:34538,Testability,log,logx,34538,"etPadTopMarginvoid SetPadTopMargin(Float_t margin=0.1)Definition TStyle.h:359; TStyle::GetStatTextColorColor_t GetStatTextColor() constDefinition TStyle.h:258; TStyle::SetLegendFontvoid SetLegendFont(Style_t font=62)Definition TStyle.h:353; TStyle::SetTitleXvoid SetTitleX(Float_t x=0)Definition TStyle.h:413; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::fCanvasDefWInt_t fCanvasDefWDefault canvas width.Definition TStyle.h:89; TStyle::SetHistFillColorvoid SetHistFillColor(Color_t color=1)Definition TStyle.h:379; TStyle::fHatchesLineWidthInt_t fHatchesLineWidthHatches line width for hatch styles > 3100.Definition TStyle.h:68; TStyle::fScreenFactorFloat_t fScreenFactorMultiplication factor for canvas size and position.Definition TStyle.h:105; TStyle::SetLegoInnerRvoid SetLegoInnerR(Float_t rad=0.5)Definition TStyle.h:316; TStyle::SetOptLogxvoid SetOptLogx(Int_t logx=1)Definition TStyle.h:329; TStyle::fYAxisExpXOffsetFloat_t fYAxisExpXOffsetY axis exponent label X offset.Definition TStyle.h:147; TStyle::fTitleFontSizeFloat_t fTitleFontSizeFont size in pixels for fonts with precision type 3.Definition TStyle.h:123; TStyle::SetDateXvoid SetDateX(Float_t x=0.01)Definition TStyle.h:337; TStyle::fCanvasDefXInt_t fCanvasDefXDefault canvas top X position.Definition TStyle.h:90; TStyle::SetStatFormatvoid SetStatFormat(const char *format=""6.4g"")Definition TStyle.h:396; TStyle::SetPadBottomMarginvoid SetPadBottomMargin(Float_t margin=0.1)Definition TStyle.h:358; TStyle::GetTitleXFloat_t GetTitleX() constDefinition TStyle.h:280; TStyle::fViolinScaledBool_t fViolinScaledViolin plot, shall the violin or histos be scaled to each other by the maximum height?Definition TStyle.h:144; TStyle::SetLegendFillColorvoid SetLegendFillColor(Color_t color=0)Definition TStyle.h:351; TStyle::fPadRightMarginFloat_t fPadRightMarginPad right margin.Definition TSt",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:42610,Testability,log,log,42610,"197; TStyle::SetCanvasDefWvoid SetCanvasDefW(Int_t w=700)Definition TStyle.h:347; TStyle::fStatFontStyle_t fStatFontFont style of Stats PaveLabel.Definition TStyle.h:109; TStyle::fLineStyleTString fLineStyle[30]String describing line style i (for postScript)Definition TStyle.h:130; TStyle::SetDateYvoid SetDateY(Float_t y=0.01)Definition TStyle.h:338; TStyle::fGridWidthWidth_t fGridWidthGrid line width.Definition TStyle.h:62; TStyle::fCandleBoxRangeDouble_t fCandleBoxRangeCandle plot, The fraction which is covered by the box (0 < x < 1), default 0.5.Definition TStyle.h:142; TStyle::GetTitleOffsetFloat_t GetTitleOffset(Option_t *axis=""X"") constReturn title offset.Definition TStyle.cxx:1228; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetFrameBorderModevoid SetFrameBorderMode(Int_t mode=1)Definition TStyle.h:378; TStyle::GetTitleFontStyle_t GetTitleFont(Option_t *axis=""X"") constReturn title font.Definition TStyle.cxx:1216; TStyle::fOptLogxInt_t fOptLogxTrue if log scale in X.Definition TStyle.h:39; TStyle::fStripDecimalsBool_t fStripDecimalsStrip decimals in axis labels.Definition TStyle.h:117; TStyle::fHistMinimumZeroBool_t fHistMinimumZeroTrue if default minimum is 0, false if minimum is automatic.Definition TStyle.h:82; TStyle::GetImageScalingFloat_t GetImageScaling() constDefinition TStyle.h:239; TStyle::fLegendFontStyle_t fLegendFontLegend font style.Definition TStyle.h:66; TStyle::SetFuncColorvoid SetFuncColor(Color_t color=1)Definition TStyle.h:367; TStyle::GetHistMinimumZeroBool_t GetHistMinimumZero() constDefinition TStyle.h:237; TStyle::fXaxisTAttAxis fXaxisX axis attributes.Definition TStyle.h:32; TStyle::SetHeaderPSvoid SetHeaderPS(const char *header)Define a string to be inserted in the Postscript header.Definition TStyle.cxx:1362; TStyle::GetStatYFloat_t GetStatY() constDefinition TStyle.h:265; TStyle::fTitleColorColor_t fTitleColorTitle fill area color.Definition TStyle.h:119; TStyle::fJoinLinePSInt_t fJoinLine",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:50623,Testability,log,logy,50623,"n the %Title of the Postscript files.Definition TStyle.cxx:1383; TStyle::fHistFillStyleStyle_t fHistFillStyleHistogram fill style.Definition TStyle.h:79; TStyle::SetHistMinimumZerovoid SetHistMinimumZero(Bool_t zero=kTRUE)If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms is set to 0.Definition TStyle.cxx:1288; TStyle::GetPadGridXBool_t GetPadGridX() constDefinition TStyle.h:215; TStyle::GetStatHFloat_t GetStatH() constDefinition TStyle.h:267; TStyle::GetShowEventStatusInt_t GetShowEventStatus() constDefinition TStyle.h:252; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::fEndErrorSizeFloat_t fEndErrorSizeSize of lines at the end of error bars.Definition TStyle.h:55; TStyle::SetStatHvoid SetStatH(Float_t h=0.1)Definition TStyle.h:400; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; TStyle::GetTitleYSizeFloat_t GetTitleYSize() constDefinition TStyle.h:279; TStyle::SetOptLogyvoid SetOptLogy(Int_t logy=1)Definition TStyle.h:330; TStyle::SetJoinLinePSvoid SetJoinLinePS(Int_t joinline=0)Set the line join method used for PostScript, PDF and SVG output. See TPostScript::SetLineJoin for de...Definition TStyle.h:306; TStyle::fIsReadingBool_t fIsReading! Set to FALSE when userclass::UseCurrentStyle is called by the style managerDefinition TStyle.h:139; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetOptFileInt_t GetOptFile() constDefinition TStyle.h:243; TStyle::fFrameBorderSizeWidth_t fFrameBorderSizePad frame border size.Definition TStyle.h:75; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::SetTitleXOffsetvoid SetTitleXOffset(Float_t offset=1)Definition TStyle.h:409; TStyle::SetLegendBorderSizevoid SetLegendBorderSize(Width_t size=4)Definition TStyle.h:350; TStyle::GetAttDateTAttText * GetAttDate()Definition TStyle.h:168; TStyle::fTitleTextColorColor_t fTitleTextColorTitle text color.Definition TStyle.h:",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:53048,Testability,log,log,53048,"stLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::fHeaderPSTString fHeaderPSUser defined additional Postscript header.Definition TStyle.h:131; TStyle::GetColorPaletteInt_t GetColorPalette(Int_t i) constReturn color number i in current palette.Definition TStyle.cxx:1101; TStyle::cdvirtual void cd()Change current style.Definition TStyle.cxx:543; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TStyle::SetLabelOffsetvoid SetLabelOffset(Float_t offset=0.005, Option_t *axis=""X"")Set offset between axis and axis labels.Definition TStyle.cxx:1429; TStyle::fPadColorColor_t fPadColorPad color.Definition TStyle.h:92; TStyle::SetFitFormatvoid SetFitFormat(const char *format=""5.4g"")Definition TStyle.h:301; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TStyle::fDateXFloat_t fDateXX position of the date in the canvas (in NDC)Definition TStyle.h:53; TStyle::fOptLogzInt_t fOptLogzTrue if log scale in z.Definition TStyle.h:41; TStyle::SetCanvasDefYvoid SetCanvasDefY(Int_t topy=10)Definition TStyle.h:349; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetTitleFillColorvoid SetTitleFillColor(Color_t color=1)Definition TStyle.h:404; TStyle::fFitFormatTString fFitFormatPrinting format for fit parameters.Definition TStyle.h:133; TStyle::fPadBorderModeInt_t fPadBorderModePad border mode.Definition TStyle.h:94; TStyle::GetLegendTextSizeDouble_t GetLegendTextSize() constDefinition TStyle.h:206; TStyle::fNumberContoursInt_t fNumberContoursDefault number of contours for 2-d plots.Definition TStyle.h:51; TStyle::SetLineStyleStringvoid SetLineStyleString(Int_t i, const char *text)Set line style string using the PostScript convention.Definition TStyle.cxx:1483; TStyle::GetCandleBoxRangeDouble_t GetCandleBoxRange() constDefinition TStyle.h:291; TStyle::fPadLeftMarginFloat_t fPadLeftMarginPad left margin.De",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:57007,Testability,log,logz,57007,"acing for hatch styles > 3100.Definition TStyle.h:69; TStyle::fStatTextColorColor_t fStatTextColorStat text color.Definition TStyle.h:107; TStyle::GetFuncWidthWidth_t GetFuncWidth() constDefinition TStyle.h:221; TStyle::fAttDateTAttText fAttDateCanvas date attribute.Definition TStyle.h:52; TStyle::fStatBorderSizeWidth_t fStatBorderSizeBorder size of Stats PaveLabel.Definition TStyle.h:108; TStyle::GetOrthoCameraBool_t GetOrthoCamera() constDefinition TStyle.h:294; TStyle::Browsevoid Browse(TBrowser *b) overrideBrowse the style object.Definition TStyle.cxx:517; TStyle::fTitleWFloat_t fTitleWWidth of title box.Definition TStyle.h:127; TStyle::fPadBorderSizeWidth_t fPadBorderSizePad border size.Definition TStyle.h:93; TStyle::SetFuncWidthvoid SetFuncWidth(Width_t width=4)Definition TStyle.h:368; TStyle::SetLegendFillStylevoid SetLegendFillStyle(Style_t style=1001)Definition TStyle.h:352; TStyle::GetDrawBorderInt_t GetDrawBorder() constDefinition TStyle.h:184; TStyle::SetOptLogzvoid SetOptLogz(Int_t logz=1)Definition TStyle.h:331; TStyle::GetTitlePSconst char * GetTitlePS() constDefinition TStyle.h:285; TStyle::fHistLineColorColor_t fHistLineColorHistogram line color.Definition TStyle.h:78; TStyle::fOptFitInt_t fOptFitTrue if option Fit is selected.Definition TStyle.h:46; TStyle::GetCanvasDefWInt_t GetCanvasDefW() constDefinition TStyle.h:192; TStyle::GetCapLinePSInt_t GetCapLinePS() constReturns the line cap method used for PostScript, PDF and SVG output. See TPostScript::SetLineCap for ...Definition TStyle.h:288; TStyle::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideFunction used by the TStyle manager when drawing a canvas showing the current style.Definition TStyle.cxx:687; TStyle::SetFrameBorderSizevoid SetFrameBorderSize(Width_t size=1)Definition TStyle.h:377; TStyle::GetStatBorderSizeWidth_t GetStatBorderSize() constDefinition TStyle.h:259; TStyle::GetPaperSizevoid GetPaperSize(Float_t &xsize, Float_t &ysize) constSet paper size for Post",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TStyle_8h_source.html:62092,Testability,log,log,62092,"l_t fCandleScaledCandle plot, shall the box-width be scaled to each other by the integral of a box?Definition TStyle.h:143; TStyle::GetTitleHFloat_t GetTitleH() constDefinition TStyle.h:283; TStyle::GetStatStyleStyle_t GetStatStyle() constDefinition TStyle.h:262; TStyle::SetTitleYvoid SetTitleY(Float_t y=0.985)Definition TStyle.h:414; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::fStatFontSizeFloat_t fStatFontSizeFont size in pixels for fonts with precision type 3.Definition TStyle.h:110; TStyle::fCanvasPreferGLBool_t fCanvasPreferGLIf true, rendering in canvas is with GL.Definition TStyle.h:84; TStyle::fLegoInnerRFloat_t fLegoInnerRInner radius for cylindrical legos.Definition TStyle.h:129; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::EPaperSizeEPaperSizeDefinition TStyle.h:153; TStyle::kA4@ kA4Definition TStyle.h:153; TStyle::kUSLetter@ kUSLetterDefinition TStyle.h:153; TStyle::fOptLogyInt_t fOptLogyTrue if log scale in y.Definition TStyle.h:40; TStyle::fAxisMaxDigitsInt_t fAxisMaxDigitsNumber of digits above which the 10^N notation is used for axis.Definition TStyle.h:149; TStyle::GetFrameLineStyleStyle_t GetFrameLineStyle() constDefinition TStyle.h:228; TStyle::SetIsReadingvoid SetIsReading(Bool_t reading=kTRUE)Sets the fIsReading member to reading (default=kTRUE).Definition TStyle.cxx:1374; TStyle::GetStatWFloat_t GetStatW() constDefinition TStyle.h:266; TStyle::fGridStyleStyle_t fGridStyleGrid line style.Definition TStyle.h:61; TStyle::fHistFillColorColor_t fHistFillColorHistogram fill color.Definition TStyle.h:77; TStyle::GetDateYFloat_t GetDateY() constDefinition TStyle.h:198; TStyle::GetFitFormatconst char * GetFitFormat() constDefinition TStyle.h:199; TStyle::SetScreenFactorvoid SetScreenFactor(Float_t factor=1)Definition TStyle.h:317; TStyle::fCanvasDefHInt_t fCanvasDefHDefault canvas height.Definition TStyle.h:88; TStyle::SetHatchesLineWidthvoid SetHatchesLineWidt",MatchSource.WIKI,doc/master/TStyle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TStyle_8h_source.html
https://root.cern/doc/master/TSysEvtHandler_8h.html:248,Integrability,depend,dependency,248,". ROOT: core/base/inc/TSysEvtHandler.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Enumerations ; TSysEvtHandler.h File Reference. #include ""TObject.h""; #include ""TQObject.h"". Include dependency graph for TSysEvtHandler.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class TFileHandler; ; class TSignalHandler; ; class TStdExceptionHandler; ; class TSysEvtHandler; Abstract base class for handling system events. More...; . Enumerations; enum ESignals { ; kSigBus; , kSigSegmentationViolation; , kSigSystem; , kSigPipe; , ; kSigIllegalInstruction; , kSigAbort; , kSigQuit; , kSigInterrupt; , ; kSigWindowChanged; , kSigAlarm; , kSigChild; , kSigUrgent; , ; kSigFloatingException; , kSigTermination; , kSigUser1; , kSigUser2. }; . Enumeration Type Documentation. ESignals. enum ESignals. EnumeratorkSigBus; kSigSegmentationViolation; kSigSystem; kSigPipe; kSigIllegalInstruction; kSigAbort; kSigQuit; kSigInterrupt; kSigWindowChanged; kSigAlarm; kSigChild; kSigUrgent; kSigFloatingException; kSigTermination; kSigUser1; kSigUser2. Definition at line 107 of file TSysEvtHandler.h. corebaseincTSysEvtHandler.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TSysEvtHandler_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSysEvtHandler_8h.html
https://root.cern/doc/master/TSystem_8cxx_source.html:7072,Availability,error,error,7072,"EXT;; 208 fObjExt = OBJEXT;; 209 fAclicMode = kDefault;; 210 fMakeSharedLib = MAKESHAREDLIB;; 211 fMakeExe = MAKEEXE;; 212 fCompiled = new TOrdCollection;; 213 ; 214 if (gEnv && fBeepDuration == 0 && fBeepFreq == 0) {; 215 fBeepDuration = gEnv->GetValue(""Root.System.BeepDuration"", 100);; 216 fBeepFreq = gEnv->GetValue(""Root.System.BeepFreq"", 440);; 217 }; 218 if (!fName.CompareTo(""Generic"")) return kTRUE;; 219 return kFALSE;; 220}; 221 ; 222////////////////////////////////////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random value",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:7193,Availability,error,error,7193,"&& fBeepDuration == 0 && fBeepFreq == 0) {; 215 fBeepDuration = gEnv->GetValue(""Root.System.BeepDuration"", 100);; 216 fBeepFreq = gEnv->GetValue(""Root.System.BeepFreq"", 440);; 217 }; 218 if (!fName.CompareTo(""Generic"")) return kTRUE;; 219 return kFALSE;; 220}; 221 ; 222////////////////////////////////////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCr",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:7228,Availability,error,error,7228,"ion"", 100);; 216 fBeepFreq = gEnv->GetValue(""Root.System.BeepFreq"", 440);; 217 }; 218 if (!fName.CompareTo(""Generic"")) return kTRUE;; 219 return kFALSE;; 220}; 221 ; 222////////////////////////////////////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273//////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:7605,Availability,error,error,7605,"//////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281/////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:8066,Availability,error,error,8066,"tem error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Static function resetting system error number.; 283 ; 284void TSystem::ResetErrno(); 285{; 286 errno = 0;; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Objects that should be deleted on exit of the OS interface.; 291 ; 292void TSystem::RemoveOnExit(TObject *obj); 293{; 294 if (!fOnExitList); 295 fOnExitList = new TOrdCollection;; 296 if (!fOnExitList->FindObject(obj)); 297 fOnExitList->Add(obj);; 298}; 299 ; 300///////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:8364,Availability,error,error,8364,"tem error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Static function resetting system error number.; 283 ; 284void TSystem::ResetErrno(); 285{; 286 errno = 0;; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Objects that should be deleted on exit of the OS interface.; 291 ; 292void TSystem::RemoveOnExit(TObject *obj); 293{; 294 if (!fOnExitList); 295 fOnExitList = new TOrdCollection;; 296 if (!fOnExitList->FindObject(obj)); 297 fOnExitList->Add(obj);; 298}; 299 ; 300///////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:8577,Availability,error,error,8577,"r;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Static function resetting system error number.; 283 ; 284void TSystem::ResetErrno(); 285{; 286 errno = 0;; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Objects that should be deleted on exit of the OS interface.; 291 ; 292void TSystem::RemoveOnExit(TObject *obj); 293{; 294 if (!fOnExitList); 295 fOnExitList = new TOrdCollection;; 296 if (!fOnExitList->FindObject(obj)); 297 fOnExitList->Add(obj);; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Return the system's host name.; 302 ; 303const char *TSystem::HostName(); 304{; 305 return ""Local host"";; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Hook to tell TSystem that the TApplication object has been created.; 310 ; 311void TSystem::NotifyApplicationCreated(); 312{; 313 // Currently needed only for WinNT in",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:33716,Availability,error,error,33716,"1074 PrependPathName(dir, nameString);; 1075 return StrDup(nameString.Data());; 1076}; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// Concatenate a directory and a file name.; 1080 ; 1081const char *TSystem::PrependPathName(const char *, TString&); 1082{; 1083 AbstractMethod(""PrependPathName"");; 1084 return nullptr;; 1085}; 1086 ; 1087 ; 1088//---- Paths & Files -----------------------------------------------------------; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1092/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1093/// environment variables in a pathname. If compatibility is not an issue; 1094/// you can use on Unix directly $XXX. This is a protected function called; 1095/// from the OS specific system classes, like TUnixSystem and TWinNTSystem.; 1096/// Returns the expanded filename or 0 in case of error.; 1097 ; 1098const char *TSystem::ExpandFileName(const char *fname); 1099{; 1100 const int kBufSize = kMAXPATHLEN;; 1101 TTHREAD_TLS_ARRAY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE otherwise.; 1115 ; 1116Bool_t TSystem::ExpandFileName(TString &fname); 1117{; 1118 const int kBufSize = kMAXPATHLEN;; 1119 char xname[kBufSize];; 1120 ; 1121 Bool_t res = ExpandFileName(fname.Data(), xname, kBufSize);; 1122 if (!res); 1123 fname = xname;; 1124 ; 1125 return res;; 1126};",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:34387,Availability,error,error,34387,"use $(XXX) instead of $XXX when using; 1093/// environment variables in a pathname. If compatibility is not an issue; 1094/// you can use on Unix directly $XXX. This is a protected function called; 1095/// from the OS specific system classes, like TUnixSystem and TWinNTSystem.; 1096/// Returns the expanded filename or 0 in case of error.; 1097 ; 1098const char *TSystem::ExpandFileName(const char *fname); 1099{; 1100 const int kBufSize = kMAXPATHLEN;; 1101 TTHREAD_TLS_ARRAY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE otherwise.; 1115 ; 1116Bool_t TSystem::ExpandFileName(TString &fname); 1117{; 1118 const int kBufSize = kMAXPATHLEN;; 1119 char xname[kBufSize];; 1120 ; 1121 Bool_t res = ExpandFileName(fname.Data(), xname, kBufSize);; 1122 if (!res); 1123 fname = xname;; 1124 ; 1125 return res;; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////; 1129/// Private method for pathname expansion.; 1130/// Returns kTRUE in case of error and kFALSE otherwise.; 1131 ; 1132Bool_t TSystem::ExpandFileName(const char *fname, char *xname, const int kBufSize); 1133{; 1134 int n, ier, iter, lx, ncopy;; 1135 char *inp, *out, *x, *t, *buff;; 1136 const char *b, *c, *e;; 1137 const char *p;; 1138 buff = new char[kBufSize * 4];; 1139 ; 1140 iter = 0; xname[0] = 0; inp = buff + kBufSize; out = inp + kBufSize;; 1141 inp[-1] = ' '; inp[0] = 0; out[-1] = ' ';; 1142 c = fname + strspn(fname, "" \t\f\r"");; 1143 //VP if (isalnum(c[0])) { strcpy(inp, WorkingDirect",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:34862,Availability,error,error,34862,"AY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE otherwise.; 1115 ; 1116Bool_t TSystem::ExpandFileName(TString &fname); 1117{; 1118 const int kBufSize = kMAXPATHLEN;; 1119 char xname[kBufSize];; 1120 ; 1121 Bool_t res = ExpandFileName(fname.Data(), xname, kBufSize);; 1122 if (!res); 1123 fname = xname;; 1124 ; 1125 return res;; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////; 1129/// Private method for pathname expansion.; 1130/// Returns kTRUE in case of error and kFALSE otherwise.; 1131 ; 1132Bool_t TSystem::ExpandFileName(const char *fname, char *xname, const int kBufSize); 1133{; 1134 int n, ier, iter, lx, ncopy;; 1135 char *inp, *out, *x, *t, *buff;; 1136 const char *b, *c, *e;; 1137 const char *p;; 1138 buff = new char[kBufSize * 4];; 1139 ; 1140 iter = 0; xname[0] = 0; inp = buff + kBufSize; out = inp + kBufSize;; 1141 inp[-1] = ' '; inp[0] = 0; out[-1] = ' ';; 1142 c = fname + strspn(fname, "" \t\f\r"");; 1143 //VP if (isalnum(c[0])) { strcpy(inp, WorkingDirectory()); strcat(inp, ""/""); } // add $cwd; 1144 ; 1145 strlcat(inp, c, kBufSize);; 1146 ; 1147again:; 1148 iter++; c = inp; ier = 0;; 1149 x = out; x[0] = 0;; 1150 ; 1151 p = nullptr; e = nullptr;; 1152 if (c[0] == '~' && c[1] == '/') { // ~/ case; 1153 std::string hd = GetHomeDirectory();; 1154 p = hd.c_str();; 1155 e = c + 1;; 1156 if (p) { // we have smth to copy; 1157 strlcpy(x, p, kBufSize);; 1158 x += strlen(p);; 1159 c = e;; 1160 } else {; 1161 ++ier;; 1162 ++c;; 11",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:41674,Availability,failure,failure,41674,"(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(gSystem->HostName()));; 1315 if (!strcmp(a.GetHostName(), b.GetHostName()) ||; 1316 !strcmp(a.GetHostAddress(), b.GetHostAddress())) {; 1317 // Host OK; 1318 localPath = kTRUE;; 1319 // Check the user if specified; 1320 if (strlen(url.GetUser()) > 0) {; 1321 UserGroup_t *u = gSystem->GetUserInfo();; 1322 if (u) {; 1323 if (strcmp(u->fUser, url.GetUser())); 1324 // Requested a different user; 1325 localPath = kFALSE;; 1326 delete u;; 1327 }; 1328 }; 1329 }; 1330 }; 1331 // Done; 1332 return localPath;; 1333}; 1334 ; 1335////////////////////////////////////////////////////////////////////////////////; 1336/// Copy a file. If overwrite is true and file already exists the; 1337/// file will be overwritten. Returns 0 when successful, -1 in case; 1338/// of file open failure, -2 in case the file already exists and overwrite; 1339/// was false and -3 in case of error during copy.; 1340 ; 1341int TSystem::CopyFile(const char *, const char *, Bool_t); 1342{; 1343 AbstractMethod(""CopyFile"");; 1344 return -1;; 1345}; 1346 ; 1347////////////////////////////////////////////////////////////////////////////////; 1348/// Rename a file.; 1349 ; 1350int TSystem::Rename(const char *, const char *); 1351{; 1352 AbstractMethod(""Rename"");; 1353 return -1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Create a link from file1 to file2.; 1358 ; 1359int TSystem::Link(const char *, const char *); 1360{; 1361 AbstractMethod(""Link"");; 1362 return -1;; 1363}; 1364 ; 1365////////////////////////////////////////////////////////////////////////////////; 1366/// Create a symbolic link from file1 to file2.; 1367 ; 1368int TSystem::Symlink(const char *, const char *); 1369{; 1370 AbstractMethod(""Symlink"");; 1371 return -1;; 1372}; 1373 ; 13",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:41769,Availability,error,error,41769,"(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(gSystem->HostName()));; 1315 if (!strcmp(a.GetHostName(), b.GetHostName()) ||; 1316 !strcmp(a.GetHostAddress(), b.GetHostAddress())) {; 1317 // Host OK; 1318 localPath = kTRUE;; 1319 // Check the user if specified; 1320 if (strlen(url.GetUser()) > 0) {; 1321 UserGroup_t *u = gSystem->GetUserInfo();; 1322 if (u) {; 1323 if (strcmp(u->fUser, url.GetUser())); 1324 // Requested a different user; 1325 localPath = kFALSE;; 1326 delete u;; 1327 }; 1328 }; 1329 }; 1330 }; 1331 // Done; 1332 return localPath;; 1333}; 1334 ; 1335////////////////////////////////////////////////////////////////////////////////; 1336/// Copy a file. If overwrite is true and file already exists the; 1337/// file will be overwritten. Returns 0 when successful, -1 in case; 1338/// of file open failure, -2 in case the file already exists and overwrite; 1339/// was false and -3 in case of error during copy.; 1340 ; 1341int TSystem::CopyFile(const char *, const char *, Bool_t); 1342{; 1343 AbstractMethod(""CopyFile"");; 1344 return -1;; 1345}; 1346 ; 1347////////////////////////////////////////////////////////////////////////////////; 1348/// Rename a file.; 1349 ; 1350int TSystem::Rename(const char *, const char *); 1351{; 1352 AbstractMethod(""Rename"");; 1353 return -1;; 1354}; 1355 ; 1356////////////////////////////////////////////////////////////////////////////////; 1357/// Create a link from file1 to file2.; 1358 ; 1359int TSystem::Link(const char *, const char *); 1360{; 1361 AbstractMethod(""Link"");; 1362 return -1;; 1363}; 1364 ; 1365////////////////////////////////////////////////////////////////////////////////; 1366/// Create a symbolic link from file1 to file2.; 1367 ; 1368int TSystem::Symlink(const char *, const char *); 1369{; 1370 AbstractMethod(""Symlink"");; 1371 return -1;; 1372}; 1373 ; 13",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47229,Availability,error,error,47229,"t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Lo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47543,Availability,error,error,47543,"y() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47815,Availability,mask,mask,47815,"///////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 Abstrac",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:48163,Availability,error,error,48163,"le; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 AbstractMethod(""FindFile"");; 1541 return nullptr;; 1542}; 1543 ; 1544////////////////////////////////////////////////////////////////////////////////; 1545/// Find location of file in a search path. User must delete returned string.; 1546/// Returns 0 in case file is not found.; 1547 ; 1548char *TSystem::Which(const char *search, const char *wfil, EAccessMode mode); 1549{; 1550 TString wfilString(wfil);; 1551 FindFile(search, wfilString, mode);; 1552 if (wfi",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:50799,Availability,error,error,50799,"he file being executed.; 1571 ; 1572Int_t TSystem::GetEffectiveUid(); 1573{; 1574 AbstractMethod(""GetEffectiveUid"");; 1575 return 0;; 1576}; 1577 ; 1578////////////////////////////////////////////////////////////////////////////////; 1579/// Returns the group's id. If group = 0, returns current user's group.; 1580 ; 1581Int_t TSystem::GetGid(const char * /*group*/); 1582{; 1583 AbstractMethod(""GetGid"");; 1584 return 0;; 1585}; 1586 ; 1587////////////////////////////////////////////////////////////////////////////////; 1588/// Returns the effective group id. The effective group id corresponds; 1589/// to the set id bit on the file being executed.; 1590 ; 1591Int_t TSystem::GetEffectiveGid(); 1592{; 1593 AbstractMethod(""GetEffectiveGid"");; 1594 return 0;; 1595}; 1596 ; 1597////////////////////////////////////////////////////////////////////////////////; 1598/// Returns all user info in the UserGroup_t structure. The returned; 1599/// structure must be deleted by the user. In case of error 0 is returned.; 1600 ; 1601UserGroup_t *TSystem::GetUserInfo(Int_t /*uid*/); 1602{; 1603 AbstractMethod(""GetUserInfo"");; 1604 return nullptr;; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 1609/// current user's id info. The returned structure must be deleted by the; 1610/// user. In case of error 0 is returned.; 1611 ; 1612UserGroup_t *TSystem::GetUserInfo(const char * /*user*/); 1613{; 1614 AbstractMethod(""GetUserInfo"");; 1615 return nullptr;; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Returns all group info in the UserGroup_t structure. The only active; 1620/// fields in the UserGroup_t structure for this call are:; 1621/// - fGid and fGroup; 1622/// The returned structure must be deleted by the user. In case of; 1623/// error 0 is returned.; 1624 ; 1625UserGroup_t *TSystem::GetGroup",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:51234,Availability,error,error,51234," ; 1587////////////////////////////////////////////////////////////////////////////////; 1588/// Returns the effective group id. The effective group id corresponds; 1589/// to the set id bit on the file being executed.; 1590 ; 1591Int_t TSystem::GetEffectiveGid(); 1592{; 1593 AbstractMethod(""GetEffectiveGid"");; 1594 return 0;; 1595}; 1596 ; 1597////////////////////////////////////////////////////////////////////////////////; 1598/// Returns all user info in the UserGroup_t structure. The returned; 1599/// structure must be deleted by the user. In case of error 0 is returned.; 1600 ; 1601UserGroup_t *TSystem::GetUserInfo(Int_t /*uid*/); 1602{; 1603 AbstractMethod(""GetUserInfo"");; 1604 return nullptr;; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 1609/// current user's id info. The returned structure must be deleted by the; 1610/// user. In case of error 0 is returned.; 1611 ; 1612UserGroup_t *TSystem::GetUserInfo(const char * /*user*/); 1613{; 1614 AbstractMethod(""GetUserInfo"");; 1615 return nullptr;; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Returns all group info in the UserGroup_t structure. The only active; 1620/// fields in the UserGroup_t structure for this call are:; 1621/// - fGid and fGroup; 1622/// The returned structure must be deleted by the user. In case of; 1623/// error 0 is returned.; 1624 ; 1625UserGroup_t *TSystem::GetGroupInfo(Int_t /*gid*/); 1626{; 1627 AbstractMethod(""GetGroupInfo"");; 1628 return nullptr;; 1629}; 1630 ; 1631////////////////////////////////////////////////////////////////////////////////; 1632/// Returns all group info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 16",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:51740,Availability,error,error,51740,"; 1599/// structure must be deleted by the user. In case of error 0 is returned.; 1600 ; 1601UserGroup_t *TSystem::GetUserInfo(Int_t /*uid*/); 1602{; 1603 AbstractMethod(""GetUserInfo"");; 1604 return nullptr;; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 1609/// current user's id info. The returned structure must be deleted by the; 1610/// user. In case of error 0 is returned.; 1611 ; 1612UserGroup_t *TSystem::GetUserInfo(const char * /*user*/); 1613{; 1614 AbstractMethod(""GetUserInfo"");; 1615 return nullptr;; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Returns all group info in the UserGroup_t structure. The only active; 1620/// fields in the UserGroup_t structure for this call are:; 1621/// - fGid and fGroup; 1622/// The returned structure must be deleted by the user. In case of; 1623/// error 0 is returned.; 1624 ; 1625UserGroup_t *TSystem::GetGroupInfo(Int_t /*gid*/); 1626{; 1627 AbstractMethod(""GetGroupInfo"");; 1628 return nullptr;; 1629}; 1630 ; 1631////////////////////////////////////////////////////////////////////////////////; 1632/// Returns all group info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 1636/// must be deleted by the user. In case of error 0 is returned.; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:52284,Availability,error,error,52284,":GetUserInfo(const char * /*user*/); 1613{; 1614 AbstractMethod(""GetUserInfo"");; 1615 return nullptr;; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Returns all group info in the UserGroup_t structure. The only active; 1620/// fields in the UserGroup_t structure for this call are:; 1621/// - fGid and fGroup; 1622/// The returned structure must be deleted by the user. In case of; 1623/// error 0 is returned.; 1624 ; 1625UserGroup_t *TSystem::GetGroupInfo(Int_t /*gid*/); 1626{; 1627 AbstractMethod(""GetGroupInfo"");; 1628 return nullptr;; 1629}; 1630 ; 1631////////////////////////////////////////////////////////////////////////////////; 1632/// Returns all group info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 1636/// must be deleted by the user. In case of error 0 is returned.; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; 1651 AbstractMethod(""Setenv"");; 1652}; 1653 ; 1654////////////////////////////////////////////////////////////////////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging -----",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:55187,Availability,error,error,55187,"::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection ---------------------------------------------; 1700 ; 1701////////////////////////////////////////////////////////////////////////////////; 1702/// Redirect standard output (stdout, stderr) to the specified file.; 1703/// If the file argument is 0 the output is set again to stderr, stdout.; 1704/// The second argument specifies whether the output should be added to the; 1705/// file (""a"", default) or the file be truncated before (""w"").; 1706/// The implementations of this function save internally the current state into; 1707/// a static structure.; 1708///; 1709/// The call can be made reentrant by specifying the opaque structure pointed; 1710/// by 'h', which is filled with the relevant information. The handle 'h'; 1711/// obtained on the first call must then be used in any subsequent call,; 1712/// included ShowOutput, to display the redirected output.; 1713/// Returns 0 on success, -1 in case of error.; 1714 ; 1715Int_t TSystem::RedirectOutput(const char *, const char *, RedirectHandle_t *); 1716{; 1717 AbstractMethod(""RedirectOutput"");; 1718 return -1;; 1719}; 1720 ; 1721////////////////////////////////////////////////////////////////////////////////; 1722/// Display the content associated with the redirection described by the; 1723/// opaque handle 'h'.; 1724 ; 1725void TSystem::ShowOutput(RedirectHandle_t *h); 1726{; 1727 // Check input ...; 1728 if (!h) {; 1729 Error(""ShowOutput"", ""handle not specified"");; 1730 return;; 1731 }; 1732 ; 1733 // ... and file access; 1734 if (gSystem->AccessPathName(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of byt",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:56790,Availability,error,error,56790,"me(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of bytes to be read from the file.; 1747 off_t ltot = lseek(fileno(f), (off_t) 0, SEEK_END);; 1748 Int_t begin = (h->fReadOffSet > 0 && h->fReadOffSet < ltot) ? h->fReadOffSet : 0;; 1749 lseek(fileno(f), (off_t) begin, SEEK_SET);; 1750 Int_t left = ltot - begin;; 1751 ; 1752 // Now readout from file; 1753 const Int_t kMAXBUF = 16384;; 1754 char buf[kMAXBUF];; 1755 Int_t wanted = (left > kMAXBUF-1) ? kMAXBUF-1 : left;; 1756 Int_t len;; 1757 do {; 1758 while ((len = read(fileno(f), buf, wanted)) < 0 &&; 1759 TSystem::GetErrno() == EINTR); 1760 TSystem::ResetErrno();; 1761 ; 1762 if (len < 0) {; 1763 SysError(""ShowOutput"", ""error reading log file"");; 1764 break;; 1765 }; 1766 ; 1767 // Null-terminate; 1768 buf[len] = 0;; 1769 fprintf(stderr,""%s"", buf);; 1770 ; 1771 // Update counters; 1772 left -= len;; 1773 wanted = (left > kMAXBUF) ? kMAXBUF : left;; 1774 ; 1775 } while (len > 0 && left > 0);; 1776 ; 1777 // Do not display twice the same thing; 1778 h->fReadOffSet = ltot;; 1779 fclose(f);; 1780}; 1781 ; 1782//---- Dynamic Loading ---------------------------------------------------------; 1783 ; 1784////////////////////////////////////////////////////////////////////////////////; 1785/// Add a new directory to the dynamic path.; 1786 ; 1787void TSystem::AddDynamicPath(const char *); 1788{; 1789 AbstractMethod(""AddDynamicPath"");; 1790}; 1791 ; 1792////////////////////////////////////////////////////////////////////////////////; 1793/// Return the dynamic path (used to find shared libraries).; 1794 ; 1795const char *TSystem::GetDynamicPath(); 1796{; 1797 AbstractMethod(""GetDynamicPath"");; 1798 return nullptr;; 1799};",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:59650,Availability,error,error,59650,"825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Len",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:67989,Availability,error,error,67989,"p}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared librari",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:68305,Availability,error,error,68305,"p}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared librari",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:68694,Availability,error,error,68694,"092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:69416,Availability,avail,available,69416,"TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {; 2159 // This is not the default value, we need to keep the custom part.; 2160 TString custom = fLinkedLibs;; 2161 custom.ReplaceAll(LINKEDLIBS,linked);; 2162 if (custom == fLinkedLibs) {; 2163 // no",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79159,Availability,error,error,79159,"///////; 2425/// Send a buffer headed by a length indicator.; 2426 ; 2427int TSystem::SendBuf(int, const void *, int); 2428{; 2429 AbstractMethod(""SendBuf"");; 2430 return -1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485/////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79512,Availability,error,error,79512,"int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler -----",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79971,Availability,error,error,79971,"///////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAndDelete(TString& target, char *tobedeleted); 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:80321,Availability,error,error,80321,"3 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAndDelete(TString& target, char *tobedeleted); 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,""r"");; 2512 if (!f) {; 2513 return """";; 2514 }; 2515 TString result;; 2516 ; 2517 char x;; 2518 while ((x = fgetc(f))!=EOF ) {; 2519 if (x=='\n' || x=='\r') break;; 2520 result += x;; 2521 }; 2522 ; 2523 fclose(f);; 2524 return result;; 2525}; 2526 ; 2527static void R__FixLink(TString &cmd); 2528{; 2529 // Replace the call to 'link' by a full path ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:81659,Availability,avail,availability,81659,"; 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,""r"");; 2512 if (!f) {; 2513 return """";; 2514 }; 2515 TString result;; 2516 ; 2517 char x;; 2518 while ((x = fgetc(f))!=EOF ) {; 2519 if (x=='\n' || x=='\r') break;; 2520 result += x;; 2521 }; 2522 ; 2523 fclose(f);; 2524 return result;; 2525}; 2526 ; 2527static void R__FixLink(TString &cmd); 2528{; 2529 // Replace the call to 'link' by a full path name call based on where cl.exe is.; 2530 // This prevents us from using inadvertently the link.exe provided by cygwin.; 2531 ; 2532 // check if link is the microsoft one...; 2533 TString res = R__Exec(""link 2>&1"");; 2534 if (res.Length()) {; 2535 if (res.Contains(""Microsoft (R) Incremental Linker"")); 2536 return;; 2537 }; 2538 // else check availability of cygpath...; 2539 res = R__Exec(""cygpath . 2>&1"");; 2540 if (res.Length()) {; 2541 if (res != "".""); 2542 return;; 2543 }; 2544 ; 2545 res = R__Exec(""which cl.exe 2>&1|grep cl|sed 's,cl\\.exe$,link\\.exe,' 2>&1"");; 2546 if (res.Length()) {; 2547 res = R__Exec(Form(""cygpath -w '%s' 2>&1"",res.Data()));; 2548 if (res.Length()) {; 2549 cmd.ReplaceAll("" link "",Form("" \""%s\"" "",res.Data()));; 2550 }; 2551 }; 2552}; 2553#endif; 2554 ; 2555#if defined(__CYGWIN__); 2556static void R__AddPath(TString &target, const TString &path) {; 2557 if (path.Length() > 2 && path[1]==':') {; 2558 target += TString::Format(""/cygdrive/%c"",path[0]) + path(2,path.Length()-2);; 2559 } else {; 2560 target += path;; 2561 }; 2562}; 2563#else; 2564static void R__AddPath(TString &target, const TString &path) {; 2565 target += path;; 2566}; 2567#endif; 2568 ; 2569static void R__WriteDependencyFile(const TString & build_loc, const TString &depfilename, const TString &filename",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:83239,Availability,echo,echo,83239," 2563#else; 2564static void R__AddPath(TString &target, const TString &path) {; 2565 target += path;; 2566}; 2567#endif; 2568 ; 2569static void R__WriteDependencyFile(const TString & build_loc, const TString &depfilename, const TString &filename, const TString &library, const TString &libname,; 2570 const TString &extension, const char *version_var_prefix, const TString &includes, const TString &defines, const TString &incPath); 2571{; 2572 // Generate the dependency via standard output, not searching the; 2573 // standard include directories,; 2574 ; 2575#ifndef WIN32; 2576 const char * stderrfile = ""/dev/null"";; 2577#else; 2578 TString stderrfile;; 2579 AssignAndDelete( stderrfile, gSystem->ConcatFileName(build_loc,""stderr.tmp"") );; 2580#endif; 2581 TString bakdepfilename = depfilename + "".bak"";; 2582 ; 2583#ifdef WIN32; 2584 TString touch = ""echo # > ""; touch += ""\"""" + depfilename + ""\"""";; 2585#else; 2586 TString touch = ""echo > ""; touch += ""\"""" + depfilename + ""\"""";; 2587#endif; 2588 TString builddep = ""rmkdepend"";; 2589 gSystem->PrependPathName(TROOT::GetBinDir(), builddep);; 2590 builddep += "" \""-f"";; 2591 builddep += depfilename;; 2592 builddep += ""\"" -o_"" + extension + ""."" + gSystem->GetSoExt() + "" "";; 2593 if (build_loc.BeginsWith(gSystem->WorkingDirectory())) {; 2594 Int_t len = strlen(gSystem->WorkingDirectory());; 2595 if ( build_loc.Length() > (len+1) ) {; 2596 builddep += "" \""-p"";; 2597 if (build_loc[len] == '/' || build_loc[len+1] != '\\' ) {; 2598 // Since the path is now ran through TSystem::ExpandPathName the single \ is also possible.; 2599 R__AddPath(builddep, build_loc.Data() + len + 1 );; 2600 } else {; 2601 // Case of dir\\name; 2602 R__AddPath(builddep, build_loc.Data() + len + 2 );; 2603 }; 2604 builddep += ""/\"" "";; 2605 }; 2606 } else {; 2607 builddep += "" \""-p"";; 2608 R__AddPath(builddep, build_loc);; 2609 builddep += ""/\"" "";; 2610 }; 2611 builddep += "" -Y -- "";; 2612 TString rootsysInclude = TROOT::GetIncludeDir();; 2613 builddep += "" \""-I",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:83321,Availability,echo,echo,83321," 2563#else; 2564static void R__AddPath(TString &target, const TString &path) {; 2565 target += path;; 2566}; 2567#endif; 2568 ; 2569static void R__WriteDependencyFile(const TString & build_loc, const TString &depfilename, const TString &filename, const TString &library, const TString &libname,; 2570 const TString &extension, const char *version_var_prefix, const TString &includes, const TString &defines, const TString &incPath); 2571{; 2572 // Generate the dependency via standard output, not searching the; 2573 // standard include directories,; 2574 ; 2575#ifndef WIN32; 2576 const char * stderrfile = ""/dev/null"";; 2577#else; 2578 TString stderrfile;; 2579 AssignAndDelete( stderrfile, gSystem->ConcatFileName(build_loc,""stderr.tmp"") );; 2580#endif; 2581 TString bakdepfilename = depfilename + "".bak"";; 2582 ; 2583#ifdef WIN32; 2584 TString touch = ""echo # > ""; touch += ""\"""" + depfilename + ""\"""";; 2585#else; 2586 TString touch = ""echo > ""; touch += ""\"""" + depfilename + ""\"""";; 2587#endif; 2588 TString builddep = ""rmkdepend"";; 2589 gSystem->PrependPathName(TROOT::GetBinDir(), builddep);; 2590 builddep += "" \""-f"";; 2591 builddep += depfilename;; 2592 builddep += ""\"" -o_"" + extension + ""."" + gSystem->GetSoExt() + "" "";; 2593 if (build_loc.BeginsWith(gSystem->WorkingDirectory())) {; 2594 Int_t len = strlen(gSystem->WorkingDirectory());; 2595 if ( build_loc.Length() > (len+1) ) {; 2596 builddep += "" \""-p"";; 2597 if (build_loc[len] == '/' || build_loc[len+1] != '\\' ) {; 2598 // Since the path is now ran through TSystem::ExpandPathName the single \ is also possible.; 2599 R__AddPath(builddep, build_loc.Data() + len + 1 );; 2600 } else {; 2601 // Case of dir\\name; 2602 R__AddPath(builddep, build_loc.Data() + len + 2 );; 2603 }; 2604 builddep += ""/\"" "";; 2605 }; 2606 } else {; 2607 builddep += "" \""-p"";; 2608 R__AddPath(builddep, build_loc);; 2609 builddep += ""/\"" "";; 2610 }; 2611 builddep += "" -Y -- "";; 2612 TString rootsysInclude = TROOT::GetIncludeDir();; 2613 builddep += "" \""-I",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:85221,Availability,echo,echo,85221,"; 2605 }; 2606 } else {; 2607 builddep += "" \""-p"";; 2608 R__AddPath(builddep, build_loc);; 2609 builddep += ""/\"" "";; 2610 }; 2611 builddep += "" -Y -- "";; 2612 TString rootsysInclude = TROOT::GetIncludeDir();; 2613 builddep += "" \""-I""+rootsysInclude+""\"" ""; // cflags; 2614 builddep += includes;; 2615 builddep += defines;; 2616 builddep += "" -- \"""";; 2617 builddep += filename;; 2618 builddep += ""\"" "";; 2619 TString targetname;; 2620 if (library.BeginsWith(gSystem->WorkingDirectory())) {; 2621 Int_t len = strlen(gSystem->WorkingDirectory());; 2622 if ( library.Length() > (len+1) ) {; 2623 if (library[len] == '/' || library[len+1] != '\\' ) {; 2624 targetname = library.Data() + len + 1;; 2625 } else {; 2626 targetname = library.Data() + len + 2;; 2627 }; 2628 } else {; 2629 targetname = library;; 2630 }; 2631 } else {; 2632 targetname = library;; 2633 }; 2634 builddep += "" \"""";; 2635 builddep += ""-t"";; 2636 R__AddPath(builddep, targetname);; 2637 builddep += ""\"" > "";; 2638 builddep += stderrfile;; 2639 builddep += "" 2>&1 "";; 2640 ; 2641 TString adddictdep = ""echo "";; 2642 R__AddPath(adddictdep,targetname);; 2643 adddictdep += "": "";; 2644#if defined(R__HAS_CLING_DICTVERSION); 2645 {; 2646 char *clingdictversion = gSystem->Which(incPath,""clingdictversion.h"");; 2647 if (clingdictversion) {; 2648 R__AddPath(adddictdep,clingdictversion);; 2649 adddictdep += "" "";; 2650 delete [] clingdictversion;; 2651 } else {; 2652 R__AddPath(adddictdep,rootsysInclude+""/clingdictversion.h "");; 2653 }; 2654 }; 2655#endif; 2656 {; 2657 const char *dictHeaders[] = { ""RVersion.h"", ""ROOT/RConfig.hxx"", ""TClass.h"",; 2658 ""TDictAttributeMap.h"",""TInterpreter.h"",""TROOT.h"",""TBuffer.h"",; 2659 ""TMemberInspector.h"",""TError.h"",""RtypesImp.h"",""TIsAProxy.h"",; 2660 ""TFileMergeInfo.h"",""TCollectionProxyInfo.h""};; 2661 ; 2662 for (unsigned int h=0; h < sizeof(dictHeaders)/sizeof(dictHeaders[0]); ++h); 2663 {; 2664 char *rootVersion = gSystem->Which(incPath,dictHeaders[h]);; 2665 if (rootVersion) {; 2666 R__AddPath",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:86677,Availability,echo,echo,86677,"clingdictversion.h "");; 2653 }; 2654 }; 2655#endif; 2656 {; 2657 const char *dictHeaders[] = { ""RVersion.h"", ""ROOT/RConfig.hxx"", ""TClass.h"",; 2658 ""TDictAttributeMap.h"",""TInterpreter.h"",""TROOT.h"",""TBuffer.h"",; 2659 ""TMemberInspector.h"",""TError.h"",""RtypesImp.h"",""TIsAProxy.h"",; 2660 ""TFileMergeInfo.h"",""TCollectionProxyInfo.h""};; 2661 ; 2662 for (unsigned int h=0; h < sizeof(dictHeaders)/sizeof(dictHeaders[0]); ++h); 2663 {; 2664 char *rootVersion = gSystem->Which(incPath,dictHeaders[h]);; 2665 if (rootVersion) {; 2666 R__AddPath(adddictdep,rootVersion);; 2667 delete [] rootVersion;; 2668 } else {; 2669 R__AddPath(adddictdep,rootsysInclude + ""/"" + dictHeaders[h]);; 2670 }; 2671 adddictdep += "" "";; 2672 }; 2673 }; 2674 {; 2675 // Add dependency on rootcling.; 2676 char *rootCling = gSystem->Which(gSystem->Getenv(""PATH""),""rootcling"");; 2677 if (rootCling) {; 2678 R__AddPath(adddictdep,rootCling);; 2679 adddictdep += "" "";; 2680 delete [] rootCling;; 2681 }; 2682 }; 2683 adddictdep += "" >> \""""+depfilename+""\"""";; 2684 ; 2685 TString addversiondep( ""echo "");; 2686 addversiondep += libname + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:87764,Availability,error,error,87764," + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/// If build_dir is specified, it is used as an alternative 'root' for the; 2733/// generation of the shared library. The library is stored in a sub-directories; 2734/// of 'build_dir' including the full pathname of the script u",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:91635,Availability,avail,available,91635,"769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.cpp}; 2777/// .X myfunc.C+(arg1,arg2); 2778/// ~~~; 2779/// In which case an external compiler will be called to create a shared; 2780/// library. This shared library will then be loaded and the function; 2781/// myfunc will be called with the two arguments. With '++' the shared library; 2782/// is always recompiled. With '+' the shared library is recompiled only; 2783/// if it does not exist yet or the macro file is newer than the shared; 2784/// library.; 2785///; 2786/// Of course the + and ++ notation is supported in similar way for .x and .L.; 2787///; 2788/// Through the function TSystem::SetMakeSharedLib(), the user will be able to; 2789/// indicate, with shell commands, how to build a shared library (a good; 2790/// default will be provided). The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// th",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92586,Availability,avail,available,92586,". The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the ac",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92910,Availability,avail,available,92910,"; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:100217,Availability,redundant,redundant,100217,"& strlen(library_specified) ) {; 2972 // Use the specified name instead of the default; 2973 libname = BaseName( library_specified );; 2974 library = library_specified;; 2975 ExpandPathName( library );; 2976 if (! IsAbsoluteFileName(library) ) {; 2977 AssignAndDelete( library , ConcatFileName( WorkingDirectory(), library ) );; 2978 }; 2979 library = TString(library) + ""."" + fSoExt;; 2980 }; 2981 library = gSystem->UnixPathName(library);; 2982 ; 2983 TString libname_ext ( libname );; 2984 libname_ext += ""."" + fSoExt;; 2985 ; 2986 TString lib_dirname = GetDirName( library );; 2987 // For some probably good reason, DirName on Windows returns the 'name' of; 2988 // the directory, omitting the drive letter (even if there was one). In; 2989 // consequence the result is not useable as a 'root directory', we need to; 2990 // add the drive letter if there was one..; 2991 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2992 lib_dirname.Prepend(library(0,2));; 2993 }; 2994 // Strip potential, somewhat redundant '/.' from the pathname ...; 2995 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""/."", 2) == 0 ) {; 2996 lib_dirname.Remove(lib_dirname.Length()-2);; 2997 }; 2998 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""\\."", 2) == 0 ) {; 2999 lib_dirname.Remove(lib_dirname.Length()-2);; 3000 }; 3001 TString lib_location( lib_dirname );; 3002 Bool_t mkdirFailed = kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:101698,Availability,error,error,101698,"kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020 Bool_t canWriteBuild_loc = !gSystem->AccessPathName(build_loc,kWritePermission);; 3021 TString build_loc_store( build_loc );; 3022 if (!flatBuildDir) {; 3023 AssignAndDelete( build_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TStrin",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:128842,Availability,redundant,redundant,128842,"estcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (L",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130843,Availability,echo,echo,130843,"3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130871,Availability,echo,echo,130871,"t(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130921,Availability,echo,echo,130921,"3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:134809,Availability,error,error,134809," 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3966{; 3967 return fMakeExe;; 3968}; 3969 ; 3970////////////////////////////////////////////////////////////////////////////////; 3971/// Get the list of include path.; 3972 ; 3973const char *TSystem::GetIncludePath(); 3974{; 3975 fListPaths = fIncludePath;; 3976#ifndef _MSC_VER; 3977 // FIXME: This is a temporary fix for the following error with ACLiC; 3978 // (and this is apparently not needed anyway):; 3979 // 48: input_line_12:8:38: error: use of undeclared identifier 'IC'; 3980 // 48: ""C:/Users/bellenot/build/debug/etc"" -IC:/Users/bellenot/build/debug/etc//cling -IC:/Users/bellenot/build/debug/include"""",; 3981 // 48: ^; 3982 // 48: Error in <ACLiC>: Dictionary generation failed!; 3983 fListPaths.Append("" "").Append(gInterpreter->GetIncludePath());; 3984#endif; 3985 return fListPaths;; 3986}; 3987 ; 3988////////////////////////////////////////////////////////////////////////////////; 3989/// Return the list of library linked to this executable.; 3990/// See TSystem::CompileMacro for more details.; 3991 ; 3992const char *TSystem::GetLinkedLibs() const; 3993{; 3994 return fLinkedLibs;; 3995}; 3996 ; 3997////////////////////////////////////////////////////////////////////////////////; 3998/// Return the linkdef suffix chosen by the user for ACLiC.; 3999/// See TSystem::CompileMacro for more details.; 4000 ; 4001const char *TSystem::GetLinkdefSuffix() const; 4002{; 4003 if (fLinkdefSuffix.Length()==0) {; 4004 if (!gE",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:134912,Availability,error,error,134912," 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3966{; 3967 return fMakeExe;; 3968}; 3969 ; 3970////////////////////////////////////////////////////////////////////////////////; 3971/// Get the list of include path.; 3972 ; 3973const char *TSystem::GetIncludePath(); 3974{; 3975 fListPaths = fIncludePath;; 3976#ifndef _MSC_VER; 3977 // FIXME: This is a temporary fix for the following error with ACLiC; 3978 // (and this is apparently not needed anyway):; 3979 // 48: input_line_12:8:38: error: use of undeclared identifier 'IC'; 3980 // 48: ""C:/Users/bellenot/build/debug/etc"" -IC:/Users/bellenot/build/debug/etc//cling -IC:/Users/bellenot/build/debug/include"""",; 3981 // 48: ^; 3982 // 48: Error in <ACLiC>: Dictionary generation failed!; 3983 fListPaths.Append("" "").Append(gInterpreter->GetIncludePath());; 3984#endif; 3985 return fListPaths;; 3986}; 3987 ; 3988////////////////////////////////////////////////////////////////////////////////; 3989/// Return the list of library linked to this executable.; 3990/// See TSystem::CompileMacro for more details.; 3991 ; 3992const char *TSystem::GetLinkedLibs() const; 3993{; 3994 return fLinkedLibs;; 3995}; 3996 ; 3997////////////////////////////////////////////////////////////////////////////////; 3998/// Return the linkdef suffix chosen by the user for ACLiC.; 3999/// See TSystem::CompileMacro for more details.; 4000 ; 4001const char *TSystem::GetLinkdefSuffix() const; 4002{; 4003 if (fLinkdefSuffix.Length()==0) {; 4004 if (!gE",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:162163,Availability,error,error,162163,"r * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::TNamedTNamed()Definition TNamed.h:36; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginM",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:162558,Availability,error,error,162558,"gCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:168362,Availability,mask,mask,168362,"efinition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:168402,Availability,mask,mask,168402,"efinition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:170089,Availability,error,error,170089,"ion TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedLibsvirtual void AddLinkedLibs(const char *linkedLib)Add linkedLib to already set linked libs.Definition TSystem.cxx:4170; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::GetBuildCompilerVersionvirtual const char * GetBuildCompilerVersion() constReturn the build compiler version.Definition TSystem.cxx:3891; TSystem::ResetSignalvirtual void ResetSignal(ESignals sig, Bool_t reset=kTRUE)If reset is true reset the signal handler for the specified signal to the default handler,...Definition TSystem.cxx:576; TSystem::GetSockNamevirtual TInetAddress GetSockName(int sock)Get Internet Protocol (IP) address of host and port #.Definition TSystem.cxx:2309; TSystem::GetFsInfovirtual int GetFsInfo(const char *path, Lo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:172458,Availability,error,error,172458,"etLinkedLibs() constReturn the list of library linked to this executable.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cx",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:173661,Availability,error,error,173661,"ystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::DirNamevirtual const char * DirName(const char *pathname)",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:173968,Availability,error,error,173968,"ded to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Defini",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:190523,Availability,mask,mask,190523,"6; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::AddStdExceptionHandlervirtual void AddStdExceptionHandler(TStdExceptionHandler *eh)Add an exception handler to list of system exception handlers.Definition TSystem.cxx:611; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoE",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:191280,Availability,error,error,191280,"and line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:193758,Availability,error,error,193758,"() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::Tem",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:65590,Deployability,update,updated,65590,")) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if found, or NULL; 2031/// if a library called lib was not found.; 2032/// This function does not open the library.; 2033 ; 2034const char *TSystem::FindDynamicLibrary(TString&, Bool_t); 2035{; 2036 AbstractMethod(""FindDynamicLibrary"");; 2037 return nullptr;; 2038}; 2039 ; 2040////////////////////////////////////////////////////////////////////////////////; 2041/// Find specific entry point in specified library. Specify ""*"" for lib; 2042/// to search in all libraries.; 2043 ; 2044Func_t TSystem::DynFindSymbol(const char * /*lib*/, const char *entry); 2045{; 2046 return (Func_t) gInterpreter->FindSym(entry);; 2047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 20",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:163577,Deployability,install,installation,163577,"fmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TReg",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:163733,Deployability,install,installation,163733,"on TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first o",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:164043,Deployability,install,installation,164043,"mt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStdExceptionHa",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:164322,Deployability,install,installation,164322," delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStdExceptionHandler::kSEHandled@ kSEHandledDefinition TSysEvtHandler.h:175; TStdExceptionHandler::kSEProceed@ kSEProceedDefinition TSysEvtHandler.h:175; TStdExceptionHandler::kSEAbort@ kSEAbortDefinition TSysEvtHandler.h:175; TStdExceptionHandler::Handlevirtual EStatus Handle(std::exception &",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:164470,Deployability,install,installation,164470,")Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2945; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStdExceptionHandler::kSEHandled@ kSEHandledDefinition TSysEvtHandler.h:175; TStdExceptionHandler::kSEProceed@ kSEProceedDefinition TSysEvtHandler.h:175; TStdExceptionHandler::kSEAbort@ kSEAbortDefinition TSysEvtHandler.h:175; TStdExceptionHandler::Handlevirtual EStatus Handle(std::exception &exc)=0; TStorage::ReAllocIntstatic Int_t * ReAllocInt(Int_t *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:258; TStringBasi",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:750,Integrability,interface,interface,750,". ROOT: core/base/src/TSystem.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TSystem.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 8944840ba34631ec28efc779647618db43c0eee5 $; 2// Author: Fons Rademakers 15/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TSystem; 13\ingroup Base; 14 ; 15Abstract base class defining a generic interface to the underlying; 16Operating System.; 17This is not an ABC in the strict sense of the (C++) word. For; 18every member function there is an implementation (often not more; 19than a call to AbstractMethod() which prints a warning saying; 20that the method should be overridden in a derived class), which; 21allows a simple partial implementation for new OS'es.; 22*/; 23 ; 24#include <ROOT/FoundationUtils.hxx>; 25#include ""strlcpy.h""; 26#include ""TSystem.h""; 27#include ""TApplication.h""; 28#include ""TException.h""; 29#include ""TROOT.h""; 30#include ""TClass.h""; 31#include ""TClassTable.h""; 32#include ""TEnv.h""; 33#include ""TOrdCollection.h""; 34#include ""TObject.h""; 35#include ""TInterpreter.h""; 36#include ""TRegexp.h""; 37#include ""TObjString.h""; 38#include ""TObjArray.h""; 39#include ""TError.h""; 40#include ""TPluginManager.h""; 41#include ""TUrl.h""; 42#include ""TVirtualMutex.h""; 43#include ""TVersionCheck.h""; 44#include ""compiledata.h""; 45#include ""RConfigure.h""; 46#include ""THashList.h""; 47#include ""ThreadLocalStorage.h""; 48 ; 49#include <functional>; 50#include <iostream>; 51#include <fstream>; 52#include <memory>; 53#include <sstream>; 54#include <string>; 55#include <sys/stat.h>; 56#include <set>; 57 ; 58#ifdef WIN32; 59#include <io.h",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:3605,Integrability,protocol,protocol,3605,"mp(TProcessEventTimer);; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create async event processor timer. Delay is in milliseconds.; 80 ; 81TProcessEventTimer::TProcessEventTimer(Long_t delay) : TTimer(delay, kFALSE); 82{; 83 gROOT->SetInterrupt(kFALSE);; 84 TurnOn();; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Process events if timer did time out. Returns kTRUE if interrupt; 89/// flag is set (by hitting a key in the canvas or selecting the; 90/// Interrupt menu item in canvas or some other action).; 91 ; 92Bool_t TProcessEventTimer::ProcessEvents(); 93{; 94 if (fTimeout) {; 95 if (gSystem->ProcessEvents()) {; 96 Remove();; 97 return kTRUE;; 98 } else {; 99 Reset();; 100 return kFALSE;; 101 }; 102 }; 103 return kFALSE;; 104}; 105 ; 106 ; 107 ; 108ClassImp(TSystem);; 109 ; 110TVirtualMutex* gSystemMutex = nullptr;; 111 ; 112 ; 113 ; 114////////////////////////////////////////////////////////////////////////////////; 115/// Strip off protocol string from specified path; 116 ; 117const char *TSystem::StripOffProto(const char *path, const char *proto); 118{; 119 return !strncmp(path, proto, strlen(proto)) ? path + strlen(proto) : path;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Create a new OS interface.; 124 ; 125TSystem::TSystem(const char *name, const char *title) : TNamed(name, title); 126{; 127 if (gSystem && name[0] != '-' && strcmp(name, ""Generic"")); 128 Error(""TSystem"", ""only one instance of TSystem allowed"");; 129 ; 130 if (!gLibraryVersion) {; 131 gLibraryVersion = new Int_t [gLibraryVersionMax];; 132 memset(gLibraryVersion, 0, gLibraryVersionMax*sizeof(Int_t));; 133 }; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Delete the OS interface.; 138 ; 139TSystem::~TSystem(); 140{; 141 if (fOnExitList) {; 142 fOnExitList->Delete();; 143 SafeDe",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:3930,Integrability,interface,interface,3930,"mp(TProcessEventTimer);; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create async event processor timer. Delay is in milliseconds.; 80 ; 81TProcessEventTimer::TProcessEventTimer(Long_t delay) : TTimer(delay, kFALSE); 82{; 83 gROOT->SetInterrupt(kFALSE);; 84 TurnOn();; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Process events if timer did time out. Returns kTRUE if interrupt; 89/// flag is set (by hitting a key in the canvas or selecting the; 90/// Interrupt menu item in canvas or some other action).; 91 ; 92Bool_t TProcessEventTimer::ProcessEvents(); 93{; 94 if (fTimeout) {; 95 if (gSystem->ProcessEvents()) {; 96 Remove();; 97 return kTRUE;; 98 } else {; 99 Reset();; 100 return kFALSE;; 101 }; 102 }; 103 return kFALSE;; 104}; 105 ; 106 ; 107 ; 108ClassImp(TSystem);; 109 ; 110TVirtualMutex* gSystemMutex = nullptr;; 111 ; 112 ; 113 ; 114////////////////////////////////////////////////////////////////////////////////; 115/// Strip off protocol string from specified path; 116 ; 117const char *TSystem::StripOffProto(const char *path, const char *proto); 118{; 119 return !strncmp(path, proto, strlen(proto)) ? path + strlen(proto) : path;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Create a new OS interface.; 124 ; 125TSystem::TSystem(const char *name, const char *title) : TNamed(name, title); 126{; 127 if (gSystem && name[0] != '-' && strcmp(name, ""Generic"")); 128 Error(""TSystem"", ""only one instance of TSystem allowed"");; 129 ; 130 if (!gLibraryVersion) {; 131 gLibraryVersion = new Int_t [gLibraryVersionMax];; 132 memset(gLibraryVersion, 0, gLibraryVersionMax*sizeof(Int_t));; 133 }; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Delete the OS interface.; 138 ; 139TSystem::~TSystem(); 140{; 141 if (fOnExitList) {; 142 fOnExitList->Delete();; 143 SafeDe",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:4442,Integrability,interface,interface,4442,"r::ProcessEvents(); 93{; 94 if (fTimeout) {; 95 if (gSystem->ProcessEvents()) {; 96 Remove();; 97 return kTRUE;; 98 } else {; 99 Reset();; 100 return kFALSE;; 101 }; 102 }; 103 return kFALSE;; 104}; 105 ; 106 ; 107 ; 108ClassImp(TSystem);; 109 ; 110TVirtualMutex* gSystemMutex = nullptr;; 111 ; 112 ; 113 ; 114////////////////////////////////////////////////////////////////////////////////; 115/// Strip off protocol string from specified path; 116 ; 117const char *TSystem::StripOffProto(const char *path, const char *proto); 118{; 119 return !strncmp(path, proto, strlen(proto)) ? path + strlen(proto) : path;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Create a new OS interface.; 124 ; 125TSystem::TSystem(const char *name, const char *title) : TNamed(name, title); 126{; 127 if (gSystem && name[0] != '-' && strcmp(name, ""Generic"")); 128 Error(""TSystem"", ""only one instance of TSystem allowed"");; 129 ; 130 if (!gLibraryVersion) {; 131 gLibraryVersion = new Int_t [gLibraryVersionMax];; 132 memset(gLibraryVersion, 0, gLibraryVersionMax*sizeof(Int_t));; 133 }; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Delete the OS interface.; 138 ; 139TSystem::~TSystem(); 140{; 141 if (fOnExitList) {; 142 fOnExitList->Delete();; 143 SafeDelete(fOnExitList);; 144 }; 145 ; 146 if (fSignalHandler) {; 147 fSignalHandler->Delete();; 148 SafeDelete(fSignalHandler);; 149 }; 150 ; 151 if (fFileHandler) {; 152 fFileHandler->Delete();; 153 SafeDelete(fFileHandler);; 154 }; 155 ; 156 if (fStdExceptionHandler) {; 157 fStdExceptionHandler->Delete();; 158 SafeDelete(fStdExceptionHandler);; 159 }; 160 ; 161 if (fTimers) {; 162 fTimers->Delete();; 163 SafeDelete(fTimers);; 164 }; 165 ; 166 if (fCompiled) {; 167 fCompiled->Delete();; 168 SafeDelete(fCompiled);; 169 }; 170 ; 171 if (fHelpers) {; 172 fHelpers->Delete();; 173 SafeDelete(fHelpers);; 174 }; 175 ; 176 if (gSystem == this); 177",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:5339,Integrability,interface,interface,5339,"/////; 123/// Create a new OS interface.; 124 ; 125TSystem::TSystem(const char *name, const char *title) : TNamed(name, title); 126{; 127 if (gSystem && name[0] != '-' && strcmp(name, ""Generic"")); 128 Error(""TSystem"", ""only one instance of TSystem allowed"");; 129 ; 130 if (!gLibraryVersion) {; 131 gLibraryVersion = new Int_t [gLibraryVersionMax];; 132 memset(gLibraryVersion, 0, gLibraryVersionMax*sizeof(Int_t));; 133 }; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Delete the OS interface.; 138 ; 139TSystem::~TSystem(); 140{; 141 if (fOnExitList) {; 142 fOnExitList->Delete();; 143 SafeDelete(fOnExitList);; 144 }; 145 ; 146 if (fSignalHandler) {; 147 fSignalHandler->Delete();; 148 SafeDelete(fSignalHandler);; 149 }; 150 ; 151 if (fFileHandler) {; 152 fFileHandler->Delete();; 153 SafeDelete(fFileHandler);; 154 }; 155 ; 156 if (fStdExceptionHandler) {; 157 fStdExceptionHandler->Delete();; 158 SafeDelete(fStdExceptionHandler);; 159 }; 160 ; 161 if (fTimers) {; 162 fTimers->Delete();; 163 SafeDelete(fTimers);; 164 }; 165 ; 166 if (fCompiled) {; 167 fCompiled->Delete();; 168 SafeDelete(fCompiled);; 169 }; 170 ; 171 if (fHelpers) {; 172 fHelpers->Delete();; 173 SafeDelete(fHelpers);; 174 }; 175 ; 176 if (gSystem == this); 177 gSystem = nullptr;; 178}; 179 ; 180////////////////////////////////////////////////////////////////////////////////; 181/// Initialize the OS interface.; 182 ; 183Bool_t TSystem::Init(); 184{; 185 fNfd = 0;; 186 fMaxrfd = -1;; 187 fMaxwfd = -1;; 188 ; 189 fSigcnt = 0;; 190 fLevel = 0;; 191 ; 192 fSignalHandler = new TOrdCollection;; 193 fFileHandler = new TOrdCollection;; 194 fStdExceptionHandler = new TOrdCollection;; 195 fTimers = new TList;; 196 fTimers->UseRWLock();; 197 ; 198 fBuildArch = BUILD_ARCH;; 199 fBuildCompiler = COMPILER;; 200 fBuildCompilerVersion = COMPILERVERS;; 201 fBuildCompilerVersionStr = COMPILERVERSSTR;; 202 fBuildNode = BUILD_NODE;; 203 fFlagsDebug = CXXDEBUG;; 204 fFlag",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:8804,Integrability,interface,interface,8804,"tErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Static function resetting system error number.; 283 ; 284void TSystem::ResetErrno(); 285{; 286 errno = 0;; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Objects that should be deleted on exit of the OS interface.; 291 ; 292void TSystem::RemoveOnExit(TObject *obj); 293{; 294 if (!fOnExitList); 295 fOnExitList = new TOrdCollection;; 296 if (!fOnExitList->FindObject(obj)); 297 fOnExitList->Add(obj);; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Return the system's host name.; 302 ; 303const char *TSystem::HostName(); 304{; 305 return ""Local host"";; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Hook to tell TSystem that the TApplication object has been created.; 310 ; 311void TSystem::NotifyApplicationCreated(); 312{; 313 // Currently needed only for WinNT interface.; 314}; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Beep for duration milliseconds with a tone of frequency freq.; 318/// Defaults to printing the `\a` char",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:9482,Integrability,interface,interface,9482,"; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Static function resetting system error number.; 283 ; 284void TSystem::ResetErrno(); 285{; 286 errno = 0;; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Objects that should be deleted on exit of the OS interface.; 291 ; 292void TSystem::RemoveOnExit(TObject *obj); 293{; 294 if (!fOnExitList); 295 fOnExitList = new TOrdCollection;; 296 if (!fOnExitList->FindObject(obj)); 297 fOnExitList->Add(obj);; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Return the system's host name.; 302 ; 303const char *TSystem::HostName(); 304{; 305 return ""Local host"";; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Hook to tell TSystem that the TApplication object has been created.; 310 ; 311void TSystem::NotifyApplicationCreated(); 312{; 313 // Currently needed only for WinNT interface.; 314}; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Beep for duration milliseconds with a tone of frequency freq.; 318/// Defaults to printing the `\a` character to stdout.; 319/// If freq or duration is <0 respectively, use default value.; 320/// If setDefault is set, only set the frequency and duration as; 321/// new defaults, but don't beep.; 322/// If default freq or duration is <0, never beep (silence); 323 ; 324void TSystem::Beep(Int_t freq /*=-1*/, Int_t duration /*=-1*/,; 325 Bool_t setDefault /*=kFALSE*/); 326{; 327 if (setDefault) {; 328 fBeepFreq = freq;; 329 fBeepDuration = duration;; 330 return;; 331 }; 332 if (fBeepDuration < 0 || fBeepFreq < 0) return; // silence; 333 if (freq < 0) freq = fBeepFreq;; 334 if (duration < 0) duration = fBeepDuration;; 335 DoBeep(freq, duration);; 336}; 337 ; 338//---- EventLoop ---------------------------------------------------------",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:12377,Integrability,depend,depending,12377,"78 printf(""%s\n"", str);; 379 }; 380 // handle every exception; 381 catch (...) {; 382 Warning(""Run"", ""handle uncaught exception, terminating"");; 383 }; 384 ; 385loop_end:; 386 fInControl = kFALSE;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Exit from event loop.; 391 ; 392void TSystem::ExitLoop(); 393{; 394 fDone = kTRUE;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Inner event loop.; 399 ; 400void TSystem::InnerLoop(); 401{; 402 fLevel++;; 403 DispatchOneEvent();; 404 fLevel--;; 405}; 406 ; 407////////////////////////////////////////////////////////////////////////////////; 408/// Process pending events (GUI, timers, sockets). Returns the result of; 409/// TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); 410/// can be set during the handling of the events. This mechanism allows; 411/// macros running in tight calculating loops to be interrupted by some; 412/// GUI event (depending on the interval with which this method is; 413/// called). For example hitting ctrl-c in a canvas will set the; 414/// interrupt flag.; 415 ; 416Bool_t TSystem::ProcessEvents(); 417{; 418 gROOT->SetInterrupt(kFALSE);; 419 ; 420 if (!gROOT->TestBit(TObject::kInvalidObject)); 421 DispatchOneEvent(kTRUE);; 422 ; 423 return gROOT->IsInterrupted();; 424}; 425 ; 426////////////////////////////////////////////////////////////////////////////////; 427/// Dispatch a single event.; 428 ; 429void TSystem::DispatchOneEvent(Bool_t); 430{; 431 AbstractMethod(""DispatchOneEvent"");; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Sleep milliSec milli seconds.; 436 ; 437void TSystem::Sleep(UInt_t); 438{; 439 AbstractMethod(""Sleep"");; 440}; 441 ; 442////////////////////////////////////////////////////////////////////////////////; 443/// Select on active file descriptors (called by TMonitor).; 444 ; 445Int_t TSystem",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:53857,Integrability,message,message,53857,"//////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Close connection to system log daemon.; 1693 ; 1694void TSystem::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection ---------------------------------------------; 1700 ; 1701////////////////////////////////////////////////////////////////////////////////; 1702/// Redirect standard output (stdout, stderr) to the specified file.; 1703/// If the file argument is 0 the output is set again to stderr, stdout.; 1704/// The second argument specifies whether the output should be added to the; 1705/// file (""a"", default) or the file be truncated before (""w"").; 1706/// The implementations of this function save internally the current state into; 1707/// a static structure.; 1708///; 1709/// The c",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:61553,Integrability,depend,dependent,61553," if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:61986,Integrability,depend,dependent,61986,"85 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());; 1936 }; 1937 }; 1938 ; 1939 gLibraryVersionIdx++;; 1940 if (gLibraryVersionIdx == gLibraryVersionMax) {; 1941 gLibraryVersionMax *= 2;; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVers",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64358,Integrability,depend,dependencies,64358," DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return St",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:67995,Integrability,message,message,67995,"p}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared librari",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:68311,Integrability,message,message,68311,"p}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared librari",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:82843,Integrability,depend,dependency,82843,"2>&1"");; 2540 if (res.Length()) {; 2541 if (res != "".""); 2542 return;; 2543 }; 2544 ; 2545 res = R__Exec(""which cl.exe 2>&1|grep cl|sed 's,cl\\.exe$,link\\.exe,' 2>&1"");; 2546 if (res.Length()) {; 2547 res = R__Exec(Form(""cygpath -w '%s' 2>&1"",res.Data()));; 2548 if (res.Length()) {; 2549 cmd.ReplaceAll("" link "",Form("" \""%s\"" "",res.Data()));; 2550 }; 2551 }; 2552}; 2553#endif; 2554 ; 2555#if defined(__CYGWIN__); 2556static void R__AddPath(TString &target, const TString &path) {; 2557 if (path.Length() > 2 && path[1]==':') {; 2558 target += TString::Format(""/cygdrive/%c"",path[0]) + path(2,path.Length()-2);; 2559 } else {; 2560 target += path;; 2561 }; 2562}; 2563#else; 2564static void R__AddPath(TString &target, const TString &path) {; 2565 target += path;; 2566}; 2567#endif; 2568 ; 2569static void R__WriteDependencyFile(const TString & build_loc, const TString &depfilename, const TString &filename, const TString &library, const TString &libname,; 2570 const TString &extension, const char *version_var_prefix, const TString &includes, const TString &defines, const TString &incPath); 2571{; 2572 // Generate the dependency via standard output, not searching the; 2573 // standard include directories,; 2574 ; 2575#ifndef WIN32; 2576 const char * stderrfile = ""/dev/null"";; 2577#else; 2578 TString stderrfile;; 2579 AssignAndDelete( stderrfile, gSystem->ConcatFileName(build_loc,""stderr.tmp"") );; 2580#endif; 2581 TString bakdepfilename = depfilename + "".bak"";; 2582 ; 2583#ifdef WIN32; 2584 TString touch = ""echo # > ""; touch += ""\"""" + depfilename + ""\"""";; 2585#else; 2586 TString touch = ""echo > ""; touch += ""\"""" + depfilename + ""\"""";; 2587#endif; 2588 TString builddep = ""rmkdepend"";; 2589 gSystem->PrependPathName(TROOT::GetBinDir(), builddep);; 2590 builddep += "" \""-f"";; 2591 builddep += depfilename;; 2592 builddep += ""\"" -o_"" + extension + ""."" + gSystem->GetSoExt() + "" "";; 2593 if (build_loc.BeginsWith(gSystem->WorkingDirectory())) {; 2594 Int_t len = strlen(gSystem->WorkingDi",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:86360,Integrability,depend,dependency,86360," builddep += "" 2>&1 "";; 2640 ; 2641 TString adddictdep = ""echo "";; 2642 R__AddPath(adddictdep,targetname);; 2643 adddictdep += "": "";; 2644#if defined(R__HAS_CLING_DICTVERSION); 2645 {; 2646 char *clingdictversion = gSystem->Which(incPath,""clingdictversion.h"");; 2647 if (clingdictversion) {; 2648 R__AddPath(adddictdep,clingdictversion);; 2649 adddictdep += "" "";; 2650 delete [] clingdictversion;; 2651 } else {; 2652 R__AddPath(adddictdep,rootsysInclude+""/clingdictversion.h "");; 2653 }; 2654 }; 2655#endif; 2656 {; 2657 const char *dictHeaders[] = { ""RVersion.h"", ""ROOT/RConfig.hxx"", ""TClass.h"",; 2658 ""TDictAttributeMap.h"",""TInterpreter.h"",""TROOT.h"",""TBuffer.h"",; 2659 ""TMemberInspector.h"",""TError.h"",""RtypesImp.h"",""TIsAProxy.h"",; 2660 ""TFileMergeInfo.h"",""TCollectionProxyInfo.h""};; 2661 ; 2662 for (unsigned int h=0; h < sizeof(dictHeaders)/sizeof(dictHeaders[0]); ++h); 2663 {; 2664 char *rootVersion = gSystem->Which(incPath,dictHeaders[h]);; 2665 if (rootVersion) {; 2666 R__AddPath(adddictdep,rootVersion);; 2667 delete [] rootVersion;; 2668 } else {; 2669 R__AddPath(adddictdep,rootsysInclude + ""/"" + dictHeaders[h]);; 2670 }; 2671 adddictdep += "" "";; 2672 }; 2673 }; 2674 {; 2675 // Add dependency on rootcling.; 2676 char *rootCling = gSystem->Which(gSystem->Getenv(""PATH""),""rootcling"");; 2677 if (rootCling) {; 2678 R__AddPath(adddictdep,rootCling);; 2679 adddictdep += "" "";; 2680 delete [] rootCling;; 2681 }; 2682 }; 2683 adddictdep += "" >> \""""+depfilename+""\"""";; 2684 ; 2685 TString addversiondep( ""echo "");; 2686 addversiondep += libname + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuil",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:87277,Integrability,depend,dependency,87277," {; 2666 R__AddPath(adddictdep,rootVersion);; 2667 delete [] rootVersion;; 2668 } else {; 2669 R__AddPath(adddictdep,rootsysInclude + ""/"" + dictHeaders[h]);; 2670 }; 2671 adddictdep += "" "";; 2672 }; 2673 }; 2674 {; 2675 // Add dependency on rootcling.; 2676 char *rootCling = gSystem->Which(gSystem->Getenv(""PATH""),""rootcling"");; 2677 if (rootCling) {; 2678 R__AddPath(adddictdep,rootCling);; 2679 adddictdep += "" "";; 2680 delete [] rootCling;; 2681 }; 2682 }; 2683 adddictdep += "" >> \""""+depfilename+""\"""";; 2684 ; 2685 TString addversiondep( ""echo "");; 2686 addversiondep += libname + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all informa",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:96488,Integrability,depend,dependency,96488,"ildDir());; 2880 if (build_dir && strlen(build_dir)) build_loc = build_dir;; 2881 if (build_loc == ""."") {; 2882 build_loc = WorkingDirectory();; 2883 } else if (build_loc.Length() && (!IsAbsoluteFileName(build_loc)) ) {; 2884 AssignAndDelete( build_loc , ConcatFileName( WorkingDirectory(), build_loc ) );; 2885 }; 2886 ; 2887 // Get the include directory list in the dir1:dir2:dir3 format; 2888 // [Used for generating the .d file and to look for header files for; 2889 // the linkdef file]; 2890 TString incPath = GetIncludePath(); // of the form -Idir1 -Idir2 -Idir3; 2891 incPath.Append("":"").Prepend("" "");; 2892 if (gEnv) {; 2893 TString fromConfig = gEnv->GetValue(""ACLiC.IncludePaths"","""");; 2894 incPath.Append(fromConfig);; 2895 }; 2896 incPath.ReplaceAll("" -I"","":""); // of form :dir1 :dir2:dir3; 2897 auto posISysRoot = incPath.Index("" -isysroot \"""");; 2898 if (posISysRoot != kNPOS) {; 2899 auto posISysRootEnd = incPath.Index('""', posISysRoot + 12);; 2900 if (posISysRootEnd != kNPOS) {; 2901 // NOTE: should probably just skip isysroot for dependency analysis.; 2902 // (And will, in the future - once we rely on compiler-generated .d files.); 2903 incPath.Insert(posISysRootEnd - 1, ""/usr/include/"");; 2904 incPath.Replace(posISysRoot, 12, "":\"""");; 2905 }; 2906 }; 2907 while ( incPath.Index("" :"") != -1 ) {; 2908 incPath.ReplaceAll("" :"","":"");; 2909 }; 2910 incPath.Prepend("":.:"");; 2911 incPath.Prepend(WorkingDirectory());; 2912 ; 2913 // ======= Get the right file names for the dictionary and the shared library; 2914 TString expFileName(filename);; 2915 ExpandPathName( expFileName );; 2916 expFileName = gSystem->UnixPathName(expFileName);; 2917 TString library = expFileName;; 2918 if (! IsAbsoluteFileName(library) ); 2919 {; 2920 const char *whichlibrary = Which(incPath,library);; 2921 if (whichlibrary) {; 2922 library = whichlibrary;; 2923 delete [] whichlibrary;; 2924 } else {; 2925 ::Error(""ACLiC"",""The file %s can not be found in the include path: %s"",filename,incPath.Data",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:98841,Integrability,depend,dependent,98841,"ove(pos, 1);; 2938 }; 2939 }; 2940 library = gSystem->UnixPathName(library);; 2941 TString filename_fullpath = library;; 2942 ; 2943 TString file_dirname = GetDirName( filename_fullpath );; 2944 // For some probably good reason, DirName on Windows returns the 'name' of; 2945 // the directory, omitting the drive letter (even if there was one). In; 2946 // consequence the result is not usable as a 'root directory', we need to; 2947 // add the drive letter if there was one..; 2948 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2949 file_dirname.Prepend(library(0,2));; 2950 }; 2951 TString file_location( file_dirname ); // Location of the script.; 2952 incPath.Prepend( file_location + "":"" );; 2953 ; 2954 Ssiz_t dot_pos = library.Last('.');; 2955 TString extension, libname_noext = library;; 2956 if (dot_pos >= 0) {; 2957 libname_noext.Remove(dot_pos);; 2958 extension = library(dot_pos+1, library.Length()-dot_pos-1);; 2959 }; 2960 ; 2961 // Extension of shared library is platform dependent!!; 2962 TString suffix = TString(""_"") + extension + ""."" + fSoExt;; 2963 if (dot_pos >= 0); 2964 library.Replace( dot_pos, library.Length()-dot_pos, suffix);; 2965 else; 2966 library.Append(suffix);; 2967 ; 2968 TString libname ( BaseName( libname_noext ) );; 2969 libname.Append(""_"").Append(extension);; 2970 ; 2971 if (library_specified && strlen(library_specified) ) {; 2972 // Use the specified name instead of the default; 2973 libname = BaseName( library_specified );; 2974 library = library_specified;; 2975 ExpandPathName( library );; 2976 if (! IsAbsoluteFileName(library) ) {; 2977 AssignAndDelete( library , ConcatFileName( WorkingDirectory(), library ) );; 2978 }; 2979 library = TString(library) + ""."" + fSoExt;; 2980 }; 2981 library = gSystem->UnixPathName(library);; 2982 ; 2983 TString libname_ext ( libname );; 2984 libname_ext += ""."" + fSoExt;; 2985 ; 2986 TString lib_dirname = GetDirName( library );; 2987 // For some probably good reason, DirName on Windows re",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:101704,Integrability,message,message,101704,"kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020 Bool_t canWriteBuild_loc = !gSystem->AccessPathName(build_loc,kWritePermission);; 3021 TString build_loc_store( build_loc );; 3022 if (!flatBuildDir) {; 3023 AssignAndDelete( build_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TStrin",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:104412,Integrability,depend,dependency,104412,"cwd/ (or -I""$cwd\ on NT); 3080 TRegexp rel_inc("" -I\""[^/\\\\$\\%-][^:\\s]+"");; 3081 Int_t len,pos;; 3082 pos = rel_inc.Index(includes,&len);; 3083 while( len != 0 ) {; 3084 TString sub = includes(pos,len);; 3085 sub.Remove(0,4); // Remove ' -I""'; 3086 AssignAndDelete( sub, ConcatFileName( WorkingDirectory(), sub ) );; 3087 sub.Prepend("" -I\"""");; 3088 includes.Replace(pos,len,sub);; 3089 pos = rel_inc.Index(includes,&len);; 3090 }; 3091 }; 3092 //includes += "" -I\"""" + build_loc;; 3093 //includes += ""\"" -I\"""";; 3094 //includes += WorkingDirectory();; 3095// if (includes[includes.Length()-1] == '\\') {; 3096// // The current directory is (most likely) the root of a windows drive and; 3097// // has a trailing \ which would espace the quote if left by itself.; 3098// includes += '\\';; 3099// }; 3100// includes += ""\"""";; 3101 if (gEnv) {; 3102 TString fromConfig = gEnv->GetValue(""ACLiC.IncludePaths"","""");; 3103 includes.Append("" "").Append(fromConfig).Append("" "");; 3104 }; 3105 ; 3106 // Extract the -D for the dependency generation.; 3107 TString defines = "" "";; 3108 {; 3109 TString cmd = GetMakeSharedLib();; 3110 TRegexp rel_def(""-D[^\\s\\t\\n\\r]*"");; 3111 Int_t len,pos;; 3112 pos = rel_def.Index(cmd,&len);; 3113 while( len != 0 ) {; 3114 defines += cmd(pos,len);; 3115 defines += "" "";; 3116 pos = rel_def.Index(cmd,&len,pos+1);; 3117 }; 3118 ; 3119 }; 3120 ; 3121 TString emergency_loc;; 3122 {; 3123 UserGroup_t *ug = gSystem->GetUserInfo(gSystem->GetUid());; 3124 if (ug) {; 3125 AssignAndDelete( emergency_loc, ConcatFileName( TempDirectory(), ug->fUser ) );; 3126 delete ug;; 3127 } else {; 3128 emergency_loc = TempDirectory();; 3129 }; 3130 }; 3131 ; 3132 Bool_t canWrite = !gSystem->AccessPathName(build_loc,kWritePermission);; 3133 ; 3134 Bool_t modified = kFALSE;; 3135 ; 3136 // Generate the dependency filename; 3137 TString depdir = build_loc;; 3138 TString depfilename;; 3139 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3140 depfilen",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:105211,Integrability,depend,dependency,105211,"dows drive and; 3097// // has a trailing \ which would espace the quote if left by itself.; 3098// includes += '\\';; 3099// }; 3100// includes += ""\"""";; 3101 if (gEnv) {; 3102 TString fromConfig = gEnv->GetValue(""ACLiC.IncludePaths"","""");; 3103 includes.Append("" "").Append(fromConfig).Append("" "");; 3104 }; 3105 ; 3106 // Extract the -D for the dependency generation.; 3107 TString defines = "" "";; 3108 {; 3109 TString cmd = GetMakeSharedLib();; 3110 TRegexp rel_def(""-D[^\\s\\t\\n\\r]*"");; 3111 Int_t len,pos;; 3112 pos = rel_def.Index(cmd,&len);; 3113 while( len != 0 ) {; 3114 defines += cmd(pos,len);; 3115 defines += "" "";; 3116 pos = rel_def.Index(cmd,&len,pos+1);; 3117 }; 3118 ; 3119 }; 3120 ; 3121 TString emergency_loc;; 3122 {; 3123 UserGroup_t *ug = gSystem->GetUserInfo(gSystem->GetUid());; 3124 if (ug) {; 3125 AssignAndDelete( emergency_loc, ConcatFileName( TempDirectory(), ug->fUser ) );; 3126 delete ug;; 3127 } else {; 3128 emergency_loc = TempDirectory();; 3129 }; 3130 }; 3131 ; 3132 Bool_t canWrite = !gSystem->AccessPathName(build_loc,kWritePermission);; 3133 ; 3134 Bool_t modified = kFALSE;; 3135 ; 3136 // Generate the dependency filename; 3137 TString depdir = build_loc;; 3138 TString depfilename;; 3139 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3140 depfilename += ""_"" + extension + "".d"";; 3141 ; 3142 if ( !recompile ) {; 3143 ; 3144 Long_t lib_time, file_time;; 3145 ; 3146 if ((gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) != 0) ||; 3147 (gSystem->GetPathInfo( expFileName, nullptr, (Long_t*)nullptr, nullptr, &file_time ) == 0 &&; 3148 (lib_time < file_time))) {; 3149 ; 3150 // the library does not exist or is older than the script.; 3151 recompile = kTRUE;; 3152 modified = kTRUE;; 3153 ; 3154 } else {; 3155 ; 3156 if ( gSystem->GetPathInfo( depfilename, nullptr,(Long_t*) nullptr, nullptr, &file_time ) != 0 ) {; 3157 if (!canWrite) {; 3158 depdir = emergency_loc;; 3159 AssignAndDelete( d",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:106416,Integrability,depend,dependencies,106416,"lename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3140 depfilename += ""_"" + extension + "".d"";; 3141 ; 3142 if ( !recompile ) {; 3143 ; 3144 Long_t lib_time, file_time;; 3145 ; 3146 if ((gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) != 0) ||; 3147 (gSystem->GetPathInfo( expFileName, nullptr, (Long_t*)nullptr, nullptr, &file_time ) == 0 &&; 3148 (lib_time < file_time))) {; 3149 ; 3150 // the library does not exist or is older than the script.; 3151 recompile = kTRUE;; 3152 modified = kTRUE;; 3153 ; 3154 } else {; 3155 ; 3156 if ( gSystem->GetPathInfo( depfilename, nullptr,(Long_t*) nullptr, nullptr, &file_time ) != 0 ) {; 3157 if (!canWrite) {; 3158 depdir = emergency_loc;; 3159 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3160 depfilename += ""_"" + extension + "".d"";; 3161 }; 3162 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3163 }; 3164 }; 3165 ; 3166 if (!modified) {; 3167 ; 3168 // We need to check the dependencies; 3169 FILE * depfile = fopen(depfilename.Data(),""r"");; 3170 if (depfile==nullptr) {; 3171 // there is no accessible dependency file, let's assume the library has been; 3172 // modified; 3173 modified = kTRUE;; 3174 recompile = kTRUE;; 3175 ; 3176 } else {; 3177 ; 3178 TString version_var = libname + version_var_prefix;; 3179 ; 3180 Int_t sz = 256;; 3181 char *line = new char[sz];; 3182 line[0] = 0;; 3183 ; 3184 int c;; 3185 Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:106545,Integrability,depend,dependency,106545,"modified = kTRUE;; 3153 ; 3154 } else {; 3155 ; 3156 if ( gSystem->GetPathInfo( depfilename, nullptr,(Long_t*) nullptr, nullptr, &file_time ) != 0 ) {; 3157 if (!canWrite) {; 3158 depdir = emergency_loc;; 3159 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3160 depfilename += ""_"" + extension + "".d"";; 3161 }; 3162 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3163 }; 3164 }; 3165 ; 3166 if (!modified) {; 3167 ; 3168 // We need to check the dependencies; 3169 FILE * depfile = fopen(depfilename.Data(),""r"");; 3170 if (depfile==nullptr) {; 3171 // there is no accessible dependency file, let's assume the library has been; 3172 // modified; 3173 modified = kTRUE;; 3174 recompile = kTRUE;; 3175 ; 3176 } else {; 3177 ; 3178 TString version_var = libname + version_var_prefix;; 3179 ; 3180 Int_t sz = 256;; 3181 char *line = new char[sz];; 3182 line[0] = 0;; 3183 ; 3184 int c;; 3185 Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; 3203 line[0] = 0;; 3204 current = 0;; 3205 } else if (isspace(c) && !nested) {; 3206 if (current) {; 3207 if (line[current-1]!=':') {; 3208 // ignore target; 3209 line[current] = 0;; 3210 ; 3211 Long_t filetime;; 3212 if (hasversion) {; 3213 modified |= strcmp(ROOT_RELEASE,line)!=0;; 3214 hasversion = kFALSE;; 3215 } else if ( gSystem->GetPathInfo( line, nullptr, (Long_t*)nullptr, nullptr, &filetime ) == 0 ) {; 3216 modified |= ( lib_time <= filetime );; 3217 }; 3218 }; 3219 }; 3220 current = 0;; 3221 line[0] = 0;",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:111995,Integrability,depend,dependencies,111995,"33 /*constexpr const*/ bool useCxxModules =; 3334#ifdef R__USE_CXXMODULES; 3335 true;; 3336#else; 3337 false;; 3338#endif; 3339 ; 3340 // FIXME: Switch to generic polymorphic when we make c++14 default.; 3341 auto ForeachSharedLibDep = [](const char *lib, std::function<bool(const char *)> f) {; 3342 using std::string, std::vector, std::istringstream, std::istream_iterator;; 3343 string deps = gInterpreter->GetSharedLibDeps(lib, /*tryDyld*/ true);; 3344 istringstream iss(deps);; 3345 vector<string> libs{istream_iterator<std::string>{iss}, istream_iterator<string>{}};; 3346 // Skip the first element: it is a relative path to `lib`.; 3347 for (auto I = libs.begin() + 1, E = libs.end(); I != E; ++I); 3348 if (!f(I->c_str())); 3349 break;; 3350 };; 3351 auto LoadLibrary = [useCxxModules, produceRootmap, ForeachSharedLibDep](const TString &lib) {; 3352 // We have no rootmap files or modules to construct `-l` flags enabling; 3353 // explicit linking. We have to resolve the dependencies by ourselves; 3354 // taking the job of the dyld.; 3355 // FIXME: This is a rare case where we have rootcling running with; 3356 // modules disabled. Remove this code once we fully switch to modules,; 3357 // or implement a special flag in rootcling which selective enables; 3358 // modules for dependent libraries and does not produce a module for; 3359 // the ACLiC library.; 3360 if (useCxxModules && !produceRootmap) {; 3361 std::function<bool(const char *)> LoadLibF = [](const char *dep) {; 3362 return gInterpreter->Load(dep, /*skipReload*/ true) >= 0;; 3363 };; 3364 ForeachSharedLibDep(lib, LoadLibF);; 3365 }; 3366 return !gSystem->Load(lib);; 3367 };; 3368 ; 3369 if (!recompile) {; 3370 // The library already exist, let's just load it.; 3371 if (loadLib) {; 3372 TNamed *k = new TNamed(library,library);; 3373 Long_t lib_time;; 3374 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3375 k->SetUniqueID(lib_time);; 3376 if (!keep) k->SetBit(kMustCleanup);; 3377 ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:112303,Integrability,depend,dependent,112303,"std::function<bool(const char *)> f) {; 3342 using std::string, std::vector, std::istringstream, std::istream_iterator;; 3343 string deps = gInterpreter->GetSharedLibDeps(lib, /*tryDyld*/ true);; 3344 istringstream iss(deps);; 3345 vector<string> libs{istream_iterator<std::string>{iss}, istream_iterator<string>{}};; 3346 // Skip the first element: it is a relative path to `lib`.; 3347 for (auto I = libs.begin() + 1, E = libs.end(); I != E; ++I); 3348 if (!f(I->c_str())); 3349 break;; 3350 };; 3351 auto LoadLibrary = [useCxxModules, produceRootmap, ForeachSharedLibDep](const TString &lib) {; 3352 // We have no rootmap files or modules to construct `-l` flags enabling; 3353 // explicit linking. We have to resolve the dependencies by ourselves; 3354 // taking the job of the dyld.; 3355 // FIXME: This is a rare case where we have rootcling running with; 3356 // modules disabled. Remove this code once we fully switch to modules,; 3357 // or implement a special flag in rootcling which selective enables; 3358 // modules for dependent libraries and does not produce a module for; 3359 // the ACLiC library.; 3360 if (useCxxModules && !produceRootmap) {; 3361 std::function<bool(const char *)> LoadLibF = [](const char *dep) {; 3362 return gInterpreter->Load(dep, /*skipReload*/ true) >= 0;; 3363 };; 3364 ForeachSharedLibDep(lib, LoadLibF);; 3365 }; 3366 return !gSystem->Load(lib);; 3367 };; 3368 ; 3369 if (!recompile) {; 3370 // The library already exist, let's just load it.; 3371 if (loadLib) {; 3372 TNamed *k = new TNamed(library,library);; 3373 Long_t lib_time;; 3374 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3375 k->SetUniqueID(lib_time);; 3376 if (!keep) k->SetBit(kMustCleanup);; 3377 fCompiled->Add(k);; 3378 ; 3379 gInterpreter->GetSharedLibDeps(library);; 3380 ; 3381 return LoadLibrary(library);; 3382 }; 3383 else return kTRUE;; 3384 }; 3385 ; 3386 if (!canWrite && recompile) {; 3387 ; 3388 if (mkdirFailed) {; 3389 ::Warning(""ACLiC"",""C",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:121834,Integrability,depend,depend,121834,"oduleMapFullPath + ""\"" "");; 3576 }; 3577 ; 3578 rcling.Append("" \"""").Append(filename_fullpath).Append(""\"" "");; 3579 rcling.Append(""\"""").Append(linkdef).Append(""\"""");; 3580 ; 3581 // ======= Run rootcling; 3582 if (withInfo) {; 3583 if (verboseLevel>3) {; 3584 ::Info(""ACLiC"",""creating the dictionary files"");; 3585 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", rcling.Data());; 3586 }; 3587 }; 3588 ; 3589 ///\returns true on success.; 3590 auto ExecAndReport = [](TString cmd) -> bool {; 3591 Int_t result = gSystem->Exec(cmd);; 3592 if (result) {; 3593 if (result == 139); 3594 ::Error(""ACLiC"", ""Executing '%s' failed with a core dump!"", cmd.Data());; 3595 else; 3596 ::Error(""ACLiC"", ""Executing '%s' failed!"", cmd.Data());; 3597 }; 3598 return !result;; 3599 };; 3600 ; 3601 Bool_t result = ExecAndReport(rcling);; 3602 TString depLibraries;; 3603 ; 3604 // ======= Load the library the script might depend on; 3605 if (result) {; 3606 TString linkedlibs = GetLibraries("""", ""S"");; 3607 TString libtoload;; 3608 TString all_libtoload;; 3609 std::ifstream liblist(mapfileout);; 3610 ; 3611 while ( liblist >> libtoload ) {; 3612 // Load the needed library except for the library we are currently building!; 3613 if (libtoload == ""#"") {; 3614 // The comment terminates the list of libraries.; 3615 std::string toskipcomment;; 3616 std::getline(liblist,toskipcomment);; 3617 break;; 3618 }; 3619 if (libtoload != library && libtoload != libname && libtoload != libname_ext) {; 3620 if (produceRootmap) {; 3621 if (loadLib || linkDepLibraries /* For GetLibraries to Work */) {; 3622 result = gROOT->LoadClass("""", libtoload) >= 0;; 3623 if (!result) {; 3624 // We failed to load one of the dependency.; 3625 break;; 3626 }; 3627 }; 3628 if (!linkedlibs.Contains(libtoload)) {; 3629 all_libtoload.Append("" "").Append(libtoload);; 3630 depLibraries.Append("" "");; 3631 depLibraries.Append(GetLibraries(libtoload,""DSL"",kFALSE));; 3632 depLibraries = depLibraries.Strip(); // Remove any trailing spaces.; 3633 }; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:122618,Integrability,depend,dependency,122618,"Int_t result = gSystem->Exec(cmd);; 3592 if (result) {; 3593 if (result == 139); 3594 ::Error(""ACLiC"", ""Executing '%s' failed with a core dump!"", cmd.Data());; 3595 else; 3596 ::Error(""ACLiC"", ""Executing '%s' failed!"", cmd.Data());; 3597 }; 3598 return !result;; 3599 };; 3600 ; 3601 Bool_t result = ExecAndReport(rcling);; 3602 TString depLibraries;; 3603 ; 3604 // ======= Load the library the script might depend on; 3605 if (result) {; 3606 TString linkedlibs = GetLibraries("""", ""S"");; 3607 TString libtoload;; 3608 TString all_libtoload;; 3609 std::ifstream liblist(mapfileout);; 3610 ; 3611 while ( liblist >> libtoload ) {; 3612 // Load the needed library except for the library we are currently building!; 3613 if (libtoload == ""#"") {; 3614 // The comment terminates the list of libraries.; 3615 std::string toskipcomment;; 3616 std::getline(liblist,toskipcomment);; 3617 break;; 3618 }; 3619 if (libtoload != library && libtoload != libname && libtoload != libname_ext) {; 3620 if (produceRootmap) {; 3621 if (loadLib || linkDepLibraries /* For GetLibraries to Work */) {; 3622 result = gROOT->LoadClass("""", libtoload) >= 0;; 3623 if (!result) {; 3624 // We failed to load one of the dependency.; 3625 break;; 3626 }; 3627 }; 3628 if (!linkedlibs.Contains(libtoload)) {; 3629 all_libtoload.Append("" "").Append(libtoload);; 3630 depLibraries.Append("" "");; 3631 depLibraries.Append(GetLibraries(libtoload,""DSL"",kFALSE));; 3632 depLibraries = depLibraries.Strip(); // Remove any trailing spaces.; 3633 }; 3634 } else {; 3635 gROOT->LoadClass("""", libtoload);; 3636 }; 3637 }; 3638 unsigned char c = liblist.peek();; 3639 if (c=='\n' || c=='\r') {; 3640 // Consume the character; 3641 liblist.get();; 3642 break;; 3643 }; 3644 }; 3645 ; 3646// depLibraries = all_libtoload;; 3647// depLibraries.ReplaceAll("" lib"","" -l"");; 3648// depLibraries.ReplaceAll(TString::Format("".%s"",fSoExt.Data()),"""");; 3649 }; 3650 ; 3651 // ======= Calculate the libraries for linking:; 3652 TString linkLibraries;; 3653",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:126627,Integrability,rout,routine,126627,"l(""$LinkedLibs"",linkLibraries);; 3711 cmd.ReplaceAll(""$LibName"",libname);; 3712 cmd.ReplaceAll(""\""$BuildDir"",""$BuildDir"");; 3713 cmd.ReplaceAll(""$BuildDir"",""\""$BuildDir\"""");; 3714 cmd.ReplaceAll(""$BuildDir"",build_loc);; 3715 TString optdebFlags;; 3716 if (mode & kDebug); 3717 optdebFlags = fFlagsDebug + "" "";; 3718 if (mode & kOpt); 3719 optdebFlags += fFlagsOpt;; 3720 cmd.ReplaceAll(""$Opt"", optdebFlags);; 3721#ifdef WIN32; 3722 R__FixLink(cmd);; 3723 cmd.ReplaceAll(""-std="", ""-std:"");; 3724#endif; 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:126882,Integrability,rout,routine,126882," 3718 if (mode & kOpt); 3719 optdebFlags += fFlagsOpt;; 3720 cmd.ReplaceAll(""$Opt"", optdebFlags);; 3721#ifdef WIN32; 3722 R__FixLink(cmd);; 3723 cmd.ReplaceAll(""-std="", ""-std:"");; 3724#endif; 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnr",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:128662,Integrability,depend,dependent,128662,"gsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TName",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:129502,Integrability,depend,dependencies,129502,">Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 384",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:140703,Integrability,depend,depends,140703," 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --display_error_number; 4126/// --diag_suppress 68 -o $SharedLib"");; 4127///; 4128/// gSystem->setMakeSharedLib(; 4129/// ""Cxx $IncludePath -c $SourceFile;; 4130/// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; 4131/// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; 4132/// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:142386,Integrability,interface,interface,142386,"-o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134/// gSystem->SetMakeSharedLib(; 4135/// ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; 4136/// -shared -o $SharedLib"");; 4137///; 4138/// gSystem->SetMakeSharedLib(; 4139/// ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; 4140/// -D_WINDOWS $IncludePath $SourceFile; 4141/// /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; 4142/// $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""); 4143/// ~~~; 4144 ; 4145void TSystem::SetMakeSharedLib(const char *directives); 4146{; 4147 fMakeSharedLib = directives;; 4148 // NOTE: add verification that the directives has the required variables; 4149}; 4150 ; 4151////////////////////////////////////////////////////////////////////////////////; 4152/// \brief Add a directory to the already set include path.; 4153/// \param[in] includePath The path to the directory.; 4154/// \note This interface is mostly relevant for ACLiC and it does *not* inform; 4155/// gInterpreter for this include path. If the TInterpreter needs to know; 4156/// about the include path please use TInterpreter::AddIncludePath() .; 4157/// \warning The path should start with the \c -I prefix, i.e.; 4158/// <tt>gSystem->AddIncludePath(""-I /path/to/my/includes"")</tt>.; 4159void TSystem::AddIncludePath(const char *includePath); 4160{; 4161 if (includePath) {; 4162 fIncludePath += "" "";; 4163 fIncludePath += includePath;; 4164 }; 4165}; 4166 ; 4167////////////////////////////////////////////////////////////////////////////////; 4168/// Add linkedLib to already set linked libs.; 4169 ; 4170void TSystem::AddLinkedLibs(const char *linkedLib); 4171{; 4172 if (linkedLib) {; 4173 fLinkedLibs += "" "";; 4174 fLinkedLibs += linkedLib;; 4175 }; 4176}; 4177 ; 4178////////////////////////////////////////////////////////////////////////////////; 4179/// IncludePath should contain the list of compiler flags to indicate where; 4180/// to find user defined heade",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:152080,Integrability,message,messages,152080,")Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; ROOT_RELEASE#define ROOT_RELEASEDefinition RVersion.hxx:29; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TClassTable.h; TClass.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TException.h; ENDTRY#define ENDTRYDefinition TException.h:64; RETRY#define RETRYDefinition TException.h:44; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameD",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:162169,Integrability,message,message,162169,"r * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::TNamedTNamed()Definition TNamed.h:36; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginM",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:162306,Integrability,message,message,162306,"ring fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:162564,Integrability,message,message,162564,"gCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:163026,Integrability,message,message,163026,"ue object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPluginHandlerDefinition TPluginManager.h:103; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::TProcessEventTimerTProcessEventTimer(Long_t delay)Create async event processor timer. Delay is in milliseconds.Definition TSystem.cxx:81; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2926; TROOT::GetRootSysstatic const TString & GetRootSys()Get the roo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:167905,Integrability,interface,interface,167905,"ng.cxx:931; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:170095,Integrability,message,message,170095,"ion TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedLibsvirtual void AddLinkedLibs(const char *linkedLib)Add linkedLib to already set linked libs.Definition TSystem.cxx:4170; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::GetBuildCompilerVersionvirtual const char * GetBuildCompilerVersion() constReturn the build compiler version.Definition TSystem.cxx:3891; TSystem::ResetSignalvirtual void ResetSignal(ESignals sig, Bool_t reset=kTRUE)If reset is true reset the signal handler for the specified signal to the default handler,...Definition TSystem.cxx:576; TSystem::GetSockNamevirtual TInetAddress GetSockName(int sock)Get Internet Protocol (IP) address of host and port #.Definition TSystem.cxx:2309; TSystem::GetFsInfovirtual int GetFsInfo(const char *path, Lo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:174382,Integrability,interface,interface,174382,"nstReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fStdExceptionHandlerDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDi",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:175090,Integrability,interface,interface,175090,"dvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fStdExceptionHandlerDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::RecvBufvirtual int RecvBuf(int sock, void *buffer, int length)Receive a buffer headed by a length indicator.Definition TSystem.cxx:2418; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).Definition TSystem.cxx:494; TS",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:182428,Integrability,protocol,protocol,182428,"* OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetHomeDirectoryvirtual std::string GetHomeDirectory(const char *userName=nullptr) constReturn the user's home directory.Definition TSystem.cxx:",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:183926,Integrability,interface,interface,183926,"stem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetHomeDirectoryvirtual std::string GetHomeDirectory(const char *userName=nullptr) constReturn the user's home directory.Definition TSystem.cxx:895; TSystem::AnnounceTcpServicevirtual int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1)Announce TCP/IP service.Definition TSystem.cxx:2345; TSystem::UnixPathNamevirtual const char * UnixPathName(const char *unixpathname)Convert from a local pathname to a Unix pathname.Definition TSystem.cxx:1063; TSystem::RecvRawvirtual int RecvRaw(int sock, void *buffer, int length, int flag)Receive exactly length bytes into buffer.Definition TSystem.cxx:2399; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::GetCryptoRandomvirtual Int_t GetCryptoRandom(void *buf, Int_t len)Return cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TSystem.cxx:266; TSystem::DispatchOneEventvirtual void DispatchOneEvent(Bool_t pendingOnly=kFALSE)Dispatch a single event.Definition TSystem.cxx:429; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::ClosePipevirtual int Clo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:193141,Integrability,protocol,protocol,193141,"k(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:196525,Integrability,interface,interface,196525,"vents.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::Removevoid Remove() overrideDefinition TTimer.h:86; TTimer::fTimeoutBool_t fTimeoutDefinition TTimer.h:56; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUserconst char * GetUser() constDefinition TUrl.h:65; TUrl::GetHostconst char * GetHost() constDefinition TUrl.h:67; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVersionCheck::TVersionCheckTVersionCheck(int versionCode)Register version of plugin library.Definition TSystem.cxx:4396; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; I#define I(x, y, z); ROOT::FoundationUtils::GetCurrentDirstd::string GetCurrentDir()Definition FoundationUtils.cxx:47; ROOT::FoundationUtils::MakePathRelativestd::string MakePathRelative(const std::string &path, const std::string &base, bool isBuildingROOT=false)Definition FoundationUtils.cxx:82; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; v@ vDefinition rootcling_impl.cxx:3699; CpuInfo_tDefinition TSystem.h:163; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; FileStat_t::fSizeLong64_t fSizeDefinition TSystem.h:128; FileStat_t::fDevLong_t fDevDefinition TSystem.h:123; FileStat_t::fMtimeLong_t fMtimeDefinition TSystem.h:129; FileStat_t::fInoLong_t fInoDefinition TSystem.h:124; MemInfo_",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:6864,Modifiability,variab,variable,6864,"ilerVersion = COMPILERVERS;; 201 fBuildCompilerVersionStr = COMPILERVERSSTR;; 202 fBuildNode = BUILD_NODE;; 203 fFlagsDebug = CXXDEBUG;; 204 fFlagsOpt = CXXOPT;; 205 fIncludePath = INCLUDEPATH;; 206 fLinkedLibs = LINKEDLIBS;; 207 fSoExt = SOEXT;; 208 fObjExt = OBJEXT;; 209 fAclicMode = kDefault;; 210 fMakeSharedLib = MAKESHAREDLIB;; 211 fMakeExe = MAKEEXE;; 212 fCompiled = new TOrdCollection;; 213 ; 214 if (gEnv && fBeepDuration == 0 && fBeepFreq == 0) {; 215 fBeepDuration = gEnv->GetValue(""Root.System.BeepDuration"", 100);; 216 fBeepFreq = gEnv->GetValue(""Root.System.BeepFreq"", 440);; 217 }; 218 if (!fName.CompareTo(""Generic"")) return kTRUE;; 219 return kFALSE;; 220}; 221 ; 222////////////////////////////////////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorStri",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:33442,Modifiability,variab,variables,33442,"1068////////////////////////////////////////////////////////////////////////////////; 1069/// Concatenate a directory and a file name. User must delete returned string.; 1070 ; 1071char *TSystem::ConcatFileName(const char *dir, const char *name); 1072{; 1073 TString nameString(name);; 1074 PrependPathName(dir, nameString);; 1075 return StrDup(nameString.Data());; 1076}; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// Concatenate a directory and a file name.; 1080 ; 1081const char *TSystem::PrependPathName(const char *, TString&); 1082{; 1083 AbstractMethod(""PrependPathName"");; 1084 return nullptr;; 1085}; 1086 ; 1087 ; 1088//---- Paths & Files -----------------------------------------------------------; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1092/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1093/// environment variables in a pathname. If compatibility is not an issue; 1094/// you can use on Unix directly $XXX. This is a protected function called; 1095/// from the OS specific system classes, like TUnixSystem and TWinNTSystem.; 1096/// Returns the expanded filename or 0 in case of error.; 1097 ; 1098const char *TSystem::ExpandFileName(const char *fname); 1099{; 1100 const int kBufSize = kMAXPATHLEN;; 1101 TTHREAD_TLS_ARRAY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE o",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:39168,Modifiability,variab,variables,39168,"235#endif; 1236 x++[0] = c[0];; 1237 } else { // It is OK, copy result; 1238 int lp = strlen(p);; 1239 if (lp >= kBufSize) {; 1240 // make sure lx will be >= kBufSize (see below); 1241 strlcpy(x, p, kBufSize);; 1242 x += kBufSize;; 1243 break;; 1244 }; 1245 strcpy(x,p);; 1246 x += lp;; 1247 c = (b==c+1) ? e-1 : e;; 1248 }; 1249 }; 1250 }; 1251 ; 1252 x[0] = 0; lx = x - out;; 1253 if (ier && iter < 3) { strlcpy(inp, out, kBufSize); goto again; }; 1254 ncopy = (lx >= kBufSize) ? kBufSize-1 : lx;; 1255 xname[0] = 0; strncat(xname, out, ncopy);; 1256 ; 1257 delete[] buff;; 1258 ; 1259 if (ier || ncopy != lx) {; 1260 ::Error(""TSystem::ExpandFileName"", ""input: %s, output: %s"", fname, xname);; 1261 return kTRUE;; 1262 }; 1263 ; 1264 return kFALSE;; 1265}; 1266 ; 1267 ; 1268////////////////////////////////////////////////////////////////////////////////; 1269/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1270/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1271/// environment variables in a pathname. If compatibility is not an issue; 1272/// you can use on Unix directly $XXX.; 1273 ; 1274Bool_t TSystem::ExpandPathName(TString&); 1275{; 1276 return kFALSE;; 1277}; 1278 ; 1279////////////////////////////////////////////////////////////////////////////////; 1280/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1281/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in t",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:39630,Modifiability,variab,variables,39630," (lx >= kBufSize) ? kBufSize-1 : lx;; 1255 xname[0] = 0; strncat(xname, out, ncopy);; 1256 ; 1257 delete[] buff;; 1258 ; 1259 if (ier || ncopy != lx) {; 1260 ::Error(""TSystem::ExpandFileName"", ""input: %s, output: %s"", fname, xname);; 1261 return kTRUE;; 1262 }; 1263 ; 1264 return kFALSE;; 1265}; 1266 ; 1267 ; 1268////////////////////////////////////////////////////////////////////////////////; 1269/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1270/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1271/// environment variables in a pathname. If compatibility is not an issue; 1272/// you can use on Unix directly $XXX.; 1273 ; 1274Bool_t TSystem::ExpandPathName(TString&); 1275{; 1276 return kFALSE;; 1277}; 1278 ; 1279////////////////////////////////////////////////////////////////////////////////; 1280/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1281/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 130",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:46422,Modifiability,config,configured,46422,"(R_ISDIR(buf.fMode)); 1447 *flags |= 2;; 1448 if (!R_ISREG(buf.fMode) && !R_ISDIR(buf.fMode)); 1449 *flags |= 4;; 1450 }; 1451 }; 1452 ; 1453 return res;; 1454}; 1455 ; 1456////////////////////////////////////////////////////////////////////////////////; 1457/// Get info about a file. Info is returned in the form of a FileStat_t; 1458/// structure (see TSystem.h).; 1459/// The function returns 0 in case of success and 1 if the file could; 1460/// not be stat'ed.; 1461 ; 1462int TSystem::GetPathInfo(const char *, FileStat_t &); 1463{; 1464 AbstractMethod(""GetPathInfo(const char *, FileStat_t&)"");; 1465 return 1;; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469/// Get info about a file system: fs type, block size, number of blocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:52661,Modifiability,variab,variable,52661,"//; 1619/// Returns all group info in the UserGroup_t structure. The only active; 1620/// fields in the UserGroup_t structure for this call are:; 1621/// - fGid and fGroup; 1622/// The returned structure must be deleted by the user. In case of; 1623/// error 0 is returned.; 1624 ; 1625UserGroup_t *TSystem::GetGroupInfo(Int_t /*gid*/); 1626{; 1627 AbstractMethod(""GetGroupInfo"");; 1628 return nullptr;; 1629}; 1630 ; 1631////////////////////////////////////////////////////////////////////////////////; 1632/// Returns all group info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 1636/// must be deleted by the user. In case of error 0 is returned.; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; 1651 AbstractMethod(""Setenv"");; 1652}; 1653 ; 1654////////////////////////////////////////////////////////////////////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For t",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:52898,Modifiability,variab,variable,52898,"ystem::GetGroupInfo(Int_t /*gid*/); 1626{; 1627 AbstractMethod(""GetGroupInfo"");; 1628 return nullptr;; 1629}; 1630 ; 1631////////////////////////////////////////////////////////////////////////////////; 1632/// Returns all group info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 1636/// must be deleted by the user. In case of error 0 is returned.; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; 1651 AbstractMethod(""Setenv"");; 1652}; 1653 ; 1654////////////////////////////////////////////////////////////////////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:53117,Modifiability,variab,variable,53117," info in the UserGroup_t structure. The only active; 1633/// fields in the UserGroup_t structure for this call are:; 1634/// - fGid and fGroup; 1635/// If group = 0, returns current user's group. The returned structure; 1636/// must be deleted by the user. In case of error 0 is returned.; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; 1651 AbstractMethod(""Setenv"");; 1652}; 1653 ; 1654////////////////////////////////////////////////////////////////////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691///",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:90055,Modifiability,variab,variables,90055,"740///; 2741/// If dirmode is not zero and we need to create the target directory, the; 2742/// file mode bit will be change to 'dirmode' using chmod.; 2743///; 2744/// If library_specified is not specified, CompileMacro generate a default name; 2745/// for library by taking the name of the file ""filename"" but replacing the; 2746/// dot before the extension by an underscore and by adding the shared; 2747/// library extension for the current platform.; 2748/// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; 2749///; 2750/// It uses the directive fMakeSharedLibs to create a shared library.; 2751/// If loading the shared library fails, it tries to output a list of missing; 2752/// symbols by creating an executable (on some platforms like OSF, this does; 2753/// not HAVE to be an executable) containing the script. It uses the; 2754/// directive fMakeExe to do so.; 2755/// For both directives, before passing them to TSystem::Exec, it expands the; 2756/// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; 2757/// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; 2758/// information on those variables.; 2759///; 2760/// This method is used to implement the following feature:; 2761///; 2762/// Synopsis:; 2763///; 2764/// The purpose of this addition is to allow the user to use an external; 2765/// compiler to create a shared library from its C++ macro (scripts).; 2766/// Currently in order to execute a script, a user has to type at the root; 2767/// prompt; 2768/// ~~~ {.cpp}; 2769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.cpp}; 2777/// .X myfunc.C+(arg1,arg2); 2778/// ~~~; 2779/// In which case an external compiler will be called to create a shared; 2780/// library. This shared library will then be loaded and the function; 2781/// myfunc will be called with the two arguments. With '++' t",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:90236,Modifiability,variab,variables,90236,"g chmod.; 2743///; 2744/// If library_specified is not specified, CompileMacro generate a default name; 2745/// for library by taking the name of the file ""filename"" but replacing the; 2746/// dot before the extension by an underscore and by adding the shared; 2747/// library extension for the current platform.; 2748/// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; 2749///; 2750/// It uses the directive fMakeSharedLibs to create a shared library.; 2751/// If loading the shared library fails, it tries to output a list of missing; 2752/// symbols by creating an executable (on some platforms like OSF, this does; 2753/// not HAVE to be an executable) containing the script. It uses the; 2754/// directive fMakeExe to do so.; 2755/// For both directives, before passing them to TSystem::Exec, it expands the; 2756/// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; 2757/// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; 2758/// information on those variables.; 2759///; 2760/// This method is used to implement the following feature:; 2761///; 2762/// Synopsis:; 2763///; 2764/// The purpose of this addition is to allow the user to use an external; 2765/// compiler to create a shared library from its C++ macro (scripts).; 2766/// Currently in order to execute a script, a user has to type at the root; 2767/// prompt; 2768/// ~~~ {.cpp}; 2769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.cpp}; 2777/// .X myfunc.C+(arg1,arg2); 2778/// ~~~; 2779/// In which case an external compiler will be called to create a shared; 2780/// library. This shared library will then be loaded and the function; 2781/// myfunc will be called with the two arguments. With '++' the shared library; 2782/// is always recompiled. With '+' the shared library is recompiled only; 2783/// if it does not exist yet or the macro",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:93150,Modifiability,variab,variables,93150,"// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char *library_specified,; 2838 const char *build_dir,; 2839 UInt_t d",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:111177,Modifiability,polymorphi,polymorphic,111177,"y);; 3307 }; 3308 ; 3309 }; 3310 ; 3311 TString libmapfilename;; 3312 AssignAndDelete( libmapfilename, ConcatFileName( build_loc, libname ) );; 3313 libmapfilename += "".rootmap"";; 3314#if (defined(R__MACOSX) && !defined(MAC_OS_X_VERSION_10_5)) || defined(R__WIN32); 3315 Bool_t produceRootmap = kTRUE;; 3316#else; 3317 Bool_t produceRootmap = kFALSE;; 3318#endif; 3319 Bool_t linkDepLibraries = !produceRootmap;; 3320 if (gEnv) {; 3321#if (defined(R__MACOSX) && !defined(MAC_OS_X_VERSION_10_5)); 3322 Int_t linkLibs = gEnv->GetValue(""ACLiC.LinkLibs"",2);; 3323#elif defined(R__WIN32); 3324 Int_t linkLibs = gEnv->GetValue(""ACLiC.LinkLibs"",3);; 3325#else; 3326 Int_t linkLibs = gEnv->GetValue(""ACLiC.LinkLibs"",1);; 3327#endif; 3328 produceRootmap = linkLibs & 0x2;; 3329 linkDepLibraries = linkLibs & 0x1;; 3330 }; 3331 ; 3332 // FIXME: Triggers clang false positive warning -Wunused-lambda-capture.; 3333 /*constexpr const*/ bool useCxxModules =; 3334#ifdef R__USE_CXXMODULES; 3335 true;; 3336#else; 3337 false;; 3338#endif; 3339 ; 3340 // FIXME: Switch to generic polymorphic when we make c++14 default.; 3341 auto ForeachSharedLibDep = [](const char *lib, std::function<bool(const char *)> f) {; 3342 using std::string, std::vector, std::istringstream, std::istream_iterator;; 3343 string deps = gInterpreter->GetSharedLibDeps(lib, /*tryDyld*/ true);; 3344 istringstream iss(deps);; 3345 vector<string> libs{istream_iterator<std::string>{iss}, istream_iterator<string>{}};; 3346 // Skip the first element: it is a relative path to `lib`.; 3347 for (auto I = libs.begin() + 1, E = libs.end(); I != E; ++I); 3348 if (!f(I->c_str())); 3349 break;; 3350 };; 3351 auto LoadLibrary = [useCxxModules, produceRootmap, ForeachSharedLibDep](const TString &lib) {; 3352 // We have no rootmap files or modules to construct `-l` flags enabling; 3353 // explicit linking. We have to resolve the dependencies by ourselves; 3354 // taking the job of the dyld.; 3355 // FIXME: This is a rare case where we have rootc",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:114214,Modifiability,variab,variable,114214," else return kTRUE;; 3384 }; 3385 ; 3386 if (!canWrite && recompile) {; 3387 ; 3388 if (mkdirFailed) {; 3389 ::Warning(""ACLiC"",""Could not create the directory: %s"",; 3390 build_loc.Data());; 3391 } else {; 3392 ::Warning(""ACLiC"",""%s is not writable!"",; 3393 build_loc.Data());; 3394 }; 3395 if (emergency_loc == build_dir ) {; 3396 ::Error(""ACLiC"",""%s is the last resort location (i.e. temp location)"",build_loc.Data());; 3397 return kFALSE;; 3398 }; 3399 ::Warning(""ACLiC"",""Output will be written to %s"",; 3400 emergency_loc.Data());; 3401 return CompileMacro(expFileName, opt, library_specified, emergency_loc, dirmode);; 3402 }; 3403 ; 3404 if (withInfo) {; 3405 Info(""ACLiC"",""creating shared library %s"",library.Data());; 3406 }; 3407 ; 3408 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3409 ; 3410 // ======= Select the dictionary name; 3411 TString dict = libname + ""_ACLiC_dict"";; 3412 ; 3413 // the file name end up in the file produced; 3414 // by rootcling as a variable name so all character need to be valid!; 3415 static const int maxforbidden = 27;; 3416 static const char *forbidden_chars[maxforbidden] =; 3417 { ""+"",""-"",""*"",""/"",""&"",""%"",""|"",""^"","">"",""<"",; 3418 ""="",""~"",""."",""("","")"",""["",""]"",""!"","","",""$"",; 3419 "" "","":"",""'"",""#"",""@"",""\\"",""\"""" };; 3420 for( int ic = 0; ic < maxforbidden; ic++ ) {; 3421 dict.ReplaceAll( forbidden_chars[ic],""_"" );; 3422 }; 3423 if ( dict.Last('.')!=dict.Length()-1 ) dict.Append(""."");; 3424 AssignAndDelete( dict, ConcatFileName( build_loc, dict ) );; 3425 TString dicth = dict;; 3426 TString dictObj = dict;; 3427 dict += ""cxx""; //no need to keep the extension of the original file, any extension will do; 3428 dicth += ""h"";; 3429 dictObj += fObjExt;; 3430 ; 3431 // ======= Generate a linkdef file; 3432 ; 3433 TString linkdef;; 3434 AssignAndDelete( linkdef, ConcatFileName( build_loc, libname ) );; 3435 linkdef += ""_ACLiC_linkdef.h"";; 3436 std::ofstream ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:139257,Modifiability,variab,variable,139257,"3/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:139667,Modifiability,variab,variables,139667,"e or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fI",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:140121,Modifiability,variab,variables,140121,"s creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --displ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:140215,Modifiability,variab,variables,140215," 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --display_error_number; 4126/// --diag_suppress 68 -o $SharedLib"");; 4127///; 4128/// gSystem->setMakeSharedLib(; 4129/// ""Cxx $IncludePath -c $SourceFile;; 4130/// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; 4131/// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; 4132/// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:142132,Modifiability,variab,variables,142132,"tion/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --display_error_number; 4126/// --diag_suppress 68 -o $SharedLib"");; 4127///; 4128/// gSystem->setMakeSharedLib(; 4129/// ""Cxx $IncludePath -c $SourceFile;; 4130/// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; 4131/// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; 4132/// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134/// gSystem->SetMakeSharedLib(; 4135/// ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; 4136/// -shared -o $SharedLib"");; 4137///; 4138/// gSystem->SetMakeSharedLib(; 4139/// ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; 4140/// -D_WINDOWS $IncludePath $SourceFile; 4141/// /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; 4142/// $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""); 4143/// ~~~; 4144 ; 4145void TSystem::SetMakeSharedLib(const char *directives); 4146{; 4147 fMakeSharedLib = directives;; 4148 // NOTE: add verification that the directives has the required variables; 4149}; 4150 ; 4151////////////////////////////////////////////////////////////////////////////////; 4152/// \brief Add a directory to the already set include path.; 4153/// \param[in] includePath The path to the directory.; 4154/// \note This interface is mostly relevant for ACLiC and it does *not* inform; 4155/// gInterpreter for this include path. If the TInterpreter needs to know; 4156/// about the include path please use TInterpreter::AddIncludePath() .; 4157/// \warning The path should start with the \c -I prefix, i.e.; 4158/// <tt>gSystem->AddIncludePath(""-I /path/to/my/includes"")</tt>.; 4159void TSystem::AddIncludePath(const char *includePath); 4160{; 4161 if (includePath) {; 4162 fIncludePath += "" "";; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:144355,Modifiability,config,config,144355,"ctives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; 4182/// ~~~ {.cpp}; 4183/// gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; 4184/// ~~~; 4185/// the default value of IncludePath on Unix is:; 4186/// ~~~ {.cpp}; 4187/// ""-I$ROOTSYS/include ""; 4188/// ~~~; 4189/// and on Windows:; 4190/// ~~~ {.cpp}; 4191/// ""/I%ROOTSYS%/include ""; 4192/// ~~~; 4193 ; 4194void TSystem::SetIncludePath(const char *includePath); 4195{; 4196 fIncludePath = includePath;; 4197}; 4198 ; 4199////////////////////////////////////////////////////////////////////////////////; 4200/// LinkedLibs should contain the library directory and list of libraries; 4201/// needed to recreate the current executable. It is used to expand $LinkedLibs; 4202/// in the directives given to SetMakeSharedLib() and SetMakeExe(); 4203/// The default value on Unix is: `root-config --glibs`; 4204 ; 4205void TSystem::SetLinkedLibs(const char *linkedLibs); 4206{; 4207 fLinkedLibs = linkedLibs;; 4208}; 4209 ; 4210////////////////////////////////////////////////////////////////////////////////; 4211/// The 'suffix' will be appended to the name of a script loaded by ACLiC; 4212/// and used to locate any eventual additional linkdef information that; 4213/// ACLiC should used to produce the dictionary.; 4214///; 4215/// So by default, when doing .L MyScript.cxx, ACLiC will look; 4216/// for a file name MyScript_linkdef and having one of the .h (.hpp,; 4217/// etc.) extensions. If such a file exist, it will be added to; 4218/// the end of the linkdef file used to created the ACLiC dictionary.; 4219/// This effectively enable the full customization of the creation; 4220/// of the dictionary. It should be noted that the file is intended; 4221/// as a linkdef `fragment`, so usually you would not list the; 4222/// typical:; 4223/// ~~~ {.cpp}; 4224/// #pragma link off ....; 4225/// ~~~; 4226 ; 4227void TSystem::SetLinkdefSuffix(const char *suffix); 4228{; 4229 fLinkdefSuffix = suffix;; 4230}; 4231 ; 4232",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:150491,Modifiability,plugin,plugin,150491,"///////////////////////////////////////////////////////////////////////////; 4366/// Remove the shared libs produced by the CompileMacro() function, together; 4367/// with their rootmaps, linkdefs, and pcms (and some more on Windows).; 4368 ; 4369void TSystem::CleanCompiledMacros(); 4370{; 4371 TIter next(fCompiled);; 4372 TNamed *lib;; 4373 const char *extensions[] = {"".lib"", "".exp"", "".d"", "".def"", "".rootmap"", ""_ACLiC_linkdef.h"", ""_ACLiC_dict_rdict.pcm""};; 4374 while ((lib = (TNamed*)next())) {; 4375 if (lib->TestBit(kMustCleanup)) {; 4376 TString libname = lib->GetTitle();; 4377#ifdef WIN32; 4378 // On Windows, we need to unload the dll before deleting it; 4379 if (gInterpreter->IsLibraryLoaded(libname)); 4380 ::FreeLibrary(::GetModuleHandle(libname));; 4381#endif; 4382 Unlink(libname);; 4383 TString target, soExt = ""."" + fSoExt;; 4384 libname.ReplaceAll(soExt, """");; 4385 for (const char *ext : extensions) {; 4386 target = libname + ext;; 4387 Unlink(target);; 4388 }; 4389 }; 4390 }; 4391}; 4392 ; 4393////////////////////////////////////////////////////////////////////////////////; 4394/// Register version of plugin library.; 4395 ; 4396TVersionCheck::TVersionCheck(int versionCode); 4397{; 4398 if (versionCode != TROOT::RootVersionCode() && gLibraryVersion); 4399 gLibraryVersion[gLibraryVersionIdx] = versionCode;; 4400}; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; ROOT_RELEASE#define ROOT_RELEASEDefinition RVersion.hxx:29; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:159802,Modifiability,config,config,159802,"ex)Definition TVirtualRWMutex.h:154; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17535; extensionconst char * extensionDefinition civetweb.c:8025; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TEnvRecDefinition TEnv.h:86; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TIterDefinition TCollection.h:235; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList:",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:174488,Modifiability,variab,variable,174488,"og(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fStdExceptionHandlerDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not ex",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:176230,Modifiability,variab,variable,176230,"erDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::RecvBufvirtual int RecvBuf(int sock, void *buffer, int length)Receive a buffer headed by a length indicator.Definition TSystem.cxx:2418; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).Definition TSystem.cxx:494; TSystem::SetSockOptvirtual int SetSockOpt(int sock, int kind, int val)Set socket option.Definition TSystem.cxx:2436; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::RemoveStdExceptionHandlervirtual TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler *eh)Remove an exception handler from list of exception handlers.Definition TSystem.cxx:621; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::AcceptConnectionvirtual int AcceptConnection(int sock)Accept a connection.Definition TSystem.cxx:2381; TSystem::GetAclicPropertiesvirtual Int_t GetAclicProperties() constReturn the ACLiC properties field.Definition TSystem.cxx:3867; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::fListLibsTString fListLibsDefinition TSystem.h:300; TSystem::ShowOutputvirtual void ShowOutput(RedirectHandle_t *h)Display the content associated with the re",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:187527,Modifiability,variab,variable,187527,"eate an executabl...Definition TSystem.cxx:4093; TSystem::fCompiledTSeqCollection * fCompiledDefinition TSystem.h:320; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TSystem::fBuildCompilerVersionTString fBuildCompilerVersionDefinition TSystem.h:304; TSystem::FindHelperTSystem * FindHelper(const char *path, void *dirptr=nullptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:191916,Modifiability,variab,variable,191916,"force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual vo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:194795,Modifiability,config,configured,194795,"ystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset(",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:196438,Modifiability,plugin,plugin,196438,"ith millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::Removevoid Remove() overrideDefinition TTimer.h:86; TTimer::fTimeoutBool_t fTimeoutDefinition TTimer.h:56; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUserconst char * GetUser() constDefinition TUrl.h:65; TUrl::GetHostconst char * GetHost() constDefinition TUrl.h:67; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVersionCheck::TVersionCheckTVersionCheck(int versionCode)Register version of plugin library.Definition TSystem.cxx:4396; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; I#define I(x, y, z); ROOT::FoundationUtils::GetCurrentDirstd::string GetCurrentDir()Definition FoundationUtils.cxx:47; ROOT::FoundationUtils::MakePathRelativestd::string MakePathRelative(const std::string &path, const std::string &base, bool isBuildingROOT=false)Definition FoundationUtils.cxx:82; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; v@ vDefinition rootcling_impl.cxx:3699; CpuInfo_tDefinition TSystem.h:163; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; FileStat_t::fSizeLong64_t fSizeDefinition TSystem.h:128; FileStat_t::fDevLong_t fDevDefinition TSystem.h:123; FileStat_t::fMtime",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:59545,Performance,load,loading,59545,"825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Len",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:59589,Performance,load,loaded,59589,"825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Len",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:59729,Performance,load,loaded,59729,"rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[id",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:60113,Performance,load,load,60113,"on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Lengt",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:60151,Performance,load,loaded,60151,"on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Lengt",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:61544,Performance,load,load,61544," if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:61978,Performance,load,loading,61978,"85 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; 1914 const char *deplib = ((TObjString*)tokens->At(i))->GetName();; 1915 if (strcmp(module,deplib)==0) {; 1916 continue;; 1917 }; 1918 if (gDebug > 0); 1919 Info(""Load"", ""loading dependent library %s for library %s"",; 1920 deplib, ((TObjString*)tokens->At(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());; 1936 }; 1937 }; 1938 ; 1939 gLibraryVersionIdx++;; 1940 if (gLibraryVersionIdx == gLibraryVersionMax) {; 1941 gLibraryVersionMax *= 2;; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVers",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:62882,Performance,load,loaded,62882,"(0))->GetName());; 1921 if ((ret = Load(deplib, """", system)) < 0) {; 1922 delete tokens;; 1923 delete [] path;; 1924 return ret;; 1925 }; 1926 }; 1927 delete tokens;; 1928 }; 1929 if (!system) {; 1930 // Mark the library in $ROOTSYS/lib as system.; 1931 TString dirname = GetDirName(path);; 1932 system = R__MatchFilename(TROOT::GetLibDir(), dirname.Data());; 1933 ; 1934 if (!system) {; 1935 system = R__MatchFilename(TROOT::GetBinDir(), dirname.Data());; 1936 }; 1937 }; 1938 ; 1939 gLibraryVersionIdx++;; 1940 if (gLibraryVersionIdx == gLibraryVersionMax) {; 1941 gLibraryVersionMax *= 2;; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec =",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:63681,Performance,load,loaded,63681,";; 1942 gLibraryVersion = TStorage::ReAllocInt(gLibraryVersion, gLibraryVersionMax, gLibraryVersionIdx);; 1943 }; 1944 ret = gInterpreter->Load(path, system);; 1945 if (ret < 0) ret = -1;; 1946 if (gDebug > 0); 1947 Info(""Load"", ""loaded library %s, status %d"", path, ret);; 1948 if (ret == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:63913,Performance,load,loadedlibs,63913,"t == 0 && gLibraryVersion[gLibraryVersionIdx]) {; 1949 int v = TROOT::ConvertVersionCode2Int(gLibraryVersion[gLibraryVersionIdx]);; 1950 Error(""Load"", ""version mismatch, %s = %d, ROOT = %d"",; 1951 path, v, gROOT->GetVersionInt());; 1952 ret = -2;; 1953 gLibraryVersion[gLibraryVersionIdx] = 0;; 1954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64255,Performance,load,load,64255,"954 }; 1955 gLibraryVersionIdx--;; 1956 delete [] path;; 1957 }; 1958 ; 1959 if (!entry || !entry[0] || ret < 0) return ret;; 1960 ; 1961 Func_t f = DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::Dy",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64336,Performance,load,load,64336," DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return St",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64511,Performance,load,loaded,64511,"///////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64588,Performance,load,loadedlibs,64588,"all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system se",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64619,Performance,load,loadedlibs,64619,"968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain t",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64653,Performance,load,load,64653,"s successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if fo",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:64797,Performance,load,loadedlibs,64797," nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if found, or NULL; 2031/// if a library called lib was not found.; 2032/// This function does ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:66974,Performance,load,loaded,66974,"thod(""FindDynamicLibrary"");; 2037 return nullptr;; 2038}; 2039 ; 2040////////////////////////////////////////////////////////////////////////////////; 2041/// Find specific entry point in specified library. Specify ""*"" for lib; 2042/// to search in all libraries.; 2043 ; 2044Func_t TSystem::DynFindSymbol(const char * /*lib*/, const char *entry); 2045{; 2046 return (Func_t) gInterpreter->FindSym(entry);; 2047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// List symbols in a shared library.; 2063 ; 2064void TSystem::ListSymbols(const char *, const char *); 2065{; 2066 AbstractMethod(""ListSymbols"");; 2067}; 2068 ; 2069////////////////////////////////////////////////////////////////////////////////; 2070/// List the loaded shared libraries.; 2071/// `regexp` is a regular expression allowing to filter the list.; 2072///; 2073/// Examples:; 2074///; 2075/// The following line lists all the libraries currently loaded:; 2076/// ~~~ {.cpp}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099/////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:67169,Performance,load,loaded,67169,"ies.; 2043 ; 2044Func_t TSystem::DynFindSymbol(const char * /*lib*/, const char *entry); 2045{; 2046 return (Func_t) gInterpreter->FindSym(entry);; 2047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// List symbols in a shared library.; 2063 ; 2064void TSystem::ListSymbols(const char *, const char *); 2065{; 2066 AbstractMethod(""ListSymbols"");; 2067}; 2068 ; 2069////////////////////////////////////////////////////////////////////////////////; 2070/// List the loaded shared libraries.; 2071/// `regexp` is a regular expression allowing to filter the list.; 2072///; 2073/// Examples:; 2074///; 2075/// The following line lists all the libraries currently loaded:; 2076/// ~~~ {.cpp}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLast",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:67315,Performance,load,loaded,67315,"047}; 2048 ; 2049////////////////////////////////////////////////////////////////////////////////; 2050/// Unload a shared library.; 2051 ; 2052void TSystem::Unload(const char *module); 2053{; 2054 char *path;; 2055 if ((path = DynamicPathName(module))) {; 2056 gInterpreter->UnloadFile(path);; 2057 delete [] path;; 2058 }; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// List symbols in a shared library.; 2063 ; 2064void TSystem::ListSymbols(const char *, const char *); 2065{; 2066 AbstractMethod(""ListSymbols"");; 2067}; 2068 ; 2069////////////////////////////////////////////////////////////////////////////////; 2070/// List the loaded shared libraries.; 2071/// `regexp` is a regular expression allowing to filter the list.; 2072///; 2073/// Examples:; 2074///; 2075/// The following line lists all the libraries currently loaded:; 2076/// ~~~ {.cpp}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local st",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:68590,Performance,load,loaded,68590,"p}; 2077/// gSystem->ListLibraries(); 2078/// ~~~; 2079///; 2080/// The following line lists all the libraries currently loaded having ""RIO"" in their names:; 2081/// ~~~ {.cpp}; 2082/// gSystem->ListLibraries("".*RIO.*""); 2083/// ~~~; 2084 ; 2085void TSystem::ListLibraries(const char *regexp) {; 2086 if (!(regexp && regexp[0])); 2087 regexp = "".*"";; 2088 TRegexp pat(regexp, kFALSE);; 2089 TString libs(GetLibraries());; 2090 TString tok;; 2091 Ssiz_t from = 0, ext;; 2092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared librari",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:68926,Performance,load,loaded,68926," }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:69198,Performance,load,loaded,69198,"//////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:69335,Performance,load,loaded,69335,"onst TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {; 2159 // This is not the default value, we need to keep the custom part.; 2160 TString custom = fLinkedLibs;; 2161 cus",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:69928,Performance,load,loaded,69928,"d shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {; 2159 // This is not the default value, we need to keep the custom part.; 2160 TString custom = fLinkedLibs;; 2161 custom.ReplaceAll(LINKEDLIBS,linked);; 2162 if (custom == fLinkedLibs) {; 2163 // no replacement done, let's append linked; 2164 slinked.Append(linked);; 2165 slinked.Append("" "");; 2166 }; 2167 slinked.Append(custom);; 2168 } else {; 2169 slinked.Append(linked);; 2170 }; 2171 } else {; 2172 slinked.Append(fLinkedLibs);; 2173 }; 2174 ; 2175 if (opt.IsNull() || opt.First('S') != kNPOS) {; 2176 // We are done, the statically linked libraries are already included.; 2177 if (libs.Length() == 0) {; 2178 libs = slinked;; 2179 } else {; 2180 // We need to add the missing linked library; 2181 ; 2182 stati",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:73123,Performance,load,loaded,73123,"ndex,end);; 2223 if (sub[0]!='-' && sub[1]!='L') {; 2224 libs.ReplaceAll(sub,"""");; 2225 }; 2226 }; 2227 start += end+1;; 2228 }; 2229 libs = libs.Strip(TString::kBoth);; 2230 }; 2231 ; 2232 // Select according to regexp; 2233 if (regexp && *regexp) {; 2234 static TRegexp separator(""[^ \\t\\s]+"");; 2235 TRegexp user_re(regexp, kTRUE);; 2236 TString s;; 2237 Ssiz_t start, index, end;; 2238 start = index = end = 0;; 2239 ; 2240 while ((start < libs.Length()) && (index != kNPOS)) {; 2241 index = libs.Index(separator,&end,start);; 2242 if (index >= 0) {; 2243 s = libs(index,end);; 2244 if ((isRegexp && s.Index(user_re) != kNPOS) ||; 2245 (!isRegexp && s.Index(regexp) != kNPOS)) {; 2246 if (!fListLibs.IsNull()); 2247 fListLibs.Append("" "");; 2248 fListLibs.Append(s);; 2249 }; 2250 }; 2251 start += end+1;; 2252 }; 2253 } else; 2254 fListLibs = libs;; 2255 ; 2256#if defined(R__MACOSX); 2257// We need to remove the libraries that are dynamically loaded and not linked; 2258{; 2259 TString libs2 = fListLibs;; 2260 TString maclibs;; 2261 ; 2262 static TRegexp separator(""[^ \\t\\s]+"");; 2263 static TRegexp dynload(""/lib-dynload/"");; 2264 ; 2265 Ssiz_t start, index, end;; 2266 start = index = end = 0;; 2267 ; 2268 while ((start < libs2.Length()) && (index != kNPOS)) {; 2269 index = libs2.Index(separator, &end, start);; 2270 if (index >= 0) {; 2271 TString s = libs2(index, end);; 2272 if (s.Index(dynload) == kNPOS) {; 2273 if (!maclibs.IsNull()) maclibs.Append("" "");; 2274 maclibs.Append(s);; 2275 }; 2276 }; 2277 start += end+1;; 2278 }; 2279 fListLibs = maclibs;; 2280}; 2281#endif; 2282 ; 2283 return fListLibs.Data();; 2284}; 2285 ; 2286//---- RPC ---------------------------------------------------------------------; 2287 ; 2288////////////////////////////////////////////////////////////////////////////////; 2289/// Get Internet Protocol (IP) address of host.; 2290 ; 2291TInetAddress TSystem::GetHostByName(const char *); 2292{; 2293 AbstractMethod(""GetHostByName"");; 2294 return TIne",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79424,Performance,load,load,79424,"1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 othe",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79441,Performance,load,load,79441,"1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 othe",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:79595,Performance,load,load,79595,"41 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAnd",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:87586,Performance,load,loads,87586,"8 R__AddPath(adddictdep,rootCling);; 2679 adddictdep += "" "";; 2680 delete [] rootCling;; 2681 }; 2682 }; 2683 adddictdep += "" >> \""""+depfilename+""\"""";; 2684 ; 2685 TString addversiondep( ""echo "");; 2686 addversiondep += libname + version_var_prefix + "" \"""" + ROOT_RELEASE + ""\"" >> \""""+depfilename+""\"""";; 2687 ; 2688 if (gDebug > 4) {; 2689 ::Info(""ACLiC"", ""%s"", touch.Data());; 2690 ::Info(""ACLiC"", ""%s"", builddep.Data());; 2691 ::Info(""ACLiC"", ""%s"", adddictdep.Data());; 2692 }; 2693 ; 2694 Int_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:87969,Performance,optimiz,optimized,87969,"nt_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/// If build_dir is specified, it is used as an alternative 'root' for the; 2733/// generation of the shared library. The library is stored in a sub-directories; 2734/// of 'build_dir' including the full pathname of the script unless a flat; 2735/// directory structure is requested ('-' option). With the '-' option the libraries; 2736/// are created directly in the directory 'build_dir'; in particular this means that; 2737/// 2 scripts with the same name in different source directory will",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:88035,Performance,load,load,88035,"nt_t depbuilt = !gSystem->Exec(touch);; 2695 if (depbuilt) depbuilt = !gSystem->Exec(builddep);; 2696 if (depbuilt) depbuilt = !gSystem->Exec(adddictdep);; 2697 if (depbuilt) depbuilt = !gSystem->Exec(addversiondep);; 2698 ; 2699 if (!depbuilt) {; 2700 ::Warning(""ACLiC"",""Failed to generate the dependency file for %s"",; 2701 library.Data());; 2702 } else {; 2703#ifdef WIN32; 2704 gSystem->Unlink(stderrfile);; 2705#endif; 2706 gSystem->Unlink(bakdepfilename);; 2707 }; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// This method compiles and loads a shared library containing; 2712/// the code from the file ""filename"".; 2713///; 2714/// The return value is true (1) in case of success and false (0); 2715/// in case of error.; 2716///; 2717/// The possible options are:; 2718/// - k : keep the shared library after the session end.; 2719/// - f : force recompilation.; 2720/// - g : compile with debug symbol; 2721/// - O : optimized the code; 2722/// - c : compile only, do not attempt to load the library.; 2723/// - s : silence all informational output; 2724/// - v : output all information output; 2725/// - d : debug ACLiC, keep all the output files.; 2726/// - - : if buildir is set, use a flat structure (see buildir below); 2727///; 2728/// If library_specified is specified, CompileMacro generates the file; 2729/// ""library_specified"".soext where soext is the shared library extension for; 2730/// the current platform.; 2731///; 2732/// If build_dir is specified, it is used as an alternative 'root' for the; 2733/// generation of the shared library. The library is stored in a sub-directories; 2734/// of 'build_dir' including the full pathname of the script unless a flat; 2735/// directory structure is requested ('-' option). With the '-' option the libraries; 2736/// are created directly in the directory 'build_dir'; in particular this means that; 2737/// 2 scripts with the same name in different source directory will",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:89698,Performance,load,loading,89698," option the libraries; 2736/// are created directly in the directory 'build_dir'; in particular this means that; 2737/// 2 scripts with the same name in different source directory will over-write each; 2738/// other's library.; 2739/// See also TSystem::SetBuildDir.; 2740///; 2741/// If dirmode is not zero and we need to create the target directory, the; 2742/// file mode bit will be change to 'dirmode' using chmod.; 2743///; 2744/// If library_specified is not specified, CompileMacro generate a default name; 2745/// for library by taking the name of the file ""filename"" but replacing the; 2746/// dot before the extension by an underscore and by adding the shared; 2747/// library extension for the current platform.; 2748/// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; 2749///; 2750/// It uses the directive fMakeSharedLibs to create a shared library.; 2751/// If loading the shared library fails, it tries to output a list of missing; 2752/// symbols by creating an executable (on some platforms like OSF, this does; 2753/// not HAVE to be an executable) containing the script. It uses the; 2754/// directive fMakeExe to do so.; 2755/// For both directives, before passing them to TSystem::Exec, it expands the; 2756/// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; 2757/// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; 2758/// information on those variables.; 2759///; 2760/// This method is used to implement the following feature:; 2761///; 2762/// Synopsis:; 2763///; 2764/// The purpose of this addition is to allow the user to use an external; 2765/// compiler to create a shared library from its C++ macro (scripts).; 2766/// Currently in order to execute a script, a user has to type at the root; 2767/// prompt; 2768/// ~~~ {.cpp}; 2769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.c",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:90978,Performance,load,loaded,90978,"passing them to TSystem::Exec, it expands the; 2756/// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; 2757/// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; 2758/// information on those variables.; 2759///; 2760/// This method is used to implement the following feature:; 2761///; 2762/// Synopsis:; 2763///; 2764/// The purpose of this addition is to allow the user to use an external; 2765/// compiler to create a shared library from its C++ macro (scripts).; 2766/// Currently in order to execute a script, a user has to type at the root; 2767/// prompt; 2768/// ~~~ {.cpp}; 2769/// .X myfunc.C(arg1,arg2); 2770/// ~~~; 2771/// We allow them to type:; 2772/// ~~~ {.cpp}; 2773/// .X myfunc.C++(arg1,arg2); 2774/// ~~~; 2775/// or; 2776/// ~~~ {.cpp}; 2777/// .X myfunc.C+(arg1,arg2); 2778/// ~~~; 2779/// In which case an external compiler will be called to create a shared; 2780/// library. This shared library will then be loaded and the function; 2781/// myfunc will be called with the two arguments. With '++' the shared library; 2782/// is always recompiled. With '+' the shared library is recompiled only; 2783/// if it does not exist yet or the macro file is newer than the shared; 2784/// library.; 2785///; 2786/// Of course the + and ++ notation is supported in similar way for .x and .L.; 2787///; 2788/// Through the function TSystem::SetMakeSharedLib(), the user will be able to; 2789/// indicate, with shell commands, how to build a shared library (a good; 2790/// default will be provided). The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may somet",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92043,Performance,load,loaded,92043,"ill be called with the two arguments. With '++' the shared library; 2782/// is always recompiled. With '+' the shared library is recompiled only; 2783/// if it does not exist yet or the macro file is newer than the shared; 2784/// library.; 2785///; 2786/// Of course the + and ++ notation is supported in similar way for .x and .L.; 2787///; 2788/// Through the function TSystem::SetMakeSharedLib(), the user will be able to; 2789/// indicate, with shell commands, how to build a shared library (a good; 2790/// default will be provided). The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814///",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92191,Performance,load,loading,92191,"/// library.; 2785///; 2786/// Of course the + and ++ notation is supported in similar way for .x and .L.; 2787///; 2788/// Through the function TSystem::SetMakeSharedLib(), the user will be able to; 2789/// indicate, with shell commands, how to build a shared library (a good; 2790/// default will be provided). The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92524,Performance,load,loader,92524,". The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the ac",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92656,Performance,load,loaded,92656," be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///;",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:94378,Performance,load,loadLib,94378,"27/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char *library_specified,; 2838 const char *build_dir,; 2839 UInt_t dirmode); 2840{; 2841 static const char *version_var_prefix = ""__ROOTBUILDVERSION="";; 2842 ; 2843 // ======= Analyze the options; 2844 Bool_t keep = kFALSE;; 2845 Bool_t recompile = kFALSE;; 2846 int mode = fAclicMode;; 2847 Bool_t loadLib = kTRUE;; 2848 Bool_t withInfo = kTRUE;; 2849 Bool_t verbose = kFALSE;; 2850 Bool_t internalDebug = kFALSE;; 2851 if (opt) {; 2852 keep = (strchr(opt,'k')!=nullptr);; 2853 recompile = (strchr(opt,'f')!=nullptr);; 2854 if (strchr(opt,'O')!=nullptr) {; 2855 mode |= kOpt;; 2856 }; 2857 if (strchr(opt,'g')!=nullptr) {; 2858 mode |= kDebug;; 2859 }; 2860 if (strchr(opt,'c')!=nullptr) {; 2861 loadLib = kFALSE;; 2862 }; 2863 withInfo = strchr(opt, 's') == nullptr;; 2864 verbose = strchr(opt, 'v') != nullptr;; 2865 internalDebug = strchr(opt, 'd') != nullptr;; 2866 }; 2867 if (mode==kDefault) {; 2868 TString rootbuild = ROOTBUILD;; 2869 if (rootbuild.Index(""debug"",0,TString::kIgnoreCase)==kNPOS) {; 2870 mode = kOpt;; 2871 } else {; 2872 mode = kDebug;; 2873 }; 2874 }; 2875 UInt_t verboseLevel = verbose ? 7 : gDebug;; 2876 Bool_t flatBuildDir = (fAclicProperties & kFlatBuildDir) || (opt && strchr(opt,'-')!=nullptr);; 2877 ; 2878 // if non-zero, build_loc indicates where to build the shared library.; 2879 TString build_loc = ExpandFileName(GetBuildDir());; 2880 if (build_dir && strlen(build_dir)) build_loc = build_dir;; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:94776,Performance,load,loadLib,94776,"27/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char *library_specified,; 2838 const char *build_dir,; 2839 UInt_t dirmode); 2840{; 2841 static const char *version_var_prefix = ""__ROOTBUILDVERSION="";; 2842 ; 2843 // ======= Analyze the options; 2844 Bool_t keep = kFALSE;; 2845 Bool_t recompile = kFALSE;; 2846 int mode = fAclicMode;; 2847 Bool_t loadLib = kTRUE;; 2848 Bool_t withInfo = kTRUE;; 2849 Bool_t verbose = kFALSE;; 2850 Bool_t internalDebug = kFALSE;; 2851 if (opt) {; 2852 keep = (strchr(opt,'k')!=nullptr);; 2853 recompile = (strchr(opt,'f')!=nullptr);; 2854 if (strchr(opt,'O')!=nullptr) {; 2855 mode |= kOpt;; 2856 }; 2857 if (strchr(opt,'g')!=nullptr) {; 2858 mode |= kDebug;; 2859 }; 2860 if (strchr(opt,'c')!=nullptr) {; 2861 loadLib = kFALSE;; 2862 }; 2863 withInfo = strchr(opt, 's') == nullptr;; 2864 verbose = strchr(opt, 'v') != nullptr;; 2865 internalDebug = strchr(opt, 'd') != nullptr;; 2866 }; 2867 if (mode==kDefault) {; 2868 TString rootbuild = ROOTBUILD;; 2869 if (rootbuild.Index(""debug"",0,TString::kIgnoreCase)==kNPOS) {; 2870 mode = kOpt;; 2871 } else {; 2872 mode = kDebug;; 2873 }; 2874 }; 2875 UInt_t verboseLevel = verbose ? 7 : gDebug;; 2876 Bool_t flatBuildDir = (fAclicProperties & kFlatBuildDir) || (opt && strchr(opt,'-')!=nullptr);; 2877 ; 2878 // if non-zero, build_loc indicates where to build the shared library.; 2879 TString build_loc = ExpandFileName(GetBuildDir());; 2880 if (build_dir && strlen(build_dir)) build_loc = build_dir;; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:102014,Performance,load,loaded,102014,"kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020 Bool_t canWriteBuild_loc = !gSystem->AccessPathName(build_loc,kWritePermission);; 3021 TString build_loc_store( build_loc );; 3022 if (!flatBuildDir) {; 3023 AssignAndDelete( build_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TStrin",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:102162,Performance,load,loaded,102162,"kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020 Bool_t canWriteBuild_loc = !gSystem->AccessPathName(build_loc,kWritePermission);; 3021 TString build_loc_store( build_loc );; 3022 if (!flatBuildDir) {; 3023 AssignAndDelete( build_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TStrin",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:102308,Performance,load,loaded,102308,"ld_loc, ConcatFileName( build_loc, lib_location) );; 3024 }; 3025 ; 3026 if (gSystem->AccessPathName(build_loc,kFileExists)) {; 3027 mkdirFailed = (0 != mkdir(build_loc, true));; 3028 if (mkdirFailed && !canWriteBuild_loc) {; 3029 // The mkdir failed __and__ we can not write to the target directory,; 3030 // let make sure the error message will be about the target directory; 3031 build_loc = build_loc_store;; 3032 mkdirFailed = kFALSE;; 3033 } else if (!mkdirFailed && dirmode!=0) {; 3034 Chmod(build_loc,dirmode);; 3035 }; 3036 }; 3037 }; 3038 library = gSystem->UnixPathName(library);; 3039 ; 3040 // ======= Check if the library need to loaded or compiled; 3041 if (!gInterpreter->IsLibraryLoaded(library) && gInterpreter->IsLoaded(expFileName)) {; 3042 // the script has already been loaded in interpreted mode; 3043 // Let's warn the user and unload it.; 3044 ; 3045 if (withInfo) {; 3046 ::Info(""ACLiC"",""script has already been loaded in interpreted mode"");; 3047 ::Info(""ACLiC"",""unloading %s and compiling it"", filename);; 3048 }; 3049 ; 3050 if ( gInterpreter->UnloadFile( expFileName ) != 0 ) {; 3051 // We can not unload it.; 3052 return kFALSE;; 3053 }; 3054 }; 3055 ; 3056 // Calculate the -I lines; 3057 TString includes = GetIncludePath();; 3058 includes.ReplaceAll(""-I "", ""-I"");; 3059 includes.Prepend(' ');; 3060 ; 3061 {; 3062 // I need to replace the -Isomerelativepath by -I../ (or -I..\ on NT); 3063 TRegexp rel_inc("" -I[^\""/\\\\$\\%-][^:\\s]+"");; 3064 Int_t len,pos;; 3065 pos = rel_inc.Index(includes,&len);; 3066 while( len != 0 ) {; 3067 TString sub = includes(pos,len);; 3068 sub.Remove(0,3); // Remove ' -I'; 3069 AssignAndDelete( sub, ConcatFileName( WorkingDirectory(), sub ) );; 3070 sub.Prepend("" -I\"""");; 3071 if (sub.EndsWith("" "")); 3072 sub.Chop(); // Remove trailing space (i.e between the -Is ...; 3073 sub.Append(""\"" "");; 3074 includes.Replace(pos,len,sub);; 3075 pos = rel_inc.Index(includes,&len);; 3076 }; 3077 }; 3078 {; 3079 // I need to replace the -I""so",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:108415,Performance,load,loaded,108415,"Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; 3203 line[0] = 0;; 3204 current = 0;; 3205 } else if (isspace(c) && !nested) {; 3206 if (current) {; 3207 if (line[current-1]!=':') {; 3208 // ignore target; 3209 line[current] = 0;; 3210 ; 3211 Long_t filetime;; 3212 if (hasversion) {; 3213 modified |= strcmp(ROOT_RELEASE,line)!=0;; 3214 hasversion = kFALSE;; 3215 } else if ( gSystem->GetPathInfo( line, nullptr, (Long_t*)nullptr, nullptr, &filetime ) == 0 ) {; 3216 modified |= ( lib_time <= filetime );; 3217 }; 3218 }; 3219 }; 3220 current = 0;; 3221 line[0] = 0;; 3222 } else {; 3223 if (current==sz-1) {; 3224 sz = 2*sz;; 3225 char *newline = new char[sz];; 3226 memcpy(newline,line, current);; 3227 delete [] line;; 3228 line = newline;; 3229 }; 3230 if (c=='""') nested = !nested;; 3231 else {; 3232 line[current] = c;; 3233 current++;; 3234 }; 3235 }; 3236 }; 3237 delete [] line;; 3238 fclose(depfile);; 3239 recompile = modified;; 3240 ; 3241 }; 3242 ; 3243 }; 3244 }; 3245 ; 3246 if ( gInterpreter->IsLibraryLoaded(library); 3247 || strlen(GetLibraries(library,""D"",kFALSE)) != 0 ) {; 3248 // The library has already been built and loaded.; 3249 ; 3250 Bool_t reload = kFALSE;; 3251 TNamed *libinfo = (TNamed*)fCompiled->FindObject(library);; 3252 if (libinfo) {; 3253 Long_t load_time = libinfo->GetUniqueID();; 3254 Long_t lib_time;; 3255 if ( gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) == 0; 3256 && (lib_time>load_time)) {; 3257 reload = kTRUE;; 3258 }; 3259 }; 3260 ; 3261 if ( !recompile && reload ) {; 3262 ; 3263 if (withInfo) {; 3",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:109612,Performance,load,loaded,109612,"binfo = (TNamed*)fCompiled->FindObject(library);; 3252 if (libinfo) {; 3253 Long_t load_time = libinfo->GetUniqueID();; 3254 Long_t lib_time;; 3255 if ( gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) == 0; 3256 && (lib_time>load_time)) {; 3257 reload = kTRUE;; 3258 }; 3259 }; 3260 ; 3261 if ( !recompile && reload ) {; 3262 ; 3263 if (withInfo) {; 3264 ::Info(""ACLiC"",""%s has been modified and will be reloaded"",; 3265 libname.Data());; 3266 }; 3267 if ( gInterpreter->UnloadFile( library.Data() ) != 0 ) {; 3268 // The library is being used. We can not unload it.; 3269 return kFALSE;; 3270 }; 3271 if (libinfo) {; 3272 fCompiled->Remove(libinfo);; 3273 delete libinfo;; 3274 libinfo = nullptr;; 3275 }; 3276 TNamed *k = new TNamed(library,library);; 3277 Long_t lib_time;; 3278 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3279 k->SetUniqueID(lib_time);; 3280 if (!keep) k->SetBit(kMustCleanup);; 3281 fCompiled->Add(k);; 3282 ; 3283 return !gSystem->Load(library);; 3284 }; 3285 ; 3286 if (withInfo) {; 3287 ::Info(""ACLiC"",""%s script has already been compiled and loaded"",; 3288 modified ? ""modified"" : ""unmodified"");; 3289 }; 3290 ; 3291 if ( !recompile ) {; 3292 return kTRUE;; 3293 } else {; 3294 if (withInfo) {; 3295 ::Info(""ACLiC"",""it will be regenerated and reloaded!"");; 3296 }; 3297 if ( gInterpreter->UnloadFile( library.Data() ) != 0 ) {; 3298 // The library is being used. We can not unload it.; 3299 return kFALSE;; 3300 }; 3301 if (libinfo) {; 3302 fCompiled->Remove(libinfo);; 3303 delete libinfo;; 3304 libinfo = nullptr;; 3305 }; 3306 Unlink(library);; 3307 }; 3308 ; 3309 }; 3310 ; 3311 TString libmapfilename;; 3312 AssignAndDelete( libmapfilename, ConcatFileName( build_loc, libname ) );; 3313 libmapfilename += "".rootmap"";; 3314#if (defined(R__MACOSX) && !defined(MAC_OS_X_VERSION_10_5)) || defined(R__WIN32); 3315 Bool_t produceRootmap = kTRUE;; 3316#else; 3317 Bool_t produceRootmap = kFALSE;; 3318#endif;",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:112748,Performance,load,load,112748,"ator<string>{}};; 3346 // Skip the first element: it is a relative path to `lib`.; 3347 for (auto I = libs.begin() + 1, E = libs.end(); I != E; ++I); 3348 if (!f(I->c_str())); 3349 break;; 3350 };; 3351 auto LoadLibrary = [useCxxModules, produceRootmap, ForeachSharedLibDep](const TString &lib) {; 3352 // We have no rootmap files or modules to construct `-l` flags enabling; 3353 // explicit linking. We have to resolve the dependencies by ourselves; 3354 // taking the job of the dyld.; 3355 // FIXME: This is a rare case where we have rootcling running with; 3356 // modules disabled. Remove this code once we fully switch to modules,; 3357 // or implement a special flag in rootcling which selective enables; 3358 // modules for dependent libraries and does not produce a module for; 3359 // the ACLiC library.; 3360 if (useCxxModules && !produceRootmap) {; 3361 std::function<bool(const char *)> LoadLibF = [](const char *dep) {; 3362 return gInterpreter->Load(dep, /*skipReload*/ true) >= 0;; 3363 };; 3364 ForeachSharedLibDep(lib, LoadLibF);; 3365 }; 3366 return !gSystem->Load(lib);; 3367 };; 3368 ; 3369 if (!recompile) {; 3370 // The library already exist, let's just load it.; 3371 if (loadLib) {; 3372 TNamed *k = new TNamed(library,library);; 3373 Long_t lib_time;; 3374 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3375 k->SetUniqueID(lib_time);; 3376 if (!keep) k->SetBit(kMustCleanup);; 3377 fCompiled->Add(k);; 3378 ; 3379 gInterpreter->GetSharedLibDeps(library);; 3380 ; 3381 return LoadLibrary(library);; 3382 }; 3383 else return kTRUE;; 3384 }; 3385 ; 3386 if (!canWrite && recompile) {; 3387 ; 3388 if (mkdirFailed) {; 3389 ::Warning(""ACLiC"",""Could not create the directory: %s"",; 3390 build_loc.Data());; 3391 } else {; 3392 ::Warning(""ACLiC"",""%s is not writable!"",; 3393 build_loc.Data());; 3394 }; 3395 if (emergency_loc == build_dir ) {; 3396 ::Error(""ACLiC"",""%s is the last resort location (i.e. temp location)"",build_loc.Data());; 3397 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:112767,Performance,load,loadLib,112767,"e job of the dyld.; 3355 // FIXME: This is a rare case where we have rootcling running with; 3356 // modules disabled. Remove this code once we fully switch to modules,; 3357 // or implement a special flag in rootcling which selective enables; 3358 // modules for dependent libraries and does not produce a module for; 3359 // the ACLiC library.; 3360 if (useCxxModules && !produceRootmap) {; 3361 std::function<bool(const char *)> LoadLibF = [](const char *dep) {; 3362 return gInterpreter->Load(dep, /*skipReload*/ true) >= 0;; 3363 };; 3364 ForeachSharedLibDep(lib, LoadLibF);; 3365 }; 3366 return !gSystem->Load(lib);; 3367 };; 3368 ; 3369 if (!recompile) {; 3370 // The library already exist, let's just load it.; 3371 if (loadLib) {; 3372 TNamed *k = new TNamed(library,library);; 3373 Long_t lib_time;; 3374 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3375 k->SetUniqueID(lib_time);; 3376 if (!keep) k->SetBit(kMustCleanup);; 3377 fCompiled->Add(k);; 3378 ; 3379 gInterpreter->GetSharedLibDeps(library);; 3380 ; 3381 return LoadLibrary(library);; 3382 }; 3383 else return kTRUE;; 3384 }; 3385 ; 3386 if (!canWrite && recompile) {; 3387 ; 3388 if (mkdirFailed) {; 3389 ::Warning(""ACLiC"",""Could not create the directory: %s"",; 3390 build_loc.Data());; 3391 } else {; 3392 ::Warning(""ACLiC"",""%s is not writable!"",; 3393 build_loc.Data());; 3394 }; 3395 if (emergency_loc == build_dir ) {; 3396 ::Error(""ACLiC"",""%s is the last resort location (i.e. temp location)"",build_loc.Data());; 3397 return kFALSE;; 3398 }; 3399 ::Warning(""ACLiC"",""Output will be written to %s"",; 3400 emergency_loc.Data());; 3401 return CompileMacro(expFileName, opt, library_specified, emergency_loc, dirmode);; 3402 }; 3403 ; 3404 if (withInfo) {; 3405 Info(""ACLiC"",""creating shared library %s"",library.Data());; 3406 }; 3407 ; 3408 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3409 ; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:122444,Performance,load,loadLib,122444,"Int_t result = gSystem->Exec(cmd);; 3592 if (result) {; 3593 if (result == 139); 3594 ::Error(""ACLiC"", ""Executing '%s' failed with a core dump!"", cmd.Data());; 3595 else; 3596 ::Error(""ACLiC"", ""Executing '%s' failed!"", cmd.Data());; 3597 }; 3598 return !result;; 3599 };; 3600 ; 3601 Bool_t result = ExecAndReport(rcling);; 3602 TString depLibraries;; 3603 ; 3604 // ======= Load the library the script might depend on; 3605 if (result) {; 3606 TString linkedlibs = GetLibraries("""", ""S"");; 3607 TString libtoload;; 3608 TString all_libtoload;; 3609 std::ifstream liblist(mapfileout);; 3610 ; 3611 while ( liblist >> libtoload ) {; 3612 // Load the needed library except for the library we are currently building!; 3613 if (libtoload == ""#"") {; 3614 // The comment terminates the list of libraries.; 3615 std::string toskipcomment;; 3616 std::getline(liblist,toskipcomment);; 3617 break;; 3618 }; 3619 if (libtoload != library && libtoload != libname && libtoload != libname_ext) {; 3620 if (produceRootmap) {; 3621 if (loadLib || linkDepLibraries /* For GetLibraries to Work */) {; 3622 result = gROOT->LoadClass("""", libtoload) >= 0;; 3623 if (!result) {; 3624 // We failed to load one of the dependency.; 3625 break;; 3626 }; 3627 }; 3628 if (!linkedlibs.Contains(libtoload)) {; 3629 all_libtoload.Append("" "").Append(libtoload);; 3630 depLibraries.Append("" "");; 3631 depLibraries.Append(GetLibraries(libtoload,""DSL"",kFALSE));; 3632 depLibraries = depLibraries.Strip(); // Remove any trailing spaces.; 3633 }; 3634 } else {; 3635 gROOT->LoadClass("""", libtoload);; 3636 }; 3637 }; 3638 unsigned char c = liblist.peek();; 3639 if (c=='\n' || c=='\r') {; 3640 // Consume the character; 3641 liblist.get();; 3642 break;; 3643 }; 3644 }; 3645 ; 3646// depLibraries = all_libtoload;; 3647// depLibraries.ReplaceAll("" lib"","" -l"");; 3648// depLibraries.ReplaceAll(TString::Format("".%s"",fSoExt.Data()),"""");; 3649 }; 3650 ; 3651 // ======= Calculate the libraries for linking:; 3652 TString linkLibraries;; 3653",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:122602,Performance,load,load,122602,"Int_t result = gSystem->Exec(cmd);; 3592 if (result) {; 3593 if (result == 139); 3594 ::Error(""ACLiC"", ""Executing '%s' failed with a core dump!"", cmd.Data());; 3595 else; 3596 ::Error(""ACLiC"", ""Executing '%s' failed!"", cmd.Data());; 3597 }; 3598 return !result;; 3599 };; 3600 ; 3601 Bool_t result = ExecAndReport(rcling);; 3602 TString depLibraries;; 3603 ; 3604 // ======= Load the library the script might depend on; 3605 if (result) {; 3606 TString linkedlibs = GetLibraries("""", ""S"");; 3607 TString libtoload;; 3608 TString all_libtoload;; 3609 std::ifstream liblist(mapfileout);; 3610 ; 3611 while ( liblist >> libtoload ) {; 3612 // Load the needed library except for the library we are currently building!; 3613 if (libtoload == ""#"") {; 3614 // The comment terminates the list of libraries.; 3615 std::string toskipcomment;; 3616 std::getline(liblist,toskipcomment);; 3617 break;; 3618 }; 3619 if (libtoload != library && libtoload != libname && libtoload != libname_ext) {; 3620 if (produceRootmap) {; 3621 if (loadLib || linkDepLibraries /* For GetLibraries to Work */) {; 3622 result = gROOT->LoadClass("""", libtoload) >= 0;; 3623 if (!result) {; 3624 // We failed to load one of the dependency.; 3625 break;; 3626 }; 3627 }; 3628 if (!linkedlibs.Contains(libtoload)) {; 3629 all_libtoload.Append("" "").Append(libtoload);; 3630 depLibraries.Append("" "");; 3631 depLibraries.Append(GetLibraries(libtoload,""DSL"",kFALSE));; 3632 depLibraries = depLibraries.Strip(); // Remove any trailing spaces.; 3633 }; 3634 } else {; 3635 gROOT->LoadClass("""", libtoload);; 3636 }; 3637 }; 3638 unsigned char c = liblist.peek();; 3639 if (c=='\n' || c=='\r') {; 3640 // Consume the character; 3641 liblist.get();; 3642 break;; 3643 }; 3644 }; 3645 ; 3646// depLibraries = all_libtoload;; 3647// depLibraries.ReplaceAll("" lib"","" -l"");; 3648// depLibraries.ReplaceAll(TString::Format("".%s"",fSoExt.Data()),"""");; 3649 }; 3650 ; 3651 // ======= Calculate the libraries for linking:; 3652 TString linkLibraries;; 3653",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130060,Performance,load,loading,130060," {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcli",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130100,Performance,load,loadLib,130100," {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcli",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:133310,Performance,optimiz,optimization,133310,"ler version identifier string; 3898 ; 3899const char *TSystem::GetBuildCompilerVersionStr() const; 3900{; 3901 return fBuildCompilerVersionStr;; 3902}; 3903 ; 3904////////////////////////////////////////////////////////////////////////////////; 3905/// Return the build node name.; 3906 ; 3907const char *TSystem::GetBuildNode() const; 3908{; 3909 return fBuildNode;; 3910}; 3911 ; 3912////////////////////////////////////////////////////////////////////////////////; 3913/// Return the path of the build directory.; 3914 ; 3915const char *TSystem::GetBuildDir() const; 3916{; 3917 if (fBuildDir.Length()==0) {; 3918 if (!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 39",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:133605,Performance,optimiz,optimized,133605,"rn the build node name.; 3906 ; 3907const char *TSystem::GetBuildNode() const; 3908{; 3909 return fBuildNode;; 3910}; 3911 ; 3912////////////////////////////////////////////////////////////////////////////////; 3913/// Return the path of the build directory.; 3914 ; 3915const char *TSystem::GetBuildDir() const; 3916{; 3917 if (fBuildDir.Length()==0) {; 3918 if (!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:133779,Performance,optimiz,optimized,133779,"!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3966{; 3967 return fMakeExe;; 3968}; 3969 ; 3970////////////////////////////////////////////////////////////////////////////////; 3971/// Get the list of include path.; 3972 ; 3973const char *TSystem::GetIncludePath(); 3974{; 3975 fListPaths = fIncludePath;; 3976#ifndef _MSC_VER; 3977 // FIXME: This is a temporary fix for the following error with ACLiC; 3978 // (",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:138309,Performance,optimiz,optimized,138309,"; 4036/// If 'isflat' is true, then no subdirectory is created and the library; 4037/// is created directly in the directory 'build_dir'. Note that in this; 4038/// mode there is a risk than 2 script of the same in different source; 4039/// directory will over-write each other.; 4040/// \note This `build_dir` can also be controlled via `ACLiC.BuildDir` in; 4041/// your `.rootrc`.; 4042 ; 4043void TSystem::SetBuildDir(const char *build_dir, Bool_t isflat); 4044{; 4045 fBuildDir = build_dir;; 4046 if (isflat); 4047 fAclicProperties |= kFlatBuildDir;; 4048 else; 4049 fAclicProperties &= ~kFlatBuildDir;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085//",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:138605,Performance,optimiz,optimized,138605,"r` can also be controlled via `ACLiC.BuildDir` in; 4041/// your `.rootrc`.; 4042 ; 4043void TSystem::SetBuildDir(const char *build_dir, Bool_t isflat); 4044{; 4045 fBuildDir = build_dir;; 4046 if (isflat); 4047 fAclicProperties |= kFlatBuildDir;; 4048 else; 4049 fAclicProperties &= ~kFlatBuildDir;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:138779,Performance,optimiz,optimized,138779,"/////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:139198,Performance,load,loading,139198,"///////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const char *flags); 4066{; 4067 fFlagsOpt = flags;; 4068}; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// AclicMode indicates whether the library should be built in; 4072/// debug mode or optimized. The values are:; 4073/// - TSystem::kDefault : compile the same as the current ROOT; 4074/// - TSystem::kDebug : compiled in debug mode; 4075/// - TSystem::kOpt : optimized the library; 4076 ; 4077void TSystem::SetAclicMode(EAclicMode mode); 4078{; 4079 fAclicMode = mode;; 4080}; 4081 ; 4082////////////////////////////////////////////////////////////////////////////////; 4083/// Directives has the same syntax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:140854,Performance,optimiz,optimization,140854," description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --display_error_number; 4126/// --diag_suppress 68 -o $SharedLib"");; 4127///; 4128/// gSystem->setMakeSharedLib(; 4129/// ""Cxx $IncludePath -c $SourceFile;; 4130/// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; 4131/// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; 4132/// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134/// gSystem->SetMakeSharedLib(; 4135/// ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; 4136/// -shared -o $SharedLib"");; 4137///; 4138/// gSystem->SetMakeSharedLib(; 4139/// ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; 4140/// -D_WINDOWS $IncludePath $SourceFile; 4141/// /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; 4142/// $Link",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:144637,Performance,load,loaded,144637,"ctives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; 4182/// ~~~ {.cpp}; 4183/// gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; 4184/// ~~~; 4185/// the default value of IncludePath on Unix is:; 4186/// ~~~ {.cpp}; 4187/// ""-I$ROOTSYS/include ""; 4188/// ~~~; 4189/// and on Windows:; 4190/// ~~~ {.cpp}; 4191/// ""/I%ROOTSYS%/include ""; 4192/// ~~~; 4193 ; 4194void TSystem::SetIncludePath(const char *includePath); 4195{; 4196 fIncludePath = includePath;; 4197}; 4198 ; 4199////////////////////////////////////////////////////////////////////////////////; 4200/// LinkedLibs should contain the library directory and list of libraries; 4201/// needed to recreate the current executable. It is used to expand $LinkedLibs; 4202/// in the directives given to SetMakeSharedLib() and SetMakeExe(); 4203/// The default value on Unix is: `root-config --glibs`; 4204 ; 4205void TSystem::SetLinkedLibs(const char *linkedLibs); 4206{; 4207 fLinkedLibs = linkedLibs;; 4208}; 4209 ; 4210////////////////////////////////////////////////////////////////////////////////; 4211/// The 'suffix' will be appended to the name of a script loaded by ACLiC; 4212/// and used to locate any eventual additional linkdef information that; 4213/// ACLiC should used to produce the dictionary.; 4214///; 4215/// So by default, when doing .L MyScript.cxx, ACLiC will look; 4216/// for a file name MyScript_linkdef and having one of the .h (.hpp,; 4217/// etc.) extensions. If such a file exist, it will be added to; 4218/// the end of the linkdef file used to created the ACLiC dictionary.; 4219/// This effectively enable the full customization of the creation; 4220/// of the dictionary. It should be noted that the file is intended; 4221/// as a linkdef `fragment`, so usually you would not list the; 4222/// typical:; 4223/// ~~~ {.cpp}; 4224/// #pragma link off ....; 4225/// ~~~; 4226 ; 4227void TSystem::SetLinkdefSuffix(const char *suffix); 4228{; 4229 fLinkdefSuffix = suffix;; 4230}; 4231 ; 4232",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:172343,Performance,optimiz,optimized,172343,"module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::GetLinkedLibsvirtual const char * GetLinkedLibs() constReturn the list of library linked to this executable.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.De",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:172994,Performance,load,loaded,172994,":Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Ret",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:179722,Performance,optimiz,optimized,179722,"ike ~.Definition TSystem.cxx:1098; TSystem::TSystemTSystem(const TSystem &)=delete; TSystem::fAclicModeEAclicMode fAclicModeDefinition TSystem.h:315; TSystem::GetPeerNamevirtual TInetAddress GetPeerName(int sock)Get Internet Protocol (IP) address of remote host and port #.Definition TSystem.cxx:2300; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::GetSysInfovirtual int GetSysInfo(SysInfo_t *info) constReturns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t s...Definition TSystem.cxx:2458; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::GetMemInfovirtual int GetMemInfo(MemInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbol",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:179858,Performance,load,loaded,179858,"mevirtual TInetAddress GetPeerName(int sock)Get Internet Protocol (IP) address of remote host and port #.Definition TSystem.cxx:2300; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::GetSysInfovirtual int GetSysInfo(SysInfo_t *info) constReturns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t s...Definition TSystem.cxx:2458; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::GetMemInfovirtual int GetMemInfo(MemInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExt",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:181079,Performance,load,load,181079,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatena",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:181096,Performance,load,load,181096,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatena",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:181307,Performance,load,loaded,181307,"ition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified acc",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:189436,Performance,load,loads,189436,"finition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix chosen by the user for ACLiC.Definition TSystem.cxx:4001; TSystem::SetDynamicPathvirtual void SetDynamicPath(const char *pathname)Set the dynamic path to a new value.Definition TSystem.cxx:1806; TSystem::fMakeSharedLibTString fMakeSharedLibDefinition TSystem.h:316; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::fMaxwfdInt_t fMaxwfdDefinition TSystem.h:282; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::AddStdExceptionHandlervirtual void AddStdExceptionHandler(TStdExceptionHandler *eh)Add an exception handler to list of system exception handlers.Definition TSystem.cxx:611; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:191095,Performance,load,loaded,191095,"virtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn t",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:194959,Performance,optimiz,optimization,194959,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::IsInterruptingSyscallsBool_t IsInterruptingSyscalls() constDefinition TTimer.h:82; TTimer::",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:11245,Safety,abort,abort,11245,"eq /*=-1*/, Int_t duration /*=-1*/,; 325 Bool_t setDefault /*=kFALSE*/); 326{; 327 if (setDefault) {; 328 fBeepFreq = freq;; 329 fBeepDuration = duration;; 330 return;; 331 }; 332 if (fBeepDuration < 0 || fBeepFreq < 0) return; // silence; 333 if (freq < 0) freq = fBeepFreq;; 334 if (duration < 0) duration = fBeepDuration;; 335 DoBeep(freq, duration);; 336}; 337 ; 338//---- EventLoop ---------------------------------------------------------------; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// System event loop.; 342 ; 343void TSystem::Run(); 344{; 345 fInControl = kTRUE;; 346 fDone = kFALSE;; 347 ; 348loop_entry:; 349 try {; 350 RETRY {; 351 while (!fDone) {; 352 gApplication->StartIdleing();; 353 InnerLoop();; 354 gApplication->StopIdleing();; 355 }; 356 } ENDTRY;; 357 }; 358 catch (std::exception& exc) {; 359 TIter next(fStdExceptionHandler);; 360 TStdExceptionHandler* eh = nullptr;; 361 while ((eh = (TStdExceptionHandler*) next())) {; 362 switch (eh->Handle(exc)); 363 {; 364 case TStdExceptionHandler::kSEProceed:; 365 break;; 366 case TStdExceptionHandler::kSEHandled:; 367 goto loop_entry;; 368 break;; 369 case TStdExceptionHandler::kSEAbort:; 370 Warning(""Run"", ""instructed to abort"");; 371 goto loop_end;; 372 break;; 373 }; 374 }; 375 throw;; 376 }; 377 catch (const char *str) {; 378 printf(""%s\n"", str);; 379 }; 380 // handle every exception; 381 catch (...) {; 382 Warning(""Run"", ""handle uncaught exception, terminating"");; 383 }; 384 ; 385loop_end:; 386 fInControl = kFALSE;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Exit from event loop.; 391 ; 392void TSystem::ExitLoop(); 393{; 394 fDone = kTRUE;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Inner event loop.; 399 ; 400void TSystem::InnerLoop(); 401{; 402 fLevel++;; 403 DispatchOneEvent();; 404 fLevel--;; 405}; 406 ; 407//////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15059,Safety,timeout,timeout,15059,"urn TTime(0);; 466}; 467 ; 468////////////////////////////////////////////////////////////////////////////////; 469/// Add timer to list of system timers.; 470 ; 471void TSystem::AddTimer(TTimer *ti); 472{; 473 if (ti && fTimers && (fTimers->FindObject(ti) == nullptr)); 474 fTimers->Add(ti);; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Remove timer from list of system timers. Returns removed timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 5",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15231,Safety,timeout,timeout,15231,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15253,Safety,timeout,timeout,15253,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15309,Safety,timeout,timeout,15309,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15325,Safety,timeout,timeout,15325,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15419,Safety,timeout,timeout,15419,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:15589,Safety,timeout,timeout,15589,"emoved timer or 0; 479/// if timer was not active.; 480 ; 481TTimer *TSystem::RemoveTimer(TTimer *ti); 482{; 483 if (fTimers) {; 484 TTimer *tr = (TTimer*) fTimers->Remove(ti);; 485 return tr;; 486 }; 487 return nullptr;; 488}; 489 ; 490////////////////////////////////////////////////////////////////////////////////; 491/// Time when next timer of mode (synchronous=kTRUE or; 492/// asynchronous=kFALSE) will time-out (in ms).; 493 ; 494Long_t TSystem::NextTimeOut(Bool_t mode); 495{; 496 if (!fTimers) return -1;; 497 ; 498 TListIter it(fTimers);; 499 TTimer *t, *to = nullptr;; 500 Long64_t tt, tnow = Now();; 501 Long_t timeout = -1;; 502 ; 503 while ((t = (TTimer *) it.Next())) {; 504 if (t->IsSync() == mode) {; 505 tt = (Long64_t)t->GetAbsTime() - tnow;; 506 if (tt < 0) tt = 0;; 507 if (timeout == -1) {; 508 timeout = (Long_t)tt;; 509 to = t;; 510 }; 511 if (tt < timeout) {; 512 timeout = (Long_t)tt;; 513 to = t;; 514 }; 515 }; 516 }; 517 ; 518 if (to && to->IsAsync() && timeout > 0) {; 519 if (to->IsInterruptingSyscalls()); 520 SigAlarmInterruptsSyscalls(kTRUE);; 521 else; 522 SigAlarmInterruptsSyscalls(kFALSE);; 523 }; 524 ; 525 return timeout;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Add a signal handler to list of system signal handlers. Only adds; 530/// the handler if it is not already in the list of signal handlers.; 531 ; 532void TSystem::AddSignalHandler(TSignalHandler *h); 533{; 534 if (h && fSignalHandler && (fSignalHandler->FindObject(h) == nullptr)); 535 fSignalHandler->Add(h);; 536}; 537 ; 538////////////////////////////////////////////////////////////////////////////////; 539/// Remove a signal handler from list of signal handlers. Returns; 540/// the handler or 0 if the handler was not in the list of signal handlers.; 541 ; 542TSignalHandler *TSystem::RemoveSignalHandler(TSignalHandler *h); 543{; 544 if (fSignalHandler); 545 return (TSignalHandler *)fSignalHandler->Remove(h);; 546 ; 547 r",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:27363,Safety,safe,safeName,27363,"ystem::GetWorkingDirectory() const; 880{; 881 return std::string();; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Return the user's home directory.; 886 ; 887const char *TSystem::HomeDirectory(const char *); 888{; 889 return nullptr;; 890}; 891 ; 892//////////////////////////////////////////////////////////////////////////////; 893/// Return the user's home directory.; 894 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (cha",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:27509,Safety,safe,safeName,27509,"ystem::GetWorkingDirectory() const; 880{; 881 return std::string();; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Return the user's home directory.; 886 ; 887const char *TSystem::HomeDirectory(const char *); 888{; 889 return nullptr;; 890}; 891 ; 892//////////////////////////////////////////////////////////////////////////////; 893/// Return the user's home directory.; 894 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (cha",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:27643,Safety,avoid,avoid,27643,"ory(const char *); 888{; 889 return nullptr;; 890}; 891 ; 892//////////////////////////////////////////////////////////////////////////////; 893/// Return the user's home directory.; 894 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (char *)strrchr(name, '/'))); 941 return ++cp;; 942 return name;; 943 }; 944 Error(""BaseName"", ""name = 0"");; 945 return nullptr;; 946}; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Return true if dir",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:27853,Safety,safe,safeName,27853,"4 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (char *)strrchr(name, '/'))); 941 return ++cp;; 942 return name;; 943 }; 944 Error(""BaseName"", ""name = 0"");; 945 return nullptr;; 946}; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Return true if dir is an absolute pathname.; 950 ; 951Bool_t TSystem::IsAbsoluteFileName(const char *dir); 952{; 953 if (dir); 954 return dir[0] == '/';; 955 return kFALSE;; 956}; 957 ; 958///////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:40527,Safety,avoid,avoid,40527," For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 1305Bool_t TSystem::IsPathLocal(const char *path); 1306{; 1307 Bool_t localPath = kTRUE;; 1308 ; 1309 TUrl url(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(gSystem->HostName()));; 1315 if (!strcmp(a.GetHostName(), b.GetHostName()) ||; 1316 !strcmp(a.GetHostAddress(), b.GetHostAddress())) {; 1317 // Host OK; 1318 localPath = kTRUE;; 1319 // Check the user if specified; 1320 if (strlen(url.GetUser()) > 0) {; 1321 UserGroup_t *u = gSystem->GetUserInfo();; 1322 if (u) {; 1323 if (strcmp(u->fUser, url.GetUser())); 1324 // Requested a different user; 1325 localPath = kFALSE;; 1326 delete u;; 1327 }; 1328 }; 1329 }; 1330 }; 1331 // Done; 1332 return localPath;; 1333}; 1334 ; 1335////////////////////////////////////////////////////////////////////////////////; 1336/// Copy a file. If overwrit",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47122,Safety,safe,safely,47122,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47164,Safety,avoid,avoids,47164,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:100217,Safety,redund,redundant,100217,"& strlen(library_specified) ) {; 2972 // Use the specified name instead of the default; 2973 libname = BaseName( library_specified );; 2974 library = library_specified;; 2975 ExpandPathName( library );; 2976 if (! IsAbsoluteFileName(library) ) {; 2977 AssignAndDelete( library , ConcatFileName( WorkingDirectory(), library ) );; 2978 }; 2979 library = TString(library) + ""."" + fSoExt;; 2980 }; 2981 library = gSystem->UnixPathName(library);; 2982 ; 2983 TString libname_ext ( libname );; 2984 libname_ext += ""."" + fSoExt;; 2985 ; 2986 TString lib_dirname = GetDirName( library );; 2987 // For some probably good reason, DirName on Windows returns the 'name' of; 2988 // the directory, omitting the drive letter (even if there was one). In; 2989 // consequence the result is not useable as a 'root directory', we need to; 2990 // add the drive letter if there was one..; 2991 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2992 lib_dirname.Prepend(library(0,2));; 2993 }; 2994 // Strip potential, somewhat redundant '/.' from the pathname ...; 2995 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""/."", 2) == 0 ) {; 2996 lib_dirname.Remove(lib_dirname.Length()-2);; 2997 }; 2998 if ( strncmp( &(lib_dirname[lib_dirname.Length()-2]), ""\\."", 2) == 0 ) {; 2999 lib_dirname.Remove(lib_dirname.Length()-2);; 3000 }; 3001 TString lib_location( lib_dirname );; 3002 Bool_t mkdirFailed = kFALSE;; 3003 ; 3004 if (build_loc.Length()==0) {; 3005 build_loc = lib_location;; 3006 } else {; 3007 // Removes an existing disk specification from the names; 3008 TRegexp disk_finder (""[A-z]:"");; 3009 Int_t pos = library.Index( disk_finder );; 3010 if (pos==0) library.Remove(pos,3);; 3011 pos = lib_location.Index( disk_finder );; 3012 if (pos==0) lib_location.Remove(pos,3);; 3013 ; 3014 if (flatBuildDir) {; 3015 AssignAndDelete( library, ConcatFileName( build_loc, libname_ext) );; 3016 } else {; 3017 AssignAndDelete( library, ConcatFileName( build_loc, library) );; 3018 }; 3019 ; 3020",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:128842,Safety,redund,redundant,128842,"estcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (L",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:129174,Safety,abort,abort,129174,"w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated libraries as we are appending; 3791 // FIXME: This likely makes rootcling --lib-list-prefix redundant.; 3792 TString depLibsFullPaths;; 3793 std::function<bool(const char *)> CollectF = [&depLibsFullPaths](const char *dep) {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:137342,Safety,risk,risk,137342,"/////////////////; 4019/// Get the object file extension.; 4020 ; 4021const char *TSystem::GetObjExt() const; 4022{; 4023 return fObjExt;; 4024}; 4025 ; 4026////////////////////////////////////////////////////////////////////////////////; 4027/// Set the location where ACLiC will create libraries and use as; 4028/// a scratch area. If unset, libraries will be created at the same; 4029/// location than the script.; 4030///; 4031/// \param build_dir the name of the build directory; 4032/// \param isflat If false (default), then the libraries are actually stored; 4033/// in sub-directories of 'build_dir' including the full pathname; 4034/// of the script. If the script is located at `/full/path/name/macro.C`; 4035/// the library will be located at `build_dir+/full/path/name/macro_C.so`; 4036/// If 'isflat' is true, then no subdirectory is created and the library; 4037/// is created directly in the directory 'build_dir'. Note that in this; 4038/// mode there is a risk than 2 script of the same in different source; 4039/// directory will over-write each other.; 4040/// \note This `build_dir` can also be controlled via `ACLiC.BuildDir` in; 4041/// your `.rootrc`.; 4042 ; 4043void TSystem::SetBuildDir(const char *build_dir, Bool_t isflat); 4044{; 4045 fBuildDir = build_dir;; 4046 if (isflat); 4047 fAclicProperties |= kFlatBuildDir;; 4048 else; 4049 fAclicProperties &= ~kFlatBuildDir;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// FlagsDebug should contain the options to pass to the C++ compiler; 4054/// in order to compile the library in debug mode.; 4055 ; 4056void TSystem::SetFlagsDebug(const char *flags); 4057{; 4058 fFlagsDebug = flags;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// FlagsOpt should contain the options to pass to the C++ compiler; 4063/// in order to compile the library in optimized mode.; 4064 ; 4065void TSystem::SetFlagsOpt(const ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:140048,Safety,avoid,avoided,140048,"tax as the argument of SetMakeSharedLib but is; 4084/// used to create an executable. This creation is used as a means to output; 4085/// a list of unresolved symbols, when loading a shared library has failed.; 4086/// The required variable is $ExeName rather than $SharedLib, e.g.:; 4087/// ~~~ {.cpp}; 4088/// gSystem->SetMakeExe(; 4089/// ""g++ -Wall -fPIC $IncludePath $SourceFiles; 4090/// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; 4091/// ~~~; 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:159471,Safety,safe,safe,159471,"R__EXTERN TSystem * gSystemDefinition TSystem.h:561; kS_IXOTH@ kS_IXOTHDefinition TSystem.h:110; kS_IXUSR@ kS_IXUSRDefinition TSystem.h:102; kS_IXGRP@ kS_IXGRPDefinition TSystem.h:106; TUrl.h; TVersionCheck.h; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17535; extensionconst char * extensionDefinition civetweb.c:8025; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TEnvRecDefinition TEnv.h:86; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TIterDefinition TCollection.h:235; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:187912,Safety,timeout,timeout,187912,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix chosen by the user for ACLiC.Definition TSystem.cxx:4001; TSystem::SetDynamicPathvir",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:22618,Security,access,access,22618,"1 return out;; 702}; 703 ; 704////////////////////////////////////////////////////////////////////////////////; 705/// Get process id.; 706 ; 707int TSystem::GetPid(); 708{; 709 AbstractMethod(""GetPid"");; 710 return -1;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Exit the application.; 715 ; 716void TSystem::Exit(int, Bool_t); 717{; 718 AbstractMethod(""Exit"");; 719 throw; // unreachable; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Abort the application.; 724 ; 725void TSystem::Abort(int); 726{; 727 AbstractMethod(""Abort"");; 728 throw; // unreachable; 729}; 730 ; 731////////////////////////////////////////////////////////////////////////////////; 732/// Print a stack trace.; 733 ; 734void TSystem::StackTrace(); 735{; 736 AbstractMethod(""StackTrace"");; 737}; 738 ; 739 ; 740//---- Directories -------------------------------------------------------------; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Create helper TSystem to handle file and directory operations that; 744/// might be special for remote file access.; 745 ; 746TSystem *TSystem::FindHelper(const char *path, void *dirptr); 747{; 748 TSystem *helper = nullptr;; 749 {; 750 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 751 ; 752 if (!fHelpers) {; 753 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 754 fHelpers = new TOrdCollection;; 755 }; 756 ; 757 if (path) {; 758 if (!GetDirPtr()) {; 759 TUrl url(path, kTRUE);; 760 if (!strcmp(url.GetProtocol(), ""file"")); 761 return nullptr;; 762 }; 763 }; 764 ; 765 // look for existing helpers; 766 TIter next(fHelpers);; 767 while ((helper = (TSystem*) next())); 768 if (helper->ConsistentWith(path, dirptr)); 769 return helper;; 770 ; 771 if (!path); 772 return nullptr;; 773 }; 774 ; 775 // create new helper; 776 TRegexp re(""^root.*:""); // also roots, rootk, etc; 777 TString pname = path;; 778 TPluginHandler *h;; 779 if (",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:39989,Security,access,access,39989,"; 1268////////////////////////////////////////////////////////////////////////////////; 1269/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1270/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1271/// environment variables in a pathname. If compatibility is not an issue; 1272/// you can use on Unix directly $XXX.; 1273 ; 1274Bool_t TSystem::ExpandPathName(TString&); 1275{; 1276 return kFALSE;; 1277}; 1278 ; 1279////////////////////////////////////////////////////////////////////////////////; 1280/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1281/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 1305Bool_t TSystem::IsPathLocal(const char *path); 1306{; 1307 Bool_t localPath = kTRUE;; 1308 ; 1309 TUrl url(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:40023,Security,access,access,40023,"; 1268////////////////////////////////////////////////////////////////////////////////; 1269/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1270/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1271/// environment variables in a pathname. If compatibility is not an issue; 1272/// you can use on Unix directly $XXX.; 1273 ; 1274Bool_t TSystem::ExpandPathName(TString&); 1275{; 1276 return kFALSE;; 1277}; 1278 ; 1279////////////////////////////////////////////////////////////////////////////////; 1280/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1281/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1282/// environment variables in a pathname. If compatibility is not an issue; 1283/// you can use on Unix directly $XXX. The user must delete returned string.; 1284 ; 1285char *TSystem::ExpandPathName(const char *); 1286{; 1287 return nullptr;; 1288}; 1289 ; 1290////////////////////////////////////////////////////////////////////////////////; 1291/// Returns FALSE if one can access a file using the specified access mode.; 1292/// The file name must not contain any special shell characters line ~ or $,; 1293/// in those cases first call ExpandPathName().; 1294/// Attention, bizarre convention of return value!!; 1295 ; 1296Bool_t TSystem::AccessPathName(const char *, EAccessMode); 1297{; 1298 return kFALSE;; 1299}; 1300 ; 1301////////////////////////////////////////////////////////////////////////////////; 1302/// Returns TRUE if the url in 'path' points to the local file system.; 1303/// This is used to avoid going through the NIC card for local operations.; 1304 ; 1305Bool_t TSystem::IsPathLocal(const char *path); 1306{; 1307 Bool_t localPath = kTRUE;; 1308 ; 1309 TUrl url(path);; 1310 if (strlen(url.GetHost()) > 0) {; 1311 // Check locality; 1312 localPath = kFALSE;; 1313 TInetAddress a(gSystem->GetHostByName(url.GetHost()));; 1314 TInetAddress b(gSystem->GetHostByName(",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:46737,Security,secur,secure,46737," 1458/// structure (see TSystem.h).; 1459/// The function returns 0 in case of success and 1 if the file could; 1460/// not be stat'ed.; 1461 ; 1462int TSystem::GetPathInfo(const char *, FileStat_t &); 1463{; 1464 AbstractMethod(""GetPathInfo(const char *, FileStat_t&)"");; 1465 return 1;; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469/// Get info about a file system: fs type, block size, number of blocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:47179,Security,secur,security,47179,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:48056,Security,access,access,48056,"an provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 AbstractMethod(""FindFile"");; 1541 return nullptr;; 1542}; 1543 ; 1544////////////////////////////////////////////////////////////////////////////////; 1545/// Find location of file in a search path. User must delete returned string.; 1546/// Returns 0 in case f",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:55762,Security,access,access,55762,"ure.; 1708///; 1709/// The call can be made reentrant by specifying the opaque structure pointed; 1710/// by 'h', which is filled with the relevant information. The handle 'h'; 1711/// obtained on the first call must then be used in any subsequent call,; 1712/// included ShowOutput, to display the redirected output.; 1713/// Returns 0 on success, -1 in case of error.; 1714 ; 1715Int_t TSystem::RedirectOutput(const char *, const char *, RedirectHandle_t *); 1716{; 1717 AbstractMethod(""RedirectOutput"");; 1718 return -1;; 1719}; 1720 ; 1721////////////////////////////////////////////////////////////////////////////////; 1722/// Display the content associated with the redirection described by the; 1723/// opaque handle 'h'.; 1724 ; 1725void TSystem::ShowOutput(RedirectHandle_t *h); 1726{; 1727 // Check input ...; 1728 if (!h) {; 1729 Error(""ShowOutput"", ""handle not specified"");; 1730 return;; 1731 }; 1732 ; 1733 // ... and file access; 1734 if (gSystem->AccessPathName(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of bytes to be read from the file.; 1747 off_t ltot = lseek(fileno(f), (off_t) 0, SEEK_END);; 1748 Int_t begin = (h->fReadOffSet > 0 && h->fReadOffSet < ltot) ? h->fReadOffSet : 0;; 1749 lseek(fileno(f), (off_t) begin, SEEK_SET);; 1750 Int_t left = ltot - begin;; 1751 ; 1752 // Now readout from file; 1753 const Int_t kMAXBUF = 16384;; 1754 char buf[kMAXBUF];; 1755 Int_t wanted = (left > kMAXBUF-1) ? kMAXBUF-1 : left;; 1756 Int_t len;; 1757 do {; 1758 while ((len = read(fileno(f), buf, wanted)) < 0 &&; 1759 TSystem::GetErrno() == EINTR); 1760 TSystem::ResetErrno();; 1761 ; 1762 if (len < 0) {; 1763 SysError(""ShowOutput"", ""error reading log file"");; 1764 br",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:92692,Security,access,accessible,92692,"; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when c",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:106534,Security,access,accessible,106534,"modified = kTRUE;; 3153 ; 3154 } else {; 3155 ; 3156 if ( gSystem->GetPathInfo( depfilename, nullptr,(Long_t*) nullptr, nullptr, &file_time ) != 0 ) {; 3157 if (!canWrite) {; 3158 depdir = emergency_loc;; 3159 AssignAndDelete( depfilename, ConcatFileName(depdir, BaseName(libname_noext)) );; 3160 depfilename += ""_"" + extension + "".d"";; 3161 }; 3162 R__WriteDependencyFile(build_loc, depfilename, filename_fullpath, library, libname, extension, version_var_prefix, includes, defines, incPath);; 3163 }; 3164 }; 3165 ; 3166 if (!modified) {; 3167 ; 3168 // We need to check the dependencies; 3169 FILE * depfile = fopen(depfilename.Data(),""r"");; 3170 if (depfile==nullptr) {; 3171 // there is no accessible dependency file, let's assume the library has been; 3172 // modified; 3173 modified = kTRUE;; 3174 recompile = kTRUE;; 3175 ; 3176 } else {; 3177 ; 3178 TString version_var = libname + version_var_prefix;; 3179 ; 3180 Int_t sz = 256;; 3181 char *line = new char[sz];; 3182 line[0] = 0;; 3183 ; 3184 int c;; 3185 Int_t current = 0;; 3186 Int_t nested = 0;; 3187 Bool_t hasversion = false;; 3188 ; 3189 while ((c = fgetc(depfile)) != EOF) {; 3190 if (c=='#') {; 3191 // skip comment; 3192 while ((c = fgetc(depfile)) != EOF) {; 3193 if (c=='\n') {; 3194 break;; 3195 }; 3196 }; 3197 continue;; 3198 }; 3199 if (current && line[current-1]=='=' && strncmp(version_var.Data(),line,current)==0) {; 3200 ; 3201 // The next word will be the version number.; 3202 hasversion = kTRUE;; 3203 line[0] = 0;; 3204 current = 0;; 3205 } else if (isspace(c) && !nested) {; 3206 if (current) {; 3207 if (line[current-1]!=':') {; 3208 // ignore target; 3209 line[current] = 0;; 3210 ; 3211 Long_t filetime;; 3212 if (hasversion) {; 3213 modified |= strcmp(ROOT_RELEASE,line)!=0;; 3214 hasversion = kFALSE;; 3215 } else if ( gSystem->GetPathInfo( line, nullptr, (Long_t*)nullptr, nullptr, &filetime ) == 0 ) {; 3216 modified |= ( lib_time <= filetime );; 3217 }; 3218 }; 3219 }; 3220 current = 0;; 3221 line[0] = 0;",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:159446,Security,access,access,159446,"R__EXTERN TSystem * gSystemDefinition TSystem.h:561; kS_IXOTH@ kS_IXOTHDefinition TSystem.h:110; kS_IXUSR@ kS_IXUSRDefinition TSystem.h:102; kS_IXGRP@ kS_IXGRPDefinition TSystem.h:106; TUrl.h; TVersionCheck.h; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17535; extensionconst char * extensionDefinition civetweb.c:8025; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TEnvRecDefinition TEnv.h:86; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TIterDefinition TCollection.h:235; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:169184,Security,secur,secure,169184,"ion object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedL",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:182239,Security,access,access,182239,"uildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Ch",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:182273,Security,access,access,182273,"uildDirDefinition TSystem.h:271; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Ch",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:193654,Security,access,access,193654,"eeded to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals hand",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:35960,Testability,assert,assert,35960,"name, const int kBufSize); 1133{; 1134 int n, ier, iter, lx, ncopy;; 1135 char *inp, *out, *x, *t, *buff;; 1136 const char *b, *c, *e;; 1137 const char *p;; 1138 buff = new char[kBufSize * 4];; 1139 ; 1140 iter = 0; xname[0] = 0; inp = buff + kBufSize; out = inp + kBufSize;; 1141 inp[-1] = ' '; inp[0] = 0; out[-1] = ' ';; 1142 c = fname + strspn(fname, "" \t\f\r"");; 1143 //VP if (isalnum(c[0])) { strcpy(inp, WorkingDirectory()); strcat(inp, ""/""); } // add $cwd; 1144 ; 1145 strlcat(inp, c, kBufSize);; 1146 ; 1147again:; 1148 iter++; c = inp; ier = 0;; 1149 x = out; x[0] = 0;; 1150 ; 1151 p = nullptr; e = nullptr;; 1152 if (c[0] == '~' && c[1] == '/') { // ~/ case; 1153 std::string hd = GetHomeDirectory();; 1154 p = hd.c_str();; 1155 e = c + 1;; 1156 if (p) { // we have smth to copy; 1157 strlcpy(x, p, kBufSize);; 1158 x += strlen(p);; 1159 c = e;; 1160 } else {; 1161 ++ier;; 1162 ++c;; 1163 }; 1164 } else if (c[0] == '~' && c[1] != '/') { // ~user case; 1165 n = strcspn(c+1, ""/ "");; 1166 assert((n+1) < kBufSize && ""This should have been prevented by the truncation 'strlcat(inp, c, kBufSize)'"");; 1167 // There is no overlap here as the buffer is segment in 4 strings of at most kBufSize; 1168 (void)strlcpy(buff, c+1, n+1); // strlcpy copy 'size-1' characters.; 1169 std::string hd = GetHomeDirectory(buff);; 1170 e = c+1+n;; 1171 if (!hd.empty()) { // we have smth to copy; 1172 p = hd.c_str();; 1173 strlcpy(x, p, kBufSize);; 1174 x += strlen(p);; 1175 c = e;; 1176 } else {; 1177 x++[0] = c[0];; 1178 //++ier;; 1179 ++c;; 1180 }; 1181 }; 1182 ; 1183 for ( ; c[0]; c++) {; 1184 ; 1185 p = nullptr; e = nullptr;; 1186 ; 1187 if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd; 1188 std::string wd = GetWorkingDirectory();; 1189 strlcpy(buff, wd.c_str(), kBufSize);; 1190 p = buff;; 1191 e = c + 1;; 1192 }; 1193 if (p) { // we have smth to copy */; 1194 strlcpy(x, p, kBufSize); x += strlen(p); c = e-1; continue;; 1195 }; 1196 ; 1197 if (c[0] != '$') { // not $, simple copy; 1",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:53470,Testability,log,log,53470,".; 1637 ; 1638UserGroup_t *TSystem::GetGroupInfo(const char * /*group*/); 1639{; 1640 AbstractMethod(""GetGroupInfo"");; 1641 return nullptr;; 1642}; 1643 ; 1644//---- environment manipulation ------------------------------------------------; 1645 ; 1646////////////////////////////////////////////////////////////////////////////////; 1647/// Set environment variable.; 1648 ; 1649void TSystem::Setenv(const char *, const char *); 1650{; 1651 AbstractMethod(""Setenv"");; 1652}; 1653 ; 1654////////////////////////////////////////////////////////////////////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Close connection to system log daemon.; 1693 ; 1694void TSystem::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection -----------------------------",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:53821,Testability,log,logging,53821,"//////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Close connection to system log daemon.; 1693 ; 1694void TSystem::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection ---------------------------------------------; 1700 ; 1701////////////////////////////////////////////////////////////////////////////////; 1702/// Redirect standard output (stdout, stderr) to the specified file.; 1703/// If the file argument is 0 the output is set again to stderr, stdout.; 1704/// The second argument specifies whether the output should be added to the; 1705/// file (""a"", default) or the file be truncated before (""w"").; 1706/// The implementations of this function save internally the current state into; 1707/// a static structure.; 1708///; 1709/// The c",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:53893,Testability,log,log,53893,"//////////////////; 1655/// Unset environment variable.; 1656 ; 1657void TSystem::Unsetenv(const char *name); 1658{; 1659 Setenv(name, """");; 1660}; 1661 ; 1662////////////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Close connection to system log daemon.; 1693 ; 1694void TSystem::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection ---------------------------------------------; 1700 ; 1701////////////////////////////////////////////////////////////////////////////////; 1702/// Redirect standard output (stdout, stderr) to the specified file.; 1703/// If the file argument is 0 the output is set again to stderr, stdout.; 1704/// The second argument specifies whether the output should be added to the; 1705/// file (""a"", default) or the file be truncated before (""w"").; 1706/// The implementations of this function save internally the current state into; 1707/// a static structure.; 1708///; 1709/// The c",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:54131,Testability,log,log,54131,"////////////////////////////////////////////////////////////////////////; 1663/// Get environment variable.; 1664 ; 1665const char *TSystem::Getenv(const char *); 1666{; 1667 AbstractMethod(""Getenv"");; 1668 return nullptr;; 1669}; 1670 ; 1671//---- System Logging ----------------------------------------------------------; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Open connection to system log daemon. For the use of the options and; 1675/// facility see the Unix openlog man page.; 1676 ; 1677void TSystem::Openlog(const char *, Int_t, ELogFacility); 1678{; 1679 AbstractMethod(""Openlog"");; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Send mess to syslog daemon. Level is the logging level and mess the; 1684/// message that will be written on the log.; 1685 ; 1686void TSystem::Syslog(ELogLevel, const char *); 1687{; 1688 AbstractMethod(""Syslog"");; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Close connection to system log daemon.; 1693 ; 1694void TSystem::Closelog(); 1695{; 1696 AbstractMethod(""Closelog"");; 1697}; 1698 ; 1699//---- Standard output redirection ---------------------------------------------; 1700 ; 1701////////////////////////////////////////////////////////////////////////////////; 1702/// Redirect standard output (stdout, stderr) to the specified file.; 1703/// If the file argument is 0 the output is set again to stderr, stdout.; 1704/// The second argument specifies whether the output should be added to the; 1705/// file (""a"", default) or the file be truncated before (""w"").; 1706/// The implementations of this function save internally the current state into; 1707/// a static structure.; 1708///; 1709/// The call can be made reentrant by specifying the opaque structure pointed; 1710/// by 'h', which is filled with the relevant information. The handle 'h'; 1711/// obtained on",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:56804,Testability,log,log,56804,"me(h->fFile, kReadPermission)) {; 1735 Error(""ShowOutput"", ""file '%s' cannot be read"", h->fFile.Data());; 1736 return;; 1737 }; 1738 ; 1739 // Open the file; 1740 FILE *f = nullptr;; 1741 if (!(f = fopen(h->fFile.Data(), ""r""))) {; 1742 Error(""ShowOutput"", ""file '%s' cannot be open"", h->fFile.Data());; 1743 return;; 1744 }; 1745 ; 1746 // Determine the number of bytes to be read from the file.; 1747 off_t ltot = lseek(fileno(f), (off_t) 0, SEEK_END);; 1748 Int_t begin = (h->fReadOffSet > 0 && h->fReadOffSet < ltot) ? h->fReadOffSet : 0;; 1749 lseek(fileno(f), (off_t) begin, SEEK_SET);; 1750 Int_t left = ltot - begin;; 1751 ; 1752 // Now readout from file; 1753 const Int_t kMAXBUF = 16384;; 1754 char buf[kMAXBUF];; 1755 Int_t wanted = (left > kMAXBUF-1) ? kMAXBUF-1 : left;; 1756 Int_t len;; 1757 do {; 1758 while ((len = read(fileno(f), buf, wanted)) < 0 &&; 1759 TSystem::GetErrno() == EINTR); 1760 TSystem::ResetErrno();; 1761 ; 1762 if (len < 0) {; 1763 SysError(""ShowOutput"", ""error reading log file"");; 1764 break;; 1765 }; 1766 ; 1767 // Null-terminate; 1768 buf[len] = 0;; 1769 fprintf(stderr,""%s"", buf);; 1770 ; 1771 // Update counters; 1772 left -= len;; 1773 wanted = (left > kMAXBUF) ? kMAXBUF : left;; 1774 ; 1775 } while (len > 0 && left > 0);; 1776 ; 1777 // Do not display twice the same thing; 1778 h->fReadOffSet = ltot;; 1779 fclose(f);; 1780}; 1781 ; 1782//---- Dynamic Loading ---------------------------------------------------------; 1783 ; 1784////////////////////////////////////////////////////////////////////////////////; 1785/// Add a new directory to the dynamic path.; 1786 ; 1787void TSystem::AddDynamicPath(const char *); 1788{; 1789 AbstractMethod(""AddDynamicPath"");; 1790}; 1791 ; 1792////////////////////////////////////////////////////////////////////////////////; 1793/// Return the dynamic path (used to find shared libraries).; 1794 ; 1795const char *TSystem::GetDynamicPath(); 1796{; 1797 AbstractMethod(""GetDynamicPath"");; 1798 return nullptr;; 1799};",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:59199,Testability,test,test,59199,"//////////////////////////////////////////////////////////////////////////////; 1813/// Figure out if left and right points to the same; 1814/// object in the file system.; 1815 ; 1816static bool R__MatchFilename(const char *left, const char *right); 1817{; 1818 if (left == right) return kTRUE;; 1819 ; 1820 if (left==nullptr || right==nullptr) return kFALSE;; 1821 ; 1822 if ( (strcmp(right,left)==0) ) {; 1823 return kTRUE;; 1824 }; 1825 ; 1826#ifdef G__WIN32; 1827 ; 1828 char leftname[_MAX_PATH];; 1829 char rightname[_MAX_PATH];; 1830 _fullpath( leftname, left, _MAX_PATH );; 1831 _fullpath( rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TStri",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:60807,Testability,test,test,60807,"es not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[idx])) {; 1877 ++idx;; 1878 // No need to test for len here, at worse idx==len and lib[idx]=='\0'; 1879 if (libs[idx] == '.') {; 1880 ++idx;; 1881 }; 1882 }; 1883 while (idx < len && libs[idx] != '.') {; 1884 if (libs[idx] == ' ' || idx+1 == len) {; 1885 return 1;; 1886 }; 1887 ++idx;; 1888 }; 1889 }; 1890 }; 1891 if (l[l.Length()-1] == '.') {; 1892 l.Remove(l.Length()-1);; 1893 }; 1894 if (l.BeginsWith(""lib"")) {; 1895 l.Replace(0, 3, ""-l"");; 1896 for(idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1897 if ((idx == 0 || libs[idx-1] == ' ') &&; 1898 (libs[idx+l.Length()] == ' ' || libs[idx+l.Length()] == 0)) {; 1899 return 1;; 1900 }; 1901 }; 1902 }; 1903 ; 1904 char *path = DynamicPathName(module);; 1905 ; 1906 int ret = -1;; 1907 if (path) {; 1908 // load any dependent libraries; 1909 TString deplibs = gInterpreter->GetSharedLibDeps(path);; 1910 if (!deplibs.IsNull()) {; 1911 TString delim("" "");; 1912 TObjArray *tokens = deplibs.Tokenize(delim);; 1913 for (Int_t i = tokens->GetEntriesFast()-1; i > 0; i--) {; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:126140,Testability,test,testcmd,126140,".ReplaceAll(""$SharedLib"",""\""$SharedLib\"""");; 3702 cmd.ReplaceAll(""$SharedLib"",library);; 3703 if (linkDepLibraries) {; 3704 if (produceRootmap) {; 3705 cmd.ReplaceAll(""$DepLibs"",depLibraries);; 3706 } else {; 3707 cmd.ReplaceAll(""$DepLibs"",linkLibraries);; 3708 }; 3709 }; 3710 cmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3711 cmd.ReplaceAll(""$LibName"",libname);; 3712 cmd.ReplaceAll(""\""$BuildDir"",""$BuildDir"");; 3713 cmd.ReplaceAll(""$BuildDir"",""\""$BuildDir\"""");; 3714 cmd.ReplaceAll(""$BuildDir"",build_loc);; 3715 TString optdebFlags;; 3716 if (mode & kDebug); 3717 optdebFlags = fFlagsDebug + "" "";; 3718 if (mode & kOpt); 3719 optdebFlags += fFlagsOpt;; 3720 cmd.ReplaceAll(""$Opt"", optdebFlags);; 3721#ifdef WIN32; 3722 R__FixLink(cmd);; 3723 cmd.ReplaceAll(""-std="", ""-std:"");; 3724#endif; 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$O",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127186,Testability,test,testcmd,127186," 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dyna",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127259,Testability,test,testcmd,127259,"e( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictiona",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127306,Testability,test,testcmd,127306," 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Inf",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127367,Testability,test,testcmd,127367,"ainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127417,Testability,test,testcmd,127417,"< ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127468,Testability,test,testcmd,127468,"ipt Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {;",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127511,Testability,test,testcmd,127511,"inFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 };",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127566,Testability,test,testcmd,127566,"< std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127639,Testability,test,testcmd,127639,"d this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We ma",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127696,Testability,test,testcmd,127696," this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 378",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127776,Testability,test,testcmd,127776,"f the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated li",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:127792,Testability,test,testcmd,127792,"f the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnresolved = cmd;; 3768#ifdef R__MACOSX; 3769 // Allow linking to succeed despite the missing symbols.; 3770 cmdAllowUnresolved.ReplaceAll(""-dynamiclib"", ""-dynamiclib -Wl,-w -Wl,-undefined,dynamic_lookup"");; 3771#endif; 3772 if (verboseLevel > 3 && withInfo) {; 3773 ::Info(""ACLiC"",""compiling the dictionary and script files"");; 3774 if (verboseLevel>4); 3775 ::Info(""ACLiC"", ""%s"", cmdAllowUnresolved.Data());; 3776 }; 3777 Int_t success = ExecAndReport(cmdAllowUnresolved);; 3778 if (!success) {; 3779 if (produceRootmap) {; 3780 gSystem->Unlink(libmapfilename);; 3781 }; 3782 }; 3783 result = success;; 3784 }; 3785 ; 3786 if ( result ) {; 3787 if (linkDepLibraries) {; 3788 // We may have unresolved symbols. Use dyld to resolve the dependent; 3789 // libraries and relink.; 3790 // FIXME: We will likely have duplicated li",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130271,Testability,test,testing,130271," {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcli",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130351,Testability,test,testcmd,130351," {; 3794 TString LibFullPath(dep);; 3795 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 3796 ::Error(""TSystem::CompileMacro"", ""Cannot find library '%s'"", dep);; 3797 return false; // abort; 3798 }; 3799 depLibsFullPaths += "" "" + LibFullPath;; 3800 return true;; 3801 };; 3802 ForeachSharedLibDep(library, CollectF);; 3803 ; 3804 TString relink_cmd = cmd.Strip(TString::kTrailing, ';');; 3805 relink_cmd += depLibsFullPaths;; 3806 if (verboseLevel > 3 && withInfo) {; 3807 ::Info(""ACLiC"", ""relinking against all dependencies"");; 3808 if (verboseLevel > 4); 3809 ::Info(""ACLiC"", ""%s"", relink_cmd.Data());; 3810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcli",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130396,Testability,test,testcmd,130396,"810 }; 3811 result = ExecAndReport(relink_cmd);; 3812 }; 3813 ; 3814 TNamed *k = new TNamed(library,library);; 3815 Long_t lib_time;; 3816 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3817 k->SetUniqueID(lib_time);; 3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuil",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:130904,Testability,test,testcmd,130904,"ompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:131025,Testability,test,testcmd,131025,"hared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888////////////////////////////////////////////////////////////////////////////////; 3889/// Return the build compiler version; 3890 ; 3891const char *TSystem::GetBuildCompilerVersion() const; 3892{; 3893 return fBuildCompil",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:173548,Testability,log,log,173548,".cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment va",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:191718,Testability,log,log,191718,"::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirec",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:1076,Usability,simpl,simple,1076,". ROOT: core/base/src/TSystem.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TSystem.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 8944840ba34631ec28efc779647618db43c0eee5 $; 2// Author: Fons Rademakers 15/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TSystem; 13\ingroup Base; 14 ; 15Abstract base class defining a generic interface to the underlying; 16Operating System.; 17This is not an ABC in the strict sense of the (C++) word. For; 18every member function there is an implementation (often not more; 19than a call to AbstractMethod() which prints a warning saying; 20that the method should be overridden in a derived class), which; 21allows a simple partial implementation for new OS'es.; 22*/; 23 ; 24#include <ROOT/FoundationUtils.hxx>; 25#include ""strlcpy.h""; 26#include ""TSystem.h""; 27#include ""TApplication.h""; 28#include ""TException.h""; 29#include ""TROOT.h""; 30#include ""TClass.h""; 31#include ""TClassTable.h""; 32#include ""TEnv.h""; 33#include ""TOrdCollection.h""; 34#include ""TObject.h""; 35#include ""TInterpreter.h""; 36#include ""TRegexp.h""; 37#include ""TObjString.h""; 38#include ""TObjArray.h""; 39#include ""TError.h""; 40#include ""TPluginManager.h""; 41#include ""TUrl.h""; 42#include ""TVirtualMutex.h""; 43#include ""TVersionCheck.h""; 44#include ""compiledata.h""; 45#include ""RConfigure.h""; 46#include ""THashList.h""; 47#include ""ThreadLocalStorage.h""; 48 ; 49#include <functional>; 50#include <iostream>; 51#include <fstream>; 52#include <memory>; 53#include <sstream>; 54#include <string>; 55#include <sys/stat.h>; 56#include <set>; 57 ; 58#ifdef WIN32; 59#include <io.h",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:36946,Usability,simpl,simple,36946,"cpy(buff, c+1, n+1); // strlcpy copy 'size-1' characters.; 1169 std::string hd = GetHomeDirectory(buff);; 1170 e = c+1+n;; 1171 if (!hd.empty()) { // we have smth to copy; 1172 p = hd.c_str();; 1173 strlcpy(x, p, kBufSize);; 1174 x += strlen(p);; 1175 c = e;; 1176 } else {; 1177 x++[0] = c[0];; 1178 //++ier;; 1179 ++c;; 1180 }; 1181 }; 1182 ; 1183 for ( ; c[0]; c++) {; 1184 ; 1185 p = nullptr; e = nullptr;; 1186 ; 1187 if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd; 1188 std::string wd = GetWorkingDirectory();; 1189 strlcpy(buff, wd.c_str(), kBufSize);; 1190 p = buff;; 1191 e = c + 1;; 1192 }; 1193 if (p) { // we have smth to copy */; 1194 strlcpy(x, p, kBufSize); x += strlen(p); c = e-1; continue;; 1195 }; 1196 ; 1197 if (c[0] != '$') { // not $, simple copy; 1198 x++[0] = c[0];; 1199 } else { // we have a $; 1200 b = c+1;; 1201 if (c[1] == '(') b++;; 1202 if (c[1] == '{') b++;; 1203 if (b[0] == '$'); 1204 e = b+1;; 1205 else; 1206 for (e = b; isalnum(e[0]) || e[0] == '_'; e++) ;; 1207 buff[0] = 0; strncat(buff, b, e-b);; 1208 p = Getenv(buff);; 1209 if (!p) { // too bad, try UPPER case; 1210 for (t = buff; (t[0] = toupper(t[0])); t++) ;; 1211 p = Getenv(buff);; 1212 }; 1213 if (!p) { // too bad, try Lower case; 1214 for (t = buff; (t[0] = tolower(t[0])); t++) ;; 1215 p = Getenv(buff);; 1216 }; 1217 if (!p && !strcmp(buff, ""cwd"")) { // it is $cwd; 1218 std::string wd = GetWorkingDirectory();; 1219 strlcpy(buff, wd.c_str(), kBufSize);; 1220 p = buff;; 1221 }; 1222 if (!p && !strcmp(buff, ""$"")) { // it is $$ (replace by GetPid()); 1223 snprintf(buff,kBufSize*4, ""%d"", GetPid());; 1224 p = buff;; 1225 }; 1226 if (!p) { // too bad, nothing can help; 1227#ifdef WIN32; 1228 // if we're on windows, we can have \\SomeMachine\C$ - don't; 1229 // complain about that, if '$' is followed by nothing or a; 1230 // path delimiter.; 1231 if (c[1] && c[1]!='\\' && c[1]!=';' && c[1]!='/'); 1232 ier++;; 1233#else; 1234 ier++;; 1235#endif; 1236 x++[0] = c[0];; 1237 } else { ",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:93069,Usability,simpl,simplify,93069,"ibraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8cxx_source.html:98217,Usability,usab,usable,98217," 2921 if (whichlibrary) {; 2922 library = whichlibrary;; 2923 delete [] whichlibrary;; 2924 } else {; 2925 ::Error(""ACLiC"",""The file %s can not be found in the include path: %s"",filename,incPath.Data());; 2926 return kFALSE;; 2927 }; 2928 } else {; 2929 if (gSystem->AccessPathName(library)) {; 2930 ::Error(""ACLiC"",""The file %s can not be found."",filename);; 2931 return kFALSE;; 2932 }; 2933 }; 2934 { // Remove multiple '/' characters, rootcling treats them as comments.; 2935 Ssiz_t pos = 0;; 2936 while ((pos = library.Index(""//"", 2, pos, TString::kExact)) != kNPOS) {; 2937 library.Remove(pos, 1);; 2938 }; 2939 }; 2940 library = gSystem->UnixPathName(library);; 2941 TString filename_fullpath = library;; 2942 ; 2943 TString file_dirname = GetDirName( filename_fullpath );; 2944 // For some probably good reason, DirName on Windows returns the 'name' of; 2945 // the directory, omitting the drive letter (even if there was one). In; 2946 // consequence the result is not usable as a 'root directory', we need to; 2947 // add the drive letter if there was one..; 2948 if (library.Length()>1 && isalpha(library[0]) && library[1]==':') {; 2949 file_dirname.Prepend(library(0,2));; 2950 }; 2951 TString file_location( file_dirname ); // Location of the script.; 2952 incPath.Prepend( file_location + "":"" );; 2953 ; 2954 Ssiz_t dot_pos = library.Last('.');; 2955 TString extension, libname_noext = library;; 2956 if (dot_pos >= 0) {; 2957 libname_noext.Remove(dot_pos);; 2958 extension = library(dot_pos+1, library.Length()-dot_pos-1);; 2959 }; 2960 ; 2961 // Extension of shared library is platform dependent!!; 2962 TString suffix = TString(""_"") + extension + ""."" + fSoExt;; 2963 if (dot_pos >= 0); 2964 library.Replace( dot_pos, library.Length()-dot_pos, suffix);; 2965 else; 2966 library.Append(suffix);; 2967 ; 2968 TString libname ( BaseName( libname_noext ) );; 2969 libname.Append(""_"").Append(extension);; 2970 ; 2971 if (library_specified && strlen(library_specified) ) {; 2972 // Use the s",MatchSource.WIKI,doc/master/TSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html
https://root.cern/doc/master/TSystem_8h.html:394,Integrability,depend,dependency,394,". ROOT: core/base/inc/TSystem.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations |; Functions |; Variables ; TSystem.h File Reference. #include <cstdio>; #include <cctype>; #include <fcntl.h>; #include <unistd.h>; #include ""TNamed.h""; #include ""TInetAddress.h""; #include ""TTimer.h""; #include <string>. Include dependency graph for TSystem.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct CpuInfo_t; ; struct FileStat_t; ; struct MemInfo_t; ; struct ProcInfo_t; ; struct RedirectHandle_t; ; struct SysInfo_t; ; class TProcessEventTimer; ; class TSystem; Abstract base class defining a generic interface to the underlying Operating System. More...; ; struct UserGroup_t; . Typedefs; typedef void(*Func_t) (); . Enumerations; enum EAccessMode { kFileExists = 0; , kExecutePermission = 1; , kWritePermission = 2; , kReadPermission = 4; }; ; enum EFileModeMask { ; kS_IFMT = 0170000; , kS_IFSOCK = 0140000; , kS_IFLNK = 0120000; , kS_IFOFF = 0110000; , ; kS_IFREG = 0100000; , kS_IFBLK = 0060000; , kS_IFDIR = 0040000; , kS_IFCHR = 0020000; , ; kS_IFIFO = 0010000; , kS_ISUID = 0004000; , kS_ISGID = 0002000; , kS_ISVTX = 0001000; , ; kS_IRWXU = 00700; , kS_IRUSR = 00400; , kS_IWUSR = 00200; , kS_IXUSR = 00100; , ; kS_IRWXG = 00070; , kS_IRGRP = 00040; , kS_IWGRP = 00020; , kS_IXGRP = 00010; , ; kS_IRWXO = 00007; , kS_IROTH = 00004; , kS_IWOTH = 00002; , kS_IXOTH = 00001. }; ; enum EFpeMask { ; kNoneMask = 0x00; , kInvalid = 0x01; , kDivByZero = 0x02; , kOverflow = 0x04; , ; kUnderflow = 0x08; , kInexact = 0x10; , kDefaultMask = 0x07; , kAllMask = 0x1F. }; ; enum ELogFacility { ; kLogLocal0; , kLogLocal1; , kLogLocal2; , kLogLocal3; , ; kLogLocal4; , kLogLocal5; , kLogLocal6; , kLogLocal7. }; ; enum ELogLevel { ; kLogEmerg = 0; , kLogAlert = 1; , kLogCrit = 2; , kLogErr = 3; , ; kLogWarning = 4; , k",MatchSource.WIKI,doc/master/TSystem_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h.html
https://root.cern/doc/master/TSystem_8h.html:748,Integrability,interface,interface,748,". ROOT: core/base/inc/TSystem.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations |; Functions |; Variables ; TSystem.h File Reference. #include <cstdio>; #include <cctype>; #include <fcntl.h>; #include <unistd.h>; #include ""TNamed.h""; #include ""TInetAddress.h""; #include ""TTimer.h""; #include <string>. Include dependency graph for TSystem.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct CpuInfo_t; ; struct FileStat_t; ; struct MemInfo_t; ; struct ProcInfo_t; ; struct RedirectHandle_t; ; struct SysInfo_t; ; class TProcessEventTimer; ; class TSystem; Abstract base class defining a generic interface to the underlying Operating System. More...; ; struct UserGroup_t; . Typedefs; typedef void(*Func_t) (); . Enumerations; enum EAccessMode { kFileExists = 0; , kExecutePermission = 1; , kWritePermission = 2; , kReadPermission = 4; }; ; enum EFileModeMask { ; kS_IFMT = 0170000; , kS_IFSOCK = 0140000; , kS_IFLNK = 0120000; , kS_IFOFF = 0110000; , ; kS_IFREG = 0100000; , kS_IFBLK = 0060000; , kS_IFDIR = 0040000; , kS_IFCHR = 0020000; , ; kS_IFIFO = 0010000; , kS_ISUID = 0004000; , kS_ISGID = 0002000; , kS_ISVTX = 0001000; , ; kS_IRWXU = 00700; , kS_IRUSR = 00400; , kS_IWUSR = 00200; , kS_IXUSR = 00100; , ; kS_IRWXG = 00070; , kS_IRGRP = 00040; , kS_IWGRP = 00020; , kS_IXGRP = 00010; , ; kS_IRWXO = 00007; , kS_IROTH = 00004; , kS_IWOTH = 00002; , kS_IXOTH = 00001. }; ; enum EFpeMask { ; kNoneMask = 0x00; , kInvalid = 0x01; , kDivByZero = 0x02; , kOverflow = 0x04; , ; kUnderflow = 0x08; , kInexact = 0x10; , kDefaultMask = 0x07; , kAllMask = 0x1F. }; ; enum ELogFacility { ; kLogLocal0; , kLogLocal1; , kLogLocal2; , kLogLocal3; , ; kLogLocal4; , kLogLocal5; , kLogLocal6; , kLogLocal7. }; ; enum ELogLevel { ; kLogEmerg = 0; , kLogAlert = 1; , kLogCrit = 2; , kLogErr = 3; , ; kLogWarning = 4; , k",MatchSource.WIKI,doc/master/TSystem_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h.html
https://root.cern/doc/master/TSystem_8h_source.html:2640,Availability,mask,mask,2640,"ug = 7; 62};; 63 ; 64enum ELogFacility {; 65 kLogLocal0,; 66 kLogLocal1,; 67 kLogLocal2,; 68 kLogLocal3,; 69 kLogLocal4,; 70 kLogLocal5,; 71 kLogLocal6,; 72 kLogLocal7; 73};; 74 ; 75enum EFpeMask {; 76 kNoneMask = 0x00,; 77 kInvalid = 0x01, // Invalid argument; 78 kDivByZero = 0x02, // Division by zero; 79 kOverflow = 0x04, // Overflow; 80 kUnderflow = 0x08, // Underflow; 81 kInexact = 0x10, // Inexact; 82 kDefaultMask = 0x07,; 83 kAllMask = 0x1F; 84};; 85 ; 86enum EFileModeMask {; 87 kS_IFMT = 0170000, // bitmask for the file type bitfields; 88 kS_IFSOCK = 0140000, // socket; 89 kS_IFLNK = 0120000, // symbolic link; 90 kS_IFOFF = 0110000, // offline file; 91 kS_IFREG = 0100000, // regular file; 92 kS_IFBLK = 0060000, // block device; 93 kS_IFDIR = 0040000, // directory; 94 kS_IFCHR = 0020000, // character device; 95 kS_IFIFO = 0010000, // fifo; 96 kS_ISUID = 0004000, // set UID bit; 97 kS_ISGID = 0002000, // set GID bit; 98 kS_ISVTX = 0001000, // sticky bit; 99 kS_IRWXU = 00700, // mask for file owner permissions; 100 kS_IRUSR = 00400, // owner has read permission; 101 kS_IWUSR = 00200, // owner has write permission; 102 kS_IXUSR = 00100, // owner has execute permission; 103 kS_IRWXG = 00070, // mask for group permissions; 104 kS_IRGRP = 00040, // group has read permission; 105 kS_IWGRP = 00020, // group has write permission; 106 kS_IXGRP = 00010, // group has execute permission; 107 kS_IRWXO = 00007, // mask for permissions for others (not in group); 108 kS_IROTH = 00004, // others have read permission; 109 kS_IWOTH = 00002, // others have write permission; 110 kS_IXOTH = 00001 // others have execute permission; 111};; 112 ; 113inline Bool_t R_ISDIR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFDIR); }; 114inline Bool_t R_ISCHR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISL",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:2858,Availability,mask,mask,2858,",; 77 kInvalid = 0x01, // Invalid argument; 78 kDivByZero = 0x02, // Division by zero; 79 kOverflow = 0x04, // Overflow; 80 kUnderflow = 0x08, // Underflow; 81 kInexact = 0x10, // Inexact; 82 kDefaultMask = 0x07,; 83 kAllMask = 0x1F; 84};; 85 ; 86enum EFileModeMask {; 87 kS_IFMT = 0170000, // bitmask for the file type bitfields; 88 kS_IFSOCK = 0140000, // socket; 89 kS_IFLNK = 0120000, // symbolic link; 90 kS_IFOFF = 0110000, // offline file; 91 kS_IFREG = 0100000, // regular file; 92 kS_IFBLK = 0060000, // block device; 93 kS_IFDIR = 0040000, // directory; 94 kS_IFCHR = 0020000, // character device; 95 kS_IFIFO = 0010000, // fifo; 96 kS_ISUID = 0004000, // set UID bit; 97 kS_ISGID = 0002000, // set GID bit; 98 kS_ISVTX = 0001000, // sticky bit; 99 kS_IRWXU = 00700, // mask for file owner permissions; 100 kS_IRUSR = 00400, // owner has read permission; 101 kS_IWUSR = 00200, // owner has write permission; 102 kS_IXUSR = 00100, // owner has execute permission; 103 kS_IRWXG = 00070, // mask for group permissions; 104 kS_IRGRP = 00040, // group has read permission; 105 kS_IWGRP = 00020, // group has write permission; 106 kS_IXGRP = 00010, // group has execute permission; 107 kS_IRWXO = 00007, // mask for permissions for others (not in group); 108 kS_IROTH = 00004, // others have read permission; 109 kS_IWOTH = 00002, // others have write permission; 110 kS_IXOTH = 00001 // others have execute permission; 111};; 112 ; 113inline Bool_t R_ISDIR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFDIR); }; 114inline Bool_t R_ISCHR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISLNK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFLNK); }; 118inline Bool_t R_ISFIFO(Int_t mode) { return ((mode & kS_IFMT) == kS_IFIFO); }; 119inline Bool_t R_ISSOCK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFSOCK",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:3071,Availability,mask,mask,3071," 83 kAllMask = 0x1F; 84};; 85 ; 86enum EFileModeMask {; 87 kS_IFMT = 0170000, // bitmask for the file type bitfields; 88 kS_IFSOCK = 0140000, // socket; 89 kS_IFLNK = 0120000, // symbolic link; 90 kS_IFOFF = 0110000, // offline file; 91 kS_IFREG = 0100000, // regular file; 92 kS_IFBLK = 0060000, // block device; 93 kS_IFDIR = 0040000, // directory; 94 kS_IFCHR = 0020000, // character device; 95 kS_IFIFO = 0010000, // fifo; 96 kS_ISUID = 0004000, // set UID bit; 97 kS_ISGID = 0002000, // set GID bit; 98 kS_ISVTX = 0001000, // sticky bit; 99 kS_IRWXU = 00700, // mask for file owner permissions; 100 kS_IRUSR = 00400, // owner has read permission; 101 kS_IWUSR = 00200, // owner has write permission; 102 kS_IXUSR = 00100, // owner has execute permission; 103 kS_IRWXG = 00070, // mask for group permissions; 104 kS_IRGRP = 00040, // group has read permission; 105 kS_IWGRP = 00020, // group has write permission; 106 kS_IXGRP = 00010, // group has execute permission; 107 kS_IRWXO = 00007, // mask for permissions for others (not in group); 108 kS_IROTH = 00004, // others have read permission; 109 kS_IWOTH = 00002, // others have write permission; 110 kS_IXOTH = 00001 // others have execute permission; 111};; 112 ; 113inline Bool_t R_ISDIR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFDIR); }; 114inline Bool_t R_ISCHR(Int_t mode) { return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISLNK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFLNK); }; 118inline Bool_t R_ISFIFO(Int_t mode) { return ((mode & kS_IFMT) == kS_IFIFO); }; 119inline Bool_t R_ISSOCK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFSOCK); }; 120inline Bool_t R_ISOFF(Int_t mode) { return ((mode & kS_IFMT) == kS_IFOFF); }; 121 ; 122struct FileStat_t {; 123 Long_t fDev; // device id; 124 Long_t fIno; // inode; 125 Int_t fMode; // protection (combin",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:6180,Availability,avail,available,6180," 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUsed(0), fSwapFree(0), fSwapCached(0), fSReclaimable(0){ }; 192 virtual ~MemInfo_t() { }; 193 ClassDef(MemInfo_t, 2); // Memory utilization information.; 194};; 195 ; 196struct ProcInfo_t {; 197 Float_t fCpuUser; // user time used by this process in seconds; 198 Float_t fCpuSys; // system time used by this process in seconds; 199 Long_t fMemResident; // resident memory used by this process in KB; 200 Long_t fMemVirtual; // virtual memory used by this process in KB; 201 ProcInfo_t() : fCpuUser(0), fCpuSys(0), fMemResident(0),; 202 fMemVirtual(0) { }; 203 virtual ~ProcInfo_t();; 204 ClassDef(ProcInfo_t, 1);// System resource usage of given process.; 205};; 206 ; 207struct RedirectHandle_t {; 208 TString fFile; // F",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:8240,Availability,alive,alive,8240,"; 210 TString fStdErrTty; // tty associated with stderr, if any (e.g. from ttyname(...)); 211 Int_t fStdOutDup{-1}; // Duplicated descriptor for stdout; 212 Int_t fStdErrDup{-1}; // Duplicated descriptor for stderr; 213 Int_t fReadOffSet{-1}; // Offset where to start reading the file (used by ShowOutput(...)); 214 RedirectHandle_t(const char *n = nullptr) : fFile(n) { }; 215 void Reset() { fFile = """"; fStdOutTty = """"; fStdErrTty = """";; 216 fStdOutDup = -1; fStdErrDup = -1; fReadOffSet = -1; }; 217};; 218 ; 219enum ESockOptions {; 220 kSendBuffer, // size of send buffer; 221 kRecvBuffer, // size of receive buffer; 222 kOobInline, // OOB message inline; 223 kKeepAlive, // keep socket alive; 224 kReuseAddr, // allow reuse of local portion of address 5-tuple; 225 kNoDelay, // send without delay; 226 kNoBlock, // non-blocking I/O; 227 kProcessGroup, // socket process group (used for SIGURG and SIGIO); 228 kAtMark, // are we at out-of-band mark (read only); 229 kBytesToRead // get number of bytes to read, FIONREAD (read only); 230};; 231 ; 232enum ESendRecvOptions {; 233 kDefault, // default option (= 0); 234 kOob, // send or receive out-of-band data; 235 kPeek, // peek at incoming message (receive only); 236 kDontBlock // send/recv as much data as possible without blocking; 237};; 238 ; 239typedef void (*Func_t)();; 240 ; 241R__EXTERN const char *gRootDir;; 242R__EXTERN const char *gProgName;; 243R__EXTERN const char *gProgPath;; 244R__EXTERN TVirtualMutex *gSystemMutex;; 245 ; 246 ; 247//////////////////////////////////////////////////////////////////////////; 248// //; 249// Asynchronous timer used for processing pending GUI and timer events //; 250// every delay ms. Call in a tight computing loop //; 251// TProcessEventTimer::ProcessEvent(). If the timer did timeout this //; 252// call will process the pending events and return kTRUE if the //; 253// TROOT::IsInterrupted() flag is set (can be done by hitting key in //; 254// canvas or selecting canvas menu item View/I",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:10593,Availability,mask,masks,10593,"//////////////////////////////////////////////////////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache use",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:10644,Availability,mask,mask,10644,"////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:10695,Availability,mask,mask,10695,"{; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to .",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:13400,Availability,error,error,13400,"dePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; ",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:13492,Availability,error,error,13492,"ing fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; 342 TSystem(const char *name = ""Generic"", const char *title = ""Generic System"");; 343 virtual ~TSystem();; 344 ; 345 //---- Misc; 346 virtual Bool_t Init();; 347 virtual void SetProgname(co",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:16557,Availability,mask,mask,16557,"SignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHandler; }; 386 ; 387 //---- Floating Point Exceptions Control; 388 virtual Int_t GetFPEMask();; 389 virtual Int_t SetFPEMask(Int_t mask = kDefaultMask);; 390 ; 391 //---- Time & Date; 392 virtual TTime Now();; 393 virtual TList *GetListOfTimers() const { return fTimers; }; 394 virtual void AddTimer(TTimer *t);; 395 virtual TTimer *RemoveTimer(TTimer *t);; 396 virtual void ResetTimer(TTimer *) { }; 397 virtual Long_t NextTimeOut(Bool_t mode);; 398 virtual void Sleep(UInt_t milliSec);; 399 ; 400 //---- Processes; 401 virtual Int_t Exec(const char *shellcmd);; 402 virtual FILE *OpenPipe(const char *command, const char *mode);; 403 virtual int ClosePipe(FILE *pipe);; 404 virtual TString GetFromPipe(const char *command);; 405 virtual int GetPid();; 406 virtual void StackTrace();; 407 ; 408 [[ noreturn ]] virtual void Exit(int code, Bool_t mode = kTRUE);; 409 [[ noreturn ]] virtual void Abort(int code = 0);; 410 ; 411 //---- Directories; 412 virtual int MakeDirectory(const char *name);; 413 virtual void *OpenDirectory(const char *name);; 414 virtual void FreeDirectory(void *dirp);; 415 virtual const char *GetDirEntry(void ",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:19761,Availability,mask,mask,19761,"436 virtual Bool_t ExpandPathName(TString &path);; 437 virtual char *ExpandPathName(const char *path);; 438 virtual Bool_t AccessPathName(const char *path, EAccessMode mode = kFileExists);; 439 virtual Bool_t IsPathLocal(const char *path);; 440 virtual int CopyFile(const char *from, const char *to, Bool_t overwrite = kFALSE);; 441 virtual int Rename(const char *from, const char *to);; 442 virtual int Link(const char *from, const char *to);; 443 virtual int Symlink(const char *from, const char *to);; 444 virtual int Unlink(const char *name);; 445 int GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime);; 446 int GetPathInfo(const char *path, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);; 447 virtual int GetPathInfo(const char *path, FileStat_t &buf);; 448 virtual int GetFsInfo(const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree);; 449 virtual int Chmod(const char *file, UInt_t mode);; 450 virtual int Umask(Int_t mask);; 451 virtual int Utime(const char *file, Long_t modtime, Long_t actime);; 452 virtual const char *UnixPathName(const char *unixpathname);; 453 virtual const char *FindFile(const char *search, TString& file, EAccessMode mode = kFileExists);; 454 virtual char *Which(const char *search, const char *file, EAccessMode mode = kFileExists);; 455 virtual TList *GetVolumes(Option_t *) const { return nullptr; }; 456 ; 457 //---- Users & Groups; 458 virtual Int_t GetUid(const char *user = nullptr);; 459 virtual Int_t GetGid(const char *group = nullptr);; 460 virtual Int_t GetEffectiveUid();; 461 virtual Int_t GetEffectiveGid();; 462 virtual UserGroup_t *GetUserInfo(Int_t uid);; 463 virtual UserGroup_t *GetUserInfo(const char *user = nullptr);; 464 virtual UserGroup_t *GetGroupInfo(Int_t gid);; 465 virtual UserGroup_t *GetGroupInfo(const char *group = nullptr);; 466 ; 467 //---- Environment Manipulation; 468 virtual void Setenv(const char *name, const char *value);; 469 virtual void Unsetenv(c",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:26855,Availability,mask,maskDefinition,26855," R__EXTERNDefinition DllImport.h:26; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Poin",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:35503,Availability,mask,mask,35503,"ool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TProcessEventTimer::NotifyBool_t Notify() overrideThis method must be overridden to handle object notification (the base implementation is no-op).Definition TSystem.h:260; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:35543,Availability,mask,mask,35543,"ool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TProcessEventTimer::NotifyBool_t Notify() overrideThis method must be overridden to handle object notification (the base implementation is no-op).Definition TSystem.h:260; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:37230,Availability,error,error,37230,"ion TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedLibsvirtual void AddLinkedLibs(const char *linkedLib)Add linkedLib to already set linked libs.Definition TSystem.cxx:4170; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::GetBuildCompilerVersionvirtual const char * GetBuildCompilerVersion() constReturn the build compiler version.Definition TSystem.cxx:3891; TSystem::ResetSignalvirtual void ResetSignal(ESignals sig, Bool_t reset=kTRUE)If reset is true reset the signal handler for the specified signal to the default handler,...Definition TSystem.cxx:576; TSystem::cdBool_t cd(const char *path)Definition TSystem.h:423; TSystem::GetSockNamevirtual TInetAddress GetSockName(int sock)Get Internet Protocol (IP) address of host and port #.Definition TSystem.cxx:23",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:39731,Availability,error,error,39731,"able.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::InControlBool_t InControl() constDefinition TSystem.h:367; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:41116,Availability,error,error,41116,"ould be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h:385; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSys",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:41423,Availability,error,error,41423,"::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h:385; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(cons",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:59239,Availability,mask,mask,59239,"6; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::AddStdExceptionHandlervirtual void AddStdExceptionHandler(TStdExceptionHandler *eh)Add an exception handler to list of system exception handlers.Definition TSystem.cxx:611; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Rem",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:60110,Availability,error,error,60110,"ck, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:62666,Availability,error,error,62666,"() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::Tem",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:833,Integrability,interface,interface,833,". ROOT: core/base/inc/TSystem.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TSystem.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 15/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TSystem; 13#define ROOT_TSystem; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TSystem //; 19// //; 20// Abstract base class defining a generic interface to the underlying //; 21// Operating System. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include <cstdio>; 26#include <cctype>; 27#include <fcntl.h>; 28#ifndef _WIN32; 29#include <unistd.h>; 30#endif; 31 ; 32#include ""TNamed.h""; 33#include ""TInetAddress.h""; 34#include ""TTimer.h""; 35#include <string>; 36 ; 37class TSeqCollection;; 38class TFdSet;; 39class TVirtualMutex;; 40 ; 41enum EAccessMode {; 42 kFileExists = 0,; 43 kExecutePermission = 1,; 44 kWritePermission = 2,; 45 kReadPermission = 4; 46};; 47 ; 48enum ELogOption {; 49 kLogPid = 0x01,; 50 kLogCons = 0x02; 51};; 52 ; 53enum ELogLevel {; 54 kLogEmerg = 0,; 55 kLogAlert = 1,; 56 kLogCrit = 2,; 57 kLogErr = 3,; 58 kLogWarning = 4,; 59 kLogNotice = 5,; 60 kLogInfo = 6,; 61 kLogDebug = 7; 62};; 63 ; 64enum ELogFacility {; 65 kLogLocal0,; 66 kLogLocal1,; 67 kLogLocal2,; 68 kLogLocal3,; 69 kLogLocal4,; 70 kLogLocal5,; 71 kLogLocal6,; 72 kLogLocal7; 73};; 74 ; 75enum EFpeMask {; 76 kNoneMask = 0x00,; 77 kInvalid = 0x01, // Invalid argument; 78 kDivByZero = 0x02, // Division by zero; 79 kOverflow = 0x04, // Overflow; 80 kUnderflow = 0x08",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:8193,Integrability,message,message,8193,"; 210 TString fStdErrTty; // tty associated with stderr, if any (e.g. from ttyname(...)); 211 Int_t fStdOutDup{-1}; // Duplicated descriptor for stdout; 212 Int_t fStdErrDup{-1}; // Duplicated descriptor for stderr; 213 Int_t fReadOffSet{-1}; // Offset where to start reading the file (used by ShowOutput(...)); 214 RedirectHandle_t(const char *n = nullptr) : fFile(n) { }; 215 void Reset() { fFile = """"; fStdOutTty = """"; fStdErrTty = """";; 216 fStdOutDup = -1; fStdErrDup = -1; fReadOffSet = -1; }; 217};; 218 ; 219enum ESockOptions {; 220 kSendBuffer, // size of send buffer; 221 kRecvBuffer, // size of receive buffer; 222 kOobInline, // OOB message inline; 223 kKeepAlive, // keep socket alive; 224 kReuseAddr, // allow reuse of local portion of address 5-tuple; 225 kNoDelay, // send without delay; 226 kNoBlock, // non-blocking I/O; 227 kProcessGroup, // socket process group (used for SIGURG and SIGIO); 228 kAtMark, // are we at out-of-band mark (read only); 229 kBytesToRead // get number of bytes to read, FIONREAD (read only); 230};; 231 ; 232enum ESendRecvOptions {; 233 kDefault, // default option (= 0); 234 kOob, // send or receive out-of-band data; 235 kPeek, // peek at incoming message (receive only); 236 kDontBlock // send/recv as much data as possible without blocking; 237};; 238 ; 239typedef void (*Func_t)();; 240 ; 241R__EXTERN const char *gRootDir;; 242R__EXTERN const char *gProgName;; 243R__EXTERN const char *gProgPath;; 244R__EXTERN TVirtualMutex *gSystemMutex;; 245 ; 246 ; 247//////////////////////////////////////////////////////////////////////////; 248// //; 249// Asynchronous timer used for processing pending GUI and timer events //; 250// every delay ms. Call in a tight computing loop //; 251// TProcessEventTimer::ProcessEvent(). If the timer did timeout this //; 252// call will process the pending events and return kTRUE if the //; 253// TROOT::IsInterrupted() flag is set (can be done by hitting key in //; 254// canvas or selecting canvas menu item View/I",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:8744,Integrability,message,message,8744,"; 210 TString fStdErrTty; // tty associated with stderr, if any (e.g. from ttyname(...)); 211 Int_t fStdOutDup{-1}; // Duplicated descriptor for stdout; 212 Int_t fStdErrDup{-1}; // Duplicated descriptor for stderr; 213 Int_t fReadOffSet{-1}; // Offset where to start reading the file (used by ShowOutput(...)); 214 RedirectHandle_t(const char *n = nullptr) : fFile(n) { }; 215 void Reset() { fFile = """"; fStdOutTty = """"; fStdErrTty = """";; 216 fStdOutDup = -1; fStdErrDup = -1; fReadOffSet = -1; }; 217};; 218 ; 219enum ESockOptions {; 220 kSendBuffer, // size of send buffer; 221 kRecvBuffer, // size of receive buffer; 222 kOobInline, // OOB message inline; 223 kKeepAlive, // keep socket alive; 224 kReuseAddr, // allow reuse of local portion of address 5-tuple; 225 kNoDelay, // send without delay; 226 kNoBlock, // non-blocking I/O; 227 kProcessGroup, // socket process group (used for SIGURG and SIGIO); 228 kAtMark, // are we at out-of-band mark (read only); 229 kBytesToRead // get number of bytes to read, FIONREAD (read only); 230};; 231 ; 232enum ESendRecvOptions {; 233 kDefault, // default option (= 0); 234 kOob, // send or receive out-of-band data; 235 kPeek, // peek at incoming message (receive only); 236 kDontBlock // send/recv as much data as possible without blocking; 237};; 238 ; 239typedef void (*Func_t)();; 240 ; 241R__EXTERN const char *gRootDir;; 242R__EXTERN const char *gProgName;; 243R__EXTERN const char *gProgPath;; 244R__EXTERN TVirtualMutex *gSystemMutex;; 245 ; 246 ; 247//////////////////////////////////////////////////////////////////////////; 248// //; 249// Asynchronous timer used for processing pending GUI and timer events //; 250// every delay ms. Call in a tight computing loop //; 251// TProcessEventTimer::ProcessEvent(). If the timer did timeout this //; 252// call will process the pending events and return kTRUE if the //; 253// TROOT::IsInterrupted() flag is set (can be done by hitting key in //; 254// canvas or selecting canvas menu item View/I",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:13406,Integrability,message,message,13406,"dePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; ",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:13498,Integrability,message,message,13498,"ing fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; 342 TSystem(const char *name = ""Generic"", const char *title = ""Generic System"");; 343 virtual ~TSystem();; 344 ; 345 //---- Misc; 346 virtual Bool_t Init();; 347 virtual void SetProgname(co",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:22470,Integrability,protocol,protocol,22470,"b, Bool_t quiet = kFALSE);; 486 virtual const char *FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE);; 487 virtual Func_t DynFindSymbol(const char *module, const char *entry);; 488 virtual int Load(const char *module, const char *entry = """", Bool_t system = kFALSE);; 489 virtual void Unload(const char *module);; 490 virtual UInt_t LoadAllLibraries();; 491 virtual void ListSymbols(const char *module, const char *re = """");; 492 virtual void ListLibraries(const char *regexp = """");; 493 virtual const char *GetLibraries(const char *regexp = """",; 494 const char *option = """",; 495 Bool_t isRegexp = kTRUE);; 496 ; 497 //---- RPC; 498 virtual TInetAddress GetHostByName(const char *server);; 499 virtual TInetAddress GetPeerName(int sock);; 500 virtual TInetAddress GetSockName(int sock);; 501 virtual int GetServiceByName(const char *service);; 502 virtual char *GetServiceByPort(int port);; 503 virtual int OpenConnection(const char *server, int port, int tcpwindowsize = -1, const char *protocol = ""tcp"");; 504 virtual int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1);; 505 virtual int AnnounceUdpService(int port, int backlog);; 506 virtual int AnnounceUnixService(int port, int backlog);; 507 virtual int AnnounceUnixService(const char *sockpath, int backlog);; 508 virtual int AcceptConnection(int sock);; 509 virtual void CloseConnection(int sock, Bool_t force = kFALSE);; 510 virtual int RecvRaw(int sock, void *buffer, int length, int flag);; 511 virtual int SendRaw(int sock, const void *buffer, int length, int flag);; 512 virtual int RecvBuf(int sock, void *buffer, int length);; 513 virtual int SendBuf(int sock, const void *buffer, int length);; 514 virtual int SetSockOpt(int sock, int kind, int val);; 515 virtual int GetSockOpt(int sock, int kind, int *val);; 516 ; 517 //---- System, CPU and Memory info; 518 virtual int GetSysInfo(SysInfo_t *info) const;; 519 virtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime = 1000) const;; 520 virt",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:25547,Integrability,interface,interface,25547,"irtual int CompileMacro(const char *filename, Option_t *opt = """", const char *library_name = """", const char *build_dir = """", UInt_t dirmode = 0);; 527 virtual Int_t GetAclicProperties() const;; 528 virtual const char *GetBuildArch() const;; 529 virtual const char *GetBuildCompiler() const;; 530 virtual const char *GetBuildCompilerVersion() const;; 531 virtual const char *GetBuildCompilerVersionStr() const;; 532 virtual const char *GetBuildNode() const;; 533 virtual const char *GetBuildDir() const;; 534 virtual const char *GetFlagsDebug() const;; 535 virtual const char *GetFlagsOpt() const;; 536 virtual const char *GetIncludePath();; 537 virtual const char *GetLinkedLibs() const;; 538 virtual const char *GetLinkdefSuffix() const;; 539 virtual EAclicMode GetAclicMode() const;; 540 virtual const char *GetMakeExe() const;; 541 virtual const char *GetMakeSharedLib() const;; 542 virtual const char *GetSoExt() const;; 543 virtual const char *GetObjExt() const;; 544 virtual void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE);; 545 virtual void SetFlagsDebug(const char *);; 546 virtual void SetFlagsOpt(const char *);; 547 virtual void SetIncludePath(const char *includePath);; 548 virtual void SetMakeExe(const char *directives);; 549 virtual void SetAclicMode(EAclicMode mode);; 550 virtual void SetMakeSharedLib(const char *directives);; 551 virtual void SetLinkedLibs(const char *linkedLibs);; 552 virtual void SetLinkdefSuffix(const char *suffix);; 553 virtual void SetSoExt(const char *soExt);; 554 virtual void SetObjExt(const char *objExt);; 555 virtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) const;; 556 virtual void CleanCompiledMacros();; 557 ; 558 ClassDefOverride(TSystem,0) //ABC defining a generic interface to the OS; 559};; 560 ; 561R__EXTERN TSystem *gSystem;; 562R__EXTERN TFileHandler *gXDisplay; // Display server (X11) input event handler; 563 ; 564 ; 565#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:35046,Integrability,interface,interface,35046," TFdSetDefinition TMacOSXSystem.mm:90; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TProcessEventTimer::NotifyBool_t Notify() overrideThis method must be overridden to handle object notification (the base implementation is no-op).Definition TSystem.h:260; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:37236,Integrability,message,message,37236,"ion TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedLibsvirtual void AddLinkedLibs(const char *linkedLib)Add linkedLib to already set linked libs.Definition TSystem.cxx:4170; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::GetBuildCompilerVersionvirtual const char * GetBuildCompilerVersion() constReturn the build compiler version.Definition TSystem.cxx:3891; TSystem::ResetSignalvirtual void ResetSignal(ESignals sig, Bool_t reset=kTRUE)If reset is true reset the signal handler for the specified signal to the default handler,...Definition TSystem.cxx:576; TSystem::cdBool_t cd(const char *path)Definition TSystem.h:423; TSystem::GetSockNamevirtual TInetAddress GetSockName(int sock)Get Internet Protocol (IP) address of host and port #.Definition TSystem.cxx:23",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:41837,Integrability,interface,interface,41837,"nstReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::operator=TSystem & operator=(const TSystem &)=delete; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fSt",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:42727,Integrability,interface,interface,42727,"tem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::operator=TSystem & operator=(const TSystem &)=delete; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fStdExceptionHandlerDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::RecvBufvirtual int RecvBuf(int sock, void *buffer, int length)Receive a buffer headed by a length indicator.Definition TSystem.cxx:2418; TSystem::fHostnameTString fHostnameDefinition TSystem.h:285; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (s",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:50860,Integrability,protocol,protocol,50860,"TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetHomeDirectoryvirtual std::string GetHomeDirectory(const char *userName=nullptr) constReturn the user's home directory.Definition TSystem.cxx:",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:52358,Integrability,interface,interface,52358,"stem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetHomeDirectoryvirtual std::string GetHomeDirectory(const char *userName=nullptr) constReturn the user's home directory.Definition TSystem.cxx:895; TSystem::AnnounceTcpServicevirtual int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1)Announce TCP/IP service.Definition TSystem.cxx:2345; TSystem::UnixPathNamevirtual const char * UnixPathName(const char *unixpathname)Convert from a local pathname to a Unix pathname.Definition TSystem.cxx:1063; TSystem::RecvRawvirtual int RecvRaw(int sock, void *buffer, int length, int flag)Receive exactly length bytes into buffer.Definition TSystem.cxx:2399; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::fWritereadyTFdSet * fWritereadyFiles with reads waiting.Definition TSystem.h:278; TSystem::GetCryptoRandomvirtual Int_t GetCryptoRandom(void *buf, Int_t len)Return cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TSystem.cxx:266; TSystem::DispatchOneEventvirtual void DispatchOneEvent(Bool_t pendingOnly=kFALSE)Dispatch a single event.Definition TSystem.cxx:429; TSystem::Renamevirtual int Rename(const char *from, ",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:62049,Integrability,protocol,protocol,62049,"n TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetErrorStrconst char * GetErrorStr() constDefinition TSystem.h:350; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:64484,Integrability,interface,interface,64484,"rtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; nconst Int_t nDefinition legend1.C:16; CpuInfo_tDefinition TSystem.h:163; CpuInfo_t::~CpuInfo_tvirtual ~CpuInfo_t()Definition TSystem.h:173; CpuInfo_t::fIdleFloat_t fIdleDefinition TSystem.h:170; CpuInfo_t::fLoad15mFloat_t fLoad15mDefinition TSystem.h:166; CpuInfo_t::fUserFloat_t fUserDefinition TSystem.h:167; CpuInfo_t::fLoad1mFloat_t fLoad1mDefinition TSystem.h:164; CpuInfo_t::CpuInfo_tCpuInfo_t()Definition TSystem.h:171; CpuInfo_t::fSysFloat_t fSysDefinition TSystem.h:168; CpuInfo_t::fTotalFloat_t fTotalDefinition TSystem.h:169; CpuInfo_t::fLoad5mFloat_t fLoad5mDefinition TSystem.h:165; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; FileStat_t::fSizeLong64_t fSizeDefinition TSystem.h:128; FileStat_t::FileStat_tFileStat_t()Definition TSystem.h:132; FileStat_t::fDevLong_t fDevDefinition TSystem.h:123; FileStat_t::fUrlTString fUrlDefinition TSystem.h:131; FileStat_t::fGidIn",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:11698,Modifiability,config,configure,11698,"7 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to ./configure); 303 TString fBuildCompiler; //Compiler used to build this ROOT; 304 TString fBuildCompilerVersion; //Compiler version used to build this ROOT; 305 TString fBuildCompilerVersionStr; //Compiler version identifier string used to build this ROOT; 306 TString fBuildNode; //Detailed information where ROOT was built; 307 TString fBuildDir; //Location where to build ACLiC shared library and use as scratch area.; 308 TString fFlagsDebug; //Flags for debug compilation; 309 TString fFlagsOpt; //Flags for optimized compilation; 310 TString fListPaths; //List of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMake",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:41943,Modifiability,variab,variable,41943,"og(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TSystem.cxx:235; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::SetFlagsOptvirtual void SetFlagsOpt(const char *)FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in op...Definition TSystem.cxx:4065; TSystem::operator=TSystem & operator=(const TSystem &)=delete; TSystem::RemoveOnExitvoid RemoveOnExit(TObject *obj)Objects that should be deleted on exit of the OS interface.Definition TSystem.cxx:292; TSystem::fStdExceptionHandlerTSeqCollection * fStdExceptionHandlerDefinition TSystem.h:297; TSystem::GetServiceByPortvirtual char * GetServiceByPort(int p",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:43928,Modifiability,variab,variable,43928,"char * GetServiceByPort(int port)Get name of internet service.Definition TSystem.cxx:2327; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::RecvBufvirtual int RecvBuf(int sock, void *buffer, int length)Receive a buffer headed by a length indicator.Definition TSystem.cxx:2418; TSystem::fHostnameTString fHostnameDefinition TSystem.h:285; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).Definition TSystem.cxx:494; TSystem::SetSockOptvirtual int SetSockOpt(int sock, int kind, int val)Set socket option.Definition TSystem.cxx:2436; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::RemoveStdExceptionHandlervirtual TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler *eh)Remove an exception handler from list of exception handlers.Definition TSystem.cxx:621; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::AcceptConnectionvirtual int AcceptConnection(int sock)Accept a connection.Definition TSystem.cxx:2381; TSystem::GetAclicPropertiesvirtual Int_t GetAclicProperties() constReturn the ACLiC properties field.Definition TSystem.cxx:3867; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::fWritemaskTFdSet * fWritemaskFiles that should be checked for read events.Definition TSystem.h:276; TSystem::fListLibsTString fListLibsDefinition TSystem.h:3",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:56160,Modifiability,variab,variable,56160,"ecked for write events.Definition TSystem.h:277; TSystem::fCompiledTSeqCollection * fCompiledDefinition TSystem.h:320; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TSystem::fBuildCompilerVersionTString fBuildCompilerVersionDefinition TSystem.h:304; TSystem::FindHelperTSystem * FindHelper(const char *path, void *dirptr=nullptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fInsideNotifystd::atomic< Bool_t > fInsideNotifyDefinition TSystem.h:286; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:60746,Modifiability,variab,variable,60746,"raries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetErrorStrconst char * GetErrorStr() constDefinition TSystem.h:350; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:63703,Modifiability,config,configured,63703,"ystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; nconst Int_t nDefinition legend1.C:16; CpuInfo_tDefinition TSystem.h:163; CpuInfo_t::~CpuInfo_tvirtual ~CpuInfo_t()Definition TSystem.h:173; CpuInfo_t::fIdle",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5141,Performance,cache,cache,5141," return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISLNK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFLNK); }; 118inline Bool_t R_ISFIFO(Int_t mode) { return ((mode & kS_IFMT) == kS_IFIFO); }; 119inline Bool_t R_ISSOCK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFSOCK); }; 120inline Bool_t R_ISOFF(Int_t mode) { return ((mode & kS_IFMT) == kS_IFOFF); }; 121 ; 122struct FileStat_t {; 123 Long_t fDev; // device id; 124 Long_t fIno; // inode; 125 Int_t fMode; // protection (combination of EFileModeMask bits); 126 Int_t fUid; // user id of owner; 127 Int_t fGid; // group id of owner; 128 Long64_t fSize; // total size in bytes; 129 Long_t fMtime; // modification date; 130 Bool_t fIsLink; // symbolic link; 131 TString fUrl; // end point url of file; 132 FileStat_t() : fDev(0), fIno(0), fMode(0), fUid(0), fGid(0), fSize(0),; 133 fMtime(0), fIsLink(kFALSE), fUrl("""") { }; 134};; 135 ; 136struct UserGroup_t {; 137 Int_t fUid; // user id; 138 Int_t fGid; // group id; 139 TString fUser; // user name; 140 TString fGroup; // group name; 141 TString fPasswd; // password; 142 TString fRealName; // user full name; 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5483,Performance,load,load,5483," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5534,Performance,load,load,5534," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5586,Performance,load,load,5586," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5641,Performance,load,load,5641," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5690,Performance,load,load,5690," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5746,Performance,load,load,5746," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:5978,Performance,load,load,5978," 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.; 161};; 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUs",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:6226,Performance,cache,cached,6226," 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUsed(0), fSwapFree(0), fSwapCached(0), fSReclaimable(0){ }; 192 virtual ~MemInfo_t() { }; 193 ClassDef(MemInfo_t, 2); // Memory utilization information.; 194};; 195 ; 196struct ProcInfo_t {; 197 Float_t fCpuUser; // user time used by this process in seconds; 198 Float_t fCpuSys; // system time used by this process in seconds; 199 Long_t fMemResident; // resident memory used by this process in KB; 200 Long_t fMemVirtual; // virtual memory used by this process in KB; 201 ProcInfo_t() : fCpuUser(0), fCpuSys(0), fMemResident(0),; 202 fMemVirtual(0) { }; 203 virtual ~ProcInfo_t();; 204 ClassDef(ProcInfo_t, 1);// System resource usage of given process.; 205};; 206 ; 207struct RedirectHandle_t {; 208 TString fFile; // F",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:6481,Performance,cache,cached,6481," 162 ; 163struct CpuInfo_t {; 164 Float_t fLoad1m; // cpu load average over 1 m; 165 Float_t fLoad5m; // cpu load average over 5 m; 166 Float_t fLoad15m; // cpu load average over 15 m; 167 Float_t fUser; // cpu user load in percentage; 168 Float_t fSys; // cpu sys load in percentage; 169 Float_t fTotal; // cpu user+sys load in percentage; 170 Float_t fIdle; // cpu idle percentage; 171 CpuInfo_t() : fLoad1m(0), fLoad5m(0), fLoad15m(0),; 172 fUser(0), fSys(0), fTotal(0), fIdle(0) { }; 173 virtual ~CpuInfo_t() { }; 174 ClassDef(CpuInfo_t, 1); // CPU load information.; 175};; 176 ; 177struct MemInfo_t {; 178 Int_t fMemTotal; // total RAM in MB; 179 Int_t fMemUsed; // used RAM in MB; 180 Int_t fMemFree; // free RAM in MB; 181 Int_t fMemAvailable; // available RAM in MB; 182 Int_t fMemCached; // cached RAM in MB; 183 Int_t fMemBuffer; // buffer RAM in MB; 184 Int_t fMemShared; // shared RAM in MB; 185 Int_t fSwapTotal; // total swap in MB; 186 Int_t fSwapUsed; // used swap in MB; 187 Int_t fSwapFree; // free swap in MB; 188 Int_t fSwapCached; // cached swap in MB; 189 Int_t fSReclaimable; // slab that might be reclaimed; 190 MemInfo_t() : fMemTotal(0), fMemUsed(0), fMemFree(0), fMemAvailable(0), fMemCached(0), fMemBuffer(0), fMemShared(0),; 191 fSwapTotal(0), fSwapUsed(0), fSwapFree(0), fSwapCached(0), fSReclaimable(0){ }; 192 virtual ~MemInfo_t() { }; 193 ClassDef(MemInfo_t, 2); // Memory utilization information.; 194};; 195 ; 196struct ProcInfo_t {; 197 Float_t fCpuUser; // user time used by this process in seconds; 198 Float_t fCpuSys; // system time used by this process in seconds; 199 Long_t fMemResident; // resident memory used by this process in KB; 200 Long_t fMemVirtual; // virtual memory used by this process in KB; 201 ProcInfo_t() : fCpuUser(0), fCpuSys(0), fMemResident(0),; 202 fMemVirtual(0) { }; 203 virtual ~ProcInfo_t();; 204 ClassDef(ProcInfo_t, 1);// System resource usage of given process.; 205};; 206 ; 207struct RedirectHandle_t {; 208 TString fFile; // F",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:11587,Performance,cache,cache,11587,"{; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to .",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:12209,Performance,optimiz,optimized,12209,"ers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //Architecture for which ROOT was built (passed to ./configure); 303 TString fBuildCompiler; //Compiler used to build this ROOT; 304 TString fBuildCompilerVersion; //Compiler version used to build this ROOT; 305 TString fBuildCompilerVersionStr; //Compiler version identifier string used to build this ROOT; 306 TString fBuildNode; //Detailed information where ROOT was built; 307 TString fBuildDir; //Location where to build ACLiC shared library and use as scratch area.; 308 TString fFlagsDebug; //Flags for debug compilation; 309 TString fFlagsOpt; //Flags for optimized compilation; 310 TString fListPaths; //List of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compile",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:39616,Performance,optimiz,optimized,39616,"rary.Definition TSystem.cxx:2044; TSystem::GetLinkedLibsvirtual const char * GetLinkedLibs() constReturn the list of library linked to this executable.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::InControlBool_t InControl() constDefinition TSystem.h:367; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.De",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:40267,Performance,load,loaded,40267,":Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h:385; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *in",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:47888,Performance,optimiz,optimized,47888,"em::fAclicModeEAclicMode fAclicModeDefinition TSystem.h:315; TSystem::GetPeerNamevirtual TInetAddress GetPeerName(int sock)Get Internet Protocol (IP) address of remote host and port #.Definition TSystem.cxx:2300; TSystem::GetListOfTimersvirtual TList * GetListOfTimers() constDefinition TSystem.h:393; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::GetSysInfovirtual int GetSysInfo(SysInfo_t *info) constReturns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t s...Definition TSystem.cxx:2458; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::GetMemInfovirtual int GetMemInfo(MemInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbol",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:48024,Performance,load,loaded,48024,"host and port #.Definition TSystem.cxx:2300; TSystem::GetListOfTimersvirtual TList * GetListOfTimers() constDefinition TSystem.h:393; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::GetSysInfovirtual int GetSysInfo(SysInfo_t *info) constReturns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t s...Definition TSystem.cxx:2458; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::GetMemInfovirtual int GetMemInfo(MemInfo_t *info) constReturns ram and swap memory usage info into the MemInfo_t structure.Definition TSystem.cxx:2479; TSystem::GetAclicModevirtual EAclicMode GetAclicMode() constAclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:3947; TSystem::GetLinkedLibrariesvirtual const char * GetLinkedLibraries()Get list of shared libraries loaded at the start of the executable.Definition TSystem.cxx:2120; TSystem::SetIncludePathvirtual void SetIncludePath(const char *includePath)IncludePath should contain the list of compiler flags to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExt",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:49245,Performance,load,load,49245,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::In",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:49262,Performance,load,load,49262,"to indicate where to find user defined header f...Definition TSystem.cxx:4194; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::In",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:49650,Performance,load,loaded,49650,"t char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListSymbolsvirtual void ListSymbols(const char *module, const char *re="""")List symbols in a shared library.Definition TSystem.cxx:2064; TSystem::DoBeepvirtual void DoBeep(Int_t=-1, Int_t=-1) constDefinition TSystem.h:332; TSystem::fObjExtTString fObjExtDefinition TSystem.h:314; TSystem::fLinkdefSuffixTString fLinkdefSuffixDefinition TSystem.h:318; TSystem::fBeepFreqInt_t fBeepFreqDefinition TSystem.h:287; TSystem::GetCpuInfovirtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) constReturns cpu load average and load info into the CpuInfo_t structure.Definition TSystem.cxx:2469; TSystem::EAclicPropertiesEAclicPropertiesDefinition TSystem.h:270; TSystem::kFlatBuildDir@ kFlatBuildDirDefinition TSystem.h:271; TSystem::GetListOfFileHandlersvirtual TSeqCollection * GetListOfFileHandlers() constDefinition TSystem.h:382; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EA",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:58152,Performance,load,loads,58152,"finition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix chosen by the user for ACLiC.Definition TSystem.cxx:4001; TSystem::SetDynamicPathvirtual void SetDynamicPath(const char *pathname)Set the dynamic path to a new value.Definition TSystem.cxx:1806; TSystem::fMakeSharedLibTString fMakeSharedLibDefinition TSystem.h:316; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::fMaxwfdInt_t fMaxwfdDefinition TSystem.h:282; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::AddStdExceptionHandlervirtual void AddStdExceptionHandler(TStdExceptionHandler *eh)Add an exception handler to list of system exception handlers.Definition TSystem.cxx:611; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:59811,Performance,load,loaded,59811,"virtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::SetPrognamevirtual void SetProgname(const char *name)Set the application name (from command line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set enviro",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:63867,Performance,optimiz,optimization,63867,"ystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::fBuildNodeTString fBuildNodeDefinition TSystem.h:306; TSystem::TempDirectoryvirtual const char * TempDirectory() constReturn a user configured or systemwide directory to create temporary files in.Definition TSystem.cxx:1482; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TSystem::ConsistentWithvirtual Bool_t ConsistentWith(const char *path, void *dirptr=nullptr)Check consistency of this helper with the one required by 'path' or 'dirptr'.Definition TSystem.cxx:804; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; nconst Int_t nDefinition legend1.C:16; CpuInfo_tDefinition TSystem.h:163; CpuInfo_t::~CpuInfo_tvirtual ~CpuInfo_t()Definition TSystem.h:173; CpuInfo_t::fIdleFloat_t fIdleDefinition TSystem.h:170; CpuInfo_t::fLoad15mFloat_t fLoad15mDefinition TSystem.h:166; CpuInfo_t::fUserFloat_t fUserDefinition TSy",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:9336,Safety,timeout,timeout,9336,"r SIGURG and SIGIO); 228 kAtMark, // are we at out-of-band mark (read only); 229 kBytesToRead // get number of bytes to read, FIONREAD (read only); 230};; 231 ; 232enum ESendRecvOptions {; 233 kDefault, // default option (= 0); 234 kOob, // send or receive out-of-band data; 235 kPeek, // peek at incoming message (receive only); 236 kDontBlock // send/recv as much data as possible without blocking; 237};; 238 ; 239typedef void (*Func_t)();; 240 ; 241R__EXTERN const char *gRootDir;; 242R__EXTERN const char *gProgName;; 243R__EXTERN const char *gProgPath;; 244R__EXTERN TVirtualMutex *gSystemMutex;; 245 ; 246 ; 247//////////////////////////////////////////////////////////////////////////; 248// //; 249// Asynchronous timer used for processing pending GUI and timer events //; 250// every delay ms. Call in a tight computing loop //; 251// TProcessEventTimer::ProcessEvent(). If the timer did timeout this //; 252// call will process the pending events and return kTRUE if the //; 253// TROOT::IsInterrupted() flag is set (can be done by hitting key in //; 254// canvas or selecting canvas menu item View/Interrupt. //; 255// //; 256//////////////////////////////////////////////////////////////////////////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSe",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:15423,Safety,timeout,timeout,15423," Bool_t Init();; 347 virtual void SetProgname(const char *name);; 348 virtual void SetDisplay();; 349 void SetErrorStr(const char *errstr);; 350 const char *GetErrorStr() const { return GetLastErrorString(); }; 351 virtual const char *GetError();; 352 virtual Int_t GetCryptoRandom(void *buf, Int_t len);; 353 void RemoveOnExit(TObject *obj);; 354 virtual const char *HostName();; 355 virtual void NotifyApplicationCreated();; 356 ; 357 static Int_t GetErrno();; 358 static void ResetErrno();; 359 void Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);; 360 void GetBeepDefaults(Int_t &freq, Int_t &duration) const { freq = fBeepFreq; duration = fBeepDuration; }; 361 ; 362 //---- EventLoop; 363 virtual void Run();; 364 virtual Bool_t ProcessEvents();; 365 virtual void DispatchOneEvent(Bool_t pendingOnly = kFALSE);; 366 virtual void ExitLoop();; 367 Bool_t InControl() const { return fInControl; }; 368 virtual void InnerLoop();; 369 virtual Int_t Select(TList *active, Long_t timeout);; 370 virtual Int_t Select(TFileHandler *fh, Long_t timeout);; 371 ; 372 //---- Handling of system events; 373 virtual void AddSignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHa",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:15484,Safety,timeout,timeout,15484,"e);; 348 virtual void SetDisplay();; 349 void SetErrorStr(const char *errstr);; 350 const char *GetErrorStr() const { return GetLastErrorString(); }; 351 virtual const char *GetError();; 352 virtual Int_t GetCryptoRandom(void *buf, Int_t len);; 353 void RemoveOnExit(TObject *obj);; 354 virtual const char *HostName();; 355 virtual void NotifyApplicationCreated();; 356 ; 357 static Int_t GetErrno();; 358 static void ResetErrno();; 359 void Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);; 360 void GetBeepDefaults(Int_t &freq, Int_t &duration) const { freq = fBeepFreq; duration = fBeepDuration; }; 361 ; 362 //---- EventLoop; 363 virtual void Run();; 364 virtual Bool_t ProcessEvents();; 365 virtual void DispatchOneEvent(Bool_t pendingOnly = kFALSE);; 366 virtual void ExitLoop();; 367 Bool_t InControl() const { return fInControl; }; 368 virtual void InnerLoop();; 369 virtual Int_t Select(TList *active, Long_t timeout);; 370 virtual Int_t Select(TFileHandler *fh, Long_t timeout);; 371 ; 372 //---- Handling of system events; 373 virtual void AddSignalHandler(TSignalHandler *sh);; 374 virtual TSignalHandler *RemoveSignalHandler(TSignalHandler *sh);; 375 virtual void ResetSignal(ESignals sig, Bool_t reset = kTRUE);; 376 virtual void ResetSignals();; 377 virtual void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE);; 378 virtual void IgnoreInterrupt(Bool_t ignore = kTRUE);; 379 virtual TSeqCollection *GetListOfSignalHandlers() const { return fSignalHandler; }; 380 virtual void AddFileHandler(TFileHandler *fh);; 381 virtual TFileHandler *RemoveFileHandler(TFileHandler *fh);; 382 virtual TSeqCollection *GetListOfFileHandlers() const { return fFileHandler; }; 383 virtual void AddStdExceptionHandler(TStdExceptionHandler *eh);; 384 virtual TStdExceptionHandler *RemoveStdExceptionHandler(TStdExceptionHandler *eh);; 385 virtual TSeqCollection *GetListOfStdExceptionHandlers() const { return fStdExceptionHandler; }; 386 ; 387 //---- Floating Point Exceptions Control;",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:56545,Safety,timeout,timeout,56545,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fInsideNotifystd::atomic< Bool_t > fInsideNotifyDefinition TSystem.h:286; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix c",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:4655,Security,password,password,4655," return ((mode & kS_IFMT) == kS_IFCHR); }; 115inline Bool_t R_ISBLK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFBLK); }; 116inline Bool_t R_ISREG(Int_t mode) { return ((mode & kS_IFMT) == kS_IFREG); }; 117inline Bool_t R_ISLNK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFLNK); }; 118inline Bool_t R_ISFIFO(Int_t mode) { return ((mode & kS_IFMT) == kS_IFIFO); }; 119inline Bool_t R_ISSOCK(Int_t mode) { return ((mode & kS_IFMT) == kS_IFSOCK); }; 120inline Bool_t R_ISOFF(Int_t mode) { return ((mode & kS_IFMT) == kS_IFOFF); }; 121 ; 122struct FileStat_t {; 123 Long_t fDev; // device id; 124 Long_t fIno; // inode; 125 Int_t fMode; // protection (combination of EFileModeMask bits); 126 Int_t fUid; // user id of owner; 127 Int_t fGid; // group id of owner; 128 Long64_t fSize; // total size in bytes; 129 Long_t fMtime; // modification date; 130 Bool_t fIsLink; // symbolic link; 131 TString fUrl; // end point url of file; 132 FileStat_t() : fDev(0), fIno(0), fMode(0), fUid(0), fGid(0), fSize(0),; 133 fMtime(0), fIsLink(kFALSE), fUrl("""") { }; 134};; 135 ; 136struct UserGroup_t {; 137 Int_t fUid; // user id; 138 Int_t fGid; // group id; 139 TString fUser; // user name; 140 TString fGroup; // group name; 141 TString fPasswd; // password; 142 TString fRealName; // user full name; 143 TString fShell; // user preferred shell; 144 UserGroup_t() : fUid(0), fGid(0), fUser(), fGroup(), fPasswd(),; 145 fRealName (), fShell() { }; 146};; 147 ; 148struct SysInfo_t {; 149 TString fOS; // OS; 150 TString fModel; // computer model; 151 TString fCpuType; // type of cpu; 152 Int_t fCpus; // number of cpus; 153 Int_t fCpuSpeed; // cpu speed in MHz; 154 Int_t fBusSpeed; // bus speed in MHz; 155 Int_t fL2Cache; // level 2 cache size in KB; 156 Int_t fPhysRam; // physical RAM in MB; 157 SysInfo_t() : fOS(), fModel(), fCpuType(), fCpus(0), fCpuSpeed(0),; 158 fBusSpeed(0), fL2Cache(0), fPhysRam(0) { }; 159 virtual ~SysInfo_t() { }; 160 ClassDef(SysInfo_t, 1); // System information - OS, CPU, RAM.",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:13337,Security,access,access,13337,"dePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; ",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:36325,Security,secur,secure,36325,"ion object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or the current directory.Definition TSystem.cxx:966; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::AnnounceUdpServicevirtual int AnnounceUdpService(int port, int backlog)Announce UDP service.Definition TSystem.cxx:2354; TSystem::fInControlBool_t fInControlDefinition TSystem.h:290; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fAclicPropertiesInt_t fAclicPropertiesDefinition TSystem.h:319; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::AddLinkedL",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:50671,Security,access,access,50671,"har *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Ch",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:50705,Security,access,access,50705,"har *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::SetMakeSharedLibvirtual void SetMakeSharedLib(const char *directives)Directives should contain the description on how to compile and link a shared lib.Definition TSystem.cxx:4145; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::InnerLoopvirtual void InnerLoop()Inner event loop.Definition TSystem.cxx:400; TSystem::GetVolumesvirtual TList * GetVolumes(Option_t *) constDefinition TSystem.h:455; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::OpenConnectionvirtual int OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"")Open a connection to another host.Definition TSystem.cxx:2336; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::IgnoreSignalvirtual void IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE)If ignore is true ignore the specified signal, else restore previous behaviour.Definition TSystem.cxx:593; TSystem::Runvirtual void Run()System event loop.Definition TSystem.cxx:343; TSystem::GetSockOptvirtual int GetSockOpt(int sock, int kind, int *val)Get socket option.Definition TSystem.cxx:2445; TSystem::ExitLoopvirtual void ExitLoop()Exit from event loop.Definition TSystem.cxx:392; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Ch",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:62562,Security,access,access,62562,"rStrconst char * GetErrorStr() constDefinition TSystem.h:350; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals hand",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:41003,Testability,log,log,41003,"d * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h:385; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::GetBuildDirvirtual const char * GetBuildDir() constReturn the path of the build directory.Definition TSystem.cxx:3915; TSystem::Openlogvirtual void Openlog(const char *name, Int_t options, ELogFacility facility)Open connection to system log daemon.Definition TSystem.cxx:1677; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::AddIncludePathvirtual void AddIncludePath(const char *includePath)Add a directory to the already set include path.Definition TSystem.cxx:4159; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::GetEffectiveGidvirtual Int_t GetEffectiveGid()Returns the effective group id.Definition TSystem.cxx:1591; TSystem::EAclicModeEAclicModeDefinition TSystem.h:269; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::kDebug@ kDebugDefinition TSystem.h:269; TSystem::kOpt@ kOptDefinition TSystem.h:269; TSystem::~TSystemvirtual ~TSystem()Delete the OS interface.Definition TSystem.cxx:139; TSystem::SetDisplayvirtual void SetDisplay()Set DISPLAY environment va",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TSystem_8h_source.html:60548,Testability,log,log,60548,"83; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::GetListOfSignalHandlersvirtual TSeqCollection * GetListOfSignalHandlers() constDefinition TSystem.h:379; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void SigAlarmInterruptsSyscalls(Bool_t)Definition TSystem.h:330; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::SetLinkedLibsvirtual void SetLinkedLibs(const char *linkedLibs)LinkedLibs should contain the library directory and list of libraries needed to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetErrorStrcons",MatchSource.WIKI,doc/master/TSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html
https://root.cern/doc/master/TText_8cxx_source.html:12717,Deployability,release,released,12717,"t(TMath::Sqrt(x2*x2+y2*y2)*2);; 354 if (Size<4) Size = 4;; 355 ; 356 SetTextSize(Size/sizetowin);; 357 TAttText::Modify();; 358 } else {; 359 dx = px - pxold; px1 += dx;; 360 dy = py - pyold; py1 += dy;; 361 }; 362 if (opaque) {; 363 if (ndcsav) this->SetNDC(kFALSE);; 364 this->SetX(gPad->PadtoX(gPad->AbsPixeltoX(px1)));; 365 this->SetY(gPad->PadtoY(gPad->AbsPixeltoY(py1)));; 366 if (resize) gPad->ShowGuidelines(this, event, 't', false);; 367 if ((!resize)&&(!turn)) gPad->ShowGuidelines(this, event, 'i', true);; 368 gPad->ShowGuidelines(this, event, !resize&!turn);; 369 this->SetTextAngle(theta);; 370 gPad->Modified(kTRUE);; 371 gPad->Update();; 372 }; 373 if (!opaque) PaintControlBox(px1, py1, -theta);; 374 pxold = px; pyold = py;; 375 break;; 376 ; 377 case kButton1Up:; 378 if (opaque) {; 379 if (ndcsav && !this->TestBit(kTextNDC)) {; 380 this->SetX((fX - gPad->GetX1())/(gPad->GetX2()-gPad->GetX1()));; 381 this->SetY((fY - gPad->GetY1())/(gPad->GetY2()-gPad->GetY1()));; 382 this->SetNDC();; 383 }; 384 gPad->ShowGuidelines(this, event, !resize&!turn);; 385 } else {; 386 if (TestBit(kTextNDC)) {; 387 dpx = gPad->GetX2() - gPad->GetX1();; 388 dpy = gPad->GetY2() - gPad->GetY1();; 389 xp1 = gPad->GetX1();; 390 yp1 = gPad->GetY1();; 391 fX = (gPad->AbsPixeltoX(px1)-xp1)/dpx;; 392 fY = (gPad->AbsPixeltoY(py1)-yp1)/dpy;; 393 } else {; 394 fX = gPad->PadtoX(gPad->AbsPixeltoX(px1));; 395 fY = gPad->PadtoY(gPad->AbsPixeltoY(py1));; 396 }; 397 fTextAngle = theta;; 398 }; 399 gPad->Modified(kTRUE);; 400 break;; 401 ; 402 case kButton1Locate:; 403 ExecuteEvent(kButton1Down, px, py);; 404 ; 405 while (1) {; 406 px = py = 0;; 407 event = gVirtualX->RequestLocator(1, 1, px, py);; 408 ; 409 ExecuteEvent(kButton1Motion, px, py);; 410 ; 411 if (event != -1) { // button is released; 412 ExecuteEvent(kButton1Up, px, py);; 413 return;; 414 }; 415 }; 416 }; 417}; 418 ; 419////////////////////////////////////////////////////////////////////////////////; 420/// Return the text control box.",MatchSource.WIKI,doc/master/TText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TText_8cxx_source.html
https://root.cern/doc/master/TText_8h_source.html:1252,Safety,detect,detection,1252,"); 27 void *fWcsTitle{nullptr}; ///<!Used by TMathText; 28 ; 29public:; 30 // TText status bits; 31 enum {; 32 kTextNDC = BIT(14) ///< The text position is in the NDC space; 33 };; 34 ; 35 TText() {} // NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see ROOT-10300; 36 TText(Double_t x, Double_t y, const char *text);; 37 TText(Double_t x, Double_t y, const wchar_t *text);; 38 TText(const TText &text);; 39 ~TText() override;; 40 ; 41 TText &operator=(const TText &src);; 42 ; 43 void Copy(TObject &text) const override;; 44 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 45 virtual TText *DrawText(Double_t x, Double_t y, const char *text);; 46 virtual TText *DrawText(Double_t x, Double_t y, const wchar_t *text);; 47 virtual TText *DrawTextNDC(Double_t x, Double_t y, const char *text);; 48 virtual TText *DrawTextNDC(Double_t x, Double_t y, const wchar_t *text);; 49 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 50 ; 51 virtual void GetControlBox(Int_t x, ",MatchSource.WIKI,doc/master/TText_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TText_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:4656,Deployability,patch,patch,4656,"atic Bool_t fgInit; ///< true if the Init has been called; 86 static Bool_t fgKerning; ///< use kerning (true by default); 87 static FT_Library fgLibrary; ///< FreeType font library; 88 static Int_t fgNumGlyphs; ///< number of glyphs in the string; 89 static FT_Matrix *fgRotMatrix; ///< rotation matrix; 90 static Bool_t fgSmoothing; ///< use anti-aliasing (true when >8 planes, false otherwise); 91 static Int_t fgTBlankW; ///< trailing blanks width; 92 static Int_t fgWidth; ///< string width, used to compute X alignment; 93 ; 94public:; 95 static Short_t CharToUnicode(UInt_t code);; 96 static void LayoutGlyphs();; 97 static void PrepareString(const char *string);; 98 static void PrepareString(const wchar_t *string);; 99 static void SetRotationMatrix(Float_t angle);; 100 ; 101public:; 102 TTF() { }; 103 virtual ~TTF();; 104 ; 105 static void Init();; 106 static void Cleanup();; 107 static void ComputeTrailingBlanksWidth(Int_t n);; 108 static Int_t GetAscent();; 109 static const FT_BBox &GetBox();; 110 static TTGlyph *GetGlyphs();; 111 static Bool_t GetHinting();; 112 static Bool_t GetKerning();; 113 static Int_t GetNumGlyphs();; 114 static FT_Matrix *GetRotMatrix();; 115 static Bool_t GetSmoothing();; 116 static Int_t GetTrailingBlanksWidth();; 117 static Int_t GetWidth();; 118 static void SetHinting(Bool_t state);; 119 static void SetKerning(Bool_t state);; 120 static void SetSmoothing(Bool_t state);; 121 static void GetTextExtent(UInt_t &w, UInt_t &h, char *text);; 122 static void GetTextExtent(UInt_t &w, UInt_t &h, wchar_t *text);; 123 static void GetTextAdvance(UInt_t &a, char *text);; 124 static void SetTextFont(Font_t fontnumber);; 125 static Int_t SetTextFont(const char *fontname, Int_t italic=0);; 126 static void SetTextSize(Float_t textsize);; 127 static Bool_t IsInitialized();; 128 static void Version(Int_t &major, Int_t &minor, Int_t &patch);; 129 ; 130 ClassDef(TTF,0) //Interface to TTF font handling; 131};; 132 ; 133#endif; a#define a(i)Definition RSha256.",MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:7841,Deployability,patch,patch,7841,"ition TTF.h:67; TTFInterface to the freetype 2 library.Definition TTF.h:53; TTF::SetKerningstatic void SetKerning(Bool_t state)Set kerning flag.Definition TTF.cxx:340; TTF::fgHintingstatic Bool_t fgHintinguse hinting (true by default)Definition TTF.h:84; TTF::kMaxGlyphs@ kMaxGlyphsDefinition TTF.h:73; TTF::kTTMaxFonts@ kTTMaxFontsDefinition TTF.h:73; TTF::IsInitializedstatic Bool_t IsInitialized()Definition TTF.cxx:615; TTF::GetTextAdvancestatic void GetTextAdvance(UInt_t &a, char *text)Get advance (a) when text is horizontal.Definition TTF.cxx:170; TTF::PrepareStringstatic void PrepareString(const char *string)Put the characters in ""string"" in the ""glyphs"" array.Definition TTF.cxx:272; TTF::fgGlyphsstatic TTF::TTGlyph fgGlyphs[kMaxGlyphs]glyphsDefinition TTF.h:83; TTF::GetKerningstatic Bool_t GetKerning()Definition TTF.cxx:601; TTF::fgSmoothingstatic Bool_t fgSmoothinguse anti-aliasing (true when >8 planes, false otherwise)Definition TTF.h:90; TTF::Versionstatic void Version(Int_t &major, Int_t &minor, Int_t &patch)Definition TTF.cxx:587; TTF::GetTrailingBlanksWidthstatic Int_t GetTrailingBlanksWidth()Definition TTF.cxx:650; TTF::SetHintingstatic void SetHinting(Bool_t state)Set hinting flag.Definition TTF.cxx:332; TTF::Initstatic void Init()Initialise the TrueType fonts interface.Definition TTF.cxx:65; TTF::fgFacestatic FT_Face fgFace[kTTMaxFonts]font faceDefinition TTF.h:82; TTF::fgCharMapstatic FT_CharMap fgCharMap[kTTMaxFonts]font character mapDefinition TTF.h:77; TTF::LayoutGlyphsstatic void LayoutGlyphs()Compute the glyphs positions, fgAscent and fgWidth (needed for alignment).Definition TTF.cxx:203; TTF::SetSmoothingstatic void SetSmoothing(Bool_t state)Set smoothing (anti-aliasing) flag.Definition TTF.cxx:371; TTF::SetRotationMatrixstatic void SetRotationMatrix(Float_t angle)Set the rotation matrix used to rotate the font outlines.Definition TTF.cxx:348; TTF::TTFTTF()Definition TTF.h:102; TTF::CharToUnicodestatic Short_t CharToUnicode(UInt_t code)Map char t",MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:6356,Integrability,interface,interface,6356,"on TGWin32VirtualXProxy.cxx:60; SetTextFontOption_t Option_t SetTextFontDefinition TGWin32VirtualXProxy.cxx:60; textsizeOption_t Option_t textsizeDefinition TGWin32VirtualXProxy.cxx:58; angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; fontnameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char fontnameDefinition TGWin32VirtualXProxy.cxx:228; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TGWin32This class is the basic interface to the Win32 graphics system.Definition TGWin32.h:64; TGX11TTFInterface to low level X11 (Xlib).Definition TGX11TTF.h:27; TMathTextRendererDefinition TMathText.cxx:55; TTF::TTGlyphTTF helper class containing glyphs description.Definition TTF.h:65; TTF::TTGlyph::fPosFT_Vector fPosposition of glyph originDefinition TTF.h:68; TTF::TTGlyph::fImageFT_Glyph fImageglyph imageDefinition TTF.h:69; TTF::TTGlyph::fIndexUInt_t fIndexglyph index in faceDefinition TTF.h:67; TTFInterface to the freetype 2 library.Definition TTF.h:53; TTF::SetKerningstatic void SetKerning(Bool_t state)Set kerning flag.Definition TTF.cxx:340; TTF::fgHintingstatic Bool_t fgHintinguse hinting (true by default)Definition TTF.h:84; TTF::kMaxGlyphs@ kMaxGlyphsDefinition TTF.h:73; TTF::kTTMaxFonts@ kTTMaxFontsDefinition TTF.h:73; TTF::IsInitializedstatic Bool_t IsInitialized()Definition TTF.cxx:615; TTF::GetTextAdvancestatic void GetTextAdvance(UInt_t &a, char *text)Get advance (a) when text is horizontal.Definitio",MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:8108,Integrability,interface,interface,8108,"lyphs@ kMaxGlyphsDefinition TTF.h:73; TTF::kTTMaxFonts@ kTTMaxFontsDefinition TTF.h:73; TTF::IsInitializedstatic Bool_t IsInitialized()Definition TTF.cxx:615; TTF::GetTextAdvancestatic void GetTextAdvance(UInt_t &a, char *text)Get advance (a) when text is horizontal.Definition TTF.cxx:170; TTF::PrepareStringstatic void PrepareString(const char *string)Put the characters in ""string"" in the ""glyphs"" array.Definition TTF.cxx:272; TTF::fgGlyphsstatic TTF::TTGlyph fgGlyphs[kMaxGlyphs]glyphsDefinition TTF.h:83; TTF::GetKerningstatic Bool_t GetKerning()Definition TTF.cxx:601; TTF::fgSmoothingstatic Bool_t fgSmoothinguse anti-aliasing (true when >8 planes, false otherwise)Definition TTF.h:90; TTF::Versionstatic void Version(Int_t &major, Int_t &minor, Int_t &patch)Definition TTF.cxx:587; TTF::GetTrailingBlanksWidthstatic Int_t GetTrailingBlanksWidth()Definition TTF.cxx:650; TTF::SetHintingstatic void SetHinting(Bool_t state)Set hinting flag.Definition TTF.cxx:332; TTF::Initstatic void Init()Initialise the TrueType fonts interface.Definition TTF.cxx:65; TTF::fgFacestatic FT_Face fgFace[kTTMaxFonts]font faceDefinition TTF.h:82; TTF::fgCharMapstatic FT_CharMap fgCharMap[kTTMaxFonts]font character mapDefinition TTF.h:77; TTF::LayoutGlyphsstatic void LayoutGlyphs()Compute the glyphs positions, fgAscent and fgWidth (needed for alignment).Definition TTF.cxx:203; TTF::SetSmoothingstatic void SetSmoothing(Bool_t state)Set smoothing (anti-aliasing) flag.Definition TTF.cxx:371; TTF::SetRotationMatrixstatic void SetRotationMatrix(Float_t angle)Set the rotation matrix used to rotate the font outlines.Definition TTF.cxx:348; TTF::TTFTTF()Definition TTF.h:102; TTF::CharToUnicodestatic Short_t CharToUnicode(UInt_t code)Map char to unicode. Returns 0 in case no mapping exists.Definition TTF.cxx:99; TTF::GetAscentstatic Int_t GetAscent()Definition TTF.cxx:629; TTF::GetTextExtentstatic void GetTextExtent(UInt_t &w, UInt_t &h, char *text)Get width (w) and height (h) when text is horizontal.Def",MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:2533,Performance,load,loaded,2533,; 63*/; 64 ; 65 class TTGlyph {; 66 public:; 67 UInt_t fIndex{0}; ///< glyph index in face; 68 FT_Vector,MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTF_8h_source.html:10818,Performance,load,loadedDefinition,10818,"nt_t fgAscentstring ascent, used to compute Y alignmentDefinition TTF.h:75; TTF::fgWidthstatic Int_t fgWidthstring width, used to compute X alignmentDefinition TTF.h:92; TTF::fgInitstatic Bool_t fgInittrue if the Init has been calledDefinition TTF.h:85; TTF::fgCurFontIdxstatic Int_t fgCurFontIdxcurrent font indexDefinition TTF.h:78; TTF::fgSymbItaFontIdxstatic Int_t fgSymbItaFontIdxSymbol italic font index.Definition TTF.h:79; TTF::Cleanupstatic void Cleanup()Cleanup. Is called by the gCleanupTTF destructor.Definition TTF.cxx:82; TTF::ComputeTrailingBlanksWidthstatic void ComputeTrailingBlanksWidth(Int_t n)Compute the trailing blanks width.Definition TTF.cxx:133; TTF::~TTFvirtual ~TTF()Cleanup TTF environment.Definition TTF.cxx:57; TTF::GetWidthstatic Int_t GetWidth()Definition TTF.cxx:622; TTF::GetBoxstatic const FT_BBox & GetBox()Definition TTF.cxx:657; TTF::fgFontNamestatic char * fgFontName[kTTMaxFonts]font nameDefinition TTF.h:81; TTF::fgLibrarystatic FT_Library fgLibraryFreeType font library.Definition TTF.h:87; TTF::fgNumGlyphsstatic Int_t fgNumGlyphsnumber of glyphs in the stringDefinition TTF.h:88; TTF::fgRotMatrixstatic FT_Matrix * fgRotMatrixrotation matrixDefinition TTF.h:89; TTF::fgKerningstatic Bool_t fgKerninguse kerning (true by default)Definition TTF.h:86; TTF::fgTBlankWstatic Int_t fgTBlankWtrailing blanks widthDefinition TTF.h:91; TTF::GetHintingstatic Bool_t GetHinting()Definition TTF.cxx:594; TTF::GetSmoothingstatic Bool_t GetSmoothing()Definition TTF.cxx:608; TTF::fgFontCountstatic Int_t fgFontCountnumber of fonts loadedDefinition TTF.h:80; TTF::GetRotMatrixstatic FT_Matrix * GetRotMatrix()Definition TTF.cxx:643; TTF::fgCBoxstatic FT_BBox fgCBoxstring control boxDefinition TTF.h:76; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. graf2dgrafincTTF.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTF_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTF_8h_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:1485,Safety,timeout,timeout,1485,"REDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTimer; 13\ingroup Base; 14 ; 15Handles synchronous and a-synchronous timer events.; 161. synchronous timer is registered into TSystem and is processed; 17 within the standard ROOT event-loop.; 182. asynchronous timer is passed to the operating system which sends; 19 an external signal to ROOT and thus interrupts its event-loop.; 20 ; 21You can use this class in one of the following ways:; 22 - Sub-class TTimer and override the Notify() method.; 23 - Re-implement the TObject::HandleTimer() method in your class; 24 and pass a pointer to this object to timer, see the SetObject(); 25 method.; 26 - Pass an interpreter command to timer, see SetCommand() method.; 27 - Create a TTimer, connect its Timeout() signal to the; 28 appropriate methods. Then when the time is up it will emit a; 29 Timeout() signal and call connected slots.; 30 ; 31Minimum timeout interval is defined in TSystem::ESysConstants as; 32`kItimerResolution` (currently 10 ms).; 33 ; 34Signal/slots example:; 35~~~{.cpp}; 36 TTimer *timer = new TTimer();; 37 timer->Connect(""Timeout()"", ""myObjectClassName"",; 38 myObject, ""TimerDone()"");; 39 timer->Start(2000, kTRUE); // 2 seconds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem);",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:1861,Safety,timeout,timeout,1861,"ered into TSystem and is processed; 17 within the standard ROOT event-loop.; 182. asynchronous timer is passed to the operating system which sends; 19 an external signal to ROOT and thus interrupts its event-loop.; 20 ; 21You can use this class in one of the following ways:; 22 - Sub-class TTimer and override the Notify() method.; 23 - Re-implement the TObject::HandleTimer() method in your class; 24 and pass a pointer to this object to timer, see the SetObject(); 25 method.; 26 - Pass an interpreter command to timer, see SetCommand() method.; 27 - Create a TTimer, connect its Timeout() signal to the; 28 appropriate methods. Then when the time is up it will emit a; 29 Timeout() signal and call connected slots.; 30 ; 31Minimum timeout interval is defined in TSystem::ESysConstants as; 32`kItimerResolution` (currently 10 ms).; 33 ; 34Signal/slots example:; 35~~~{.cpp}; 36 TTimer *timer = new TTimer();; 37 timer->Connect(""Timeout()"", ""myObjectClassName"",; 38 myObject, ""TimerDone()"");; 39 timer->Start(2000, kTRUE); // 2 seconds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 8",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:2765,Safety,timeout,timeout,2765,"ds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 80/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 81/// i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; 82/// a-synchronous. The default is synchronous. Add a timer to the system; 83/// eventloop by calling TurnOn(). Set command to be executed from Notify(); 84/// or set the object whose HandleTimer() method will be called via Notify(),; 85/// derive from TTimer and override Notify() or connect slots to the; 86/// signals Timeout(), TurnOn() and TurnOff().; 87 ; 88TTimer::TTimer(Long_t ms, Bool_t mode) : fTime(ms); 89{; 90 fObject = nullptr;; 91 fCommand = """";; 92 fSync = mode;; 93 fIntSyscalls = kFALSE;; 94 Reset();; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Create timer that times out in ms milliseconds. If mode == kTRUE then; 99/// the timer is synchronous else a-synchronous. The default is synchronous.; 100/// Add a timer to the system eventloop by calling TurnOn().; 101/// The object's HandleTimer() will be ca",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:2793,Safety,timeout,timeout,2793,"ds single-shot; 40~~~; 41To emit the Timeout signal repeatedly with minimum timeout:; 42~~~ {.cpp}; 43 timer->Start(0, kFALSE);; 44~~~; 45*/; 46 ; 47#include ""TTimer.h""; 48#include ""TSystem.h""; 49#include ""TROOT.h""; 50 ; 51ClassImp(TTimer);; 52 ; 53 ; 54class TSingleShotCleaner : public TTimer {; 55private:; 56 TList *fGarbage;; 57public:; 58 TSingleShotCleaner() : TTimer(10, kTRUE) { fGarbage = new TList(); }; 59 virtual ~TSingleShotCleaner() { fGarbage->Delete(); delete fGarbage; }; 60 void TurnOn() override; 61 {; 62 TObject *obj = (TObject *)gTQSender;; 63 fGarbage->Add(obj);; 64 Reset();; 65 if (gSystem); 66 gSystem->AddTimer(this);; 67 }; 68 Bool_t Notify() override; 69 {; 70 fGarbage->Delete();; 71 Reset();; 72 if (gSystem); 73 gSystem->RemoveTimer(this);; 74 return kTRUE;; 75 }; 76};; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Create timer that times out in ms milliseconds. If milliSec is 0; 80/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 81/// i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; 82/// a-synchronous. The default is synchronous. Add a timer to the system; 83/// eventloop by calling TurnOn(). Set command to be executed from Notify(); 84/// or set the object whose HandleTimer() method will be called via Notify(),; 85/// derive from TTimer and override Notify() or connect slots to the; 86/// signals Timeout(), TurnOn() and TurnOff().; 87 ; 88TTimer::TTimer(Long_t ms, Bool_t mode) : fTime(ms); 89{; 90 fObject = nullptr;; 91 fCommand = """";; 92 fSync = mode;; 93 fIntSyscalls = kFALSE;; 94 Reset();; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Create timer that times out in ms milliseconds. If mode == kTRUE then; 99/// the timer is synchronous else a-synchronous. The default is synchronous.; 100/// Add a timer to the system eventloop by calling TurnOn().; 101/// The object's HandleTimer() will be ca",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:6749,Safety,timeout,timeout,6749,"; 168 if (!fSync) gSystem->ResetTimer(this);; 169 }; 170}; 171 ; 172////////////////////////////////////////////////////////////////////////////////; 173/// Set the interpreter command to be executed at time out. Removes the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(thi",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:7062,Safety,timeout,timeout,7062," the; 174/// object to be notified (if it was set).; 175 ; 176void TTimer::SetCommand(const char *command); 177{; 178 fObject = nullptr;; 179 fCommand = command;; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has be",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:7105,Safety,timeout,timeout,7105," ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has been placed in the system timer list (using TurnOn()).; 228/// If a TTimer subclass is placed on another list, override TurnOff() to; 229/// remove the timer from the correct",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:7133,Safety,timeout,timeout,7133," ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Set the object to be notified at time out. Removes the command to; 184/// be executed (if it was set).; 185 ; 186void TTimer::SetObject(TObject *object); 187{; 188 fObject = object;; 189 fCommand = """";; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// When the argument is true the a-synchronous timer (SIGALRM) signal; 194/// handler is set so that interrupted syscalls will not be restarted; 195/// by the kernel. This is typically used in case one wants to put a; 196/// timeout on an I/O operation. By default interrupted syscalls will; 197/// be restarted.; 198 ; 199void TTimer::SetInterruptSyscalls(Bool_t set); 200{; 201 fIntSyscalls = set;; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Starts the timer with a milliSec timeout. If milliSec is 0; 206/// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; 207/// i.e. 10 ms), if milliSec is -1 then the time interval as previously; 208/// specified (in ctor or SetTime()) will be used.; 209/// If singleShot is kTRUE, the timer will be activated only once,; 210/// otherwise it will continue until it is stopped.; 211/// See also TurnOn(), Stop(), TurnOff().; 212 ; 213void TTimer::Start(Long_t milliSec, Bool_t singleShot); 214{; 215 if (milliSec >= 0); 216 SetTime(milliSec);; 217 Reset();; 218 TurnOn();; 219 if (singleShot); 220 Connect(this, ""Timeout()"", ""TTimer"", this, ""TurnOff()"");; 221 else; 222 Disconnect(this, ""Timeout()"", this, ""TurnOff()"");; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////////; 226/// Remove timer from system timer list. This requires that a timer; 227/// has been placed in the system timer list (using TurnOn()).; 228/// If a TTimer subclass is placed on another list, override TurnOff() to; 229/// remove the timer from the correct",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8cxx_source.html:13166,Safety,timeout,timeout,13166,"geDefinition TTimer.cxx:56; TSingleShotCleaner::TSingleShotCleanerTSingleShotCleaner()Definition TTimer.cxx:58; TString::LengthSsiz_t Length() constDefinition TString.h:417; TSystem::ResetTimervirtual void ResetTimer(TTimer *)Definition TSystem.h:396; TSystem::GetListOfTimersvirtual TList * GetListOfTimers() constDefinition TSystem.h:393; TSystem::Nowvirtual TTime Now()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TSystem.cxx:463; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::SetObjectvoid SetObject(TObject *object)Set the object to be notified at time out.Definition TTimer.cxx:186; TTimer::SingleShotstatic void SingleShot(Int_t milliSec, const char *receiver",MatchSource.WIKI,doc/master/TTimer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8cxx_source.html
https://root.cern/doc/master/TTimer_8h_source.html:1413,Safety,timeout,timeout,1413,"TSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTimer; 13#define ROOT_TTimer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has timed out; 57 Bool_t fSync; // true if synchrounous timer; 58 Bool_t fIntSyscalls; // true is a-synchronous timer is to interrupt system calls; 59 UInt_t fTimeID; // the system ID of this timer (for WIN32",MatchSource.WIKI,doc/master/TTimer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html
https://root.cern/doc/master/TTimer_8h_source.html:1820,Safety,timeout,timeout,1820,"7// //; 18// TTimer //; 19// //; 20// Handles synchronous and a-synchronous timer events. You can use //; 21// this class in one of the following ways: //; 22// - Sub-class TTimer and override the Notify() method. //; 23// - Re-implement the TObject::HandleTimer() method in your class //; 24// and pass a pointer to this object to timer, see the SetObject() //; 25// method. //; 26// - Pass an interpreter command to timer, see SetCommand() method. //; 27// - Create a TTimer, connect its Timeout() signal to the //; 28// appropriate methods. Then when the time is up it will emit a //; 29// Timeout() signal and call connected slots. //; 30// //; 31// Minimum timeout interval is defined in TSystem::ESysConstants as //; 32// kItimerResolution (currently 10 ms). //; 33// //; 34// Signal/slots example: //; 35// TTimer *timer = new TTimer(); //; 36// timer->Connect(""Timeout()"", ""myObjectClassName"", //; 37// myObject, ""TimerDone()""); //; 38// timer->Start(2000, kTRUE); // 2 seconds single-shot //; 39// //; 40// // Timeout signal is emitted repeadetly with minimum timeout //; 41// // timer->Start(0, kFALSE); //; 42// //; 43//////////////////////////////////////////////////////////////////////////; 44 ; 45#include ""TSysEvtHandler.h""; 46#include ""TTime.h""; 47#include ""TString.h""; 48 ; 49 ; 50 ; 51class TTimer : public TSysEvtHandler {; 52 ; 53protected:; 54 TTime fTime; // time out time in ms; 55 TTime fAbsTime; // absolute time out time in ms; 56 Bool_t fTimeout; // true if timer has timed out; 57 Bool_t fSync; // true if synchrounous timer; 58 Bool_t fIntSyscalls; // true is a-synchronous timer is to interrupt system calls; 59 UInt_t fTimeID; // the system ID of this timer (for WIN32); 60 TObject *fObject; // object to be notified (if any); 61 TString fCommand; // interpreter command to be executed; 62 ; 63private:; 64 TTimer(const TTimer&) = delete;; 65 TTimer& operator=(const TTimer&) = delete;; 66 ; 67public:; 68 TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE);; 69 TTimer(TO",MatchSource.WIKI,doc/master/TTimer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html
https://root.cern/doc/master/TTimer_8h_source.html:5716,Safety,timeout,timeout,5716," GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; TString.h; TSysEvtHandler.h; TTime.h; TObjectMother of all ROOT objects.Definition TObject.h:41; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TSysEvtHandlerAbstract base class for handling system events.Definition TSysEvtHandler.h:28; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::GetAbsTimeTTime GetAbsTime() constDefinition TTimer.h:78; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; TTimer::~TTimervirtual ~TTimer()Definition TTimer.h:71; TTimer::SetTimerIDvoid SetTimerID(UInt_t id=0)Definition TTimer.h:92; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::SetCommandvoid SetCommand(const char *command)Set the interpreter command to be executed at time out.Definition TTimer.cxx:176; TTimer::fCommandTString fCommandDefinition TTimer.h:61; TTimer::SetInterruptSyscallsvoid SetInterruptSyscalls(Bool_t set=kTRUE)When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted...Definition TTimer.cxx:199; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::GetCommandconst char * GetCommand() constDefinition TTimer.h:74; TTimer::fTimeTTime fTimeDefinition TTimer.h:54; TTimer::GetObjectTObject * GetObject()Definition TTimer.h:75; TTimer::Resetvoid Reset()Reset the timer.Defi",MatchSource.WIKI,doc/master/TTimer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTimer_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:33721,Availability,error,error,33721," TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetTitleColorvoid SetTitleColor(Int_t titlecolor)Definition TGaxis.h:131; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGaxis::SetNamevirtual void SetName(const char *name)Change the name of the axis.Definition TGaxis.cxx:2904; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.D",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:40409,Energy Efficiency,monitor,monitoredDefinition,40409,"tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormReal time scale factor for fGraphTime.Definition TTreePerfStats.h:57; TTreePerfStats::GetBasketInfoBasketInfo & GetBasketInfo(TBranch *b, size_t basketNumber)Return the BasketInfo corresponding to the given branch and basket.Definition TTreePerfStats.cxx:372; TTreePerfStats::fBasketsInfostd::vector< std::vector< BasketInfo > > fBasketsInfoDefinition TTreePerfStats.h:77; TTreePerfStats::fUnzipObjSizeLong64_t fUnzipObjSizeUncompressed bytes produced by the decompressor.Definition TTreePerfStats.h:63; TTreePerfStats::fWatchTStopwatch * fWatchTStopwatch pointer.Definition TTreePerfStats.h:72; TTreePerfStats::fTreeTTree * fTree! Pointer to the Tree being monitoredDefinition TTreePerfStats.h:68; TTreePerfStats::fHostInfoTString fHostInfoName of the host system, ROOT version and date.Definition TTreePerfStats.h:66; TTreePerfStats::Printvoid Print(Option_t *option="""") const overridePrint the TTree I/O perf stats.Definition TTreePerfStats.cxx:540; TTreePerfStats::fReadCallsInt_t fReadCallsNumber of read calls.Definition TTreePerfStats.h:53; TTreePerfStats::fBytesReadLong64_t fBytesReadNumber of bytes read.Definition TTreePerfStats.h:55; TTreePerfStats::UpdateBranchIndicesvoid UpdateBranchIndices(TObjArray *branchNames) overrideUpdate the fBranchIndexCache collection to match the current TTree given the ordered list of branch n...Definition TTreePerfStats.cxx:360; TTreePerfStats::GetDuplicateBasketCacheBasketList_t GetDuplicateBasketCache() constReturn the collection of baskets which have been read by the TTreeCache more than once.Definition TTreePerfStats.cxx:424; TTreePerfStats::fCpuTimeDouble_t fCpuTimeCpu time.Definition",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:45535,Integrability,interface,interface,45535,"ze_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; double; int; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; Drawth1 Draw(). treetreeplayersrcTTreePerfStats.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:06 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:31950,Modifiability,inherit,inherits,31950,"ributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TAttMarker::SaveMarkerAttributesvirtual void SaveMarkerAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttMarker.cxx:348; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Defin",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:688,Performance,perform,performance,688,". ROOT: tree/treeplayer/src/TTreePerfStats.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreePerfStats.cxx. Go to the documentation of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Rene Brun 29/10/09; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreePerfStats; 13 ; 14TTree I/O performance measurement. see example of use below.; 15 ; 16The function FileReadEvent is called from TFile::ReadBuffer.; 17For each call the following information is stored in fGraphIO; 18 - x[i] = Tree entry number; 19 - y[i] = 1e-6*(file position); 20 - ey[i] = 1e-9*number of bytes read; 21For each call the following information is stored in fGraphTime; 22 - x[i] = Tree entry number; 23 - y[i] = Time now; 24 - ey[i] = readtime, eg timenow - start; 25The TTreePerfStats object can be saved in a ROOT file in such a way that; 26its inspection can be done outside the job that generated it.; 27 ; 28Example of use:; 29~~~{.cpp}; 30{; 31 TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; 32 T = (TTree*)f->Get(""Events"");; 33 Long64_t nentries = T->GetEntries();; 34 T->SetCacheSize(10000000);; 35 T->SetCacheEntryRange(0,nentries);; 36 T->AddBranchToCache(""*"");; 37//; 38 TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; 39//; 40 for (Int_t i=0;i<nentries;i++) {; 41 T->GetEntry(i);; 42 }; 43 ps->SaveAs(""cmsperf.root"");; 44}; 45~~~; 46then, in a root interactive session, one can do:; 47~~~{.cpp}; 48 root > TFile f(""cmsperf.root"");; 49 root > ioperf->Draw();; 50 root > ioperf->Print();; 51~~~; 52The Draw or Print functions print the following information:; 53 - TreeCache = TTree cache size in",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:1988,Performance,cache,cache,1988,"TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; 32 T = (TTree*)f->Get(""Events"");; 33 Long64_t nentries = T->GetEntries();; 34 T->SetCacheSize(10000000);; 35 T->SetCacheEntryRange(0,nentries);; 36 T->AddBranchToCache(""*"");; 37//; 38 TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; 39//; 40 for (Int_t i=0;i<nentries;i++) {; 41 T->GetEntry(i);; 42 }; 43 ps->SaveAs(""cmsperf.root"");; 44}; 45~~~; 46then, in a root interactive session, one can do:; 47~~~{.cpp}; 48 root > TFile f(""cmsperf.root"");; 49 root > ioperf->Draw();; 50 root > ioperf->Print();; 51~~~; 52The Draw or Print functions print the following information:; 53 - TreeCache = TTree cache size in MBytes; 54 - N leaves = Number of leaves in the TTree; 55 - ReadTotal = Total number of zipped bytes read; 56 - ReadUnZip = Total number of unzipped bytes read; 57 - ReadCalls = Total number of disk reads; 58 - ReadSize = Average read size in KBytes; 59 - Readahead = Readahead size in KBytes; 60 - Readextra = Readahead overhead in percent; 61 - Real Time = Real Time in seconds; 62 - CPU Time = CPU Time in seconds; 63 - Disk Time = Real Time spent in pure raw disk IO; 64 - Disk IO = Raw disk IO speed in MBytes/second; 65 - ReadUZRT = Unzipped MBytes per RT second; 66 - ReadUZCP = Unipped MBytes per CP second; 67 - ReadRT = Zipped MBytes per RT second; 68 - ReadCP = Zipped MBytes per CP second; 69 ; 70 ### NOTE 1 :; 71The ReadTotal value indicates the effective number of zipped bytes; 72returned to the application. The physical number of bytes read; 73from the device (as measured for example with strace) is; 74ReadTotal +ReadTotal*Readextra/100. Same for ReadSize.; 75 ; 76 ### NOTE 2 :; 77A consequence of NOTE1, the Disk I/O speed corresponds to the effective; 78number of bytes returned to the application per second.; 79The Physical disk speed is DiskIO + DiskIO*ReadExtra/100.; 80*/; 81 ; 82#include ""TTreePerfStats.h""; 83#include ""TROOT.h""; 84#include ""TSystem.h""; 85#include ""TFile.h""; 86#include ""TTree.h"";",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:13193,Performance,cache,cache,13193," fGraphTime->GetEY()[i] = 0;; 353 }; 354}; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357/// Update the fBranchIndexCache collection to match the current TTree given; 358/// the ordered list of branch names.; 359 ; 360void TTreePerfStats::UpdateBranchIndices(TObjArray *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size(",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:13266,Performance,cache,cache,13266," fGraphTime->GetEY()[i] = 0;; 353 }; 354}; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357/// Update the fBranchIndexCache collection to match the current TTree given; 358/// the ordered list of branch names.; 359 ; 360void TTreePerfStats::UpdateBranchIndices(TObjArray *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size(",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:13434,Performance,cache,cache,13434,"ay *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerf",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:14746,Performance,cache,cache,14746,"; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerfStats::BasketList_t TTreePerfStats::GetDuplicateBasketCache() const; 425{; 426 BasketList_t result;; 427 ; 428 TFile *file = fTree->GetCurrentFile();; 429 if (!file); 430 return result;; 431 ; 432 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 433 if (!cache); 434 return result;; 435 ; 436 auto branches = cache->GetCachedBranches();; 437 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 438 bool first = true;; 439 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 440 auto &info(fBasketsInfo[i][j]);; 441 if ((info.fLoaded + info.fLoadedMiss) > 1) {; 442 if (first) {; 443 result.emplace_back(BasketList_t::value_type((TBranch*)branches->At(i), std::vector<size_t>(1)));; 444 first = false;; 445 }; 446 auto &ref( result.back() );; 447 ref.second.push_back(j);; 448 }; 449 }; 450 }; 451 ; 452 return result;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Draw the TTree I/O perf graph.; 457 ; 458void TTreePerfStats::Paint(Option_t *option); 459{; 460 Int_t npoin",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:14819,Performance,cache,cache,14819,"; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerfStats::BasketList_t TTreePerfStats::GetDuplicateBasketCache() const; 425{; 426 BasketList_t result;; 427 ; 428 TFile *file = fTree->GetCurrentFile();; 429 if (!file); 430 return result;; 431 ; 432 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 433 if (!cache); 434 return result;; 435 ; 436 auto branches = cache->GetCachedBranches();; 437 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 438 bool first = true;; 439 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 440 auto &info(fBasketsInfo[i][j]);; 441 if ((info.fLoaded + info.fLoadedMiss) > 1) {; 442 if (first) {; 443 result.emplace_back(BasketList_t::value_type((TBranch*)branches->At(i), std::vector<size_t>(1)));; 444 first = false;; 445 }; 446 auto &ref( result.back() );; 447 ref.second.push_back(j);; 448 }; 449 }; 450 }; 451 ; 452 return result;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Draw the TTree I/O perf graph.; 457 ; 458void TTreePerfStats::Paint(Option_t *option); 459{; 460 Int_t npoin",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:14873,Performance,cache,cache,14873,"; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerfStats::BasketList_t TTreePerfStats::GetDuplicateBasketCache() const; 425{; 426 BasketList_t result;; 427 ; 428 TFile *file = fTree->GetCurrentFile();; 429 if (!file); 430 return result;; 431 ; 432 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 433 if (!cache); 434 return result;; 435 ; 436 auto branches = cache->GetCachedBranches();; 437 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 438 bool first = true;; 439 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 440 auto &info(fBasketsInfo[i][j]);; 441 if ((info.fLoaded + info.fLoadedMiss) > 1) {; 442 if (first) {; 443 result.emplace_back(BasketList_t::value_type((TBranch*)branches->At(i), std::vector<size_t>(1)));; 444 first = false;; 445 }; 446 auto &ref( result.back() );; 447 ref.second.push_back(j);; 448 }; 449 }; 450 }; 451 ; 452 return result;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Draw the TTree I/O perf graph.; 457 ; 458void TTreePerfStats::Paint(Option_t *option); 459{; 460 Int_t npoin",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:20978,Performance,cache,cache,20978,"kTime);; 566 printf(""ReadUZRT = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fRealTime);; 567 printf(""ReadUZCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fCpuTime);; 568 printf(""ReadRT = %7.3f MBytes/s\n"",1e-6*fBytesRead/fRealTime);; 569 printf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.f",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21051,Performance,cache,cache,21051,"kTime);; 566 printf(""ReadUZRT = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fRealTime);; 567 printf(""ReadUZCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fCpuTime);; 568 printf(""ReadRT = %7.3f MBytes/s\n"",1e-6*fBytesRead/fRealTime);; 569 printf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.f",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21098,Performance,cache,cache,21098,"kTime);; 566 printf(""ReadUZRT = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fRealTime);; 567 printf(""ReadUZCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fCpuTime);; 568 printf(""ReadRT = %7.3f MBytes/s\n"",1e-6*fBytesRead/fRealTime);; 569 printf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.f",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21279,Performance,cache,cached,21279,"rintf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.fLoaded + info.fLoadedMiss) && !info.fUsed) {; 622 if (info.fLoadedMiss); 623 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 624 else; 625 printf(""%zu "", j);; 626 }; 627 }; 628 printf(""\n"");; 629 ; 630 if (all) {; 631 printf("" br=",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21551,Performance,cache,cached,21551,"ption);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.fLoaded + info.fLoadedMiss) && !info.fUsed) {; 622 if (info.fLoadedMiss); 623 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 624 else; 625 printf(""%zu "", j);; 626 }; 627 }; 628 printf(""\n"");; 629 ; 630 if (all) {; 631 printf("" br=%zu %s: "", i, branchname);; 632 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 633 auto &info(fBasketsInfo[i][j]);; 634 printf(""%zu[%d,%d,%d,%d] "", j, info.fUsed, info.fLoaded, info.fLoadedMiss, info.fMissed);; 635 }; 636 printf(""\n"");; 637 }; 638 }; 639 for (Int_t i = fBasketsInfo.size(); i ",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21856,Performance,cache,cached,21856,"asketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.fLoaded + info.fLoadedMiss) && !info.fUsed) {; 622 if (info.fLoadedMiss); 623 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 624 else; 625 printf(""%zu "", j);; 626 }; 627 }; 628 printf(""\n"");; 629 ; 630 if (all) {; 631 printf("" br=%zu %s: "", i, branchname);; 632 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 633 auto &info(fBasketsInfo[i][j]);; 634 printf(""%zu[%d,%d,%d,%d] "", j, info.fUsed, info.fLoaded, info.fLoadedMiss, info.fMissed);; 635 }; 636 printf(""\n"");; 637 }; 638 }; 639 for (Int_t i = fBasketsInfo.size(); i < branches->GetEntries(); ++i) {; 640 printf("" br=%d %s: no basket information\n"", i, branches->At(i)->GetName());; 641 }; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Save this object to filename; 646 ; 647void TTreePerfStats::SaveAs(const char *filenam",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:32910,Performance,cache,cache,32910,"37; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetTitleColorvoid SetTitleColor(Int_t titlecolor)Definition TGaxis.h:131; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGaxis::SetNamevirtual void SetName(const char *name)Change the name of the axis.Definition TGaxis.cxx:2904; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex an",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:38738,Performance,cache,cache,38738,"atstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TTextBase class for several text objects.Definition TText.h:22; TText::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a string.Definition TText.cxx:144; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::GetCachedBranchesconst TObjArray * GetCachedBranches() constDefinition TTreeCache.h:139; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfStats::fNleavesInt_t fNleavesNumber of leaves in the tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormRe",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:38938,Performance,perform,performance,38938,"tainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TTextBase class for several text objects.Definition TText.h:22; TText::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a string.Definition TText.cxx:144; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::GetCachedBranchesconst TObjArray * GetCachedBranches() constDefinition TTreeCache.h:139; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfStats::fNleavesInt_t fNleavesNumber of leaves in the tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormReal time scale factor for fGraphTime.Definition TTreePerfStats.h:57; TTreePerfStats::GetBasketInfoBasketInfo & GetBasketInfo(TBranch *b, size_t basketNumber)Return the BasketInfo corr",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:43300,Performance,cache,cache,43300,"avePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TTreePerfStats.cxx:657; TTreePerfStats::Classstatic TClass * Class(); TTreePerfStats::PrintBasketInfovoid PrintBasketInfo(Option_t *option="""") const overridePrint the TTree basket information.Definition TTreePerfStats.cxx:581; TTreePerfStats::Drawvoid Draw(Option_t *option="""") overrideDraw the TTree I/O perf graph.Definition TTreePerfStats.cxx:250; TTreePerfStats::fFileTFile * fFile! Pointer to the file containing the TreeDefinition TTreePerfStats.h:67; TTreePerfStats::GetHostInfoconst char * GetHostInfo() constDefinition TTreePerfStats.h:101; TTreePerfStats::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:217; TTreePerfStats::fRealTimeDouble_t fRealTimeReal time.Definition TTreePerfStats.h:58; TTreePerfStats::fReadaheadSizeInt_t fReadaheadSizeRead-ahead cache size.Definition TTreePerfStats.h:54; TTreePerfStats::fBranchIndexCachestd::unordered_map< TBranch *, size_t > fBranchIndexCacheDefinition TTreePerfStats.h:76; TTreePerfStats::~TTreePerfStats~TTreePerfStats() overrideDestructor.Definition TTreePerfStats.cxx:188; TTreePerfStats::fDiskTimeDouble_t fDiskTimeTime spent in pure raw disk IO.Definition TTreePerfStats.h:60; TTreePerfStats::fRealTimeAxisTGaxis * fRealTimeAxisPointer to TGaxis object showing real-time.Definition TTreePerfStats.h:73; TTreePerfStats::fUnzipTimeDouble_t fUnzipTimeTime spent uncompressing the data.Definition TTreePerfStats.h:61; TTreePerfStats::BasketList_tstd::vector< std::pair< TBranch *, std::vector< size_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraph",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:44601,Performance,cache,cache,44601,"rfStats.cxx:188; TTreePerfStats::fDiskTimeDouble_t fDiskTimeTime spent in pure raw disk IO.Definition TTreePerfStats.h:60; TTreePerfStats::fRealTimeAxisTGaxis * fRealTimeAxisPointer to TGaxis object showing real-time.Definition TTreePerfStats.h:73; TTreePerfStats::fUnzipTimeDouble_t fUnzipTimeTime spent uncompressing the data.Definition TTreePerfStats.h:61; TTreePerfStats::BasketList_tstd::vector< std::pair< TBranch *, std::vector< size_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for th",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:45568,Performance,perform,performance,45568,"ze_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; double; int; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; Drawth1 Draw(). treetreeplayersrcTTreePerfStats.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:06 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:12580,Usability,clear,clear,12580,"40 fRealTime = fWatch->RealTime();; 341 fCpuTime = fWatch->CpuTime();; 342 if (fUnzipInputSize); 343 fCompress = ((double)fUnzipObjSize) / fUnzipInputSize;; 344 Int_t npoints = fGraphIO->GetN();; 345 if (!npoints) return;; 346 Double_t iomax = TMath::MaxElement(npoints,fGraphIO->GetY());; 347 fRealNorm = iomax/fRealTime;; 348 fGraphTime->GetY()[0] = fRealNorm*fGraphTime->GetEY()[0];; 349 // we normalize the fGraphTime such that it can be drawn on top of fGraphIO; 350 for (Int_t i=1;i<npoints;i++) {; 351 fGraphTime->GetY()[i] = fGraphTime->GetY()[i-1] +fRealNorm*fGraphTime->GetEY()[i];; 352 fGraphTime->GetEY()[i] = 0;; 353 }; 354}; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357/// Update the fBranchIndexCache collection to match the current TTree given; 358/// the ordered list of branch names.; 359 ; 360void TTreePerfStats::UpdateBranchIndices(TObjArray *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 3",MatchSource.WIKI,doc/master/TTreePerfStats_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:10628,Availability,error,error,10628,"Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TString.h; TVirtualPerfStats.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTextBase class for several text objects.Definition TText.h:22; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::GetNumEventsLong64_t GetNumEvents() const overrideDefinition TTreePerfStats.h:104; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::SetUsedvoid SetUsed(size_t bi, size_t basketNumber) overrideD",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:2860,Energy Efficiency,monitor,monitored,2860,"/< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:14254,Energy Efficiency,monitor,monitoredDefinition,14254,"ePerfStats::fRealNormDouble_t fRealNormReal time scale factor for fGraphTime.Definition TTreePerfStats.h:57; TTreePerfStats::FileEventvoid FileEvent(const char *, const char *, const char *, const char *, bool) overrideDefinition TTreePerfStats.h:118; TTreePerfStats::GetBasketInfoBasketInfo & GetBasketInfo(TBranch *b, size_t basketNumber)Return the BasketInfo corresponding to the given branch and basket.Definition TTreePerfStats.cxx:372; TTreePerfStats::PacketEventvoid PacketEvent(const char *, const char *, const char *, Long64_t, Double_t, Double_t, Double_t, Long64_t) overrideDefinition TTreePerfStats.h:116; TTreePerfStats::fBasketsInfostd::vector< std::vector< BasketInfo > > fBasketsInfoDefinition TTreePerfStats.h:77; TTreePerfStats::fUnzipObjSizeLong64_t fUnzipObjSizeUncompressed bytes produced by the decompressor.Definition TTreePerfStats.h:63; TTreePerfStats::fWatchTStopwatch * fWatchTStopwatch pointer.Definition TTreePerfStats.h:72; TTreePerfStats::fTreeTTree * fTree! Pointer to the Tree being monitoredDefinition TTreePerfStats.h:68; TTreePerfStats::SetReadaheadSizevirtual void SetReadaheadSize(Int_t nbytes)Definition TTreePerfStats.h:137; TTreePerfStats::fHostInfoTString fHostInfoName of the host system, ROOT version and date.Definition TTreePerfStats.h:66; TTreePerfStats::Printvoid Print(Option_t *option="""") const overridePrint the TTree I/O perf stats.Definition TTreePerfStats.cxx:540; TTreePerfStats::GetStopwatchTStopwatch * GetStopwatch() constDefinition TTreePerfStats.h:109; TTreePerfStats::fReadCallsInt_t fReadCallsNumber of read calls.Definition TTreePerfStats.h:53; TTreePerfStats::fBytesReadLong64_t fBytesReadNumber of bytes read.Definition TTreePerfStats.h:55; TTreePerfStats::UpdateBranchIndicesvoid UpdateBranchIndices(TObjArray *branchNames) overrideUpdate the fBranchIndexCache collection to match the current TTree given the ordered list of branch n...Definition TTreePerfStats.cxx:360; TTreePerfStats::SetLoadedvoid SetLoaded(TBranch *b, size_t bask",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:21895,Integrability,interface,interface,21895,"::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; TTreePerfStats::BasketInfo::fMissedUInt_t fMissedNumber of times the basket was read directly from the file.Definition TTreePerfStats.h:45; TTreePerfStats::BasketInfo::fLoadedUInt_t fLoadedNumber of times the basket was put in the primary TTreeCache.Definition TTreePerfStats.h:43; TTreePerfStats::BasketInfo::fLoadedMissUInt_t fLoadedMissNumber of times the basket was put in the secondary cache.Definition TTreePerfStats.h:44; TTreePerfStats::BasketInfo::fUsedUInt_t fUsedNumber of times the basket was requested from the disk.Definition TTreePerfStats.h:42; Drawth1 Draw(). treetreeplayerincTTreePerfStats.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:840,Performance,perform,performance,840,". ROOT: tree/treeplayer/inc/TTreePerfStats.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreePerfStats.h. Go to the documentation of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Rene Brun 29/10/09; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTreePerfStats; 13#define ROOT_TTreePerfStats; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TTreePerfStats //; 18// //; 19// TTree I/O performance measurement //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23 ; 24#include ""TVirtualPerfStats.h""; 25#include ""TString.h""; 26#include <vector>; 27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache siz",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:1586,Performance,cache,cache,1586,"EDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TTreePerfStats; 13#define ROOT_TTreePerfStats; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TTreePerfStats //; 18// //; 19// TTree I/O performance measurement //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23 ; 24#include ""TVirtualPerfStats.h""; 25#include ""TString.h""; 26#include <vector>; 27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:1992,Performance,cache,cache,1992,"27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Po",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:2133,Performance,cache,cache,2133,"27#include <unordered_map>; 28 ; 29class TBrowser;; 30class TFile;; 31class TTree;; 32class TStopwatch;; 33class TPaveText;; 34class TGraphErrors;; 35class TGaxis;; 36class TText;; 37 ; 38class TTreePerfStats : public TVirtualPerfStats {; 39 ; 40public:; 41 struct BasketInfo {; 42 UInt_t fUsed = {0}; ///< Number of times the basket was requested from the disk.; 43 UInt_t fLoaded = {0}; ///< Number of times the basket was put in the primary TTreeCache; 44 UInt_t fLoadedMiss = {0}; ///< Number of times the basket was put in the secondary cache; 45 UInt_t fMissed = {0}; ///< Number of times the basket was read directly from the file.; 46 };; 47 ; 48 using BasketList_t = std::vector<std::pair<TBranch*, std::vector<size_t>>>;; 49 ; 50protected:; 51 Int_t fTreeCacheSize; ///< TTreeCache buffer size; 52 Int_t fNleaves; ///< Number of leaves in the tree; 53 Int_t fReadCalls; ///< Number of read calls; 54 Int_t fReadaheadSize; ///< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Po",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:3377,Performance,cache,cache,3377,"/< Read-ahead cache size; 55 Long64_t fBytesRead; ///< Number of bytes read; 56 Long64_t fBytesReadExtra;///< Number of bytes (overhead) of the read-ahead cache; 57 Double_t fRealNorm; ///< Real time scale factor for fGraphTime; 58 Double_t fRealTime; ///< Real time; 59 Double_t fCpuTime; ///< Cpu time; 60 Double_t fDiskTime; ///< Time spent in pure raw disk IO; 61 Double_t fUnzipTime; ///< Time spent uncompressing the data.; 62 Long64_t fUnzipInputSize;///< Compressed bytes seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:3486,Performance,cache,cached,3486,"seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_t *option="""") override;; 93 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 94 virtual void Finish();; 95 Long64_t GetBytesRead() const override {return fBytesRead;}; 96 virtual Long64_t GetBytesReadExtra() const {return fBytesReadExtra;}; 97 virtual Double_t GetCpuTime() const {return fCpuTime;}; 98 virtual Double_t GetDiskTime() const {return fDiskTime;}; 99 TGraphErrors *GetGraphIO() {return fGraphIO;}; 100 TGraphErrors *GetGraphTime() {return fGraphTime;}; 1",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:3500,Performance,cache,cached,3500,"seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_t *option="""") override;; 93 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 94 virtual void Finish();; 95 Long64_t GetBytesRead() const override {return fBytesRead;}; 96 virtual Long64_t GetBytesReadExtra() const {return fBytesReadExtra;}; 97 virtual Double_t GetCpuTime() const {return fCpuTime;}; 98 virtual Double_t GetDiskTime() const {return fDiskTime;}; 99 TGraphErrors *GetGraphIO() {return fGraphIO;}; 100 TGraphErrors *GetGraphTime() {return fGraphTime;}; 1",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:8241,Performance,perform,performance,8241,";; 145 void SetLoaded(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fLoaded; }; 146 void SetLoaded(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fLoaded; }; 147 void SetLoadedMiss(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fLoadedMiss; }; 148 void SetLoadedMiss(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fLoadedMiss; }; 149 void SetMissed(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fMissed; }; 150 void SetMissed(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fMissed; }; 151 void SetUsed(TBranch *b, size_t basketNumber) override { ++GetBasketInfo(b, basketNumber).fUsed; }; 152 void SetUsed(size_t bi, size_t basketNumber) override { ++GetBasketInfo(bi, basketNumber).fUsed; }; 153 void UpdateBranchIndices(TObjArray *branchNames) override;; 154 ; 155 BasketList_t GetDuplicateBasketCache() const;; 156 ; 157 ClassDefOverride(TTreePerfStats, 8) // TTree I/O performance measurement; 158};; 159 ; 160#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:11135,Performance,perform,performance,11135,"t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TString.h; TVirtualPerfStats.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTextBase class for several text objects.Definition TText.h:22; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::GetNumEventsLong64_t GetNumEvents() const overrideDefinition TTreePerfStats.h:104; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::SetUsedvoid SetUsed(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:152; TTreePerfStats::SetGraphIOvirtual void SetGraphIO(TGraphErrors *gr)Definition TTreePerfStats.h:132; TTreePerfStats::GetPaveTPaveText * GetPave()Definition TTreePerfStats.h:105; TTreePerfStats::SetUsedvoid SetUsed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:151; TTreePerfStats::SetRealNormvirtual void SetRealNorm(Double_t rnorm)Definition TTreePerfStats.h:139; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfS",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:18287,Performance,cache,cache,18287,"std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TTreePerfStats.cxx:657; TTreePerfStats::PrintBasketInfovoid PrintBasketInfo(Option_t *option="""") const overridePrint the TTree basket information.Definition TTreePerfStats.cxx:581; TTreePerfStats::GetReadaheadSizevirtual Int_t GetReadaheadSize() constDefinition TTreePerfStats.h:106; TTreePerfStats::fFileTFile * fFile! Pointer to the file containing the TreeDefinition TTreePerfStats.h:67; TTreePerfStats::GetHostInfoconst char * GetHostInfo() constDefinition TTreePerfStats.h:101; TTreePerfStats::GetUnzipTimevirtual Double_t GetUnzipTime() constDefinition TTreePerfStats.h:111; TTreePerfStats::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:217; TTreePerfStats::fRealTimeDouble_t fRealTimeReal time.Definition TTreePerfStats.h:58; TTreePerfStats::fReadaheadSizeInt_t fReadaheadSizeRead-ahead cache size.Definition TTreePerfStats.h:54; TTreePerfStats::SetLoadedMissvoid SetLoadedMiss(size_t bi, size_t basketNumber) overrideDefinition TTreePerfStats.h:148; TTreePerfStats::GetRealTimevirtual Double_t GetRealTime() constDefinition TTreePerfStats.h:108; TTreePerfStats::SetUnzipTimevirtual void SetUnzipTime(Double_t uztime)Definition TTreePerfStats.h:142; TTreePerfStats::SetReadCallsvirtual void SetReadCalls(Int_t ncalls)Definition TTreePerfStats.h:138; TTreePerfStats::GetDiskTimevirtual Double_t GetDiskTime() constDefinition TTreePerfStats.h:98; TTreePerfStats::fBranchIndexCachestd::unordered_map< TBranch *, size_t > fBranchIndexCacheDefinition TTreePerfStats.h:76; TTreePerfStats::~TTreePerfStats~TTreePerfStats() overrideDestructor.Definition TTreePerfStats.cxx:188; TTreePerfStats::FileOpenEventvoid FileOpenEvent(TFile *, const char *, Double_t) overrideDefinition TTreePerfStats.h:119; TTreePerfStats::SetGraphTimevirtual void SetGraphTime(TGraphErrors ",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:21241,Performance,cache,cache,21241,"tLoadedMissvoid SetLoadedMiss(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:147; TTreePerfStats::SetRealTimevirtual void SetRealTime(Double_t rtime)Definition TTreePerfStats.h:140; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::SetDiskTimevirtual void SetDiskTime(Double_t t)Definition TTreePerfStats.h:129; TTreePerfStats::SetBytesReadvoid SetBytesRead(Long64_t nbytes) overrideDefinition TTreePerfStats.h:126; TTreePerfStats::SetNleavesvirtual void SetNleaves(Int_t nleaves)Definition TTreePerfStats.h:136; TTreePerfStats::GetGraphIOTGraphErrors * GetGraphIO()Definition TTreePerfStats.h:99; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTre",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:21928,Performance,perform,performance,21928,"::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; TTreePerfStats::BasketInfo::fMissedUInt_t fMissedNumber of times the basket was read directly from the file.Definition TTreePerfStats.h:45; TTreePerfStats::BasketInfo::fLoadedUInt_t fLoadedNumber of times the basket was put in the primary TTreeCache.Definition TTreePerfStats.h:43; TTreePerfStats::BasketInfo::fLoadedMissUInt_t fLoadedMissNumber of times the basket was put in the secondary cache.Definition TTreePerfStats.h:44; TTreePerfStats::BasketInfo::fUsedUInt_t fUsedNumber of times the basket was requested from the disk.Definition TTreePerfStats.h:42; Drawth1 Draw(). treetreeplayerincTTreePerfStats.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePerfStats_8h_source.html:22599,Performance,cache,cache,22599,"oTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::SetMissedvoid SetMissed(TBranch *b, size_t basketNumber) overrideDefinition TTreePerfStats.h:149; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::SetCpuTimevirtual void SetCpuTime(Double_t cptime)Definition TTreePerfStats.h:131; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreePerfStats::SetHostInfovirtual void SetHostInfo(const char *info)Definition TTreePerfStats.h:134; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualPerfStats::EEventTypeEEventTypeDefinition TVirtualPerfStats.h:42; double; int; unsigned int; grTGraphErrors * grDefinition legend1.C:25; TTreePerfStats::BasketInfoDefinition TTreePerfStats.h:41; TTreePerfStats::BasketInfo::fMissedUInt_t fMissedNumber of times the basket was read directly from the file.Definition TTreePerfStats.h:45; TTreePerfStats::BasketInfo::fLoadedUInt_t fLoadedNumber of times the basket was put in the primary TTreeCache.Definition TTreePerfStats.h:43; TTreePerfStats::BasketInfo::fLoadedMissUInt_t fLoadedMissNumber of times the basket was put in the secondary cache.Definition TTreePerfStats.h:44; TTreePerfStats::BasketInfo::fUsedUInt_t fUsedNumber of times the basket was requested from the disk.Definition TTreePerfStats.h:42; Drawth1 Draw(). treetreeplayerincTTreePerfStats.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreePerfStats_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html
https://root.cern/doc/master/TTreePlayer_8cxx.html:1902,Integrability,depend,dependency,1902,"onesArray.h""; #include ""TClass.h""; #include ""TVirtualPad.h""; #include ""TProfile.h""; #include ""TProfile2D.h""; #include ""TTreeFormula.h""; #include ""TTreeFormulaManager.h""; #include ""TStyle.h""; #include ""Foption.h""; #include ""TTreeResult.h""; #include ""TTreeRow.h""; #include ""TPrincipal.h""; #include ""TChain.h""; #include ""TChainElement.h""; #include ""TF1.h""; #include ""TVirtualFitter.h""; #include ""THLimitsFinder.h""; #include ""TSelectorDraw.h""; #include ""TSelectorEntries.h""; #include ""TPluginManager.h""; #include ""TObjString.h""; #include ""TTreeProxyGenerator.h""; #include ""TTreeReaderGenerator.h""; #include ""TTreeIndex.h""; #include ""TChainIndex.h""; #include ""TRefProxy.h""; #include ""TRefArrayProxy.h""; #include ""TVirtualMonitoring.h""; #include ""TTreeCache.h""; #include ""TVirtualMutex.h""; #include ""ThreadLocalStorage.h""; #include ""strlcpy.h""; #include ""snprintf.h""; #include ""HFitInterface.h""; #include ""Fit/BinData.h""; #include ""Fit/UnBinData.h""; #include ""Math/MinimizerOptions.h"". Include dependency graph for TTreePlayer.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Functions; static TStringR__GetBranchPointerName (TLeaf *leaf, bool replace=true); Return the name of the branch pointer needed by MakeClass/MakeSelector. ; . Variables; R__EXTERN Foption_tFoption; ; TVirtualFitter *tFitter = nullptr; . Function Documentation. R__GetBranchPointerName(). static TString R__GetBranchPointerName ; (; TLeaf *; leaf, . bool; replace = true. ). static . Return the name of the branch pointer needed by MakeClass/MakeSelector. ; Definition at line 647 of file TTreePlayer.cxx. Variable Documentation. Foption. R__EXTERN Foption_t Foption. Definition at line 98 of file TTreePlayer.cxx. tFitter. TVirtualFitter* tFitter = nullptr. Definition at line 100",MatchSource.WIKI,doc/master/TTreePlayer_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreePlayer_8cxx.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx.html:940,Integrability,depend,dependency,940,". ROOT: tree/treeplayer/src/TTreeProxyGenerator.cxx File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces |; Functions ; TTreeProxyGenerator.cxx File Reference. #include ""TTreeProxyGenerator.h""; #include ""TFriendProxyDescriptor.h""; #include ""TBranchProxyDescriptor.h""; #include ""TBranchProxyClassDescriptor.h""; #include ""TList.h""; #include ""Varargs.h""; #include <cstdio>; #include ""TClass.h""; #include ""TClassEdit.h""; #include ""TClonesArray.h""; #include ""TError.h""; #include ""TROOT.h""; #include ""TObjString.h""; #include ""TTreeFormula.h""; #include ""TFormLeafInfo.h""; #include ""TBranchElement.h""; #include ""TChain.h""; #include ""TFile.h""; #include ""TFriendElement.h""; #include ""TLeaf.h""; #include ""TLeafC.h""; #include ""TTree.h""; #include ""TVirtualStreamerInfo.h""; #include ""TStreamerElement.h""; #include ""TSystem.h""; #include ""TLeafObject.h""; #include ""TVirtualCollectionProxy.h"". Include dependency graph for TTreeProxyGenerator.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ; namespace ROOT::Internal; . Functions; voidDebug (Int_t level, const char *fmt,...); ; TStringROOT::Internal::GetArrayType (TStreamerElement *element, const char *subtype, TTreeProxyGenerator::EContainer container); ; static boolROOT::Internal::R__AddPragmaForClass (TTreeProxyGenerator *gen, const char *classname); Add the ""pragma C++ class"" if needed and return true if it has been added or if it is known to not be needed. ; ; static boolROOT::Internal::R__AddPragmaForClass (TTreeProxyGenerator *gen, TClass *cl); Add the ""pragma C++ class"" if needed and return true if it has been added or if it is known to not be needed. ; . Function Documentation. Debug(). void Debug ; (; Int_t; level, . const char *; fmt, . ;",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:2722,Availability,error,error,2722,"d require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h""; 61#include ""TObjString.h""; 62 ; 63#include ""TTreeFormula.h""; 64#include ""TFormLeafInfo.h""; 65 ; 66#include ""TBranchElement.h""; 67#include ""TChain.h""; 68#include ""TFile.h""; 69#include ""TFriendElement.h""; 70#include ""TLeaf.h""; 71#include ""TLeafC.h""; 72#include ""TTree.h""; 73#include ""TVirtualStreamerInfo.h""; 74#include ""TStreamerElement.h""; 75#include ""TSystem.h""; 76#include ""TLeafObject.h""; 77#include ""TVirtualCollectionProxy.h""; 78 ; 79void Debug(Int_t level, const char *va_(fmt), ...); 80{; 81 // Use this function in case an error occurred.; 82 ; 83 if (gDebug>=level) {; 84 va_list ap;; 85 va_start(ap,va_(fmt));; 86 ErrorHandler(kInfo,""TTreeProxyGenerator"",va_(fmt), ap);; 87 va_end(ap);; 88 }; 89}; 90 ; 91namespace {; 92 ; 93 bool AreDifferent(const TString& from, const TString& to); 94 {; 95 FILE *left = fopen(from.Data(),""r"");; 96 FILE *right = fopen(to.Data(),""r"");; 97 ; 98 char leftbuffer[256];; 99 char rightbuffer[256];; 100 ; 101 char *lvalue,*rvalue;; 102 ; 103 bool areEqual = true;; 104 ; 105 do {; 106 lvalue = fgets(leftbuffer, sizeof(leftbuffer), left);; 107 rvalue = fgets(rightbuffer, sizeof(rightbuffer), right);; 108 ; 109 if (lvalue&&rvalue) {; 110 if (strstr(lvalue,""by ROOT version"")) {; 111 // skip the comment line with the time and date; 112 } else {; 113 areEqual = areEqual && (0 == strncmp(lvalue,rvalue,sizeof(leftbuffer)));; 114 }; 115 }; 116 if (lvalue&&!rvalue) areEqual = false;; 117 if (rvalue&&!lvalue) areEqual = false;; 118 ; 119 } while(areEqual && lvalue && rvalue);;",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:11946,Availability,avail,available,11946,"*cl); 369 {; 370 if (cl) AddForward(cl->GetName());; 371 }; 372 ; 373 ////////////////////////////////////////////////////////////////////////////////; 374 /// Add a forward declaration request.; 375 ; 376 void TTreeProxyGenerator::AddPragma(const char *pragma_text); 377 {; 378 TIter i( &fListOfPragmas );; 379 for(TObjString *n = (TObjString*) i(); n; n = (TObjString*)i() ) {; 380 if (pragma_text == n->GetString()) {; 381 return;; 382 }; 383 }; 384 ; 385 fListOfPragmas.Add( new TObjString( pragma_text ) );; 386 ; 387 }; 388 ; 389 ////////////////////////////////////////////////////////////////////////////////; 390 /// Add a branch descriptor.; 391 ; 392 void TTreeProxyGenerator::AddDescriptor(TBranchProxyDescriptor *desc); 393 {; 394 if (desc) {; 395 TBranchProxyDescriptor *existing =; 396 (TBranchProxyDescriptor*)((*fCurrentListOfTopProxies)(desc->GetName()));; 397 if (existing) {; 398 Warning(""TTreeProxyGenerator"",""The branch name \""%s\"" is duplicated. Only the first instance \n""; 399 ""\twill be available directly. The other instance(s) might be available via their complete name\n""; 400 ""\t(including the name of their mother branche's name)."",desc->GetName());; 401 } else {; 402 fCurrentListOfTopProxies->Add(desc);; 403 UInt_t len = strlen(desc->GetTypeName());; 404 if ((len+2)>fMaxDatamemberType) fMaxDatamemberType = len+2;; 405 }; 406 }; 407 }; 408 ; 409 ////////////////////////////////////////////////////////////////////////////////; 410 /// Generate an enum for a given type if it is not known in the list of class; 411 /// unless the type itself a template.; 412 ; 413 void TTreeProxyGenerator::AddMissingClassAsEnum(const char *clname, bool isscope); 414 {; 415 if (!TClassEdit::IsStdClass(clname) && !TClass::GetClass(clname) && gROOT->GetType(clname) == nullptr) {; 416 ; 417 TObject *obj = fListOfForwards.FindObject(clname);; 418 if (obj) return;; 419 ; 420 // The class does not exist, let's create it if ew can.; 421 if (clname[strlen(clname)-1]=='>') {; 422 // ",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:11997,Availability,avail,available,11997,"//////////////////////////////////////////////////////; 374 /// Add a forward declaration request.; 375 ; 376 void TTreeProxyGenerator::AddPragma(const char *pragma_text); 377 {; 378 TIter i( &fListOfPragmas );; 379 for(TObjString *n = (TObjString*) i(); n; n = (TObjString*)i() ) {; 380 if (pragma_text == n->GetString()) {; 381 return;; 382 }; 383 }; 384 ; 385 fListOfPragmas.Add( new TObjString( pragma_text ) );; 386 ; 387 }; 388 ; 389 ////////////////////////////////////////////////////////////////////////////////; 390 /// Add a branch descriptor.; 391 ; 392 void TTreeProxyGenerator::AddDescriptor(TBranchProxyDescriptor *desc); 393 {; 394 if (desc) {; 395 TBranchProxyDescriptor *existing =; 396 (TBranchProxyDescriptor*)((*fCurrentListOfTopProxies)(desc->GetName()));; 397 if (existing) {; 398 Warning(""TTreeProxyGenerator"",""The branch name \""%s\"" is duplicated. Only the first instance \n""; 399 ""\twill be available directly. The other instance(s) might be available via their complete name\n""; 400 ""\t(including the name of their mother branche's name)."",desc->GetName());; 401 } else {; 402 fCurrentListOfTopProxies->Add(desc);; 403 UInt_t len = strlen(desc->GetTypeName());; 404 if ((len+2)>fMaxDatamemberType) fMaxDatamemberType = len+2;; 405 }; 406 }; 407 }; 408 ; 409 ////////////////////////////////////////////////////////////////////////////////; 410 /// Generate an enum for a given type if it is not known in the list of class; 411 /// unless the type itself a template.; 412 ; 413 void TTreeProxyGenerator::AddMissingClassAsEnum(const char *clname, bool isscope); 414 {; 415 if (!TClassEdit::IsStdClass(clname) && !TClass::GetClass(clname) && gROOT->GetType(clname) == nullptr) {; 416 ; 417 TObject *obj = fListOfForwards.FindObject(clname);; 418 if (obj) return;; 419 ; 420 // The class does not exist, let's create it if ew can.; 421 if (clname[strlen(clname)-1]=='>') {; 422 // Template instantiation.; 423 fListOfForwards.Add(new TNamed(clname,TString::Format(""template <> c",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:66615,Availability,reliab,reliably,66615,"ROOT headers needed by the proxy\n"");; 1746 fprintf(hf,""#include <TROOT.h>\n"");; 1747 fprintf(hf,""#include <TChain.h>\n"");; 1748 fprintf(hf,""#include <TFile.h>\n"");; 1749 fprintf(hf,""#include <TPad.h>\n"");; 1750 fprintf(hf,""#include <TH1.h>\n"");; 1751 fprintf(hf,""#include <TSelector.h>\n"");; 1752 fprintf(hf,""#include <TBranchProxy.h>\n"");; 1753 fprintf(hf,""#include <TBranchProxyDirector.h>\n"");; 1754 fprintf(hf,""#include <TBranchProxyTemplate.h>\n"");; 1755 fprintf(hf,""#include <TFriendProxy.h>\n"");; 1756 fprintf(hf,""using namespace ROOT::Internal;\n""); // questionable; 1757 fprintf(hf,""using ROOT::Detail::TBranchProxy;\n""); // questionable; 1758 fprintf(hf,""\n"");; 1759 ; 1760 fprintf(hf,""// forward declarations needed by this particular proxy\n"");; 1761 TIter next( &fListOfForwards );; 1762 TObject *current;; 1763 while ( (current=next()) ) {; 1764 if (strstr(current->GetTitle(),""::"")==nullptr) {; 1765 // We can not forward declared nested classes (well we might be able to do so for; 1766 // the one nested in a namespace but it is not clear yet if we can really reliably; 1767 // find this information); 1768 fprintf(hf,""%s"",current->GetTitle());; 1769 }; 1770 }; 1771 ; 1772 fprintf(hf,""\n\n"");; 1773 fprintf(hf,""// Header needed by this particular proxy\n"");; 1774 next = &fListOfHeaders;; 1775 TObject *header;; 1776 while ( (header = next()) ) {; 1777 fprintf(hf,""%s"",header->GetTitle());; 1778 }; 1779 fprintf(hf,""\n\n"");; 1780 ; 1781 fprintf(hf,""class %s_Interface {\n"", scriptfunc.Data());; 1782 fprintf(hf,"" // This class defines the list of methods that are directly used by %s,\n"",classname.Data());; 1783 fprintf(hf,"" // and that can be overloaded in the user's script\n"");; 1784 fprintf(hf,""public:\n"");; 1785 fprintf(hf,"" void %s_Begin(TTree*) {}\n"",scriptfunc.Data());; 1786 fprintf(hf,"" void %s_SlaveBegin(TTree*) {}\n"",scriptfunc.Data());; 1787 fprintf(hf,"" bool %s_Notify() { return true; }\n"",scriptfunc.Data());; 1788 fprintf(hf,"" bool %s_Process(Long64_t) { return",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75356,Availability,avail,available,75356,"is called on each slave server.\n"");; 1956 fprintf(hf,"" // The tree argument is deprecated (on PROOF 0 is passed).\n"");; 1957 fprintf(hf,""\n"");; 1958 fprintf(hf,"" Init(tree);\n"");; 1959 fprintf(hf,""\n"");; 1960 fprintf(hf,"" %s_SlaveBegin(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEntry(entry).\n"");; 1985 fprintf(hf,""\n"");; 1986 fprintf(hf,""\n"");; 1987 fprintf(hf,"" fDirector.SetReadEntry(entry);\n"");; 1988 if (fOptions & kNoHist) {; 1989 if (cutfilename) {; 1990 fprintf(hf,"" if (%s()) %s();\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1991 } else {; 19",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:78891,Availability,error,error,78891,"ff\"")) drawflag = false;\n"");; 2027 fprintf(hf,"" if (drawflag) htemp->Draw(fOption);\n"");; 2028 fprintf(hf,"" }\n"");; 2029 fprintf(hf,"" %s_Terminate();\n"",scriptfunc.Data());; 2030 fprintf(hf,""}\n"");; 2031 ; 2032 fclose(hf);; 2033 ; 2034 if (updating) {; 2035 // over-write existing file only if needed.; 2036 if (AreDifferent(fHeaderFileName,tmpfilename)) {; 2037 gSystem->Unlink(fHeaderFileName);; 2038 gSystem->Rename(tmpfilename,fHeaderFileName);; 2039 } else gSystem->Unlink(tmpfilename);; 2040 }; 2041 delete [] filename;; 2042 delete [] cutfilename;; 2043 }; 2044 ; 2045} // namespace Internal; 2046} // namespace ROOT; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TBranchElement.h; TBranchProxyClassDescriptor.h; TBranchProxyDescriptor.h; TChain.h; TClassEdit.h; TClass.h; TClonesArray.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TFile.h; TFormLeafInfo.h; TFriendElement.h; TFriendProxyDescriptor.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyl",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:79040,Availability,error,error,79040,"f,"" %s_Terminate();\n"",scriptfunc.Data());; 2030 fprintf(hf,""}\n"");; 2031 ; 2032 fclose(hf);; 2033 ; 2034 if (updating) {; 2035 // over-write existing file only if needed.; 2036 if (AreDifferent(fHeaderFileName,tmpfilename)) {; 2037 gSystem->Unlink(fHeaderFileName);; 2038 gSystem->Rename(tmpfilename,fHeaderFileName);; 2039 } else gSystem->Unlink(tmpfilename);; 2040 }; 2041 delete [] filename;; 2042 delete [] cutfilename;; 2043 }; 2044 ; 2045} // namespace Internal; 2046} // namespace ROOT; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TBranchElement.h; TBranchProxyClassDescriptor.h; TBranchProxyDescriptor.h; TChain.h; TClassEdit.h; TClass.h; TClonesArray.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TFile.h; TFormLeafInfo.h; TFriendElement.h; TFriendProxyDescriptor.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t ",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:79086,Availability,error,error,79086,"se(hf);; 2033 ; 2034 if (updating) {; 2035 // over-write existing file only if needed.; 2036 if (AreDifferent(fHeaderFileName,tmpfilename)) {; 2037 gSystem->Unlink(fHeaderFileName);; 2038 gSystem->Rename(tmpfilename,fHeaderFileName);; 2039 } else gSystem->Unlink(tmpfilename);; 2040 }; 2041 delete [] filename;; 2042 delete [] cutfilename;; 2043 }; 2044 ; 2045} // namespace Internal; 2046} // namespace ROOT; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TBranchElement.h; TBranchProxyClassDescriptor.h; TBranchProxyDescriptor.h; TChain.h; TClassEdit.h; TClass.h; TClonesArray.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TFile.h; TFormLeafInfo.h; TFriendElement.h; TFriendProxyDescriptor.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TSt",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:79217,Availability,error,error,79217,"pfilename)) {; 2037 gSystem->Unlink(fHeaderFileName);; 2038 gSystem->Rename(tmpfilename,fHeaderFileName);; 2039 } else gSystem->Unlink(tmpfilename);; 2040 }; 2041 delete [] filename;; 2042 delete [] cutfilename;; 2043 }; 2044 ; 2045} // namespace Internal; 2046} // namespace ROOT; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; TBranchElement.h; TBranchProxyClassDescriptor.h; TBranchProxyDescriptor.h; TChain.h; TClassEdit.h; TClass.h; TClonesArray.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ErrorHandlervoid ErrorHandler(int level, const char *location, const char *fmt, std::va_list va)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; kInfoconstexpr Int_t kInfoDefinition TError.h:45; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TFile.h; TFormLeafInfo.h; TFriendElement.h; TFriendProxyDescriptor.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:713,Integrability,wrap,wrapper,713,". ROOT: tree/treeplayer/src/TTreeProxyGenerator.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeProxyGenerator.cxx. Go to the documentation of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Philippe Canal 06/06/2004; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/*; 13 TODO:; 14 Have separate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; ",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:70952,Integrability,inject,inject,70952,"me());; 1846 }; 1847 next = &fListOfFriends;; 1848 TFriendProxyDescriptor *fpd;; 1849 while ( (fpd = (TFriendProxyDescriptor*)next()) ) {; 1850 fprintf(hf,"",\n %-*s(&fDirector,tree,%d)"",; 1851 fMaxDatamemberType, fpd->GetTitle(), fpd->GetIndex());; 1852 }; 1853 ; 1854 fprintf(hf, ""\n { }\n"");; 1855 ; 1856 // Other functions.; 1857 fprintf(hf,"" ~%s() override;\n"",classname.Data());; 1858 fprintf(hf,"" Int_t Version() const override {return 1;}\n"");; 1859 fprintf(hf,"" void Begin(::TTree *tree) override;\n"");; 1860 fprintf(hf,"" void SlaveBegin(::TTree *tree) override;\n"");; 1861 fprintf(hf,"" void Init(::TTree *tree) override;\n"");; 1862 fprintf(hf,"" bool Notify() override;\n"");; 1863 fprintf(hf,"" bool Process(Long64_t entry) override;\n"");; 1864 fprintf(hf,"" void SlaveTerminate() override;\n"");; 1865 fprintf(hf,"" void Terminate() override;\n"");; 1866 fprintf(hf,""\n"");; 1867 fprintf(hf,"" ClassDefOverride(%s,0);\n"",classname.Data());; 1868 fprintf(hf,""\n\n"");; 1869 ; 1870 fprintf(hf,""//inject the user's code\n"");; 1871 fprintf(hf,""#include \""%s\""\n"",fScript.Data());; 1872 ; 1873 if (cutfilename) {; 1874 fprintf(hf,""#include \""%s\""\n"",fCutScript.Data());; 1875 }; 1876 ; 1877 // Close the class.; 1878 fprintf(hf,""};\n"");; 1879 fprintf(hf,""\n"");; 1880 fprintf(hf,""#endif\n"");; 1881 fprintf(hf,""\n\n"");; 1882 ; 1883 fprintf(hf,""#ifdef __MAKECINT__\n"");; 1884 if (fListOfClasses.LastIndex()>=0) {; 1885 TBranchProxyClassDescriptor *clp;; 1886 next = &fListOfClasses;; 1887 while ( (clp = (TBranchProxyClassDescriptor*)next()) ) {; 1888 fprintf(hf,""#pragma link C++ class %s::%s-;\n"",classname.Data(),clp->GetName());; 1889 if (clp->GetContainerName().Length()) {; 1890 R__AddPragmaForClass(this, clp->GetContainerName());; 1891 }; 1892 }; 1893 next = &fListOfPragmas;; 1894 TObjString *prag;; 1895 while ( (prag = (TObjString*)next()) ) {; 1896 fprintf(hf,""%s"",prag->String().Data());; 1897 }; 1898 }; 1899 fprintf(hf,""#pragma link C++ class %s;\n"",classname.Data());; 1900 fprintf(hf,""#endif",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:103876,Integrability,rout,routine,103876,"GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetLeafInfoTFormLeafInfo * GetLeafInfo(Int_t code) constReturn DataMember corresponding to code.Definition TTreeFormula.cxx:4456; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::kULong64@ kULong64Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kObjectp",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:1139,Modifiability,inherit,inheritance,1139,"tion of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Philippe Canal 06/06/2004; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/*; 13 TODO:; 14 Have separate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h"";",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:36465,Modifiability,variab,variable,36465,";; 939 // TLeaf *leafcount = leaf->GetLeafCount();; 940 ; 941 UInt_t dim = 0;; 942 std::vector<Int_t> maxDim;; 943 //maxDim[0] = maxDim[1] = maxDim[2] = 1;; 944 ; 945 TString dimensions;; 946 TString temp = leaf->GetName();; 947 pos = temp.Index(""["");; 948 if (pos!=-1) {; 949 if (pos) temp.Remove(0,pos);; 950 dimensions.Append(temp);; 951 }; 952 temp = leaf->GetTitle();; 953 pos = temp.Index(""["");; 954 if (pos!=-1) {; 955 if (pos) temp.Remove(0,pos);; 956 dimensions.Append(temp);; 957 }; 958 ; 959 Int_t dimlen = dimensions.Length();; 960 ; 961 if (dimlen) {; 962 const char *current = dimensions.Data();; 963 ; 964 Int_t index;; 965 Int_t scanindex ;; 966 while (current) {; 967 current++;; 968 if (current[0] == ']') {; 969 maxDim.push_back(-1); // maxDim[dim] = -1; // Loop over all elements;; 970 } else {; 971 scanindex = sscanf(current,""%d"",&index);; 972 if (scanindex) {; 973 maxDim.push_back(index); // maxDim[dim] = index;; 974 } else {; 975 maxDim.push_back(-2); // maxDim[dim] = -2; // Index is calculated via a variable.; 976 }; 977 }; 978 dim ++;; 979 current = (char*)strstr( current, ""["" );; 980 }; 981 ; 982 }; 983 //char *twodim = (char*)strstr(leaf->GetTitle(),""]["");; 984 ; 985 //if (leafcount) {; 986 // len = leafcount->GetMaximum();; 987 //}; 988 if (dim == 0 && leaf->IsA() == TLeafC::Class()) {; 989 // For C style strings.; 990 dim = 1;; 991 }; 992 ; 993 TString type;; 994 switch (dim) {; 995 case 0: {; 996 type = ""T"";; 997 type += leafTypeName;; 998 type += ""Proxy"";; 999 break;; 1000 }; 1001 case 1: {; 1002 type = ""TArray"";; 1003 type += leafTypeName;; 1004 type += ""Proxy"";; 1005 break;; 1006 }; 1007 default: {; 1008 type = ""TArrayProxy<"";; 1009 for(Int_t ind = dim - 2; ind > 0; --ind) {; 1010 type += ""TMultiArrayType<"";; 1011 }; 1012 type += ""TArrayType<"";; 1013 type += leaf->GetTypeName();; 1014 type += "","";; 1015 type += maxDim[dim-1];; 1016 type += ""> "";; 1017 for(Int_t ind = dim - 2; ind > 0; --ind) {; 1018 type += "","";; 1019 type += maxDim[ind];; 1020",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:100245,Modifiability,inherit,inherits,100245,"d::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Classstatic TClass * Class(); TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TSeqCollection::LastIndexInt_t LastIndex() constDefinition TSeqCollection.h:55; TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:218; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetTypeInt_t GetType() constDefinition TStreamerElement.h:118; TStreamerElement::GetClassPointervirtual TClass * GetClassPointer() constReturns a pointer to the TClass of this element.Definition TStreamerElement.cxx:294; TStreamerElement::GetArrayDimInt_t GetArrayDim() constDefinition TStreamerElement.h:105; TStreamerElement::GetMaxIndexInt_t GetMaxIndex(Int_t i) constD",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:73068,Performance,load,loading,73068,"ntf(hf,""inline %s::~%s() {\n"",classname.Data(),classname.Data());; 1905 fprintf(hf,"" // destructor. Clean up helpers.\n"");; 1906 fprintf(hf,""\n"");; 1907 fprintf(hf,""}\n"");; 1908 fprintf(hf,""\n"");; 1909 fprintf(hf,""inline void %s::Init(TTree *tree)\n"",classname.Data());; 1910 fprintf(hf,""{\n"");; 1911 fprintf(hf,""// Set branch addresses\n"");; 1912 fprintf(hf,"" if (tree == 0) return;\n"");; 1913 fprintf(hf,"" fChain = tree;\n"");; 1914 fprintf(hf,"" fDirector.SetTree(fChain);\n"");; 1915 fprintf(hf,"" if (htemp == 0) {\n"");; 1916 fprintf(hf,"" htemp = fDirector.CreateHistogram(GetOption());\n"");; 1917 if (cutfilename) {; 1918 fprintf(hf,"" htemp->SetTitle(\""%s {%s}\"");\n"",fScript.Data(),fCutScript.Data());; 1919 } else {; 1920 fprintf(hf,"" htemp->SetTitle(\""%s\"");\n"",fScript.Data());; 1921 }; 1922 fprintf(hf,"" fObject = htemp;\n"");; 1923 fprintf(hf,"" }\n"");; 1924 fprintf(hf,""}\n"");; 1925 fprintf(hf,""\n"");; 1926 fprintf(hf,""bool %s::Notify()\n"",classname.Data());; 1927 fprintf(hf,""{\n"");; 1928 fprintf(hf,"" // Called when loading a new file.\n"");; 1929 fprintf(hf,"" // Get branch pointers.\n"");; 1930 fprintf(hf,"" fDirector.SetTree(fChain);\n"");; 1931 fprintf(hf,"" %s_Notify();\n"",scriptfunc.Data());; 1932 fprintf(hf,"" \n"");; 1933 fprintf(hf,"" return true;\n"");; 1934 fprintf(hf,""}\n"");; 1935 fprintf(hf,"" \n"");; 1936 ; 1937 // generate code for class member function Begin; 1938 fprintf(hf,""\n"");; 1939 fprintf(hf,""inline void %s::Begin(TTree *tree)\n"",classname.Data());; 1940 fprintf(hf,""{\n"");; 1941 fprintf(hf,"" // The Begin() function is called at the start of the query.\n"");; 1942 fprintf(hf,"" // When running with PROOF Begin() is only called on the client.\n"");; 1943 fprintf(hf,"" // The tree argument is deprecated (on PROOF 0 is passed).\n"");; 1944 fprintf(hf,""\n"");; 1945 fprintf(hf,"" TString option = GetOption();\n"");; 1946 fprintf(hf,"" %s_Begin(tree);\n"",scriptfunc.Data());; 1947 fprintf(hf,""\n"");; 1948 fprintf(hf,""}\n"");; 1949 ; 1950 // generate code for class member function S",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75082,Performance,load,loaded,75082,"printf(hf,""\n"");; 1952 fprintf(hf,""inline void %s::SlaveBegin(TTree *tree)\n"",classname.Data());; 1953 fprintf(hf,""{\n"");; 1954 fprintf(hf,"" // The SlaveBegin() function is called after the Begin() function.\n"");; 1955 fprintf(hf,"" // When running with PROOF SlaveBegin() is called on each slave server.\n"");; 1956 fprintf(hf,"" // The tree argument is deprecated (on PROOF 0 is passed).\n"");; 1957 fprintf(hf,""\n"");; 1958 fprintf(hf,"" Init(tree);\n"");; 1959 fprintf(hf,""\n"");; 1960 fprintf(hf,"" %s_SlaveBegin(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEnt",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75342,Performance,load,loaded,75342,"is called on each slave server.\n"");; 1956 fprintf(hf,"" // The tree argument is deprecated (on PROOF 0 is passed).\n"");; 1957 fprintf(hf,""\n"");; 1958 fprintf(hf,"" Init(tree);\n"");; 1959 fprintf(hf,""\n"");; 1960 fprintf(hf,"" %s_SlaveBegin(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEntry(entry).\n"");; 1985 fprintf(hf,""\n"");; 1986 fprintf(hf,""\n"");; 1987 fprintf(hf,"" fDirector.SetReadEntry(entry);\n"");; 1988 if (fOptions & kNoHist) {; 1989 if (cutfilename) {; 1990 fprintf(hf,"" if (%s()) %s();\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1991 } else {; 19",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:96989,Performance,load,load,96989,"em.Definition TClass.h:81; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TFormLeafInfoThis class is a small helper class to implement reading a data member on an object stored in a TTree.Definition TFormLeafInfo.h:47; TFormLeafInfo::GetLocalValuePointervirtual void * GetLocalValuePointer(TLeaf *leaf, Int_t instance=0)returns the address of the value pointed to by the TFormLeafInfo.Definition TFormLeafInfo.cxx:60",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:1206,Safety,avoid,avoid,1206,"tion of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Philippe Canal 06/06/2004; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/*; 13 TODO:; 14 Have separate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h"";",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:1624,Safety,avoid,avoid,1624,"arate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h""; 61#include ""TObjString.h""; 62 ; 63#include ""TTreeFormula.h""; 64#include ""TFormLeafInfo.h""; 65 ; 66#include ""TBranchElement.h""; 67#include ""TChain.h""; 68#include ""TFile.h""; 69#include ""TFriendElement.h""; 70#include ""TLeaf.h""; 71#include ""TLeafC.h""; 72#include ""TTree.h""; 73#include ""TVirtualStreamerInfo.h""; 74#include ""TStreamerElement.h""; 75#include ""TSystem.h""; 76#include ""TLeafObject.h""; 77#include ""TVirtualCollectionProxy.h""; 78 ; 79void Debug(Int_t level, const char *va_(fmt), ...); 80{; 81 // ",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:1576,Security,expose,exposed,1576,"*; 10 *************************************************************************/; 11 ; 12/*; 13 TODO:; 14 Have separate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h""; 61#include ""TObjString.h""; 62 ; 63#include ""TTreeFormula.h""; 64#include ""TFormLeafInfo.h""; 65 ; 66#include ""TBranchElement.h""; 67#include ""TChain.h""; 68#include ""TFile.h""; 69#include ""TFriendElement.h""; 70#include ""TLeaf.h""; 71#include ""TLeafC.h""; 72#include ""TTree.h""; 73#include ""TVirtualStreamerInfo.h""; 74#include ""TStreamerElement.h""; 75#include ""TSystem.h""; 76#include ""TLeafObject.h",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:70952,Security,inject,inject,70952,"me());; 1846 }; 1847 next = &fListOfFriends;; 1848 TFriendProxyDescriptor *fpd;; 1849 while ( (fpd = (TFriendProxyDescriptor*)next()) ) {; 1850 fprintf(hf,"",\n %-*s(&fDirector,tree,%d)"",; 1851 fMaxDatamemberType, fpd->GetTitle(), fpd->GetIndex());; 1852 }; 1853 ; 1854 fprintf(hf, ""\n { }\n"");; 1855 ; 1856 // Other functions.; 1857 fprintf(hf,"" ~%s() override;\n"",classname.Data());; 1858 fprintf(hf,"" Int_t Version() const override {return 1;}\n"");; 1859 fprintf(hf,"" void Begin(::TTree *tree) override;\n"");; 1860 fprintf(hf,"" void SlaveBegin(::TTree *tree) override;\n"");; 1861 fprintf(hf,"" void Init(::TTree *tree) override;\n"");; 1862 fprintf(hf,"" bool Notify() override;\n"");; 1863 fprintf(hf,"" bool Process(Long64_t entry) override;\n"");; 1864 fprintf(hf,"" void SlaveTerminate() override;\n"");; 1865 fprintf(hf,"" void Terminate() override;\n"");; 1866 fprintf(hf,""\n"");; 1867 fprintf(hf,"" ClassDefOverride(%s,0);\n"",classname.Data());; 1868 fprintf(hf,""\n\n"");; 1869 ; 1870 fprintf(hf,""//inject the user's code\n"");; 1871 fprintf(hf,""#include \""%s\""\n"",fScript.Data());; 1872 ; 1873 if (cutfilename) {; 1874 fprintf(hf,""#include \""%s\""\n"",fCutScript.Data());; 1875 }; 1876 ; 1877 // Close the class.; 1878 fprintf(hf,""};\n"");; 1879 fprintf(hf,""\n"");; 1880 fprintf(hf,""#endif\n"");; 1881 fprintf(hf,""\n\n"");; 1882 ; 1883 fprintf(hf,""#ifdef __MAKECINT__\n"");; 1884 if (fListOfClasses.LastIndex()>=0) {; 1885 TBranchProxyClassDescriptor *clp;; 1886 next = &fListOfClasses;; 1887 while ( (clp = (TBranchProxyClassDescriptor*)next()) ) {; 1888 fprintf(hf,""#pragma link C++ class %s::%s-;\n"",classname.Data(),clp->GetName());; 1889 if (clp->GetContainerName().Length()) {; 1890 R__AddPragmaForClass(this, clp->GetContainerName());; 1891 }; 1892 }; 1893 next = &fListOfPragmas;; 1894 TObjString *prag;; 1895 while ( (prag = (TObjString*)next()) ) {; 1896 fprintf(hf,""%s"",prag->String().Data());; 1897 }; 1898 }; 1899 fprintf(hf,""#pragma link C++ class %s;\n"",classname.Data());; 1900 fprintf(hf,""#endif",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:102735,Security,secur,secure,102735," & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::PrependTString & Prepend(const char *cs)Definition TString.h:673; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSyst",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:910,Testability,test,testing,910,"tion of this file. 1// @(#)root/treeplayer:$Id$; 2// Author: Philippe Canal 06/06/2004; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/*; 13 TODO:; 14 Have separate names for the wrapper classes in the cases of: [done]; 15 clones/non clones; 16 split/non split; 17 split levels; 18 ; 19 Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]; 20 ; 21 Have a solution for the return by references of abstract classes [not done]; 22 ; 23 Have object inside ClonesArray properly treated! [done]; 24 Why is there 2 TRef proxy classes? [done]; 25 ; 26 check why some inheritance are TObjProxy and not TPx_; 27 ; 28 Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!; 29 ; 30 When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(; 31 ; 32 CINT does not properly call the custom operators when doing return fNtrack.; 33 ; 34 CINT does not handle fMatrix[2][1] well.; 35 ; 36 The user's function in script.h are not exposed by ACLiC.; 37 ; 38 Review the method to avoid the useless refreshing of the generated file; 39 - for most efficiency it would require a different name for each tree; 40*/; 41 ; 42#include ""TTreeProxyGenerator.h""; 43 ; 44#include ""TFriendProxyDescriptor.h""; 45#include ""TBranchProxyDescriptor.h""; 46#include ""TBranchProxyClassDescriptor.h""; 47 ; 48#include ""TList.h""; 49#include ""Varargs.h""; 50#include <cstdio>; 51 ; 52class TTree;; 53class TBranch;; 54class TStreamerElement;; 55 ; 56#include ""TClass.h""; 57#include ""TClassEdit.h""; 58#include ""TClonesArray.h""; 59#include ""TError.h""; 60#include ""TROOT.h"";",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:66588,Usability,clear,clear,66588,"ROOT headers needed by the proxy\n"");; 1746 fprintf(hf,""#include <TROOT.h>\n"");; 1747 fprintf(hf,""#include <TChain.h>\n"");; 1748 fprintf(hf,""#include <TFile.h>\n"");; 1749 fprintf(hf,""#include <TPad.h>\n"");; 1750 fprintf(hf,""#include <TH1.h>\n"");; 1751 fprintf(hf,""#include <TSelector.h>\n"");; 1752 fprintf(hf,""#include <TBranchProxy.h>\n"");; 1753 fprintf(hf,""#include <TBranchProxyDirector.h>\n"");; 1754 fprintf(hf,""#include <TBranchProxyTemplate.h>\n"");; 1755 fprintf(hf,""#include <TFriendProxy.h>\n"");; 1756 fprintf(hf,""using namespace ROOT::Internal;\n""); // questionable; 1757 fprintf(hf,""using ROOT::Detail::TBranchProxy;\n""); // questionable; 1758 fprintf(hf,""\n"");; 1759 ; 1760 fprintf(hf,""// forward declarations needed by this particular proxy\n"");; 1761 TIter next( &fListOfForwards );; 1762 TObject *current;; 1763 while ( (current=next()) ) {; 1764 if (strstr(current->GetTitle(),""::"")==nullptr) {; 1765 // We can not forward declared nested classes (well we might be able to do so for; 1766 // the one nested in a namespace but it is not clear yet if we can really reliably; 1767 // find this information); 1768 fprintf(hf,""%s"",current->GetTitle());; 1769 }; 1770 }; 1771 ; 1772 fprintf(hf,""\n\n"");; 1773 fprintf(hf,""// Header needed by this particular proxy\n"");; 1774 next = &fListOfHeaders;; 1775 TObject *header;; 1776 while ( (header = next()) ) {; 1777 fprintf(hf,""%s"",header->GetTitle());; 1778 }; 1779 fprintf(hf,""\n\n"");; 1780 ; 1781 fprintf(hf,""class %s_Interface {\n"", scriptfunc.Data());; 1782 fprintf(hf,"" // This class defines the list of methods that are directly used by %s,\n"",classname.Data());; 1783 fprintf(hf,"" // and that can be overloaded in the user's script\n"");; 1784 fprintf(hf,""public:\n"");; 1785 fprintf(hf,"" void %s_Begin(TTree*) {}\n"",scriptfunc.Data());; 1786 fprintf(hf,"" void %s_SlaveBegin(TTree*) {}\n"",scriptfunc.Data());; 1787 fprintf(hf,"" bool %s_Notify() { return true; }\n"",scriptfunc.Data());; 1788 fprintf(hf,"" bool %s_Process(Long64_t) { return",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:75521,Usability,simpl,simple,75521,"n(tree);\n"",scriptfunc.Data());; 1961 fprintf(hf,""\n"");; 1962 fprintf(hf,""}\n"");; 1963 fprintf(hf,""\n"");; 1964 ; 1965 // generate code for class member function Process; 1966 fprintf(hf,""inline bool %s::Process(Long64_t entry)\n"",classname.Data());; 1967 fprintf(hf,""{\n"");; 1968 ; 1969 fprintf(hf,"" // The Process() function is called for each entry in the tree (or possibly\n""; 1970 "" // keyed object in the case of PROOF) to be processed. The entry argument\n""; 1971 "" // specifies which entry in the currently loaded tree is to be processed.\n""; 1972 "" // It can be passed to either TTree::GetEntry() or TBranch::GetEntry()\n""; 1973 "" // to read either all or the required parts of the data. When processing\n""; 1974 "" // keyed objects with PROOF, the object is already loaded and is available\n""; 1975 "" // via the fObject pointer.\n""; 1976 "" //\n""; 1977 "" // This function should contain the \""body\"" of the analysis. It can contain\n""; 1978 "" // simple or elaborate selection criteria, run algorithms on the data\n""; 1979 "" // of the event and typically fill histograms.\n\n"");; 1980 fprintf(hf,"" // WARNING when a selector is used with a TChain, you must use\n"");; 1981 fprintf(hf,"" // the pointer to the current TTree to call GetEntry(entry).\n"");; 1982 fprintf(hf,"" // The entry is always the local entry number in the current tree.\n"");; 1983 fprintf(hf,"" // Assuming that fChain is the pointer to the TChain being processed,\n"");; 1984 fprintf(hf,"" // use fChain->GetTree()->GetEntry(entry).\n"");; 1985 fprintf(hf,""\n"");; 1986 fprintf(hf,""\n"");; 1987 fprintf(hf,"" fDirector.SetReadEntry(entry);\n"");; 1988 if (fOptions & kNoHist) {; 1989 if (cutfilename) {; 1990 fprintf(hf,"" if (%s()) %s();\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1991 } else {; 1992 fprintf(hf,"" %s();\n"",scriptfunc.Data());; 1993 }; 1994 } else {; 1995 if (cutfilename) {; 1996 fprintf(hf,"" if (%s()) htemp->Fill(%s());\n"",cutscriptfunc.Data(),scriptfunc.Data());; 1997 } else {; 1998 fprintf(hf,"" htemp->Fill(%s(",MatchSource.WIKI,doc/master/TTreeProxyGenerator_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:2020,Availability,error,error,2020,"////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -4, ///< Some other error - hopefully the error message helps.; 56 kSetupMissingDictionary = -3, ///< To read this branch, we need a dictionary.; 57 kSetupMismatch = -2, ///< Mismatch of branch type and reader template type.; 58 kSetupNotACollection = -1, ///< The branch class type is not a collection.; 59 kSetupMatch = 0, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 60 kSetupMatchBranch = 7, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:2042,Availability,error,error,2042,"////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -4, ///< Some other error - hopefully the error message helps.; 56 kSetupMissingDictionary = -3, ///< To read this branch, we need a dictionary.; 57 kSetupMismatch = -2, ///< Mismatch of branch type and reader template type.; 58 kSetupNotACollection = -1, ///< The branch class type is not a collection.; 59 kSetupMatch = 0, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 60 kSetupMatchBranch = 7, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:8192,Availability,error,error,8192,"lue final : public ROOT::Internal::TTreeReaderValueBase {; 159 public:; 160 TTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname); 161 : TTreeReaderValueBase(&tr, branchname, /*dict*/ nullptr, /*opaqueRead*/ true); 162 {; 163 }; 164 ; 165 protected:; 166 const char *GetDerivedTypeName() const { return """"; }; 167 };; 168 ; 169} // namespace Internal; 170} // namespace ROOT; 171 ; 172 ; 173template <typename T>; 174class R__CLING_PTRCHECK(off) TTreeReaderValue final: public ROOT::Internal::TTreeReaderValueBase {; 175// R__CLING_PTRCHECK is disabled because pointer / types are checked by CreateProxy().; 176 ; 177public:; 178 using NonConstT_t = typename std::remove_const<T>::type;; 179 TTreeReaderValue() = delete;; 180 TTreeReaderValue(TTreeReader& tr, const char* branchname):; 181 TTreeReaderValueBase(&tr, branchname,; 182 TDictionary::GetDictionary(typeid(NonConstT_t))) {}; 183 ; 184 /// Return a pointer to the value of the current entry.; 185 /// Return a nullptr and print an error if no entry has been loaded yet.; 186 /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; 187 /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; 188 /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.; 189 T *Get(); 190 {; 191 if (!fProxy) {; 192 ErrorAboutMissingProxyIfNeeded();; 193 return nullptr;; 194 }; 195 void *address = GetAddress(); // Needed to figure out if it's a pointer; 196 return fProxy->IsaPointer() ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occ",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:11253,Availability,error,error,11253,"ithout knowledge of its type.Definition TTreeReaderValue.h:158; ROOT::Internal::TTreeReaderOpaqueValue::GetDerivedTypeNameconst char * GetDerivedTypeName() constDefinition TTreeReaderValue.h:166; ROOT::Internal::TTreeReaderOpaqueValue::TTreeReaderOpaqueValueTTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:160; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; ROOT::Internal::TTreeReaderValueBase::RegisterWithTreeReadervoid RegisterWithTreeReader()Register with tree reader.Definition TTreeReaderValue.cxx:130; ROOT::Internal::TTreeReaderValueBase::ESetupStatusESetupStatusStatus flags, 0 is good.Definition TTreeReaderValue.h:49; ROOT::Internal::TTreeReaderValueBase::kSetupMatchBranch@ kSetupMatchBranchThis branch has been set up, branch data type and reader template type match, reading should succeed.Definition TTreeReaderValue.h:60; ROOT::Internal::TTreeReaderValueBase::kSetupInternalError@ kSetupInternalErrorSome other error - hopefully the error message helps.Definition TTreeReaderValue.h:55; ROOT::Internal::TTreeReaderValueBase::kSetupMissingBranch@ kSetupMissingBranchThe specified branch cannot be found.Definition TTreeReaderValue.h:54; ROOT::Internal::TTreeReaderValueBase::kSetupNotSetup@ kSetupNotSetupNo initialization has happened yet.Definition TTreeReaderValue.h:50; ROOT::Internal::TTreeReaderValueBase::kSetupMakeClassModeMismatch@ kSetupMakeClassModeMismatchreaders disagree on whether TTree::SetMakeBranch() should be onDefinition TTreeReaderValue.h:52; ROOT::Internal::TTreeReaderValueBase::kSetupNotACollection@ kSetupNotACollectionThe branch class type is not a collection.Definition TTreeReaderValue.h:58; ROOT::Internal::TTreeReaderValueBase::kSetupMissingDictionary@ kSetupMissingDictionaryTo read this branch, we need a dictionary.Definition TTreeReaderValue.h:56; ROOT::Internal::TTreeReaderValueBase::kSetupMissingCounterBranch@ kSetupMissingCounterBranchThe array c",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:11275,Availability,error,error,11275,"ithout knowledge of its type.Definition TTreeReaderValue.h:158; ROOT::Internal::TTreeReaderOpaqueValue::GetDerivedTypeNameconst char * GetDerivedTypeName() constDefinition TTreeReaderValue.h:166; ROOT::Internal::TTreeReaderOpaqueValue::TTreeReaderOpaqueValueTTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:160; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; ROOT::Internal::TTreeReaderValueBase::RegisterWithTreeReadervoid RegisterWithTreeReader()Register with tree reader.Definition TTreeReaderValue.cxx:130; ROOT::Internal::TTreeReaderValueBase::ESetupStatusESetupStatusStatus flags, 0 is good.Definition TTreeReaderValue.h:49; ROOT::Internal::TTreeReaderValueBase::kSetupMatchBranch@ kSetupMatchBranchThis branch has been set up, branch data type and reader template type match, reading should succeed.Definition TTreeReaderValue.h:60; ROOT::Internal::TTreeReaderValueBase::kSetupInternalError@ kSetupInternalErrorSome other error - hopefully the error message helps.Definition TTreeReaderValue.h:55; ROOT::Internal::TTreeReaderValueBase::kSetupMissingBranch@ kSetupMissingBranchThe specified branch cannot be found.Definition TTreeReaderValue.h:54; ROOT::Internal::TTreeReaderValueBase::kSetupNotSetup@ kSetupNotSetupNo initialization has happened yet.Definition TTreeReaderValue.h:50; ROOT::Internal::TTreeReaderValueBase::kSetupMakeClassModeMismatch@ kSetupMakeClassModeMismatchreaders disagree on whether TTree::SetMakeBranch() should be onDefinition TTreeReaderValue.h:52; ROOT::Internal::TTreeReaderValueBase::kSetupNotACollection@ kSetupNotACollectionThe branch class type is not a collection.Definition TTreeReaderValue.h:58; ROOT::Internal::TTreeReaderValueBase::kSetupMissingDictionary@ kSetupMissingDictionaryTo read this branch, we need a dictionary.Definition TTreeReaderValue.h:56; ROOT::Internal::TTreeReaderValueBase::kSetupMissingCounterBranch@ kSetupMissingCounterBranchThe array c",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:20263,Availability,robust,robust,20263,"e name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treetreeplayerincTTreeReaderValue.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:904,Integrability,interface,interface,904,". ROOT: tree/treeplayer/inc/TTreeReaderValue.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeReaderValue.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Axel Naumann, 2010-08-02; 3// Author: Vincenzo Eduardo Padulano CERN 09/2024; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TTreeReaderValue; 14#define ROOT_TTreeReaderValue; 15 ; 16////////////////////////////////////////////////////////////////////////////; 17// //; 18// TTreeReaderValue //; 19// //; 20// A simple interface for reading data from trees or chains. //; 21// //; 22// //; 23////////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:2048,Integrability,message,message,2048,"////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -4, ///< Some other error - hopefully the error message helps.; 56 kSetupMissingDictionary = -3, ///< To read this branch, we need a dictionary.; 57 kSetupMismatch = -2, ///< Mismatch of branch type and reader template type.; 58 kSetupNotACollection = -1, ///< The branch class type is not a collection.; 59 kSetupMatch = 0, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 60 kSetupMatchBranch = 7, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:11281,Integrability,message,message,11281,"ithout knowledge of its type.Definition TTreeReaderValue.h:158; ROOT::Internal::TTreeReaderOpaqueValue::GetDerivedTypeNameconst char * GetDerivedTypeName() constDefinition TTreeReaderValue.h:166; ROOT::Internal::TTreeReaderOpaqueValue::TTreeReaderOpaqueValueTTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:160; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; ROOT::Internal::TTreeReaderValueBase::RegisterWithTreeReadervoid RegisterWithTreeReader()Register with tree reader.Definition TTreeReaderValue.cxx:130; ROOT::Internal::TTreeReaderValueBase::ESetupStatusESetupStatusStatus flags, 0 is good.Definition TTreeReaderValue.h:49; ROOT::Internal::TTreeReaderValueBase::kSetupMatchBranch@ kSetupMatchBranchThis branch has been set up, branch data type and reader template type match, reading should succeed.Definition TTreeReaderValue.h:60; ROOT::Internal::TTreeReaderValueBase::kSetupInternalError@ kSetupInternalErrorSome other error - hopefully the error message helps.Definition TTreeReaderValue.h:55; ROOT::Internal::TTreeReaderValueBase::kSetupMissingBranch@ kSetupMissingBranchThe specified branch cannot be found.Definition TTreeReaderValue.h:54; ROOT::Internal::TTreeReaderValueBase::kSetupNotSetup@ kSetupNotSetupNo initialization has happened yet.Definition TTreeReaderValue.h:50; ROOT::Internal::TTreeReaderValueBase::kSetupMakeClassModeMismatch@ kSetupMakeClassModeMismatchreaders disagree on whether TTree::SetMakeBranch() should be onDefinition TTreeReaderValue.h:52; ROOT::Internal::TTreeReaderValueBase::kSetupNotACollection@ kSetupNotACollectionThe branch class type is not a collection.Definition TTreeReaderValue.h:58; ROOT::Internal::TTreeReaderValueBase::kSetupMissingDictionary@ kSetupMissingDictionaryTo read this branch, we need a dictionary.Definition TTreeReaderValue.h:56; ROOT::Internal::TTreeReaderValueBase::kSetupMissingCounterBranch@ kSetupMissingCounterBranchThe array c",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:19028,Integrability,interface,interface,19028,"eBase::fProxyDetail::TBranchProxy * fProxyProxy for this branch, owned by TTreeReader.Definition TTreeReaderValue.h:132; ROOT::Internal::TTreeReaderValueBase::fStaticClassOffsetsstd::vector< Long64_t > fStaticClassOffsetsDefinition TTreeReaderValue.h:134; ROOT::Internal::TTreeReaderValueBase::SearchBranchWithCompositeNameTBranch * SearchBranchWithCompositeName(TLeaf *&myleaf, TDictionary *&branchActualType, std::string &err)Search a branch the name of which contains a ""."".Definition TTreeReaderValue.cxx:303; ROOT::Internal::TTreeReaderValueBase::GetBranchDataTypestatic const char * GetBranchDataType(TBranch *branch, TDictionary *&dict, TDictionary const *curDict)Retrieve the type of data stored by branch; put its dictionary into dict, return its type name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type N",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:19312,Integrability,interface,interface,19312,"e::SearchBranchWithCompositeNameTBranch * SearchBranchWithCompositeName(TLeaf *&myleaf, TDictionary *&branchActualType, std::string &err)Search a branch the name of which contains a ""."".Definition TTreeReaderValue.cxx:303; ROOT::Internal::TTreeReaderValueBase::GetBranchDataTypestatic const char * GetBranchDataType(TBranch *branch, TDictionary *&dict, TDictionary const *curDict)Retrieve the type of data stored by branch; put its dictionary into dict, return its type name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar dataset",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:20279,Integrability,interface,interface,20279,"e name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treetreeplayerincTTreeReaderValue.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:8219,Performance,load,loaded,8219,"lue final : public ROOT::Internal::TTreeReaderValueBase {; 159 public:; 160 TTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname); 161 : TTreeReaderValueBase(&tr, branchname, /*dict*/ nullptr, /*opaqueRead*/ true); 162 {; 163 }; 164 ; 165 protected:; 166 const char *GetDerivedTypeName() const { return """"; }; 167 };; 168 ; 169} // namespace Internal; 170} // namespace ROOT; 171 ; 172 ; 173template <typename T>; 174class R__CLING_PTRCHECK(off) TTreeReaderValue final: public ROOT::Internal::TTreeReaderValueBase {; 175// R__CLING_PTRCHECK is disabled because pointer / types are checked by CreateProxy().; 176 ; 177public:; 178 using NonConstT_t = typename std::remove_const<T>::type;; 179 TTreeReaderValue() = delete;; 180 TTreeReaderValue(TTreeReader& tr, const char* branchname):; 181 TTreeReaderValueBase(&tr, branchname,; 182 TDictionary::GetDictionary(typeid(NonConstT_t))) {}; 183 ; 184 /// Return a pointer to the value of the current entry.; 185 /// Return a nullptr and print an error if no entry has been loaded yet.; 186 /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; 187 /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; 188 /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.; 189 T *Get(); 190 {; 191 if (!fProxy) {; 192 ErrorAboutMissingProxyIfNeeded();; 193 return nullptr;; 194 }; 195 void *address = GetAddress(); // Needed to figure out if it's a pointer; 196 return fProxy->IsaPointer() ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occ",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:9142,Performance,load,loaded,9142,"value of the current entry.; 185 /// Return a nullptr and print an error if no entry has been loaded yet.; 186 /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; 187 /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; 188 /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.; 189 T *Get(); 190 {; 191 if (!fProxy) {; 192 ErrorAboutMissingProxyIfNeeded();; 193 return nullptr;; 194 }; 195 void *address = GetAddress(); // Needed to figure out if it's a pointer; 196 return fProxy->IsaPointer() ? *(T **)address : (T *)address;; 197 }; 198 ; 199 /// Return a pointer to the value of the current entry.; 200 /// Equivalent to Get().; 201 T* operator->() { return Get(); }; 202 ; 203 /// Return a reference to the value of the current entry.; 204 /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; 205 /// Most likely a crash will occur.; 206 T& operator*() { return *Get(); }; 207 ; 208protected:; 209 // FIXME: use IsA() instead once we have ClassDefTInline; 210 /// Get the template argument as a string.; 211 const char* GetDerivedTypeName() const override {; 212 static const std::string sElementTypeName = GetElementTypeName(typeid(T));; 213 return sElementTypeName.data();; 214 }; 215 ; 216 // FIXME: re-introduce once we have ClassDefTInline!; 217 //ClassDefT(TTreeReaderValue, 0);//Accessor to data via TTreeReader; 218};; 219 ; 220namespace cling {; 221std::string printValue(ROOT::Internal::TTreeReaderValueBase *val);; 222template <typename T>; 223std::string printValue(TTreeReaderValue<T> *val); 224{; 225 return printValue(static_cast<ROOT::Internal::TTreeReaderValueBase *>(val));; 226}; 227} // namespace cling; 228 ; 229#endif // ROOT_TTreeReaderValue; TBranchProxy.h; TDictionary.h; TString.h; ROOT::Detail::TBranchProxyBase class for all the proxy o",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:3296,Security,access,accessed,3296," ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading should succeed.; 64 // kSetupVoidPtr = 4,; 65 kSetupNoCheck = 5,; 66 kSetupMatchLeaf = 6 ///< This branch (or TLeaf, really) has been set up, reading should succeed.; 67 };; 68 enum EReadStatus {; 69 kReadSuccess = 0, ///< Data read okay; 70 kReadNothingYet, ///< Data now yet accessed; 71 kReadError ///< Problem reading data; 72 };; 73 ; 74 EReadStatus ProxyRead() { return (this->*fProxyReadFunc)(); }; 75 ; 76 EReadStatus ProxyReadDefaultImpl();; 77 ; 78 typedef bool (ROOT::Detail::TBranchProxy::*BranchProxyRead_t)();; 79 template <BranchProxyRead_t Func>; 80 ROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate();; 81 ; 82 /// Return true if the branch was setup \em and \em read correctly.; 83 /// Use GetSetupStatus() to only check the setup status.; 84 bool IsValid() const { return fProxy && 0 == (int)fSetupStatus && 0 == (int)fReadStatus; }; 85 /// Return this TTreeReaderValue's setup status.; 86 /// Use this method to check e.g. whether the TTreeReaderValue is correctly setup and ready for reading.; 87 ESetupStatus GetSetupStatus() const { return fSetupStatus; }; 88 virtual EReadStatus GetReadStatus() const { return fReadStatus; }; 89 ; 90 /// If we are reading a leaf, return the corresponding TLeaf.; 91 TLeaf* GetLeaf() { return fLeaf; }; 92 ; 93 void* GetAddress();; 94 ; 95 const char* GetBranchName() const { return fBranchName; }; 96 ; 97 virtual ~TTreeReaderValueBase();; 98 ; 99 protected:; 100",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:5663,Security,access,access,5663," RegisterWithTreeReader();; 105 void NotifyNewTree(TTree* newTree);; 106 ; 107 TBranch* SearchBranchWithCompositeName(TLeaf *&myleaf, TDictionary *&branchActualType, std::string &err);; 108 virtual void CreateProxy();; 109 static const char* GetBranchDataType(TBranch* branch,; 110 TDictionary* &dict,; 111 TDictionary const *curDict);; 112 ; 113 virtual const char* GetDerivedTypeName() const = 0;; 114 ; 115 Detail::TBranchProxy* GetProxy() const { return fProxy; }; 116 ; 117 void MarkTreeReaderUnavailable() { fTreeReader = nullptr; fSetupStatus = kSetupTreeDestructed; }; 118 ; 119 /// Stringify the template argument.; 120 static std::string GetElementTypeName(const std::type_info& ti);; 121 ; 122 void ErrorAboutMissingProxyIfNeeded();; 123 ; 124 bool fHaveLeaf : 1; ///< Whether the data is in a leaf; 125 bool fHaveStaticClassOffsets : 1; ///< Whether !fStaticClassOffsets.empty(); 126 EReadStatus fReadStatus : 2; ///< Read status of this data access; 127 ESetupStatus fSetupStatus = kSetupNotSetup; ///< Setup status of this data access; 128 TString fBranchName; ///< Name of the branch to read data from.; 129 TString fLeafName;; 130 TTreeReader* fTreeReader; ///< Tree reader we belong to; 131 TDictionary* fDict; ///< Type that the branch should contain; 132 Detail::TBranchProxy* fProxy = nullptr; ///< Proxy for this branch, owned by TTreeReader; 133 TLeaf* fLeaf = nullptr;; 134 std::vector<Long64_t> fStaticClassOffsets;; 135 typedef EReadStatus (TTreeReaderValueBase::*Read_t)();; 136 Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl; ///<! Pointer to the Read implementation to use.; 137 /**; 138 * If true, the reader will not do any type-checking against the actual; 139 * type held by the branch. Useful to just check if the current entry can; 140 * be read or not without caring about its value.; 141 * \note Only used by TTreeReaderOpaqueValue.; 142 */; 143 bool fOpaqueRead{false};; 144 ; 145 // FIXME: re-introduce once we have ClassDefInline!; 146 //Cl",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:5750,Security,access,access,5750," RegisterWithTreeReader();; 105 void NotifyNewTree(TTree* newTree);; 106 ; 107 TBranch* SearchBranchWithCompositeName(TLeaf *&myleaf, TDictionary *&branchActualType, std::string &err);; 108 virtual void CreateProxy();; 109 static const char* GetBranchDataType(TBranch* branch,; 110 TDictionary* &dict,; 111 TDictionary const *curDict);; 112 ; 113 virtual const char* GetDerivedTypeName() const = 0;; 114 ; 115 Detail::TBranchProxy* GetProxy() const { return fProxy; }; 116 ; 117 void MarkTreeReaderUnavailable() { fTreeReader = nullptr; fSetupStatus = kSetupTreeDestructed; }; 118 ; 119 /// Stringify the template argument.; 120 static std::string GetElementTypeName(const std::type_info& ti);; 121 ; 122 void ErrorAboutMissingProxyIfNeeded();; 123 ; 124 bool fHaveLeaf : 1; ///< Whether the data is in a leaf; 125 bool fHaveStaticClassOffsets : 1; ///< Whether !fStaticClassOffsets.empty(); 126 EReadStatus fReadStatus : 2; ///< Read status of this data access; 127 ESetupStatus fSetupStatus = kSetupNotSetup; ///< Setup status of this data access; 128 TString fBranchName; ///< Name of the branch to read data from.; 129 TString fLeafName;; 130 TTreeReader* fTreeReader; ///< Tree reader we belong to; 131 TDictionary* fDict; ///< Type that the branch should contain; 132 Detail::TBranchProxy* fProxy = nullptr; ///< Proxy for this branch, owned by TTreeReader; 133 TLeaf* fLeaf = nullptr;; 134 std::vector<Long64_t> fStaticClassOffsets;; 135 typedef EReadStatus (TTreeReaderValueBase::*Read_t)();; 136 Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl; ///<! Pointer to the Read implementation to use.; 137 /**; 138 * If true, the reader will not do any type-checking against the actual; 139 * type held by the branch. Useful to just check if the current entry can; 140 * be read or not without caring about its value.; 141 * \note Only used by TTreeReaderOpaqueValue.; 142 */; 143 bool fOpaqueRead{false};; 144 ; 145 // FIXME: re-introduce once we have ClassDefInline!; 146 //Cl",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:6765,Security,access,accessors,6765,"der* fTreeReader; ///< Tree reader we belong to; 131 TDictionary* fDict; ///< Type that the branch should contain; 132 Detail::TBranchProxy* fProxy = nullptr; ///< Proxy for this branch, owned by TTreeReader; 133 TLeaf* fLeaf = nullptr;; 134 std::vector<Long64_t> fStaticClassOffsets;; 135 typedef EReadStatus (TTreeReaderValueBase::*Read_t)();; 136 Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl; ///<! Pointer to the Read implementation to use.; 137 /**; 138 * If true, the reader will not do any type-checking against the actual; 139 * type held by the branch. Useful to just check if the current entry can; 140 * be read or not without caring about its value.; 141 * \note Only used by TTreeReaderOpaqueValue.; 142 */; 143 bool fOpaqueRead{false};; 144 ; 145 // FIXME: re-introduce once we have ClassDefInline!; 146 //ClassDefOverride(TTreeReaderValueBase, 0);//Base class for accessors to data via TTreeReader; 147 ; 148 friend class ::TTreeReader;; 149 };; 150 ; 151 /**; 152 * \brief Read a value in a branch without knowledge of its type; 153 *; 154 * This class is helpful in situations where the actual contents of the branch; 155 * at the current entry are not relevant and one only wants to know whether; 156 * the entry can be read.; 157 */; 158 class R__CLING_PTRCHECK(off) TTreeReaderOpaqueValue final : public ROOT::Internal::TTreeReaderValueBase {; 159 public:; 160 TTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname); 161 : TTreeReaderValueBase(&tr, branchname, /*dict*/ nullptr, /*opaqueRead*/ true); 162 {; 163 }; 164 ; 165 protected:; 166 const char *GetDerivedTypeName() const { return """"; }; 167 };; 168 ; 169} // namespace Internal; 170} // namespace ROOT; 171 ; 172 ; 173template <typename T>; 174class R__CLING_PTRCHECK(off) TTreeReaderValue final: public ROOT::Internal::TTreeReaderValueBase {; 175// R__CLING_PTRCHECK is disabled because pointer / types are checked by CreateProxy().; 176 ; 177public:; 178 using NonConstT_t = typename std",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:15200,Security,access,accessed,15200,"eaderValueBase::MarkTreeReaderUnavailablevoid MarkTreeReaderUnavailable()Definition TTreeReaderValue.h:117; ROOT::Internal::TTreeReaderValueBase::fLeafTLeaf * fLeafDefinition TTreeReaderValue.h:133; ROOT::Internal::TTreeReaderValueBase::GetProxyDetail::TBranchProxy * GetProxy() constDefinition TTreeReaderValue.h:115; ROOT::Internal::TTreeReaderValueBase::fHaveStaticClassOffsetsbool fHaveStaticClassOffsetsWhether !fStaticClassOffsets.empty()Definition TTreeReaderValue.h:125; ROOT::Internal::TTreeReaderValueBase::GetAddressvoid * GetAddress()Returns the memory address of the object being read.Definition TTreeReaderValue.cxx:255; ROOT::Internal::TTreeReaderValueBase::EReadStatusEReadStatusDefinition TTreeReaderValue.h:68; ROOT::Internal::TTreeReaderValueBase::kReadError@ kReadErrorProblem reading data.Definition TTreeReaderValue.h:71; ROOT::Internal::TTreeReaderValueBase::kReadSuccess@ kReadSuccessData read okay.Definition TTreeReaderValue.h:69; ROOT::Internal::TTreeReaderValueBase::kReadNothingYet@ kReadNothingYetData now yet accessed.Definition TTreeReaderValue.h:70; ROOT::Internal::TTreeReaderValueBase::GetElementTypeNamestatic std::string GetElementTypeName(const std::type_info &ti)Stringify the template argument.Definition TTreeReaderValue.cxx:217; ROOT::Internal::TTreeReaderValueBase::fSetupStatusESetupStatus fSetupStatusSetup status of this data access.Definition TTreeReaderValue.h:127; ROOT::Internal::TTreeReaderValueBase::IsValidbool IsValid() constReturn true if the branch was setup and read correctly.Definition TTreeReaderValue.h:84; ROOT::Internal::TTreeReaderValueBase::GetDerivedTypeNamevirtual const char * GetDerivedTypeName() const =0; ROOT::Internal::TTreeReaderValueBase::fBranchNameTString fBranchNameName of the branch to read data from.Definition TTreeReaderValue.h:128; ROOT::Internal::TTreeReaderValueBase::ProxyReadTemplateROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate()Try to read the value from the TBranchProxy, returns the sta",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:15532,Security,access,access,15532,"OOT::Internal::TTreeReaderValueBase::fHaveStaticClassOffsetsbool fHaveStaticClassOffsetsWhether !fStaticClassOffsets.empty()Definition TTreeReaderValue.h:125; ROOT::Internal::TTreeReaderValueBase::GetAddressvoid * GetAddress()Returns the memory address of the object being read.Definition TTreeReaderValue.cxx:255; ROOT::Internal::TTreeReaderValueBase::EReadStatusEReadStatusDefinition TTreeReaderValue.h:68; ROOT::Internal::TTreeReaderValueBase::kReadError@ kReadErrorProblem reading data.Definition TTreeReaderValue.h:71; ROOT::Internal::TTreeReaderValueBase::kReadSuccess@ kReadSuccessData read okay.Definition TTreeReaderValue.h:69; ROOT::Internal::TTreeReaderValueBase::kReadNothingYet@ kReadNothingYetData now yet accessed.Definition TTreeReaderValue.h:70; ROOT::Internal::TTreeReaderValueBase::GetElementTypeNamestatic std::string GetElementTypeName(const std::type_info &ti)Stringify the template argument.Definition TTreeReaderValue.cxx:217; ROOT::Internal::TTreeReaderValueBase::fSetupStatusESetupStatus fSetupStatusSetup status of this data access.Definition TTreeReaderValue.h:127; ROOT::Internal::TTreeReaderValueBase::IsValidbool IsValid() constReturn true if the branch was setup and read correctly.Definition TTreeReaderValue.h:84; ROOT::Internal::TTreeReaderValueBase::GetDerivedTypeNamevirtual const char * GetDerivedTypeName() const =0; ROOT::Internal::TTreeReaderValueBase::fBranchNameTString fBranchNameName of the branch to read data from.Definition TTreeReaderValue.h:128; ROOT::Internal::TTreeReaderValueBase::ProxyReadTemplateROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate()Try to read the value from the TBranchProxy, returns the status of the read.Definition TTreeReaderValue.cxx:145; ROOT::Internal::TTreeReaderValueBase::fTreeReaderTTreeReader * fTreeReaderTree reader we belong to.Definition TTreeReaderValue.h:130; ROOT::Internal::TTreeReaderValueBase::fDictTDictionary * fDictType that the branch should contain.Definition TTreeReaderValue.h:131; R",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:16734,Security,access,access,16734,"orrectly.Definition TTreeReaderValue.h:84; ROOT::Internal::TTreeReaderValueBase::GetDerivedTypeNamevirtual const char * GetDerivedTypeName() const =0; ROOT::Internal::TTreeReaderValueBase::fBranchNameTString fBranchNameName of the branch to read data from.Definition TTreeReaderValue.h:128; ROOT::Internal::TTreeReaderValueBase::ProxyReadTemplateROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate()Try to read the value from the TBranchProxy, returns the status of the read.Definition TTreeReaderValue.cxx:145; ROOT::Internal::TTreeReaderValueBase::fTreeReaderTTreeReader * fTreeReaderTree reader we belong to.Definition TTreeReaderValue.h:130; ROOT::Internal::TTreeReaderValueBase::fDictTDictionary * fDictType that the branch should contain.Definition TTreeReaderValue.h:131; ROOT::Internal::TTreeReaderValueBase::operator=TTreeReaderValueBase & operator=(const TTreeReaderValueBase &)Copy-assign.Definition TTreeReaderValue.cxx:93; ROOT::Internal::TTreeReaderValueBase::fReadStatusEReadStatus fReadStatusRead status of this data access.Definition TTreeReaderValue.h:126; ROOT::Internal::TTreeReaderValueBase::GetBranchNameconst char * GetBranchName() constDefinition TTreeReaderValue.h:95; ROOT::Internal::TTreeReaderValueBase::ErrorAboutMissingProxyIfNeededvoid ErrorAboutMissingProxyIfNeeded()Definition TTreeReaderValue.cxx:817; ROOT::Internal::TTreeReaderValueBase::GetLeafTLeaf * GetLeaf()If we are reading a leaf, return the corresponding TLeaf.Definition TTreeReaderValue.h:91; ROOT::Internal::TTreeReaderValueBase::ProxyReadEReadStatus ProxyRead()Definition TTreeReaderValue.h:74; ROOT::Internal::TTreeReaderValueBase::~TTreeReaderValueBasevirtual ~TTreeReaderValueBase()Unregister from tree reader, cleanup.Definition TTreeReaderValue.cxx:118; ROOT::Internal::TTreeReaderValueBase::BranchProxyRead_tbool(ROOT::Detail::TBranchProxy::* BranchProxyRead_t)()Definition TTreeReaderValue.h:78; ROOT::Internal::TTreeReaderValueBase::ProxyReadDefaultImplEReadStatus ProxyReadDefa",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:897,Usability,simpl,simple,897,". ROOT: tree/treeplayer/inc/TTreeReaderValue.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeReaderValue.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Axel Naumann, 2010-08-02; 3// Author: Vincenzo Eduardo Padulano CERN 09/2024; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TTreeReaderValue; 14#define ROOT_TTreeReaderValue; 15 ; 16////////////////////////////////////////////////////////////////////////////; 17// //; 18// TTreeReaderValue //; 19// //; 20// A simple interface for reading data from trees or chains. //; 21// //; 22// //; 23////////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReaderValue_8h_source.html:20255,Usability,simpl,simple,20255,"e name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treetreeplayerincTTreeReaderValue.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/TTreeReaderValue_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:5932,Availability,error,error,5932,"re really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully initialized.; 162 kIndexedFriendNoMatch, ///< A friend with TTreeIndex doesn't have an entry for this index; 163 kMissingBranchWhenSwitchingTree, ///< A branch was not found when switching to the next TTree in the chain; 164 kEntryUnknownError ///< LoadTree return less than -6, likely a 'newer' error code.; 165 };; 166 ; 167 enum ELoadTreeStatus {; 168 kNoTree = 0, ///< default state, no TTree is connected (formerly 'Zombie' state); 169 kLoadTreeNone, ///< Notify has not been called yet.; 170 kInternalLoadTree, ///< Notify/LoadTree was last called from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend ",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:6981,Availability,error,error,6981,"led from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend with TTreeIndex doesn't have an entry for this index"",; 185 ""A branch was not found when switching to the next TTree in the chain"",; 186 ""LoadTree return less than -6, likely a 'newer' error code""};; 187 ; 188 TTreeReader();; 189 ; 190 TTreeReader(TTree *tree, TEntryList *entryList = nullptr, bool warnAboutLongerFriends = true,; 191 const std::vector<std::string> &suppressErrorsForMissingBranches = {});; 192 TTreeReader(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 193 TTreeReader(const char *keyname, TEntryList *entryList = nullptr) : TTreeReader(keyname, nullptr, entryList) {}; 194 ; 195 ~TTreeReader() override;; 196 ; 197 void SetTree(TTree* tree, TEntryList* entryList = nullptr);; 198 void SetTree(const char* keyname, TEntryList* entryList = nullptr) {; 199 SetTree(keyname, nullptr, entryList);; 200 }; 201 void SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. Thi",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:8656,Availability,avail,available,8656,"SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. This allows; 215 /// the function to be used in `while (reader.Next()) { ... }`; 216 bool Next() {; 217 return SetEntry(GetCurrentEntry() + 1) == kEntryValid;; 218 }; 219 ; 220 /// Set the next entry (or index of the TEntryList if that is set).; 221 ///; 222 /// \param entry If not TEntryList is set, the entry is a global entry (i.e.; 223 /// not the entry number local to the chain's current tree).; 224 /// \returns the `entry`'s read status, i.e. whether the entry is available.; 225 EEntryStatus SetEntry(Long64_t entry) { return SetEntryBase(entry, false); }; 226 ; 227 /// Set the next local tree entry. If a TEntryList is set, this function is; 228 /// equivalent to `SetEntry()`.; 229 ///; 230 /// \param entry Entry number of the TChain's current TTree. This is the; 231 /// entry number passed for instance by `TSelector::Process(entry)`, i.e.; 232 /// within `TSelector::Process()` always use `SetLocalEntry()` and not; 233 /// `SetEntry()`!; 234 /// \return the `entry`'s read status, i.e. whether the entry is available.; 235 EEntryStatus SetLocalEntry(Long64_t entry) { return SetEntryBase(entry, true); }; 236 ; 237 EEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry);; 238 ; 239 /// Get the begin and end entry numbers; 240 ///; 241 /// \return a pair contained the begin and end entry numbers.; 242 std::pair<Long64_t, Long64_t> GetEntriesRange() const { return std::make_pair(fBeginEntry, fEndEntry); }; 243 ; 244 /// Restart a Ne",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:9208,Availability,avail,available,9208,"/ the function to be used in `while (reader.Next()) { ... }`; 216 bool Next() {; 217 return SetEntry(GetCurrentEntry() + 1) == kEntryValid;; 218 }; 219 ; 220 /// Set the next entry (or index of the TEntryList if that is set).; 221 ///; 222 /// \param entry If not TEntryList is set, the entry is a global entry (i.e.; 223 /// not the entry number local to the chain's current tree).; 224 /// \returns the `entry`'s read status, i.e. whether the entry is available.; 225 EEntryStatus SetEntry(Long64_t entry) { return SetEntryBase(entry, false); }; 226 ; 227 /// Set the next local tree entry. If a TEntryList is set, this function is; 228 /// equivalent to `SetEntry()`.; 229 ///; 230 /// \param entry Entry number of the TChain's current TTree. This is the; 231 /// entry number passed for instance by `TSelector::Process(entry)`, i.e.; 232 /// within `TSelector::Process()` always use `SetLocalEntry()` and not; 233 /// `SetEntry()`!; 234 /// \return the `entry`'s read status, i.e. whether the entry is available.; 235 EEntryStatus SetLocalEntry(Long64_t entry) { return SetEntryBase(entry, true); }; 236 ; 237 EEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry);; 238 ; 239 /// Get the begin and end entry numbers; 240 ///; 241 /// \return a pair contained the begin and end entry numbers.; 242 std::pair<Long64_t, Long64_t> GetEntriesRange() const { return std::make_pair(fBeginEntry, fEndEntry); }; 243 ; 244 /// Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set).; 245 void Restart();; 246 ; 247 ///\}; 248 ; 249 EEntryStatus GetEntryStatus() const { return fEntryStatus; }; 250 ; 251 Long64_t GetEntries() const;; 252 Long64_t GetEntries(bool force);; 253 ; 254 /// Returns the index of the current entry being read.; 255 ///; 256 /// If `IsChain()`, the returned index corresponds to the global entry number; 257 /// (i.e. not the entry number local to the chain's current tree).; 258 /// If `fEntryList`, the returned index corresponds to an in",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:14450,Availability,error,error,14450,"ndEntry.; 335 Long64_t fEndEntry = -1LL;; 336 Long64_t fBeginEntry = 0LL; ///< This allows us to propagate the range to the TTreeCache; 337 bool fProxiesSet = false; ///< True if the proxies have been set, false otherwise; 338 bool fSetEntryBaseCallingLoadTree = false; ///< True if during the LoadTree execution triggered by SetEntryBase.; 339 ; 340 // Flag to activate or deactivate warnings in case the friend trees have; 341 // more entries than the main one. In some cases we may want to deactivate; 342 // this behaviour, notably in multithreaded runs where we have to partition; 343 // the main tree but keep the entire friend trees in every thread to ensure; 344 // alignment.; 345 bool fWarnAboutLongerFriends{true};; 346 void WarnIfFriendsHaveMoreEntries();; 347 ; 348 // List of branches for which we want to suppress the printed error about; 349 // missing branch when switching to a new tree; 350 std::vector<std::string> fSuppressErrorsForMissingBranches{};; 351 std::vector<std::string> fMissingProxies{};; 352 ; 353 friend class ROOT::Internal::TTreeReaderValueBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represen",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:18687,Availability,robust,robust,18687,"==(const Iterator_t &lhs) constCompare two iterators for equality.Definition TTreeReader.h:83; TTreeReader::Iterator_t::fReaderTTreeReader * fReaderThe reader we select the entries on.Definition TTreeReader.h:61; TTreeReader::Iterator_t::operator*const Long64_t & operator*()Set the entry number in the reader and return it.Definition TTreeReader.h:134; TTreeReader::Iterator_t::IsValidbool IsValid() constWhether the iterator points to a valid entry.Definition TTreeReader.h:64; TTreeReader::Iterator_t::iterator_categorystd::input_iterator_tag iterator_categoryDefinition TTreeReader.h:67; TTreeReader::Iterator_t::operator!=bool operator!=(const Iterator_t &lhs) constCompare two iterators for inequality.Definition TTreeReader.h:109; TTreeReader::Iterator_t::operator++Iterator_t operator++(int)Increment the iterator (postfix i++).Definition TTreeReader.h:114; TTreeReader::Iterator_t::pointerconst Long64_t * pointerDefinition TTreeReader.h:70; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::TTreeReaderTTreeReader()Default constructor. Call SetTree to connect to a TTree.Definition TTreeReader.cxx:191; TTreeReader::fMissingProxiesstd::vector< std::string > fMissingProxiesDefinition TTreeReader.h:351; TTreeReader::fLoadTreeStatusELoadTreeStatus fLoadTreeStatusIndicator on how LoadTree was called 'last' time.Definition TTreeReader.h:321; TTreeReader::SetTreevoid SetTree(const char *keyname, TEntryList *entryList=nullptr)Definition TTreeReader.h:198; TTreeReader::IsInvalidbool IsInvalid() constDefinition TTreeReader.h:205; TTreeReader::GetEntriesLong64_t GetEntries() constReturns the number of entries of the TEntryList if one is provided, else of the TTree / TChain,...Definition TTreeReader.cxx:589; TTreeReader::fEntryStatusEEntryStatus fEntryStatusstatus of most recent read requestDefinition TTreeReader.h:320; TTreeReader::fSuppressErrorsForMissingBranchesstd::vector< std::strin",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:21307,Availability,error,error,21307,"eeReader~TTreeReader() overrideTell all value readers that the tree reader does not exist anymore.Definition TTreeReader.cxx:251; TTreeReader::fNotifyTNotifyLink< TTreeReader > fNotifyTTree and TChain will notify this object upon LoadTree, leading to a call to TTreeReader::Notify().Definition TTreeReader.h:323; TTreeReader::fProxiesSetbool fProxiesSetTrue if the proxies have been set, false otherwise.Definition TTreeReader.h:337; TTreeReader::IsChainbool IsChain() constDefinition TTreeReader.h:203; TTreeReader::AddProxyvoid AddProxy(std::unique_ptr< ROOT::Internal::TNamedBranchProxy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe tree entry number does not existDefinition TTreeReader.h:156; TTreeReader::kIndexedFriendNoMatch@ kIndexedFriendNoMatchA friend with TTreeIndex doesn't have an entry for this index.Definition TTreeReader.h:162; TTreeReader::kEntryUnknownError@ kEntryUnknownErrorLoadTree return less than -6, likely a 'newer' error code.Definition TTreeReader.h:164; TTreeReader::kEntryDictionaryError@ kEntryDictionaryErrorproblem reading dictionary info from treeDefinition TTreeReader.h:159; TTreeReader::kEntryChainSetupError@ kEntryChainSetupErrorproblem in accessing a chain element, e.g. file without the treeDefinition TTreeReader.h:157; TTreeReader::kMissingBranchWhenSwitchingTree@ kMissingBranchWhenSwitchingTreeA branch was not found when switching to the next TTree in the chain.Definition TTreeReader.h:163; TTreeReader::kEntryNotLoaded@ kEntryNotLoadedno entry has been loaded yetDefinition TTreeReader.h:154; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160; TTreeReader::kEntryChainFileError@ kEntryChainFileErrorproblem in opening a chain's fileDefinition TTreeReader.h:158; TTreeReader::kEntryNoTree@ kEntryNoTreethe tree does not existDefinition TTreeReader.h:155; TTreeReader::kEntryBadReader@ kEnt",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:20026,Deployability,update,update,20026,"efinition TTreeReader.h:351; TTreeReader::fLoadTreeStatusELoadTreeStatus fLoadTreeStatusIndicator on how LoadTree was called 'last' time.Definition TTreeReader.h:321; TTreeReader::SetTreevoid SetTree(const char *keyname, TEntryList *entryList=nullptr)Definition TTreeReader.h:198; TTreeReader::IsInvalidbool IsInvalid() constDefinition TTreeReader.h:205; TTreeReader::GetEntriesLong64_t GetEntries() constReturns the number of entries of the TEntryList if one is provided, else of the TTree / TChain,...Definition TTreeReader.cxx:589; TTreeReader::fEntryStatusEEntryStatus fEntryStatusstatus of most recent read requestDefinition TTreeReader.h:320; TTreeReader::fSuppressErrorsForMissingBranchesstd::vector< std::string > fSuppressErrorsForMissingBranchesDefinition TTreeReader.h:350; TTreeReader::NamedProxies_tstd::unordered_map< std::string, std::unique_ptr< ROOT::Internal::TNamedBranchProxy > > NamedProxies_tDefinition TTreeReader.h:273; TTreeReader::SetTreevoid SetTree(TTree *tree, TEntryList *entryList=nullptr)Set (or update) the which tree to read from.Definition TTreeReader.cxx:806; TTreeReader::GetEntriesRangestd::pair< Long64_t, Long64_t > GetEntriesRange() constGet the begin and end entry numbers.Definition TTreeReader.h:242; TTreeReader::~TTreeReader~TTreeReader() overrideTell all value readers that the tree reader does not exist anymore.Definition TTreeReader.cxx:251; TTreeReader::fNotifyTNotifyLink< TTreeReader > fNotifyTTree and TChain will notify this object upon LoadTree, leading to a call to TTreeReader::Notify().Definition TTreeReader.h:323; TTreeReader::fProxiesSetbool fProxiesSetTrue if the proxies have been set, false otherwise.Definition TTreeReader.h:337; TTreeReader::IsChainbool IsChain() constDefinition TTreeReader.h:203; TTreeReader::AddProxyvoid AddProxy(std::unique_ptr< ROOT::Internal::TNamedBranchProxy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe t",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:884,Integrability,interface,interface,884,". ROOT: tree/treeplayer/inc/TTreeReader.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeReader.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Axel Naumann, 2010-08-02; 3// Author: Vincenzo Eduardo Padulano CERN 09/2024; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TTreeReader; 14#define ROOT_TTreeReader; 15 ; 16 ; 17////////////////////////////////////////////////////////////////////////////; 18// //; 19// TTreeReader //; 20// //; 21// A simple interface for reading trees or chains. //; 22// //; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TTree.h""; 27#include ""TTreeReaderUtils.h""; 28#include ""TNotifyLink.h""; 29 ; 30#include <deque>; 31#include <iterator>; 32#include <unordered_map>; 33#include <string>; 34 ; 35class TDictionary;; 36class TDirectory;; 37class TFileCollection;; 38 ; 39namespace ROOT {; 40namespace Internal {; 41 class TBranchProxyDirector;; 42 class TFriendProxy;; 43}; 44}; 45 ; 46class TTreeReader: public TObject {; 47public:; 48 ; 49 ///\class TTreeReader::Iterator_t; 50 /// Iterate through the entries of a TTree.; 51 ///; 52 /// This iterator drives the associated TTreeReader; its; 53 /// dereferencing (and actually even the iteration) will; 54 /// set the entry number represented by this iterator.; 55 /// It does not really represent a data element; it simply; 56 /// returns the entry number (or -1 once the end of the tree; 57 /// is reached).; 58 class Iterator_t {; 59 private:; 60 Long64_t fEntry; ///< Entry number of the tree referenced by this iterator; -1 ",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:14805,Integrability,interface,interface,14805,"ndEntry.; 335 Long64_t fEndEntry = -1LL;; 336 Long64_t fBeginEntry = 0LL; ///< This allows us to propagate the range to the TTreeCache; 337 bool fProxiesSet = false; ///< True if the proxies have been set, false otherwise; 338 bool fSetEntryBaseCallingLoadTree = false; ///< True if during the LoadTree execution triggered by SetEntryBase.; 339 ; 340 // Flag to activate or deactivate warnings in case the friend trees have; 341 // more entries than the main one. In some cases we may want to deactivate; 342 // this behaviour, notably in multithreaded runs where we have to partition; 343 // the main tree but keep the entire friend trees in every thread to ensure; 344 // alignment.; 345 bool fWarnAboutLongerFriends{true};; 346 void WarnIfFriendsHaveMoreEntries();; 347 ; 348 // List of branches for which we want to suppress the printed error about; 349 // missing branch when switching to a new tree; 350 std::vector<std::string> fSuppressErrorsForMissingBranches{};; 351 std::vector<std::string> fMissingProxies{};; 352 ; 353 friend class ROOT::Internal::TTreeReaderValueBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represen",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:15672,Integrability,interface,interface,15672,"eBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represent and give acces...; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries.Definition TFileCollection.h:39; TFriendProxyConcrete implementation of the proxy around a Friend Tree.; TNotifyLinkA node in a doubly linked list of subscribers to TChain notifications.Definition TNotifyLink.h:127; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TTreeReader::Iterator_tIterate through the entries of a TTree.Definition TTreeReader.h:58; TTreeReader::Iterator_t::const_pointerconst Long64_t * const_pointerDefinition T",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:18703,Integrability,interface,interface,18703,"==(const Iterator_t &lhs) constCompare two iterators for equality.Definition TTreeReader.h:83; TTreeReader::Iterator_t::fReaderTTreeReader * fReaderThe reader we select the entries on.Definition TTreeReader.h:61; TTreeReader::Iterator_t::operator*const Long64_t & operator*()Set the entry number in the reader and return it.Definition TTreeReader.h:134; TTreeReader::Iterator_t::IsValidbool IsValid() constWhether the iterator points to a valid entry.Definition TTreeReader.h:64; TTreeReader::Iterator_t::iterator_categorystd::input_iterator_tag iterator_categoryDefinition TTreeReader.h:67; TTreeReader::Iterator_t::operator!=bool operator!=(const Iterator_t &lhs) constCompare two iterators for inequality.Definition TTreeReader.h:109; TTreeReader::Iterator_t::operator++Iterator_t operator++(int)Increment the iterator (postfix i++).Definition TTreeReader.h:114; TTreeReader::Iterator_t::pointerconst Long64_t * pointerDefinition TTreeReader.h:70; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::TTreeReaderTTreeReader()Default constructor. Call SetTree to connect to a TTree.Definition TTreeReader.cxx:191; TTreeReader::fMissingProxiesstd::vector< std::string > fMissingProxiesDefinition TTreeReader.h:351; TTreeReader::fLoadTreeStatusELoadTreeStatus fLoadTreeStatusIndicator on how LoadTree was called 'last' time.Definition TTreeReader.h:321; TTreeReader::SetTreevoid SetTree(const char *keyname, TEntryList *entryList=nullptr)Definition TTreeReader.h:198; TTreeReader::IsInvalidbool IsInvalid() constDefinition TTreeReader.h:205; TTreeReader::GetEntriesLong64_t GetEntries() constReturns the number of entries of the TEntryList if one is provided, else of the TTree / TChain,...Definition TTreeReader.cxx:589; TTreeReader::fEntryStatusEEntryStatus fEntryStatusstatus of most recent read requestDefinition TTreeReader.h:320; TTreeReader::fSuppressErrorsForMissingBranchesstd::vector< std::strin",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:3324,Performance,latency,latency,3324," using value_type = const Long64_t;; 69 using difference_type = Long64_t;; 70 using pointer = const Long64_t *;; 71 using const_pointer = const Long64_t *;; 72 using reference = const Long64_t &;; 73 ; 74 /// Default-initialize the iterator as ""past the end"".; 75 Iterator_t(): fEntry(-1), fReader(nullptr) {}; 76 ; 77 /// Initialize the iterator with the reader it steers and a; 78 /// tree entry number; -1 is invalid.; 79 Iterator_t(TTreeReader& reader, Long64_t entry):; 80 fEntry(entry), fReader(&reader) {}; 81 ; 82 /// Compare two iterators for equality.; 83 bool operator==(const Iterator_t &lhs) const; 84 {; 85 // From C++14: value initialized (past-end) it compare equal.; 86 if (!IsValid() && !lhs.IsValid()); 87 return true;; 88 // The iterators refer to different readers; 89 if (fReader != lhs.fReader); 90 return false;; 91 // #16249: range based loop and the tree has zero entries; 92 // as well as analogous cases.; 93 // Getting the number of events can have a cost, for example in; 94 // case of chains of remote files accessible with high latency.; 95 // However, it is reasonable to assume that if iterators are; 96 // being compared is because an iteration is taking place,; 97 // therefore such cost has to be paid anyway, it's just; 98 // anticipated.; 99 if (fReader->GetTree()->GetEntriesFast() == 0 && fEntry == 0 && !lhs.IsValid()) {; 100 return true;; 101 }; 102 if (lhs.fReader->GetTree()->GetEntriesFast() == 0 && lhs.fEntry == 0 && !IsValid()) {; 103 return true;; 104 }; 105 return fEntry == lhs.fEntry;; 106 }; 107 ; 108 /// Compare two iterators for inequality.; 109 bool operator!=(const Iterator_t& lhs) const {; 110 return !(*this == lhs);; 111 }; 112 ; 113 /// Increment the iterator (postfix i++).; 114 Iterator_t operator++(int) {; 115 Iterator_t ret = *this;; 116 this->operator++();; 117 return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:5145,Performance,load,loaded,5145,"return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully initialized.; 162 kIndexedFriendNoMatch, ///< A friend with TTreeIndex doesn't have an entry for this index; 163 kMissingBranchWhenSwitchingTree, ///< A branch was not found when switching to the next TTree in the chain; 164 kEntryUnknownError ///< LoadTree return less than -6, likely a 'newer' error code.; 165 };; 166 ; 167 enum ELoadTreeStatus {; 168 kNoTree = 0, ///< default state, no TTree is connected (formerly 'Zombie' state); 169 kLoadTreeNone, ///<",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:6335,Performance,load,loading,6335,"led from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend with TTreeIndex doesn't have an entry for this index"",; 185 ""A branch was not found when switching to the next TTree in the chain"",; 186 ""LoadTree return less than -6, likely a 'newer' error code""};; 187 ; 188 TTreeReader();; 189 ; 190 TTreeReader(TTree *tree, TEntryList *entryList = nullptr, bool warnAboutLongerFriends = true,; 191 const std::vector<std::string> &suppressErrorsForMissingBranches = {});; 192 TTreeReader(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 193 TTreeReader(const char *keyname, TEntryList *entryList = nullptr) : TTreeReader(keyname, nullptr, entryList) {}; 194 ; 195 ~TTreeReader() override;; 196 ; 197 void SetTree(TTree* tree, TEntryList* entryList = nullptr);; 198 void SetTree(const char* keyname, TEntryList* entryList = nullptr) {; 199 SetTree(keyname, nullptr, entryList);; 200 }; 201 void SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. Thi",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:21866,Performance,load,loaded,21866,"xy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe tree entry number does not existDefinition TTreeReader.h:156; TTreeReader::kIndexedFriendNoMatch@ kIndexedFriendNoMatchA friend with TTreeIndex doesn't have an entry for this index.Definition TTreeReader.h:162; TTreeReader::kEntryUnknownError@ kEntryUnknownErrorLoadTree return less than -6, likely a 'newer' error code.Definition TTreeReader.h:164; TTreeReader::kEntryDictionaryError@ kEntryDictionaryErrorproblem reading dictionary info from treeDefinition TTreeReader.h:159; TTreeReader::kEntryChainSetupError@ kEntryChainSetupErrorproblem in accessing a chain element, e.g. file without the treeDefinition TTreeReader.h:157; TTreeReader::kMissingBranchWhenSwitchingTree@ kMissingBranchWhenSwitchingTreeA branch was not found when switching to the next TTree in the chain.Definition TTreeReader.h:163; TTreeReader::kEntryNotLoaded@ kEntryNotLoadedno entry has been loaded yetDefinition TTreeReader.h:154; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160; TTreeReader::kEntryChainFileError@ kEntryChainFileErrorproblem in opening a chain's fileDefinition TTreeReader.h:158; TTreeReader::kEntryNoTree@ kEntryNoTreethe tree does not existDefinition TTreeReader.h:155; TTreeReader::kEntryBadReader@ kEntryBadReaderOne of the readers was not successfully initialized.Definition TTreeReader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:23388,Performance,load,loaded,23388,"ader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a value reader for this tree.Definition TTreeReader.cxx:858; TTreeReader::fTreeTTree * fTreetree that's readDefinition TTreeReader.h:318; TTreeReader::fWarnAboutLongerFriendsbool fWarnAboutLongerFriendsDefinition TTreeReader.h:345; TTreeReader::GetTreeTTree * GetTree() constDefinition TTreeReader.h:207; TTreeReader::endIterator_t end()Return an iterator beyond the last TTree entry.Definition TTreeReader.h:270; TTreeReader::SetEntriesRangeEEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry)Set the range of entries to be loaded by Next(); end will not be loaded.Definition TTreeReader.cxx:533; TTreeReader::SetEntryBaseEEntryStatus SetEntryBase(Long64_t entry, bool local)Load an entry into the tree, return the status of the read.Definition TTreeReader.cxx:630; TTreeReader::GetProxyKeystd::string GetProxyKey(const char *branchname)Definition TTreeReader.h:304; TTreeReader::WarnIfFriendsHaveMoreEntriesvoid WarnIfFriendsHaveMoreEntries()Definition TTreeReader.cxx:440; TTreeReader::GetEntryStatusEEntryStatus GetEntryStatus() constDefinition TTreeReader.h:249; TTreeReader::ELoadTreeStatusELoadTreeStatusDefinition TTreeReader.h:167; TTreeReader::kInternalLoadTree@ kInternalLoadTreeNotify/LoadTree was last called from SetEntryBase.Definition TTreeReader.h:170; TTreeReader::kMissingBranchFromTree@ kMissingBranchFromTreeMissing expected branch when loading new tree.Definition TTreeReader.h:172; TTreeReader::kNoTree@ kNoTreedefault state, no TTree is connected (formerl",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:23422,Performance,load,loaded,23422,"ader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if during the LoadTree execution triggered by SetEntryBase.Definition TTreeReader.h:338; TTreeReader::fValuesstd::deque< ROOT::Internal::TTreeReaderValueBase * > fValuesreaders that use our directorDefinition TTreeReader.h:327; TTreeReader::RegisterValueReaderbool RegisterValueReader(ROOT::Internal::TTreeReaderValueBase *reader)Add a value reader for this tree.Definition TTreeReader.cxx:858; TTreeReader::fTreeTTree * fTreetree that's readDefinition TTreeReader.h:318; TTreeReader::fWarnAboutLongerFriendsbool fWarnAboutLongerFriendsDefinition TTreeReader.h:345; TTreeReader::GetTreeTTree * GetTree() constDefinition TTreeReader.h:207; TTreeReader::endIterator_t end()Return an iterator beyond the last TTree entry.Definition TTreeReader.h:270; TTreeReader::SetEntriesRangeEEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry)Set the range of entries to be loaded by Next(); end will not be loaded.Definition TTreeReader.cxx:533; TTreeReader::SetEntryBaseEEntryStatus SetEntryBase(Long64_t entry, bool local)Load an entry into the tree, return the status of the read.Definition TTreeReader.cxx:630; TTreeReader::GetProxyKeystd::string GetProxyKey(const char *branchname)Definition TTreeReader.h:304; TTreeReader::WarnIfFriendsHaveMoreEntriesvoid WarnIfFriendsHaveMoreEntries()Definition TTreeReader.cxx:440; TTreeReader::GetEntryStatusEEntryStatus GetEntryStatus() constDefinition TTreeReader.h:249; TTreeReader::ELoadTreeStatusELoadTreeStatusDefinition TTreeReader.h:167; TTreeReader::kInternalLoadTree@ kInternalLoadTreeNotify/LoadTree was last called from SetEntryBase.Definition TTreeReader.h:170; TTreeReader::kMissingBranchFromTree@ kMissingBranchFromTreeMissing expected branch when loading new tree.Definition TTreeReader.h:172; TTreeReader::kNoTree@ kNoTreedefault state, no TTree is connected (formerl",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:24221,Performance,load,loading,24221,"()Return an iterator beyond the last TTree entry.Definition TTreeReader.h:270; TTreeReader::SetEntriesRangeEEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry)Set the range of entries to be loaded by Next(); end will not be loaded.Definition TTreeReader.cxx:533; TTreeReader::SetEntryBaseEEntryStatus SetEntryBase(Long64_t entry, bool local)Load an entry into the tree, return the status of the read.Definition TTreeReader.cxx:630; TTreeReader::GetProxyKeystd::string GetProxyKey(const char *branchname)Definition TTreeReader.h:304; TTreeReader::WarnIfFriendsHaveMoreEntriesvoid WarnIfFriendsHaveMoreEntries()Definition TTreeReader.cxx:440; TTreeReader::GetEntryStatusEEntryStatus GetEntryStatus() constDefinition TTreeReader.h:249; TTreeReader::ELoadTreeStatusELoadTreeStatusDefinition TTreeReader.h:167; TTreeReader::kInternalLoadTree@ kInternalLoadTreeNotify/LoadTree was last called from SetEntryBase.Definition TTreeReader.h:170; TTreeReader::kMissingBranchFromTree@ kMissingBranchFromTreeMissing expected branch when loading new tree.Definition TTreeReader.h:172; TTreeReader::kNoTree@ kNoTreedefault state, no TTree is connected (formerly 'Zombie' state)Definition TTreeReader.h:168; TTreeReader::kExternalLoadTree@ kExternalLoadTreeUser code called LoadTree directly.Definition TTreeReader.h:171; TTreeReader::kLoadTreeNone@ kLoadTreeNoneNotify has not been called yet.Definition TTreeReader.h:169; TTreeReader::Initializevoid Initialize()Initialization of the director.Definition TTreeReader.cxx:272; TTreeReader::Restartvoid Restart()Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set).Definition TTreeReader.cxx:571; TTreeReader::fEntryListTEntryList * fEntryListentry list to be usedDefinition TTreeReader.h:319; TTreeReader::fEntryLong64_t fEntryCurrent (non-local) entry of fTree or of fEntryList if set.Definition TTreeReader.h:330; TTreeReader::Notifybool Notify() overrideNotify director and values of a change in tree.Definition TTreeRead",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:3303,Security,access,accessible,3303," using value_type = const Long64_t;; 69 using difference_type = Long64_t;; 70 using pointer = const Long64_t *;; 71 using const_pointer = const Long64_t *;; 72 using reference = const Long64_t &;; 73 ; 74 /// Default-initialize the iterator as ""past the end"".; 75 Iterator_t(): fEntry(-1), fReader(nullptr) {}; 76 ; 77 /// Initialize the iterator with the reader it steers and a; 78 /// tree entry number; -1 is invalid.; 79 Iterator_t(TTreeReader& reader, Long64_t entry):; 80 fEntry(entry), fReader(&reader) {}; 81 ; 82 /// Compare two iterators for equality.; 83 bool operator==(const Iterator_t &lhs) const; 84 {; 85 // From C++14: value initialized (past-end) it compare equal.; 86 if (!IsValid() && !lhs.IsValid()); 87 return true;; 88 // The iterators refer to different readers; 89 if (fReader != lhs.fReader); 90 return false;; 91 // #16249: range based loop and the tree has zero entries; 92 // as well as analogous cases.; 93 // Getting the number of events can have a cost, for example in; 94 // case of chains of remote files accessible with high latency.; 95 // However, it is reasonable to assume that if iterators are; 96 // being compared is because an iteration is taking place,; 97 // therefore such cost has to be paid anyway, it's just; 98 // anticipated.; 99 if (fReader->GetTree()->GetEntriesFast() == 0 && fEntry == 0 && !lhs.IsValid()) {; 100 return true;; 101 }; 102 if (lhs.fReader->GetTree()->GetEntriesFast() == 0 && lhs.fEntry == 0 && !IsValid()) {; 103 return true;; 104 }; 105 return fEntry == lhs.fEntry;; 106 }; 107 ; 108 /// Compare two iterators for inequality.; 109 bool operator!=(const Iterator_t& lhs) const {; 110 return !(*this == lhs);; 111 }; 112 ; 113 /// Increment the iterator (postfix i++).; 114 Iterator_t operator++(int) {; 115 Iterator_t ret = *this;; 116 this->operator++();; 117 return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:4653,Security,access,access,4653,"rn true;; 101 }; 102 if (lhs.fReader->GetTree()->GetEntriesFast() == 0 && lhs.fEntry == 0 && !IsValid()) {; 103 return true;; 104 }; 105 return fEntry == lhs.fEntry;; 106 }; 107 ; 108 /// Compare two iterators for inequality.; 109 bool operator!=(const Iterator_t& lhs) const {; 110 return !(*this == lhs);; 111 }; 112 ; 113 /// Increment the iterator (postfix i++).; 114 Iterator_t operator++(int) {; 115 Iterator_t ret = *this;; 116 this->operator++();; 117 return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully ",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:5311,Security,access,accessing,5311,"return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully initialized.; 162 kIndexedFriendNoMatch, ///< A friend with TTreeIndex doesn't have an entry for this index; 163 kMissingBranchWhenSwitchingTree, ///< A branch was not found when switching to the next TTree in the chain; 164 kEntryUnknownError ///< LoadTree return less than -6, likely a 'newer' error code.; 165 };; 166 ; 167 enum ELoadTreeStatus {; 168 kNoTree = 0, ///< default state, no TTree is connected (formerly 'Zombie' state); 169 kLoadTreeNone, ///<",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:6562,Security,access,access,6562,"led from SetEntryBase; 171 kExternalLoadTree, ///< User code called LoadTree directly.; 172 kMissingBranchFromTree ///< Missing expected branch when loading new tree; 173 };; 174 ; 175 static constexpr const char *const fgEntryStatusText[kEntryUnknownError + 1] = {; 176 ""valid entry"",; 177 ""the tree does not exist"",; 178 ""the tree entry number does not exist"",; 179 ""cannot access chain element"",; 180 ""problem in opening a chain's file"",; 181 ""problem reading dictionary info from tree"",; 182 ""last entry loop has reached its end"",; 183 ""one of the readers was not successfully initialized"",; 184 ""A friend with TTreeIndex doesn't have an entry for this index"",; 185 ""A branch was not found when switching to the next TTree in the chain"",; 186 ""LoadTree return less than -6, likely a 'newer' error code""};; 187 ; 188 TTreeReader();; 189 ; 190 TTreeReader(TTree *tree, TEntryList *entryList = nullptr, bool warnAboutLongerFriends = true,; 191 const std::vector<std::string> &suppressErrorsForMissingBranches = {});; 192 TTreeReader(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 193 TTreeReader(const char *keyname, TEntryList *entryList = nullptr) : TTreeReader(keyname, nullptr, entryList) {}; 194 ; 195 ~TTreeReader() override;; 196 ; 197 void SetTree(TTree* tree, TEntryList* entryList = nullptr);; 198 void SetTree(const char* keyname, TEntryList* entryList = nullptr) {; 199 SetTree(keyname, nullptr, entryList);; 200 }; 201 void SetTree(const char* keyname, TDirectory* dir, TEntryList* entryList = nullptr);; 202 ; 203 bool IsChain() const { return TestBit(kBitIsChain); }; 204 ; 205 bool IsInvalid() const { return fLoadTreeStatus == kNoTree; }; 206 ; 207 TTree* GetTree() const { return fTree; }; 208 TEntryList* GetEntryList() const { return fEntryList; }; 209 ; 210 ///\{ \name Entry setters; 211 ; 212 /// Move to the next entry (or index of the TEntryList if that is set).; 213 ///; 214 /// \return false if the previous entry was already the last entry. Thi",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:21544,Security,access,accessing,21544,"TTreeReader::Notify().Definition TTreeReader.h:323; TTreeReader::fProxiesSetbool fProxiesSetTrue if the proxies have been set, false otherwise.Definition TTreeReader.h:337; TTreeReader::IsChainbool IsChain() constDefinition TTreeReader.h:203; TTreeReader::AddProxyvoid AddProxy(std::unique_ptr< ROOT::Internal::TNamedBranchProxy > p)Definition TTreeReader.h:281; TTreeReader::EEntryStatusEEntryStatusDefinition TTreeReader.h:152; TTreeReader::kEntryNotFound@ kEntryNotFoundthe tree entry number does not existDefinition TTreeReader.h:156; TTreeReader::kIndexedFriendNoMatch@ kIndexedFriendNoMatchA friend with TTreeIndex doesn't have an entry for this index.Definition TTreeReader.h:162; TTreeReader::kEntryUnknownError@ kEntryUnknownErrorLoadTree return less than -6, likely a 'newer' error code.Definition TTreeReader.h:164; TTreeReader::kEntryDictionaryError@ kEntryDictionaryErrorproblem reading dictionary info from treeDefinition TTreeReader.h:159; TTreeReader::kEntryChainSetupError@ kEntryChainSetupErrorproblem in accessing a chain element, e.g. file without the treeDefinition TTreeReader.h:157; TTreeReader::kMissingBranchWhenSwitchingTree@ kMissingBranchWhenSwitchingTreeA branch was not found when switching to the next TTree in the chain.Definition TTreeReader.h:163; TTreeReader::kEntryNotLoaded@ kEntryNotLoadedno entry has been loaded yetDefinition TTreeReader.h:154; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160; TTreeReader::kEntryChainFileError@ kEntryChainFileErrorproblem in opening a chain's fileDefinition TTreeReader.h:158; TTreeReader::kEntryNoTree@ kEntryNoTreethe tree does not existDefinition TTreeReader.h:155; TTreeReader::kEntryBadReader@ kEntryBadReaderOne of the readers was not successfully initialized.Definition TTreeReader.h:161; TTreeReader::kEntryValid@ kEntryValiddata read okayDefinition TTreeReader.h:153; TTreeReader::fSetEntryBaseCallingLoadTreebool fSetEntryBaseCallingLoadTreeTrue if durin",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:877,Usability,simpl,simple,877,". ROOT: tree/treeplayer/inc/TTreeReader.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeReader.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Axel Naumann, 2010-08-02; 3// Author: Vincenzo Eduardo Padulano CERN 09/2024; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TTreeReader; 14#define ROOT_TTreeReader; 15 ; 16 ; 17////////////////////////////////////////////////////////////////////////////; 18// //; 19// TTreeReader //; 20// //; 21// A simple interface for reading trees or chains. //; 22// //; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TTree.h""; 27#include ""TTreeReaderUtils.h""; 28#include ""TNotifyLink.h""; 29 ; 30#include <deque>; 31#include <iterator>; 32#include <unordered_map>; 33#include <string>; 34 ; 35class TDictionary;; 36class TDirectory;; 37class TFileCollection;; 38 ; 39namespace ROOT {; 40namespace Internal {; 41 class TBranchProxyDirector;; 42 class TFriendProxy;; 43}; 44}; 45 ; 46class TTreeReader: public TObject {; 47public:; 48 ; 49 ///\class TTreeReader::Iterator_t; 50 /// Iterate through the entries of a TTree.; 51 ///; 52 /// This iterator drives the associated TTreeReader; its; 53 /// dereferencing (and actually even the iteration) will; 54 /// set the entry number represented by this iterator.; 55 /// It does not really represent a data element; it simply; 56 /// returns the entry number (or -1 once the end of the tree; 57 /// is reached).; 58 class Iterator_t {; 59 private:; 60 Long64_t fEntry; ///< Entry number of the tree referenced by this iterator; -1 ",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:1789,Usability,simpl,simply,1789,"///////////////////////; 18// //; 19// TTreeReader //; 20// //; 21// A simple interface for reading trees or chains. //; 22// //; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TTree.h""; 27#include ""TTreeReaderUtils.h""; 28#include ""TNotifyLink.h""; 29 ; 30#include <deque>; 31#include <iterator>; 32#include <unordered_map>; 33#include <string>; 34 ; 35class TDictionary;; 36class TDirectory;; 37class TFileCollection;; 38 ; 39namespace ROOT {; 40namespace Internal {; 41 class TBranchProxyDirector;; 42 class TFriendProxy;; 43}; 44}; 45 ; 46class TTreeReader: public TObject {; 47public:; 48 ; 49 ///\class TTreeReader::Iterator_t; 50 /// Iterate through the entries of a TTree.; 51 ///; 52 /// This iterator drives the associated TTreeReader; its; 53 /// dereferencing (and actually even the iteration) will; 54 /// set the entry number represented by this iterator.; 55 /// It does not really represent a data element; it simply; 56 /// returns the entry number (or -1 once the end of the tree; 57 /// is reached).; 58 class Iterator_t {; 59 private:; 60 Long64_t fEntry; ///< Entry number of the tree referenced by this iterator; -1 is invalid.; 61 TTreeReader* fReader; ///< The reader we select the entries on.; 62 ; 63 /// Whether the iterator points to a valid entry.; 64 bool IsValid() const { return fEntry >= 0; }; 65 ; 66 public:; 67 using iterator_category = std::input_iterator_tag;; 68 using value_type = const Long64_t;; 69 using difference_type = Long64_t;; 70 using pointer = const Long64_t *;; 71 using const_pointer = const Long64_t *;; 72 using reference = const Long64_t &;; 73 ; 74 /// Default-initialize the iterator as ""past the end"".; 75 Iterator_t(): fEntry(-1), fReader(nullptr) {}; 76 ; 77 /// Initialize the iterator with the reader it steers and a; 78 /// tree entry number; -1 is invalid.; 79 Iterator_t(TTreeReader& reader, Long64_t entry):; 80 fEntry(entry), fReader(&reader) {}; 81 ; 82 /// Compare two itera",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:14798,Usability,simpl,simple,14798,"ndEntry.; 335 Long64_t fEndEntry = -1LL;; 336 Long64_t fBeginEntry = 0LL; ///< This allows us to propagate the range to the TTreeCache; 337 bool fProxiesSet = false; ///< True if the proxies have been set, false otherwise; 338 bool fSetEntryBaseCallingLoadTree = false; ///< True if during the LoadTree execution triggered by SetEntryBase.; 339 ; 340 // Flag to activate or deactivate warnings in case the friend trees have; 341 // more entries than the main one. In some cases we may want to deactivate; 342 // this behaviour, notably in multithreaded runs where we have to partition; 343 // the main tree but keep the entire friend trees in every thread to ensure; 344 // alignment.; 345 bool fWarnAboutLongerFriends{true};; 346 void WarnIfFriendsHaveMoreEntries();; 347 ; 348 // List of branches for which we want to suppress the printed error about; 349 // missing branch when switching to a new tree; 350 std::vector<std::string> fSuppressErrorsForMissingBranches{};; 351 std::vector<std::string> fMissingProxies{};; 352 ; 353 friend class ROOT::Internal::TTreeReaderValueBase;; 354 friend class ROOT::Internal::TTreeReaderArrayBase;; 355 ; 356 ClassDefOverride(TTreeReader, 0); // A simple interface to read trees; 357};; 358 ; 359#endif // defined TTreeReader; Long64_tlong long Long64_tDefinition RtypesCore.h:69; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TNotifyLink.h; TTreeReaderUtils.h; TTree.h; ROOT::Internal::TFriendProxyDefinition TFriendProxy.h:22; ROOT::Internal::TNamedBranchProxyDefinition TTreeReaderUtils.h:43; ROOT::Internal::TTreeReaderArrayBaseBase class of TTreeReaderArray.Definition TTreeReaderArray.h:29; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TBranchProxyDirectorThis class is used to 'drive' and hold a serie of TBranchProxy objects which represen",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeReader_8h_source.html:18679,Usability,simpl,simple,18679,"==(const Iterator_t &lhs) constCompare two iterators for equality.Definition TTreeReader.h:83; TTreeReader::Iterator_t::fReaderTTreeReader * fReaderThe reader we select the entries on.Definition TTreeReader.h:61; TTreeReader::Iterator_t::operator*const Long64_t & operator*()Set the entry number in the reader and return it.Definition TTreeReader.h:134; TTreeReader::Iterator_t::IsValidbool IsValid() constWhether the iterator points to a valid entry.Definition TTreeReader.h:64; TTreeReader::Iterator_t::iterator_categorystd::input_iterator_tag iterator_categoryDefinition TTreeReader.h:67; TTreeReader::Iterator_t::operator!=bool operator!=(const Iterator_t &lhs) constCompare two iterators for inequality.Definition TTreeReader.h:109; TTreeReader::Iterator_t::operator++Iterator_t operator++(int)Increment the iterator (postfix i++).Definition TTreeReader.h:114; TTreeReader::Iterator_t::pointerconst Long64_t * pointerDefinition TTreeReader.h:70; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeReader::TTreeReaderTTreeReader()Default constructor. Call SetTree to connect to a TTree.Definition TTreeReader.cxx:191; TTreeReader::fMissingProxiesstd::vector< std::string > fMissingProxiesDefinition TTreeReader.h:351; TTreeReader::fLoadTreeStatusELoadTreeStatus fLoadTreeStatusIndicator on how LoadTree was called 'last' time.Definition TTreeReader.h:321; TTreeReader::SetTreevoid SetTree(const char *keyname, TEntryList *entryList=nullptr)Definition TTreeReader.h:198; TTreeReader::IsInvalidbool IsInvalid() constDefinition TTreeReader.h:205; TTreeReader::GetEntriesLong64_t GetEntries() constReturns the number of entries of the TEntryList if one is provided, else of the TTree / TChain,...Definition TTreeReader.cxx:589; TTreeReader::fEntryStatusEEntryStatus fEntryStatusstatus of most recent read requestDefinition TTreeReader.h:320; TTreeReader::fSuppressErrorsForMissingBranchesstd::vector< std::strin",MatchSource.WIKI,doc/master/TTreeReader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:1797,Availability,echo,echoed,1797,"g terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issu",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:81342,Availability,echo,echo,81342,"Picture(""cut-disable_t.xpm""));; 2268 }; 2269 }; 2270 if (*itemType & kLTPackType) {; 2271 fScanMode = true;; 2272 ExecuteDraw();; 2273 }; 2274 }; 2275 }; 2276 break;; 2277 case kButton2:; 2278 break;; 2279 case kButton3:; 2280 break;; 2281 default:; 2282 break;; 2283 }; 2284 break;; 2285 case 4:; 2286// std::cout << ""Dragging Item"" << std::endl;; 2287 default:; 2288 break;; 2289 }; 2290 break;; 2291 default:; 2292 break;; 2293 }; 2294 return true;; 2295}; 2296 ; 2297////////////////////////////////////////////////////////////////////////////////; 2298/// Close the viewer.; 2299 ; 2300void TTreeViewer::CloseWindow(); 2301{; 2302 DeleteWindow();; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Execute all user commands.; 2307 ; 2308void TTreeViewer::ExecuteCommand(const char* command, bool fast); 2309{; 2310 // Execute the command, write it to history file and echo it to output; 2311 if (fBarRec->GetState() == kButtonDown) {; 2312 // show the command on the command line; 2313 //printf(""%s\n"", command);; 2314 char comm[2000];; 2315 comm[0] = 0;; 2316 if (strlen(command) > 1999) {; 2317 Warning(""ExecuteCommand"", ""Command too long: aborting."");; 2318 return;; 2319 }; 2320 snprintf(comm,2000, ""%s"", command);; 2321 // print the command to history file; 2322 Gl_histadd(comm);; 2323 }; 2324 // execute it; 2325 if (fast) {; 2326 gROOT->ProcessLineFast(command);; 2327 } else {; 2328 gROOT->ProcessLine(command);; 2329 }; 2330 // make sure that 'draw on double-click' flag is reset; 2331 fVarDraw = false;; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Scan the selected options from option menu.; 2336 ; 2337void TTreeViewer::MapOptions(Long_t parm1); 2338{; 2339 Int_t ind;; 2340 if (parm1 == kOptionsReset) {; 2341 for (ind=kOptionsGeneral; ind<kOptionsGeneral+16; ind++); 2342 fOptionsGen->UnCheckEntry(ind);; 2343 for (ind=kOptions1D; ind<kOptions1D+12; ind++); 2",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:94631,Availability,error,error,94631,"mpty();; 2630 if (fMappedTree) MapTree(fTree);; 2631 if (fMappedBranch) MapBranch(fMappedBranch);; 2632 fListView->Layout();; 2633 fNexpressions++;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Find parent tree of a clicked item.; 2638 ; 2639void TTreeViewer::SetParentTree(TGListTreeItem *item); 2640{; 2641 if (!item) return;; 2642 ULong_t *itemType = (ULong_t *)item->GetUserData();; 2643 if (!itemType) return;; 2644 TGListTreeItem *parent = nullptr;; 2645 Int_t index;; 2646 if (!(*itemType & kLTTreeType)) {; 2647 parent = item->GetParent();; 2648 SetParentTree(parent);; 2649 } else {; 2650 index = (Int_t)(*itemType >> 8);; 2651 SwitchTree(index);; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Send a message on the status bar.; 2657 ; 2658void TTreeViewer::Message(const char* msg); 2659{; 2660 fStatusBar->SetText(msg);; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Put error/warning into TMsgBox and also forward to console.; 2665 ; 2666void TTreeViewer::DoError(int level, const char *location, const char *fmt, va_list va) const; 2667{; 2668 TObject::DoError(level, location, fmt, va);; 2669 ; 2670 // in case level will abort we will not come here...; 2671 ; 2672 static const int buf_size = 2048;; 2673 char buf[buf_size], *bp;; 2674 ; 2675 int n = vsnprintf(buf, buf_size, fmt, va);; 2676 // old vsnprintf's return -1 if string is truncated new ones return; 2677 // total number of characters that would have been written; 2678 if (n == -1 || n >= buf_size) {; 2679 TObject::Warning(""DoError"", ""Error message string truncated..."");; 2680 }; 2681 if (level >= kSysError && level < kFatal); 2682 bp = Form(""%s (%s)"", buf, gSystem->GetError());; 2683 else; 2684 bp = buf;; 2685 ; 2686 const char *title = """";; 2687 if (level == kInfo); 2688 title = ""Info"";; 2689 if (level == kWarning); 2690",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:118215,Availability,down,down,118215,"::SetStatevirtual void SetState(EButtonState state, Bool_t emit=kFALSE)Set button state.Definition TGButton.cxx:235; TGCanvasA frame containing two scrollbars (a horizontal and a vertical) and a viewport.Definition TGCanvas.h:192; TGCanvas::SetContainervirtual void SetContainer(TGFrame *f)Definition TGCanvas.h:222; TGCanvas::GetViewPortTGViewPort * GetViewPort() constDefinition TGCanvas.h:217; TGCheckButtonSelects different options.Definition TGButton.h:264; TGCheckButton::SetStatevoid SetState(EButtonState state, Bool_t emit=kFALSE) overrideSet check button state.Definition TGButton.cxx:1250; TGClient::GetRootconst TGWindow * GetRoot() constReturns current root (i.e.Definition TGClient.cxx:224; TGClient::GetPictureconst TGPicture * GetPicture(const char *name)Get picture from the picture pool.Definition TGClient.cxx:289; TGClient::NeedRedrawvoid NeedRedraw(TGWindow *w, Bool_t force=kFALSE)Set redraw flags.Definition TGClient.cxx:372; TGComboBoxA combobox (also known as a drop down listbox) allows the selection of one item out of a list of item...Definition TGComboBox.h:47; TGComboBox::AddEntryvirtual void AddEntry(TGString *s, Int_t id)Definition TGComboBox.h:86; TGComboBox::RemoveEntriesvirtual void RemoveEntries(Int_t from_ID, Int_t to_ID)Definition TGComboBox.h:105; TGComboBox::Selectvirtual void Select(Int_t id, Bool_t emit=kTRUE)Make the selected item visible in the combo box window and emit signals according to the second param...Definition TGComboBox.cxx:456; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGCompositeFrame::GetDefaultSizeTGDimension GetDefaultSize() const overridestd::cout << fWidth << ""x"" << fHeight << std::endl;Definition TGFrame.h:316; TGCompositeFrame::AddFramevirtual void AddFrame(TGFrame *f, TGLayoutHints *l=nullptr)Add frame to the composite frame using the specified layout hints.Definition TGFrame.cxx:1117; TGCompositeFrame::GetDefaultWidthUInt_t GetDefaultWidth() const over",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:135528,Availability,error,error,135528,"ider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::UnixPathNamevirtual const char * UnixPathName(const char *unixpathname)Convert from a local pathname to a Unix pathname.Definition TSystem.cxx:1063; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TTVLVContainerThis class represent the list view container for the TreeView class.Definition TTVLVContainer.h:110; TTVLVContainer::SelectItemvoid SelectItem(const char *name)Select an item.Definition TTVLVContainer.cxx:626; TTVLVContainer::SetViewervoid SetViewer(TTreeViewer *viewer)Definition TTVLVContainer.h:135; TTVLVContainer::ExpressionListTList * ExpressionList()Return the list of user-defined expressions.Definition TTVLVContainer.cxx:361; TTVLVContainer::Cutconst char * Cut()Return the cut entry.Definition TTVLVContainer.cxx:334; TTVLVContainer::Ezconst char * Ez()Return the expression on Z.Definition TTVLVContainer.cxx:408; TTVLVContainer::Eyconst char * Ey()Return the expression on Y.Definition TTVLVContainer.cxx:394; TTVLVContainer::ScanListconst char * ScanList()Return the cut entry.Definition TTVLVContainer.cxx:422; TTVLVContainer::AddThisItemvirtual void AddThisItem(TTVLVEntry *item)Definition TTVLVConta",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:2419,Deployability,toggle,toggles,2419,"31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issued and SCAN enables redirecting of TTree::Scan command in; 47 an ASCII file (see -Scanning expressions-);; 48 - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; 49 drawing and stop the current command respectively, two text widgets where; 50 input and output event lists can be specified, a message box and a RESET; 51 button on the right that clear edited expression content (see Editing...); 52 - a tree-type list on the main left panel where you can select among trees or; 53 branches. The tree/branch will be detailed in the right panel.; 54 Mapped trees are provided with context menus, activated by right-clicking;; 55 - a view-type list on the right panel. The first column contain X, Y and; 56 Z expression items, an optional cut and ten optional editable expressions.; 57 Expressions and leaf-type items can be dragged or deleted. A right click on; 58 the list-box or item activates context menus.; 59 ; 60### Opening a new tree and saving a session :; 61 ; 62 To open a new tree in the viewer use `<File/Open tree file>` menu; 63The content of the file (keys) will be listed. Use `<SetTreeName>` function; 64from the context me",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:6262,Deployability,toggle,toggle,6262,"he right panel by clicking on it (recommandable);; 100 - you can click on other expressions/leaves to paste them in the editor;; 101 - you should write the item alias by hand since it not only make the; 102 expression meaningful, but it also highly improve the layout for big; 103 expressions; 104 - you may redefine an old alias - the other expressions depending on it will; 105 be modified accordingly. An alias must not be the leading string of other; 106 aliases. When Draw commands are issued, the name of the corresponding; 107 histogram axes will become the aliases of the expressions.; 108 ; 109User commands can be issued directly from the textbox labeled ""Command""; 110from the upper-left toolbar by typing and pressing Enter at the end.; 111 ; 112 Another way is from the right panel context menu : ExecuteCommand.; 113All commands can be interrupted at any time by pressing the STOP button; 114from the bottom-left; 115You can toggle recording of the current command in the history file by; 116checking the Rec button from the top-right; 117 ; 118### Context menus; 119 ; 120 You can activate context menus by right-clicking on items or inside the; 121right panel.; 122 ; 123Context menus for mapped items from the left tree-type list :; 124 The items from the left that are provided with context menus are tree and; 125branch items. You can directly activate the *MENU* marked methods of TTree; 126from this menu.; 127 ; 128Context menu for the right panel:; 129 ; 130 A general context menu is activated if the user right-clicks the right panel.; 131 ; 132 Commands are :; 133 - EmptyAll : clears the content of all expressions;; 134 - ExecuteCommand : execute a ROOT command;; 135 - MakeSelector : equivalent of TTree::MakeSelector();; 136 - NewExpression : add an expression item in the right panel;; 137 - Process : equivalent of TTree::Process();; 138 - SaveSource : save the current session as a C++ macro;; 139 - SetScanFileName : define a name for the file where TTree::Scan comma",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:31389,Deployability,update,update,31389,"0),kBarCommand);; 782 fBarCommand->SetWidth(120);; 783 fBarCommand->Associate(this);; 784 fBarCommand->SetToolTipText(""User commands executed via interpreter. Type <ENTER> to execute"");; 785 fToolBar->AddFrame(fBarCommand, lo);; 786 //--- first vertical separator; 787 TGVertical3DLine *vSeparator = new TGVertical3DLine(fToolBar);; 788 lo = new TGLayoutHints(kLHintsLeft | kLHintsExpandY, 4,4,0,0);; 789 fWidgets->Add(lo);; 790 fWidgets->Add(vSeparator);; 791 fToolBar->AddFrame(vSeparator, lo);; 792 ; 793 lo = new TGLayoutHints(kLHintsLeft | kLHintsCenterY, 4,4,0,0);; 794 fWidgets->Add(lo);; 795 //--- label for Option text entry; 796 fBarLbl2 = new TGLabel(fToolBar,""Option"");; 797 fToolBar->AddFrame(fBarLbl2, lo);; 798 //--- drawing option text entry; 799 fBarOption = new TGTextEntry(fToolBar, new TGTextBuffer(200),kBarOption);; 800 fBarOption->SetWidth(100);; 801 fBarOption->Associate(this);; 802 fBarOption->SetToolTipText(""Histogram graphics option. Type option here and click <Draw> (or <ENTER> to update current histogram)."");; 803 fToolBar->AddFrame(fBarOption, lo);; 804 //--- second vertical separator; 805 vSeparator = new TGVertical3DLine(fToolBar);; 806 lo = new TGLayoutHints(kLHintsLeft | kLHintsExpandY, 4,4,0,0);; 807 fWidgets->Add(lo);; 808 fWidgets->Add(vSeparator);; 809 fToolBar->AddFrame(vSeparator, lo);; 810 ; 811 lo = new TGLayoutHints(kLHintsLeft | kLHintsCenterY, 4,4,0,0);; 812 fWidgets->Add(lo);; 813 //--- label for Histogram text entry; 814 fBarLbl3 = new TGLabel(fToolBar,""Histogram"");; 815 fToolBar->AddFrame(fBarLbl3, lo);; 816 ; 817 //--- histogram name text entry; 818 lo = new TGLayoutHints(kLHintsCenterY | kLHintsExpandX, 4,4,0,0);; 819 fWidgets->Add(lo);; 820 fBarHist = new TGTextEntry(fToolBar, new TGTextBuffer(100));; 821 fBarHist->Resize(50, fBarHist->GetDefaultHeight());; 822 fBarHist->SetDefaultSize(50, fBarHist->GetDefaultHeight());; 823 fBarHist->SetText(""htemp"");; 824 fToolBar->AddFrame(fBarHist, lo);; 825 ; 826 //--- Hist check button; 8",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:55640,Deployability,update,updated,55640," fSlider->GetMinPositionD() + 1);; 1457 Long64_t firstentry = fSlider->GetMinPositionL();; 1458//printf(""firstentry=%lld, nentries=%lld\n"",firstentry,nentries);; 1459 // check if Scan is checked and if there is something in the box; 1460 if (fScanMode) {; 1461// fBarScan->SetState(kButtonUp);; 1462 fScanMode = false;; 1463 if (ScanList() && strlen(ScanList())) varexp = ScanList();; 1464 command = TString::Format(""tv__tree->Scan(\""%s\"",\""%s\"",\""%s\"", %lld, %lld);"",; 1465 varexp.Data(), cut, gopt, nentries, firstentry);; 1466 if (fBarScan->GetState() == kButtonDown) {; 1467 ((TTreePlayer *)fTree->GetPlayer())->SetScanRedirect(true);; 1468 } else {; 1469 ((TTreePlayer *)fTree->GetPlayer())->SetScanRedirect(false);; 1470 }; 1471 ExecuteCommand(command.Data(), true);; 1472 return;; 1473 }; 1474 // check if only histogram has to be updated; 1475 if (fBarH->GetState() == kButtonDown) {; 1476 // reset 'Hist' mode; 1477 fBarH->SetState(kButtonUp);; 1478 TH1 *hist = fTree->GetHistogram();; 1479 if (hist && gPad) {; 1480 //hist = (TH1*)gPad->GetListOfPrimitives()->FindObject(fBarHist->GetText());; 1481 if (hist) {; 1482 // check if graphic option was modified; 1483 TString last(fLastOption);; 1484 TString current(gopt);; 1485 current.ToUpper();; 1486 last.ToUpper();; 1487 if (current == last) {; 1488 gPad->Update();; 1489 return;; 1490 }; 1491 if (dimension == 3 && strlen(gopt)) {; 1492 std::cout << ""Graphics option "" << gopt << "" not valid for 3D histograms"" << std::endl;; 1493 return;; 1494 }; 1495 std::cout << "" Graphics option for current histogram changed to "" << gopt << std::endl;; 1496 hist->Draw(gopt);; 1497 fLastOption = fBarOption->GetText();; 1498 gPad->Update();; 1499 return;; 1500 }; 1501 }; 1502 }; 1503 // send draw command; 1504 fLastOption = fBarOption->GetText();; 1505 //if (!gopt[0] && dimension!=3) {; 1506 // gopt = ""hist"";; 1507 // fLastOption = ""hist"";; 1508 //}; 1509 if (dimension == 3 && strlen(gopt)) {; 1510 std::cout << ""Graphics option "" << gopt << "" n",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:133953,Deployability,install,installation,133953," objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::DoErrorvirtual void DoError(int level, const char *location, const char *fmt, va_list va) constInterface to ErrorHandler (protected).Definition TObject.cxx:954; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TRootHelpDialogA TRootHelpDialog is used to display help text (or any text in a dialog window).Definition TRootHelpDialog.h:22; TRootHelpDialog::SetTextvoid SetText(const char *helpText)Set help text from helpText buffer in TGTextView.Definition TRootHelpDialog.cxx:77; TRootHelpDialog::Popupvoid Popup()Show help dialog.Definition TRootHelpDialog.cxx:69; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remov",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:140717,Deployability,toggle,toggle,140717," X, Y, Z settings.Definition TTVSession.cxx:272; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram...Definition TTreePlayer.h:37; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid UpdateRecord(const char *name=""new name""); TTreeViewer::fBarOptionTGTextEntry * fBarOptionHistogram drawing option entry.Definition TTreeViewer.h:136; TTreeViewer::fBLbl4TGLabel * fBLbl4Label for input list entry.Definition TTreeViewer.h:153; TTreeViewer::fBarCommandTGTextEntry * fBarCommandUser command entry.Definition TTreeViewer.h:135; TTreeViewer::fOptions2DTGPopupMenu * fOptions2DDefinition TTreeViewer.h:117; TTreeViewer::fListViewTGListView * fListViewListView with branches and leaves.Definition TTreeViewer.h:179; TTreeViewer::fComboTGCom",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:856,Energy Efficiency,adapt,adapted,856,". ROOT: tree/treeviewer/src/TTreeViewer.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeViewer.cxx. Go to the documentation of this file. 1// @(#)root/treeviewer:$Id: c8e226dde2f9b6f39946bfe90cabcb778d63dc4f $; 2//Author : Andrei Gheata 16/08/00; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leav",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:726,Integrability,interface,interface,726,". ROOT: tree/treeviewer/src/TTreeViewer.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeViewer.cxx. Go to the documentation of this file. 1// @(#)root/treeviewer:$Id: c8e226dde2f9b6f39946bfe90cabcb778d63dc4f $; 2//Author : Andrei Gheata 16/08/00; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leav",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:2821,Integrability,message,message,2821,"31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issued and SCAN enables redirecting of TTree::Scan command in; 47 an ASCII file (see -Scanning expressions-);; 48 - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; 49 drawing and stop the current command respectively, two text widgets where; 50 input and output event lists can be specified, a message box and a RESET; 51 button on the right that clear edited expression content (see Editing...); 52 - a tree-type list on the main left panel where you can select among trees or; 53 branches. The tree/branch will be detailed in the right panel.; 54 Mapped trees are provided with context menus, activated by right-clicking;; 55 - a view-type list on the right panel. The first column contain X, Y and; 56 Z expression items, an optional cut and ten optional editable expressions.; 57 Expressions and leaf-type items can be dragged or deleted. A right click on; 58 the list-box or item activates context menus.; 59 ; 60### Opening a new tree and saving a session :; 61 ; 62 To open a new tree in the viewer use `<File/Open tree file>` menu; 63The content of the file (keys) will be listed. Use `<SetTreeName>` function; 64from the context me",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:5677,Integrability,depend,depending,5677,"10 pixels.; 81 ; 82### Editing expressions:; 83 ; 84 Any editable expression from the right panel has two components : a; 85true name (that will be used when TTree::Draw() commands are issued) and an; 86alias. The visible name is the alias. Aliases of user defined expressions have; 87a leading ~ and may be used in new expressions. Expressions containing boolean; 88operators have a specific icon and may be dragged to the active cut (scissors; 89item) position.; 90 ; 91 The expression editor can be activated by double-clicking empty expression,; 92using `<EditExpression>` from the selected expression context menu or using; 93`<Edit/Expression>` menu.; 94 ; 95 The editor will pop-up in the left part, but it can be moved.; 96The editor usage is the following :; 97 ; 98 - you can write C expressions made of leaf names by hand or you can insert; 99 any item from the right panel by clicking on it (recommandable);; 100 - you can click on other expressions/leaves to paste them in the editor;; 101 - you should write the item alias by hand since it not only make the; 102 expression meaningful, but it also highly improve the layout for big; 103 expressions; 104 - you may redefine an old alias - the other expressions depending on it will; 105 be modified accordingly. An alias must not be the leading string of other; 106 aliases. When Draw commands are issued, the name of the corresponding; 107 histogram axes will become the aliases of the expressions.; 108 ; 109User commands can be issued directly from the textbox labeled ""Command""; 110from the upper-left toolbar by typing and pressing Enter at the end.; 111 ; 112 Another way is from the right panel context menu : ExecuteCommand.; 113All commands can be interrupted at any time by pressing the STOP button; 114from the bottom-left; 115You can toggle recording of the current command in the history file by; 116checking the Rec button from the top-right; 117 ; 118### Context menus; 119 ; 120 You can activate context menus by right-cli",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:66288,Integrability,message,messages,66288,,MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:66930,Integrability,message,messages,66930,,MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:67145,Integrability,depend,depends,67145,"5{; 1796 TRootHelpDialog *hd;; 1797 TTVRecord *record;; 1798 ; 1799 switch (GET_MSG(msg)) {; 1800 case kC_VSLIDER :; 1801 // handle slider messages; 1802 PrintEntries();; 1803 break;; 1804 case kC_TEXTENTRY:; 1805 switch (GET_SUBMSG(msg)) {; 1806 // handle enter posted by the Command text entry; 1807 case kTE_ENTER:; 1808 if ((ERootTreeViewerCommands)parm1 == kBarCommand) {; 1809 ExecuteCommand(fBarCommand->GetText());; 1810 fBarCommand->Clear();; 1811 }; 1812 if ((ERootTreeViewerCommands)parm1 == kBarOption) {; 1813 fVarDraw = false;; 1814 fBarH->SetState(kButtonDown);; 1815 ExecuteDraw();; 1816 fBarH->SetState(kButtonUp);; 1817 }; 1818 break;; 1819 default:; 1820 break;; 1821 }; 1822 break;; 1823 case kC_LISTTREE:; 1824 switch (GET_SUBMSG(msg)) {; 1825 // handle mouse messages in the list-tree (left panel); 1826 case kCT_ITEMCLICK :; 1827 // tell coverity that parm1 is a Long_t, and not an enum (even; 1828 // if we compare it with an enum value) and the meaning of; 1829 // parm1 depends on GET_MSG(msg) and GET_SUBMSG(msg); 1830 // coverity[mixed_enums]; 1831 if (((EMouseButton)parm1==kButton1) ||; 1832 ((EMouseButton)parm1==kButton3)) {; 1833 TGListTreeItem *ltItem = nullptr;; 1834 // get item that sent this; 1835 if ((ltItem = fLt->GetSelected()) != nullptr) {; 1836 // get item type; 1837 ULong_t *itemType = (ULong_t *)ltItem->GetUserData();; 1838 if (!itemType); 1839 break;; 1840 if (*itemType & kLTTreeType) {; 1841 // already mapped tree item clicked; 1842 Int_t index = (Int_t)(*itemType >> 8);; 1843 SwitchTree(index);; 1844 if (fTree != fMappedTree) {; 1845 // switch also the global ""tree"" variable; 1846 fLVContainer->RemoveNonStatic();; 1847 // map it on the right panel; 1848 MapTree(fTree);; 1849 fListView->Layout();; 1850 }; 1851 // activate context menu for this tree; 1852 if (parm1 == kButton3) {; 1853 Int_t x = (Int_t)(parm2 &0xffff);; 1854 Int_t y = (Int_t)((parm2 >> 16) & 0xffff);; 1855 fContextMenu->Popup(x, y, fTree);; 1856 }; 1857 }; 1858 ; 1859 if ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:70303,Integrability,message,messages,70303,"ntainer->RemoveNonStatic();; 1896 MapBranch(branch);; 1897 fStopMapping = false;; 1898 fListView->Layout();; 1899 }; 1900 }; 1901 // select corresponding leaf on the right panel; 1902 fLVContainer->SelectItem(ltItem->GetText());; 1903 if (parm1 == kButton3) {; 1904 // activate context menu for this leaf; 1905 ProcessMessage(MK_MSG(kC_CONTAINER, kCT_ITEMCLICK), kButton3, parm2);; 1906 }; 1907 }; 1908 }; 1909 }; 1910 break;; 1911 case kCT_ITEMDBLCLICK :; 1912 fClient->NeedRedraw(fLt);; 1913 if (parm1 == kButton1) {; 1914 // execute double-click action for corresponding item in the right panel; 1915 ProcessMessage(MK_MSG(kC_CONTAINER, kCT_ITEMDBLCLICK), kButton1, parm2);; 1916 }; 1917 break;; 1918 default:; 1919 break;; 1920 }; 1921 break;; 1922 case kC_COMMAND:; 1923 switch (GET_SUBMSG(msg)) {; 1924 case kCM_COMBOBOX:; 1925 if ((record = fSession->GetRecord((Int_t)parm2))); 1926 fSession->Show(record);; 1927 break;; 1928 case kCM_BUTTON:; 1929 switch (parm1) {; 1930 // handle button messages; 1931 case kRESET:; 1932 EmptyAll();; 1933 break;; 1934 case kDRAW:; 1935 fVarDraw = false;; 1936 ExecuteDraw();; 1937 break;; 1938 case kSTOP:; 1939 if (fCounting); 1940 gROOT->SetInterrupt(true);; 1941 break;; 1942 case kCLOSE:; 1943 SendCloseMessage();; 1944 break;; 1945 case kBGFirst:; 1946 if ((record = fSession->First())); 1947 fSession->Show(record);; 1948 break;; 1949 case kBGPrevious:; 1950 if ((record = fSession->Previous())); 1951 fSession->Show(record);; 1952 break;; 1953 case kBGRecord:; 1954 fSession->AddRecord();; 1955 break;; 1956 case kBGNext:; 1957 if ((record = fSession->Next())); 1958 fSession->Show(record);; 1959 break;; 1960 case kBGLast:; 1961 if ((record = fSession->Last())); 1962 fSession->Show(record);; 1963 break;; 1964 default:; 1965 break;; 1966 }; 1967 break;; 1968 case kCM_MENU:; 1969 // handle menu messages; 1970 // check if sent by Options menu; 1971 if ((parm1>=kOptionsReset) && (parm1<kHelpAbout)) {; 1972 Dimension();; 1973 if ((fDimension==0) && ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:71154,Integrability,message,messages,71154,";; 1898 fListView->Layout();; 1899 }; 1900 }; 1901 // select corresponding leaf on the right panel; 1902 fLVContainer->SelectItem(ltItem->GetText());; 1903 if (parm1 == kButton3) {; 1904 // activate context menu for this leaf; 1905 ProcessMessage(MK_MSG(kC_CONTAINER, kCT_ITEMCLICK), kButton3, parm2);; 1906 }; 1907 }; 1908 }; 1909 }; 1910 break;; 1911 case kCT_ITEMDBLCLICK :; 1912 fClient->NeedRedraw(fLt);; 1913 if (parm1 == kButton1) {; 1914 // execute double-click action for corresponding item in the right panel; 1915 ProcessMessage(MK_MSG(kC_CONTAINER, kCT_ITEMDBLCLICK), kButton1, parm2);; 1916 }; 1917 break;; 1918 default:; 1919 break;; 1920 }; 1921 break;; 1922 case kC_COMMAND:; 1923 switch (GET_SUBMSG(msg)) {; 1924 case kCM_COMBOBOX:; 1925 if ((record = fSession->GetRecord((Int_t)parm2))); 1926 fSession->Show(record);; 1927 break;; 1928 case kCM_BUTTON:; 1929 switch (parm1) {; 1930 // handle button messages; 1931 case kRESET:; 1932 EmptyAll();; 1933 break;; 1934 case kDRAW:; 1935 fVarDraw = false;; 1936 ExecuteDraw();; 1937 break;; 1938 case kSTOP:; 1939 if (fCounting); 1940 gROOT->SetInterrupt(true);; 1941 break;; 1942 case kCLOSE:; 1943 SendCloseMessage();; 1944 break;; 1945 case kBGFirst:; 1946 if ((record = fSession->First())); 1947 fSession->Show(record);; 1948 break;; 1949 case kBGPrevious:; 1950 if ((record = fSession->Previous())); 1951 fSession->Show(record);; 1952 break;; 1953 case kBGRecord:; 1954 fSession->AddRecord();; 1955 break;; 1956 case kBGNext:; 1957 if ((record = fSession->Next())); 1958 fSession->Show(record);; 1959 break;; 1960 case kBGLast:; 1961 if ((record = fSession->Last())); 1962 fSession->Show(record);; 1963 break;; 1964 default:; 1965 break;; 1966 }; 1967 break;; 1968 case kCM_MENU:; 1969 // handle menu messages; 1970 // check if sent by Options menu; 1971 if ((parm1>=kOptionsReset) && (parm1<kHelpAbout)) {; 1972 Dimension();; 1973 if ((fDimension==0) && (parm1>=kOptions1D)) {; 1974 Warning(""ProcessMessage"", ""Edit expressions first.",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:76498,Integrability,message,messages,76498,"xt(gTVHelpSession);; 2113 hd->Popup();; 2114 break;; 2115 case kHelpCommands:; 2116 hd = new TRootHelpDialog(this, ""Executing user commands..."", 600, 400);; 2117 hd->SetText(gTVHelpUserCommands);; 2118 hd->Popup();; 2119 break;; 2120 case kHelpContext:; 2121 hd = new TRootHelpDialog(this, ""Context menus..."", 600, 400);; 2122 hd->SetText(gTVHelpContext);; 2123 hd->Popup();; 2124 break;; 2125 case kHelpDrawing:; 2126 hd = new TRootHelpDialog(this, ""Drawing histograms..."", 600, 400);; 2127 hd->SetText(gTVHelpDrawing);; 2128 hd->Popup();; 2129 break;; 2130 case kHelpMacros:; 2131 hd = new TRootHelpDialog(this, ""Using macros..."", 600, 400);; 2132 hd->SetText(gTVHelpMacros);; 2133 hd->Popup();; 2134 break;; 2135 default:; 2136 break;; 2137 }; 2138 break;; 2139 default:; 2140 break;; 2141 }; 2142 break;; 2143 case kC_CONTAINER:; 2144 switch (GET_SUBMSG(msg)) {; 2145 // handle messages sent from the listview (right panel); 2146 case kCT_SELCHANGED:; 2147 break;; 2148 case kCT_ITEMCLICK:; 2149 // handle mouse messages; 2150 switch (parm1) {; 2151 case kButton1:; 2152 if (fLVContainer->NumSelected()) {; 2153 // get item that sent this; 2154 void *p = nullptr;; 2155 TTVLVEntry *item;; 2156 if ((item = (TTVLVEntry *) fLVContainer->GetNextSelected(&p)) != nullptr) {; 2157 const char* vname = item->GetTrueName();; 2158 TString trueName(vname);; 2159 if (trueName.Contains(""[]"")) {; 2160 TIter next(fTree->GetListOfLeaves());; 2161 TLeaf *leaf;; 2162 while((leaf=(TLeaf*)next())) {; 2163 if (!strcmp(vname, EmptyBrackets(leaf->GetName()))); 2164 vname = leaf->GetName();; 2165 }; 2166 }; 2167 char* msg2 = new char[2000];; 2168 // get item type; 2169 ULong_t *itemType = (ULong_t *) item->GetUserData();; 2170 if (*itemType & kLTTreeType) {; 2171 // X, Y or Z clicked; 2172 char symbol = (char)((*itemType) >> 8);; 2173 snprintf(msg2,2000, ""%c expression : %s"", symbol, vname);; 2174 } else {; 2175 if (*itemType & kLTCutType) {; 2176 // scissors clicked; 2177 snprintf(msg2,2000, ""Cut : %s"", v",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:76632,Integrability,message,messages,76632,"xt(gTVHelpSession);; 2113 hd->Popup();; 2114 break;; 2115 case kHelpCommands:; 2116 hd = new TRootHelpDialog(this, ""Executing user commands..."", 600, 400);; 2117 hd->SetText(gTVHelpUserCommands);; 2118 hd->Popup();; 2119 break;; 2120 case kHelpContext:; 2121 hd = new TRootHelpDialog(this, ""Context menus..."", 600, 400);; 2122 hd->SetText(gTVHelpContext);; 2123 hd->Popup();; 2124 break;; 2125 case kHelpDrawing:; 2126 hd = new TRootHelpDialog(this, ""Drawing histograms..."", 600, 400);; 2127 hd->SetText(gTVHelpDrawing);; 2128 hd->Popup();; 2129 break;; 2130 case kHelpMacros:; 2131 hd = new TRootHelpDialog(this, ""Using macros..."", 600, 400);; 2132 hd->SetText(gTVHelpMacros);; 2133 hd->Popup();; 2134 break;; 2135 default:; 2136 break;; 2137 }; 2138 break;; 2139 default:; 2140 break;; 2141 }; 2142 break;; 2143 case kC_CONTAINER:; 2144 switch (GET_SUBMSG(msg)) {; 2145 // handle messages sent from the listview (right panel); 2146 case kCT_SELCHANGED:; 2147 break;; 2148 case kCT_ITEMCLICK:; 2149 // handle mouse messages; 2150 switch (parm1) {; 2151 case kButton1:; 2152 if (fLVContainer->NumSelected()) {; 2153 // get item that sent this; 2154 void *p = nullptr;; 2155 TTVLVEntry *item;; 2156 if ((item = (TTVLVEntry *) fLVContainer->GetNextSelected(&p)) != nullptr) {; 2157 const char* vname = item->GetTrueName();; 2158 TString trueName(vname);; 2159 if (trueName.Contains(""[]"")) {; 2160 TIter next(fTree->GetListOfLeaves());; 2161 TLeaf *leaf;; 2162 while((leaf=(TLeaf*)next())) {; 2163 if (!strcmp(vname, EmptyBrackets(leaf->GetName()))); 2164 vname = leaf->GetName();; 2165 }; 2166 }; 2167 char* msg2 = new char[2000];; 2168 // get item type; 2169 ULong_t *itemType = (ULong_t *) item->GetUserData();; 2170 if (*itemType & kLTTreeType) {; 2171 // X, Y or Z clicked; 2172 char symbol = (char)((*itemType) >> 8);; 2173 snprintf(msg2,2000, ""%c expression : %s"", symbol, vname);; 2174 } else {; 2175 if (*itemType & kLTCutType) {; 2176 // scissors clicked; 2177 snprintf(msg2,2000, ""Cut : %s"", v",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:78123,Integrability,message,message,78123,") {; 2157 const char* vname = item->GetTrueName();; 2158 TString trueName(vname);; 2159 if (trueName.Contains(""[]"")) {; 2160 TIter next(fTree->GetListOfLeaves());; 2161 TLeaf *leaf;; 2162 while((leaf=(TLeaf*)next())) {; 2163 if (!strcmp(vname, EmptyBrackets(leaf->GetName()))); 2164 vname = leaf->GetName();; 2165 }; 2166 }; 2167 char* msg2 = new char[2000];; 2168 // get item type; 2169 ULong_t *itemType = (ULong_t *) item->GetUserData();; 2170 if (*itemType & kLTTreeType) {; 2171 // X, Y or Z clicked; 2172 char symbol = (char)((*itemType) >> 8);; 2173 snprintf(msg2,2000, ""%c expression : %s"", symbol, vname);; 2174 } else {; 2175 if (*itemType & kLTCutType) {; 2176 // scissors clicked; 2177 snprintf(msg2,2000, ""Cut : %s"", vname);; 2178 } else {; 2179 if (*itemType & kLTPackType) {; 2180 snprintf(msg2,2000, ""Box : %s"", vname);; 2181 } else {; 2182 if (*itemType & kLTExpressionType) {; 2183 // expression clicked; 2184 snprintf(msg2,2000, ""Expression : %s"", vname);; 2185 } else {; 2186 if (*itemType & kLTBranchType) {; 2187 snprintf(msg2,2000, ""Branch : %s"", vname);; 2188 } else {; 2189 snprintf(msg2,2000, ""Leaf : %s"", vname);; 2190 }; 2191 }; 2192 }; 2193 }; 2194 }; 2195 // write who is responsable for this; 2196 TString message = msg2;; 2197 message = message(0,150);; 2198 Message(msg2);; 2199 delete[] msg2;; 2200 // check if this should be pasted into the expression editor; 2201 if ((*itemType & kLTBranchType) || (*itemType & kLTCutType)) break;; 2202 fDialogBox = TGSelectBox::GetInstance();; 2203 if (!fDialogBox || !vname[0]) break;; 2204 if (item == fDialogBox->EditedEntry()) break;; 2205 // paste it; 2206// char first = (char) vname[0];; 2207 TString insert(item->GetAlias());; 2208// if (first != '(') insert += ""("";; 2209// insert += item->GetAlias();; 2210// if (first != '(') insert += "")"";; 2211 ; 2212 fDialogBox->GrabPointer();; 2213 fDialogBox->InsertText(insert.Data());; 2214 // put the cursor at the right position; 2215 }; 2216 }; 2217 break;; 2218 case kButto",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:78145,Integrability,message,message,78145,") {; 2157 const char* vname = item->GetTrueName();; 2158 TString trueName(vname);; 2159 if (trueName.Contains(""[]"")) {; 2160 TIter next(fTree->GetListOfLeaves());; 2161 TLeaf *leaf;; 2162 while((leaf=(TLeaf*)next())) {; 2163 if (!strcmp(vname, EmptyBrackets(leaf->GetName()))); 2164 vname = leaf->GetName();; 2165 }; 2166 }; 2167 char* msg2 = new char[2000];; 2168 // get item type; 2169 ULong_t *itemType = (ULong_t *) item->GetUserData();; 2170 if (*itemType & kLTTreeType) {; 2171 // X, Y or Z clicked; 2172 char symbol = (char)((*itemType) >> 8);; 2173 snprintf(msg2,2000, ""%c expression : %s"", symbol, vname);; 2174 } else {; 2175 if (*itemType & kLTCutType) {; 2176 // scissors clicked; 2177 snprintf(msg2,2000, ""Cut : %s"", vname);; 2178 } else {; 2179 if (*itemType & kLTPackType) {; 2180 snprintf(msg2,2000, ""Box : %s"", vname);; 2181 } else {; 2182 if (*itemType & kLTExpressionType) {; 2183 // expression clicked; 2184 snprintf(msg2,2000, ""Expression : %s"", vname);; 2185 } else {; 2186 if (*itemType & kLTBranchType) {; 2187 snprintf(msg2,2000, ""Branch : %s"", vname);; 2188 } else {; 2189 snprintf(msg2,2000, ""Leaf : %s"", vname);; 2190 }; 2191 }; 2192 }; 2193 }; 2194 }; 2195 // write who is responsable for this; 2196 TString message = msg2;; 2197 message = message(0,150);; 2198 Message(msg2);; 2199 delete[] msg2;; 2200 // check if this should be pasted into the expression editor; 2201 if ((*itemType & kLTBranchType) || (*itemType & kLTCutType)) break;; 2202 fDialogBox = TGSelectBox::GetInstance();; 2203 if (!fDialogBox || !vname[0]) break;; 2204 if (item == fDialogBox->EditedEntry()) break;; 2205 // paste it; 2206// char first = (char) vname[0];; 2207 TString insert(item->GetAlias());; 2208// if (first != '(') insert += ""("";; 2209// insert += item->GetAlias();; 2210// if (first != '(') insert += "")"";; 2211 ; 2212 fDialogBox->GrabPointer();; 2213 fDialogBox->InsertText(insert.Data());; 2214 // put the cursor at the right position; 2215 }; 2216 }; 2217 break;; 2218 case kButto",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:78155,Integrability,message,message,78155,") {; 2157 const char* vname = item->GetTrueName();; 2158 TString trueName(vname);; 2159 if (trueName.Contains(""[]"")) {; 2160 TIter next(fTree->GetListOfLeaves());; 2161 TLeaf *leaf;; 2162 while((leaf=(TLeaf*)next())) {; 2163 if (!strcmp(vname, EmptyBrackets(leaf->GetName()))); 2164 vname = leaf->GetName();; 2165 }; 2166 }; 2167 char* msg2 = new char[2000];; 2168 // get item type; 2169 ULong_t *itemType = (ULong_t *) item->GetUserData();; 2170 if (*itemType & kLTTreeType) {; 2171 // X, Y or Z clicked; 2172 char symbol = (char)((*itemType) >> 8);; 2173 snprintf(msg2,2000, ""%c expression : %s"", symbol, vname);; 2174 } else {; 2175 if (*itemType & kLTCutType) {; 2176 // scissors clicked; 2177 snprintf(msg2,2000, ""Cut : %s"", vname);; 2178 } else {; 2179 if (*itemType & kLTPackType) {; 2180 snprintf(msg2,2000, ""Box : %s"", vname);; 2181 } else {; 2182 if (*itemType & kLTExpressionType) {; 2183 // expression clicked; 2184 snprintf(msg2,2000, ""Expression : %s"", vname);; 2185 } else {; 2186 if (*itemType & kLTBranchType) {; 2187 snprintf(msg2,2000, ""Branch : %s"", vname);; 2188 } else {; 2189 snprintf(msg2,2000, ""Leaf : %s"", vname);; 2190 }; 2191 }; 2192 }; 2193 }; 2194 }; 2195 // write who is responsable for this; 2196 TString message = msg2;; 2197 message = message(0,150);; 2198 Message(msg2);; 2199 delete[] msg2;; 2200 // check if this should be pasted into the expression editor; 2201 if ((*itemType & kLTBranchType) || (*itemType & kLTCutType)) break;; 2202 fDialogBox = TGSelectBox::GetInstance();; 2203 if (!fDialogBox || !vname[0]) break;; 2204 if (item == fDialogBox->EditedEntry()) break;; 2205 // paste it; 2206// char first = (char) vname[0];; 2207 TString insert(item->GetAlias());; 2208// if (first != '(') insert += ""("";; 2209// insert += item->GetAlias();; 2210// if (first != '(') insert += "")"";; 2211 ; 2212 fDialogBox->GrabPointer();; 2213 fDialogBox->InsertText(insert.Data());; 2214 // put the cursor at the right position; 2215 }; 2216 }; 2217 break;; 2218 case kButto",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:94397,Integrability,message,message,94397,"nStatic();; 2621 const TGPicture *pic = gClient->GetPicture(""expression_t.xpm"");; 2622 const TGPicture *spic = gClient->GetPicture(""expression_t.xpm"");; 2623 ; 2624 TTVLVEntry *entry = new TTVLVEntry(fLVContainer,pic,spic,; 2625 new TGString(),nullptr,kLVSmallIcons);; 2626 entry->SetUserData(new ULong_t(kLTExpressionType | kLTDragType));; 2627 fLVContainer->AddThisItem(entry);; 2628 entry->MapWindow();; 2629 entry->Empty();; 2630 if (fMappedTree) MapTree(fTree);; 2631 if (fMappedBranch) MapBranch(fMappedBranch);; 2632 fListView->Layout();; 2633 fNexpressions++;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Find parent tree of a clicked item.; 2638 ; 2639void TTreeViewer::SetParentTree(TGListTreeItem *item); 2640{; 2641 if (!item) return;; 2642 ULong_t *itemType = (ULong_t *)item->GetUserData();; 2643 if (!itemType) return;; 2644 TGListTreeItem *parent = nullptr;; 2645 Int_t index;; 2646 if (!(*itemType & kLTTreeType)) {; 2647 parent = item->GetParent();; 2648 SetParentTree(parent);; 2649 } else {; 2650 index = (Int_t)(*itemType >> 8);; 2651 SwitchTree(index);; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Send a message on the status bar.; 2657 ; 2658void TTreeViewer::Message(const char* msg); 2659{; 2660 fStatusBar->SetText(msg);; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Put error/warning into TMsgBox and also forward to console.; 2665 ; 2666void TTreeViewer::DoError(int level, const char *location, const char *fmt, va_list va) const; 2667{; 2668 TObject::DoError(level, location, fmt, va);; 2669 ; 2670 // in case level will abort we will not come here...; 2671 ; 2672 static const int buf_size = 2048;; 2673 char buf[buf_size], *bp;; 2674 ; 2675 int n = vsnprintf(buf, buf_size, fmt, va);; 2676 // old vsnprintf's return -1 if string is truncated new ones return; 2677 // to",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:95268,Integrability,message,message,95268,"itemType & kLTTreeType)) {; 2647 parent = item->GetParent();; 2648 SetParentTree(parent);; 2649 } else {; 2650 index = (Int_t)(*itemType >> 8);; 2651 SwitchTree(index);; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Send a message on the status bar.; 2657 ; 2658void TTreeViewer::Message(const char* msg); 2659{; 2660 fStatusBar->SetText(msg);; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Put error/warning into TMsgBox and also forward to console.; 2665 ; 2666void TTreeViewer::DoError(int level, const char *location, const char *fmt, va_list va) const; 2667{; 2668 TObject::DoError(level, location, fmt, va);; 2669 ; 2670 // in case level will abort we will not come here...; 2671 ; 2672 static const int buf_size = 2048;; 2673 char buf[buf_size], *bp;; 2674 ; 2675 int n = vsnprintf(buf, buf_size, fmt, va);; 2676 // old vsnprintf's return -1 if string is truncated new ones return; 2677 // total number of characters that would have been written; 2678 if (n == -1 || n >= buf_size) {; 2679 TObject::Warning(""DoError"", ""Error message string truncated..."");; 2680 }; 2681 if (level >= kSysError && level < kFatal); 2682 bp = Form(""%s (%s)"", buf, gSystem->GetError());; 2683 else; 2684 bp = buf;; 2685 ; 2686 const char *title = """";; 2687 if (level == kInfo); 2688 title = ""Info"";; 2689 if (level == kWarning); 2690 title = ""Warning"";; 2691 if (level == kError); 2692 title = ""Error"";; 2693 if (level == kSysError); 2694 title = ""System Error"";; 2695 ; 2696 new TGMsgBox(fClient->GetRoot(), this, title, bp, kMBIconExclamation);; 2697}; 2698 ; 2699////////////////////////////////////////////////////////////////////////////////; 2700/// Print the number of selected entries on status-bar.; 2701 ; 2702void TTreeViewer::PrintEntries(); 2703{; 2704 if (!fTree) return;; 2705 char * msg = new char[100];; 2706 snprintf(msg,100, ""First entry : %lld Last entry : %lld""",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:115340,Integrability,interface,interface,115340,"Definition WidgetMessageTypes.h:48; kC_LISTTREE@ kC_LISTTREEDefinition WidgetMessageTypes.h:65; kC_VSLIDER@ kC_VSLIDERDefinition WidgetMessageTypes.h:59; kCT_ITEMDBLCLICK@ kCT_ITEMDBLCLICKDefinition WidgetMessageTypes.h:55; kC_CONTAINER@ kC_CONTAINERDefinition WidgetMessageTypes.h:53; GET_SUBMSGInt_t GET_SUBMSG(Long_t val)Definition WidgetMessageTypes.h:111; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TAxisClass to manage histogram axis.Definition TAxis.h:31; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetNleavesInt_t GetNleaves() constDefinition TBranch.h:249; TBranch::GetListOfLeavesTObjArray * GetListOfLeaves()Definition TBranch.h:247; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TContextMenu::Actionvirtual void Action(TObject *object, TMethod *method)Action to be performed when this menu item is selected.Definition TContextMenu.cxx:93; TContextMenu::Popupvirtual void Popup(Int_t x, Int_t y, TObject *obj, TVirtualPad *c=nullptr, TVirtualPad *p=nullptr)Popup context menu at given location in canvas c and pad p for selected object.Definition TContextMenu.cxx:411; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDe",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:116554,Integrability,interface,interface,116554," is selected.Definition TContextMenu.cxx:93; TContextMenu::Popupvirtual void Popup(Int_t x, Int_t y, TObject *obj, TVirtualPad *c=nullptr, TVirtualPad *p=nullptr)Popup context menu at given location in canvas c and pad p for selected object.Definition TContextMenu.cxx:411; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::cdvirtual Bool_t cd()Change current directory to ""this"" directory.Definition TDirectory.cxx:538; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Definition TFriendElement.cxx:217; TGButton::SetToolTipTextvirtual void SetToolTipText(const char *text, Long_t delayms=400)Set tool tip text associated with this button.Definition TGButton.cxx:445; TGButton::GetStatevirtual EButtonState GetState() constDefinition TGButton.h:112; TGButton::SetStatevirtual void SetState(EButtonState state, Bool_t emit=kFALSE)Set button state.Definition TGButton.cxx:235; TGCanvasA frame containing two scrollbars (a horizontal and a vertical) and a viewport.Definition TGCanvas.h:192; TGCanvas::SetContainervirtual void SetContainer(TGFrame *f)Definition TGCan",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:124987,Integrability,message,message,124987,"e::GetSelectedTGListTreeItem * GetSelected() constDefinition TGListTree.h:382; TGListTree::FindChildByNameTGListTreeItem * FindChildByName(TGListTreeItem *item, const char *name)Find child of item by name.Definition TGListTree.cxx:2274; TGListTree::HighlightItemvoid HighlightItem(TGListTreeItem *item)Highlight item.Definition TGListTree.cxx:2376; TGListViewA list view is a widget that can contain a number of items arranged in a grid or list.Definition TGListView.h:115; TGListView::Layoutvoid Layout() overrideLayout list view components (container and contents of container).Definition TGListView.cxx:1448; TGListView::SetContainervoid SetContainer(TGFrame *f) overrideSet list view container.Definition TGListView.cxx:1383; TGListView::SetViewModevirtual void SetViewMode(EListViewMode viewMode)Set list view mode.Definition TGListView.cxx:1366; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:397; TGMainFrame::SendCloseMessagevirtual void SendCloseMessage()Send close message to self.Definition TGFrame.cxx:1744; TGMainFrame::SetWindowNamevoid SetWindowName(const char *name=nullptr) overrideSet window name. This is typically done via the window manager.Definition TGFrame.cxx:1788; TGMenuBarThe TGMenu.h header contains all different menu classes.Definition TGMenu.h:282; TGMenuBar::AddPopupvirtual void AddPopup(TGHotString *s, TGPopupMenu *menu, TGLayoutHints *l, TGPopupMenu *before=nullptr)Add popup menu to menu bar.Definition TGMenu.cxx:418; TGMsgBoxDefinition TGMsgBox.h:52; TGObject::fClientTGClient * fClientConnection to display server.Definition TGObject.h:25; TGPictureButtonYield an action as soon as it is clicked.Definition TGButton.h:228; TGPictureThe TGPicture class implements pictures and icons used in the different GUI elements and widgets.Definition TGPicture.h:25; TGPicture::GetPicturePixmap_t GetPicture() constDefinition TGPicture.h:54; TGPopupMenuThis class creates a popup menu object.Definition TGMenu.h:11",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:128695,Integrability,wrap,wraps,128695,"ryTTVLVEntry * EditedEntry()Definition TTVLVContainer.h:181; TGSelectBox::InsertTextvoid InsertText(const char *text)Insert text in text entry.Definition TTVLVContainer.cxx:825; TGSelectBox::GrabPointervoid GrabPointer()Just focus the cursor inside.Definition TTVLVContainer.cxx:755; TGSelectBox::SetLabelvoid SetLabel(const char *title)Set label of selection box.Definition TTVLVContainer.cxx:769; TGSelectBox::SetEntryvoid SetEntry(TTVLVEntry *entry)Connect one entry.Definition TTVLVContainer.cxx:814; TGSelectBox::GetInstancestatic TGSelectBox * GetInstance()Return the pointer to the instantiated singleton.Definition TTVLVContainer.cxx:747; TGStatusBarProvides a StatusBar widget.Definition TGStatusBar.h:21; TGStatusBar::Draw3DCornervoid Draw3DCorner(Bool_t corner)Definition TGStatusBar.h:59; TGStatusBar::SetTextvirtual void SetText(TGString *text, Int_t partidx=0)Set text in partition partidx in status bar.Definition TGStatusBar.cxx:145; TGStringTGString wraps a TString and adds some graphics routines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextBufferA text buffer is used in several widgets, like TGTextEntry, TGFileDialog, etc.Definition TGTextBuffer.h:17; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextEntryA TGTextEntry is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:128734,Integrability,rout,routines,128734,"ryTTVLVEntry * EditedEntry()Definition TTVLVContainer.h:181; TGSelectBox::InsertTextvoid InsertText(const char *text)Insert text in text entry.Definition TTVLVContainer.cxx:825; TGSelectBox::GrabPointervoid GrabPointer()Just focus the cursor inside.Definition TTVLVContainer.cxx:755; TGSelectBox::SetLabelvoid SetLabel(const char *title)Set label of selection box.Definition TTVLVContainer.cxx:769; TGSelectBox::SetEntryvoid SetEntry(TTVLVEntry *entry)Connect one entry.Definition TTVLVContainer.cxx:814; TGSelectBox::GetInstancestatic TGSelectBox * GetInstance()Return the pointer to the instantiated singleton.Definition TTVLVContainer.cxx:747; TGStatusBarProvides a StatusBar widget.Definition TGStatusBar.h:21; TGStatusBar::Draw3DCornervoid Draw3DCorner(Bool_t corner)Definition TGStatusBar.h:59; TGStatusBar::SetTextvirtual void SetText(TGString *text, Int_t partidx=0)Set text in partition partidx in status bar.Definition TGStatusBar.cxx:145; TGStringTGString wraps a TString and adds some graphics routines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextBufferA text buffer is used in several widgets, like TGTextEntry, TGFileDialog, etc.Definition TGTextBuffer.h:17; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextEntryA TGTextEntry is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:133307,Integrability,message,message,133307," TMethod.h:38; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::DoErrorvirtual void DoError(int level, const char *location, const char *fmt, va_list va) constInterface to ErrorHandler (protected).Definition TObject.cxx:954; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TRootHelpDialogA TRootHelpDialog is used to display help text (or any text in a dialog window).Definition TRootHelpDialog.h:22; TRootHelpDialog::SetTextvoid SetText(const char *helpText)Set help text from helpText buffer in TGTextView.Definition TRootHelpDialog.cxx:77; TRootHelpDial",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:140222,Integrability,interface,interface,140222,"VSession::GetEntriesInt_t GetEntries()Definition TTVSession.h:91; TTVSession::FirstTTVRecord * First()Definition TTVSession.h:94; TTVSession::RemoveLastRecordvoid RemoveLastRecord()Remove current record from list.Definition TTVSession.cxx:224; TTVSession::NextTTVRecord * Next()Definition TTVSession.h:96; TTVSession::UpdateRecordvoid UpdateRecord(const char *name)Updates current record according to new X, Y, Z settings.Definition TTVSession.cxx:272; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram...Definition TTreePlayer.h:37; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid UpdateRecord(const char *name=""new name""); TTreeViewer::fBarOptionTGTextEntry * fBarOptionHistogram drawing option entry.Definition TTreeViewer.h:",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:856,Modifiability,adapt,adapted,856,". ROOT: tree/treeviewer/src/TTreeViewer.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTreeViewer.cxx. Go to the documentation of this file. 1// @(#)root/treeviewer:$Id: c8e226dde2f9b6f39946bfe90cabcb778d63dc4f $; 2//Author : Andrei Gheata 16/08/00; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leav",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:1204,Modifiability,variab,variables,1204,"g terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issu",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:14870,Modifiability,variab,variable,14870,"//////////////////////////////////////////////////////////; 387/// Allow geting the tree from the context menu.; 388 ; 389void TTreeViewer::AppendTree(TTree *tree); 390{; 391 if (!tree) return;; 392 TTree *ftree;; 393 if (fTreeList) {; 394 if (fTreeList->FindObject(tree)) {; 395 printf(""Tree found\n"");; 396 TIter next(fTreeList);; 397 Int_t index = 0;; 398 while ((ftree = (TTree*)next())) {; 399 if (ftree==tree) {printf(""found at index %i\n"", index);break;}; 400 index++;; 401 }; 402 SwitchTree(index);; 403 if (fTree != fMappedTree) {; 404 // switch also the global ""tree"" variable; 405 fLVContainer->RemoveNonStatic();; 406 // map it on the right panel; 407 MapTree(fTree);; 408 fListView->Layout();; 409 TGListTreeItem *base = nullptr;; 410 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 411 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 412 fLt->ClearHighlighted();; 413 fLt->HighlightItem(item);; 414 fClient->NeedRedraw(fLt);; 415 }; 416 return;; 417 }; 418 }; 419 if (fTree != tree) {; 420 fTree = tree;; 421 // load the tree via the interpreter; 422 char command[100];; 423 command[0] = 0;; 424 // define a global ""tree"" variable for the same tree; 425 snprintf(command,100, ""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 426 ExecuteCommand(command);; 427 }; 428 //--- add the tree to the list if it is not already in; 429 if (fTreeList) fTreeList->Add(fTree);; 430 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 431 //--- map this tree; 432 TGListTreeItem *base = nullptr;; 433 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 434 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 435 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 436 fTreeIndex++;; 437 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 438 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 439 MapTree(fTree, lTreeItem, false);; 440 fLt->OpenItem(parent);; ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:15470,Modifiability,variab,variable,15470,"//////////////////////////////////////////////////////////; 387/// Allow geting the tree from the context menu.; 388 ; 389void TTreeViewer::AppendTree(TTree *tree); 390{; 391 if (!tree) return;; 392 TTree *ftree;; 393 if (fTreeList) {; 394 if (fTreeList->FindObject(tree)) {; 395 printf(""Tree found\n"");; 396 TIter next(fTreeList);; 397 Int_t index = 0;; 398 while ((ftree = (TTree*)next())) {; 399 if (ftree==tree) {printf(""found at index %i\n"", index);break;}; 400 index++;; 401 }; 402 SwitchTree(index);; 403 if (fTree != fMappedTree) {; 404 // switch also the global ""tree"" variable; 405 fLVContainer->RemoveNonStatic();; 406 // map it on the right panel; 407 MapTree(fTree);; 408 fListView->Layout();; 409 TGListTreeItem *base = nullptr;; 410 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 411 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 412 fLt->ClearHighlighted();; 413 fLt->HighlightItem(item);; 414 fClient->NeedRedraw(fLt);; 415 }; 416 return;; 417 }; 418 }; 419 if (fTree != tree) {; 420 fTree = tree;; 421 // load the tree via the interpreter; 422 char command[100];; 423 command[0] = 0;; 424 // define a global ""tree"" variable for the same tree; 425 snprintf(command,100, ""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 426 ExecuteCommand(command);; 427 }; 428 //--- add the tree to the list if it is not already in; 429 if (fTreeList) fTreeList->Add(fTree);; 430 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 431 //--- map this tree; 432 TGListTreeItem *base = nullptr;; 433 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 434 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 435 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 436 fTreeIndex++;; 437 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 438 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 439 MapTree(fTree, lTreeItem, false);; 440 fLt->OpenItem(parent);; ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:17931,Modifiability,variab,variable,17931,"0}; 461////////////////////////////////////////////////////////////////////////////////; 462/// Set the name of the file where to redirect `<Scan>` output.; 463 ; 464void TTreeViewer::SetScanFileName(const char *name); 465{; 466 if (fTree) ((TTreePlayer *)fTree->GetPlayer())->SetScanFileName(name);; 467}; 468////////////////////////////////////////////////////////////////////////////////; 469/// Set the state of Scan check button.; 470 ; 471void TTreeViewer::SetScanRedirect(bool mode); 472{; 473 if (mode); 474 fBarScan->SetState(kButtonDown);; 475 else; 476 fBarScan->SetState(kButtonUp);; 477}; 478////////////////////////////////////////////////////////////////////////////////; 479/// Assign the fTree member from existing tree, e.g. when calling; 480/// tree->StartViewer() from the browser, or even from the command line.; 481 ; 482void TTreeViewer::SetTree(TTree *tree); 483{; 484 if (!tree) return;; 485 if (fTree != tree) {; 486 fTree = tree;; 487 // load the tree via the interpreter; 488 // define a global ""tree"" variable for the same tree; 489 TString command = TString::Format(""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 490 ExecuteCommand(command.Data());; 491 }; 492 //--- add the tree to the list if it is not already in; 493 if (fTreeList) fTreeList->Add(fTree);; 494 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 495 //--- map this tree; 496 TGListTreeItem *base = nullptr;; 497 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 498 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 499 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 500 fTreeIndex++;; 501 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 502 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 503 MapTree(fTree, lTreeItem, false);; 504 fLt->OpenItem(parent);; 505 fLt->HighlightItem(lTreeItem);; 506 fClient->NeedRedraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTree",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:19702,Modifiability,variab,variable,19702,"Redraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTreeIndex-1);; 510 fLVContainer->RemoveNonStatic();; 511 MapTree(fTree);; 512 fListView->Layout();; 513 SetFile();; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Allow geting the tree from the context menu.; 517 ; 518void TTreeViewer::SetTreeName(const char* treeName); 519{; 520 if (!treeName) return;; 521 TTree *tree = (TTree *) gROOT->FindObject(treeName);; 522 if (fTreeList) {; 523 if (fTreeList->FindObject(treeName)) {; 524 printf(""Tree found\n"");; 525 TIter next(fTreeList);; 526 Int_t index = 0;; 527 while ((tree = (TTree*)next())) {; 528 if (!strcmp(treeName, tree->GetName())) {printf(""found at index %i\n"", index);break;}; 529 index++;; 530 }; 531 SwitchTree(index);; 532 if (fTree != fMappedTree) {; 533 // switch also the global ""tree"" variable; 534 fLVContainer->RemoveNonStatic();; 535 // map it on the right panel; 536 MapTree(fTree);; 537 fListView->Layout();; 538 TGListTreeItem *base = nullptr;; 539 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 540 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 541 fLt->ClearHighlighted();; 542 fLt->HighlightItem(item);; 543 fClient->NeedRedraw(fLt);; 544 }; 545 return;; 546 }; 547 }; 548 if (!tree) return;; 549// ((TTreePlayer *)tree->GetPlayer())->SetViewer(this);; 550 if (fTree != tree) {; 551 fTree = tree;; 552 // load the tree via the interpreter; 553 // define a global ""tree"" variable for the same tree; 554 TString command = TString::Format(""tv__tree = (TTree *) gROOT->FindObject(\""%s\"");"", treeName);; 555 ExecuteCommand(command.Data());; 556 }; 557 //--- add the tree to the list if it is not already in; 558 if (fTreeList) fTreeList->Add(fTree);; 559 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 560 //--- map this tree; 561 TGListTreeItem *base = nullptr;; 562 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 563 if (!parent) parent ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:20341,Modifiability,variab,variable,20341,"Redraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTreeIndex-1);; 510 fLVContainer->RemoveNonStatic();; 511 MapTree(fTree);; 512 fListView->Layout();; 513 SetFile();; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Allow geting the tree from the context menu.; 517 ; 518void TTreeViewer::SetTreeName(const char* treeName); 519{; 520 if (!treeName) return;; 521 TTree *tree = (TTree *) gROOT->FindObject(treeName);; 522 if (fTreeList) {; 523 if (fTreeList->FindObject(treeName)) {; 524 printf(""Tree found\n"");; 525 TIter next(fTreeList);; 526 Int_t index = 0;; 527 while ((tree = (TTree*)next())) {; 528 if (!strcmp(treeName, tree->GetName())) {printf(""found at index %i\n"", index);break;}; 529 index++;; 530 }; 531 SwitchTree(index);; 532 if (fTree != fMappedTree) {; 533 // switch also the global ""tree"" variable; 534 fLVContainer->RemoveNonStatic();; 535 // map it on the right panel; 536 MapTree(fTree);; 537 fListView->Layout();; 538 TGListTreeItem *base = nullptr;; 539 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 540 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 541 fLt->ClearHighlighted();; 542 fLt->HighlightItem(item);; 543 fClient->NeedRedraw(fLt);; 544 }; 545 return;; 546 }; 547 }; 548 if (!tree) return;; 549// ((TTreePlayer *)tree->GetPlayer())->SetViewer(this);; 550 if (fTree != tree) {; 551 fTree = tree;; 552 // load the tree via the interpreter; 553 // define a global ""tree"" variable for the same tree; 554 TString command = TString::Format(""tv__tree = (TTree *) gROOT->FindObject(\""%s\"");"", treeName);; 555 ExecuteCommand(command.Data());; 556 }; 557 //--- add the tree to the list if it is not already in; 558 if (fTreeList) fTreeList->Add(fTree);; 559 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 560 //--- map this tree; 561 TGListTreeItem *base = nullptr;; 562 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 563 if (!parent) parent ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:40662,Modifiability,variab,variable,40662,"me(fBLbl4, lo);; 1003 //--- IList text entry; 1004 fBarListIn = new TGTextEntry(fBFrame, new TGTextBuffer(100));; 1005 fBarListIn->SetWidth(60);; 1006 fBarListIn->SetToolTipText(""Name of a previously created event list"");; 1007 fBFrame->AddFrame(fBarListIn, lo);; 1008 //--- label for OList text entry; 1009 fBLbl5 = new TGLabel(fBFrame,""OList"");; 1010 fBFrame->AddFrame(fBLbl5, lo);; 1011 //--- OList text entry; 1012 fBarListOut = new TGTextEntry(fBFrame, new TGTextBuffer(100));; 1013 fBarListOut->SetWidth(60);; 1014 fBarListOut->SetToolTipText(""Output event list. Use <Draw> to generate it."");; 1015 fBFrame->AddFrame(fBarListOut, lo);; 1016 //--- Status bar; 1017 fStatusBar = new TGStatusBar(fBFrame, 10, 10);; 1018 fStatusBar->SetWidth(200);; 1019 fStatusBar->Draw3DCorner(false);; 1020 lo = new TGLayoutHints(kLHintsCenterX | kLHintsCenterY | kLHintsLeft | kLHintsExpandX, 2,2,2,2);; 1021 fWidgets->Add(lo);; 1022 fBFrame->AddFrame(fStatusBar, lo);; 1023 //--- RESET button; 1024 fReset = new TGTextButton(fBFrame,""RESET"",kRESET);; 1025 fReset->SetToolTipText(""Reset variable's fields and drawing options"");; 1026 fReset->Associate(this);; 1027 lo = new TGLayoutHints(kLHintsTop | kLHintsRight, 2,2,2,2);; 1028 fWidgets->Add(lo);; 1029 fBFrame->AddFrame(fReset,lo);; 1030 //--- group of buttons for session handling; 1031 fBGFirst = new TGPictureButton(fBFrame,; 1032 gClient->GetPicture(""first_t.xpm""), kBGFirst);; 1033 fBGFirst->SetToolTipText(""First record"");; 1034 fBGFirst->Associate(this);; 1035 fBGPrevious = new TGPictureButton(fBFrame,; 1036 gClient->GetPicture(""previous_t.xpm""), kBGPrevious);; 1037 fBGPrevious->SetToolTipText(""Previous record"");; 1038 fBGPrevious->Associate(this);; 1039 fBGRecord = new TGPictureButton(fBFrame,; 1040 gClient->GetPicture(""record_t.xpm""), kBGRecord);; 1041 fBGRecord->SetToolTipText(""Record"");; 1042 fBGRecord->Associate(this);; 1043 fBGNext = new TGPictureButton(fBFrame,; 1044 gClient->GetPicture(""next_t.xpm""), kBGNext);; 1045 fBGNext->SetToolT",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:59544,Modifiability,variab,variables,59544,");; 1577 }; 1578 if (Ey() && strlen(Ey()) && Ex() && strlen(Ex())) varexp += "":"";; 1579 if (Ex() && strlen(Ex())) {; 1580 previousexp = true;; 1581 dimension++;; 1582 varexp += Ex();; 1583 item = ExpressionItem(0);; 1584 alias[0] = item->GetAlias();; 1585 if (alias[0].BeginsWith(""~"")) alias[0].Remove(0, 1);; 1586 }; 1587 for(Int_t i=0;i<10;++i){; 1588 if(En(i+5) && strlen(En(i+5))){; 1589 ++dimension;; 1590 if(previousexp){; 1591 varexp += "":"";; 1592 varexp += En(i+5);; 1593 } else varexp = En(i+5);; 1594 previousexp = true;; 1595 }; 1596 }; 1597 if (dimension<3) {; 1598 Warning(""ExecuteSpider"", ""Need at least 3 variables"");; 1599 return;; 1600 }; 1601 // find ListIn; 1602 fTree->SetEventList(nullptr);; 1603 TEventList *elist = nullptr;; 1604 if (strlen(fBarListIn->GetText())) {; 1605 elist = (TEventList *) gROOT->FindObject(fBarListIn->GetText());; 1606 if (elist) fTree->SetEventList(elist);; 1607 }; 1608 // find ListOut; 1609 if (strlen(fBarListOut->GetText())) varexp = TString::Format("">>%s"", fBarListOut->GetText());; 1610 // find canvas/pad where to draw; 1611 auto pad = gROOT->GetSelectedPad();; 1612 if (pad) pad->cd();; 1613 // find graphics option; 1614 const char* gopt = fBarOption->GetText();; 1615 // just in case a previous interrupt was posted; 1616 gROOT->SetInterrupt(false);; 1617 // check if cut is enabled; 1618 const char *cut = """";; 1619 if (fEnableCut) cut = Cut();; 1620 ; 1621 // get entries to be processed; 1622 Long64_t nentries = (Long64_t)(fSlider->GetMaxPositionD() -; 1623 fSlider->GetMinPositionD() + 1);; 1624 Long64_t firstentry = fSlider->GetMinPositionL();; 1625 ; 1626 // create the spider plot; 1627 ; 1628 TSpider* spider = new TSpider(fTree,varexp.Data(),cut,Form(""%s spider average"",gopt),nentries,firstentry);; 1629 spider->Draw();; 1630 ; 1631 if (gPad) gPad->Update();; 1632}; 1633 ; 1634////////////////////////////////////////////////////////////////////////////////; 1635/// Get the expression to be drawn on X axis.; 1636 ; 1637const c",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:67772,Modifiability,variab,variable,67772,"Up);; 1817 }; 1818 break;; 1819 default:; 1820 break;; 1821 }; 1822 break;; 1823 case kC_LISTTREE:; 1824 switch (GET_SUBMSG(msg)) {; 1825 // handle mouse messages in the list-tree (left panel); 1826 case kCT_ITEMCLICK :; 1827 // tell coverity that parm1 is a Long_t, and not an enum (even; 1828 // if we compare it with an enum value) and the meaning of; 1829 // parm1 depends on GET_MSG(msg) and GET_SUBMSG(msg); 1830 // coverity[mixed_enums]; 1831 if (((EMouseButton)parm1==kButton1) ||; 1832 ((EMouseButton)parm1==kButton3)) {; 1833 TGListTreeItem *ltItem = nullptr;; 1834 // get item that sent this; 1835 if ((ltItem = fLt->GetSelected()) != nullptr) {; 1836 // get item type; 1837 ULong_t *itemType = (ULong_t *)ltItem->GetUserData();; 1838 if (!itemType); 1839 break;; 1840 if (*itemType & kLTTreeType) {; 1841 // already mapped tree item clicked; 1842 Int_t index = (Int_t)(*itemType >> 8);; 1843 SwitchTree(index);; 1844 if (fTree != fMappedTree) {; 1845 // switch also the global ""tree"" variable; 1846 fLVContainer->RemoveNonStatic();; 1847 // map it on the right panel; 1848 MapTree(fTree);; 1849 fListView->Layout();; 1850 }; 1851 // activate context menu for this tree; 1852 if (parm1 == kButton3) {; 1853 Int_t x = (Int_t)(parm2 &0xffff);; 1854 Int_t y = (Int_t)((parm2 >> 16) & 0xffff);; 1855 fContextMenu->Popup(x, y, fTree);; 1856 }; 1857 }; 1858 ; 1859 if (*itemType & kLTBranchType) {; 1860 // branch item clicked; 1861 SetParentTree(ltItem);; 1862 if (!fTree) break; // really needed ?; 1863 TBranch *branch = fTree->GetBranch(ltItem->GetText());; 1864 if (!branch) break;; 1865 // check if it is mapped on the right panel; 1866 if (branch != fMappedBranch) {; 1867 fLVContainer->RemoveNonStatic();; 1868 MapBranch(branch);; 1869 fStopMapping = false;; 1870 fListView->Layout();; 1871 }; 1872 // activate context menu for this branch (no *MENU* methods ):); 1873 if (parm1 == kButton3) {; 1874 Int_t x = (Int_t)(parm2 &0xffff);; 1875 Int_t y = (Int_t)((parm2 >> 16) & 0xffff);; 1876",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:133580,Modifiability,inherit,inherits,133580,"r of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::DoErrorvirtual void DoError(int level, const char *location, const char *fmt, va_list va) constInterface to ErrorHandler (protected).Definition TObject.cxx:954; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TRootHelpDialogA TRootHelpDialog is used to display help text (or any text in a dialog window).Definition TRootHelpDialog.h:22; TRootHelpDialog::SetTextvoid SetText(const char *helpText)Set help text from helpText buffer in TGTextView.Definition TRootHelpDialog.cxx:77; TRootHelpDialog::Popupvoid Popup()Show help dialog.Definition TRootHelpDialog.cxx:69; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:8184,Performance,load,load,8184,";; 139 - SetScanFileName : define a name for the file where TTree::Scan command; 140 is redirected when the `<Scan>` button is checked;; 141 - SetTreeName : open a new tree with this name in the viewer;; 142 ; 143 A specific context menu is activated if expressions/leaves are right-clicked.; 144 ; 145 Commands are :; 146 - Draw : draw a histogram for this item;; 147 - EditExpression : pops-up the expression editor;; 148 - Empty : empty the name and alias of this item;; 149 - RemoveItem : removes clicked item from the list;; 150 - Scan : scan this expression;; 151 - SetExpression : edit name and alias for this item by hand;; 152 ; 153Starting the viewer; 154 ; 155 1. From the TBrowser: Select a tree in the TBrowser, then call the; 156 StartViewer() method from its context menu (right-click on the tree).; 157 2. From the command line: Start a ROOT session in the directory where you have; 158 your tree. You will need first to load the library for TTreeViewer and; 159 optionally other libraries for user defined classes (you can do this later in; 160 the session) :; 161~~~ {.cpp}; 162 root [0] gSystem->Load(\""TTreeViewer\"");; 163~~~; 164Supposing you have the tree MyTree in the file MyFile, you can do :; 165~~~ {.cpp}; 166 root [1] TFile file(""Myfile"");; 167 root [2] new TTreeViewer(""Mytree"");; 168~~~; 169or :; 170~~~ {.cpp}; 171 root [2] TTreeViewer *tv = new TTreeViewer();; 172 root [3] tv->SetTreeName(""Mytree"");; 173~~~; 174\image html ttree_treeview.png; 175*/; 176 ; 177#include ""RConfigure.h""; 178 ; 179#include <iostream>; 180#include <fstream>; 181#include ""TTreeViewer.h""; 182#include ""HelpText.h""; 183#include ""HelpTextTV.h""; 184#include ""TTVLVContainer.h""; 185#include ""TTVSession.h""; 186 ; 187#include ""TROOT.h""; 188#include ""TError.h""; 189#include ""TGMsgBox.h""; 190#include ""TTreePlayer.h""; 191#include ""TContextMenu.h""; 192#include ""TInterpreter.h""; 193#include ""TLeaf.h""; 194#include ""TBranch.h""; 195#include ""TRootHelpDialog.h""; 196#include ""TSystem.h""; 197#include",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:15360,Performance,load,load,15360,"//////////////////////////////////////////////////////////; 387/// Allow geting the tree from the context menu.; 388 ; 389void TTreeViewer::AppendTree(TTree *tree); 390{; 391 if (!tree) return;; 392 TTree *ftree;; 393 if (fTreeList) {; 394 if (fTreeList->FindObject(tree)) {; 395 printf(""Tree found\n"");; 396 TIter next(fTreeList);; 397 Int_t index = 0;; 398 while ((ftree = (TTree*)next())) {; 399 if (ftree==tree) {printf(""found at index %i\n"", index);break;}; 400 index++;; 401 }; 402 SwitchTree(index);; 403 if (fTree != fMappedTree) {; 404 // switch also the global ""tree"" variable; 405 fLVContainer->RemoveNonStatic();; 406 // map it on the right panel; 407 MapTree(fTree);; 408 fListView->Layout();; 409 TGListTreeItem *base = nullptr;; 410 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 411 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 412 fLt->ClearHighlighted();; 413 fLt->HighlightItem(item);; 414 fClient->NeedRedraw(fLt);; 415 }; 416 return;; 417 }; 418 }; 419 if (fTree != tree) {; 420 fTree = tree;; 421 // load the tree via the interpreter; 422 char command[100];; 423 command[0] = 0;; 424 // define a global ""tree"" variable for the same tree; 425 snprintf(command,100, ""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 426 ExecuteCommand(command);; 427 }; 428 //--- add the tree to the list if it is not already in; 429 if (fTreeList) fTreeList->Add(fTree);; 430 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 431 //--- map this tree; 432 TGListTreeItem *base = nullptr;; 433 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 434 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 435 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 436 fTreeIndex++;; 437 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 438 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 439 MapTree(fTree, lTreeItem, false);; 440 fLt->OpenItem(parent);; ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:17866,Performance,load,load,17866,"0}; 461////////////////////////////////////////////////////////////////////////////////; 462/// Set the name of the file where to redirect `<Scan>` output.; 463 ; 464void TTreeViewer::SetScanFileName(const char *name); 465{; 466 if (fTree) ((TTreePlayer *)fTree->GetPlayer())->SetScanFileName(name);; 467}; 468////////////////////////////////////////////////////////////////////////////////; 469/// Set the state of Scan check button.; 470 ; 471void TTreeViewer::SetScanRedirect(bool mode); 472{; 473 if (mode); 474 fBarScan->SetState(kButtonDown);; 475 else; 476 fBarScan->SetState(kButtonUp);; 477}; 478////////////////////////////////////////////////////////////////////////////////; 479/// Assign the fTree member from existing tree, e.g. when calling; 480/// tree->StartViewer() from the browser, or even from the command line.; 481 ; 482void TTreeViewer::SetTree(TTree *tree); 483{; 484 if (!tree) return;; 485 if (fTree != tree) {; 486 fTree = tree;; 487 // load the tree via the interpreter; 488 // define a global ""tree"" variable for the same tree; 489 TString command = TString::Format(""tv__tree = (TTree *)0x%zx;"", (size_t)tree);; 490 ExecuteCommand(command.Data());; 491 }; 492 //--- add the tree to the list if it is not already in; 493 if (fTreeList) fTreeList->Add(fTree);; 494 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 495 //--- map this tree; 496 TGListTreeItem *base = nullptr;; 497 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 498 if (!parent) parent = fLt->AddItem(base, ""TreeList"", new ULong_t(kLTNoType));; 499 ULong_t *itemType = new ULong_t((fTreeIndex << 8) | kLTTreeType);; 500 fTreeIndex++;; 501 TGListTreeItem *lTreeItem = fLt->AddItem(parent, tree->GetName(), itemType,; 502 gClient->GetPicture(""tree_t.xpm""), gClient->GetPicture(""tree_t.xpm""));; 503 MapTree(fTree, lTreeItem, false);; 504 fLt->OpenItem(parent);; 505 fLt->HighlightItem(lTreeItem);; 506 fClient->NeedRedraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTree",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:20276,Performance,load,load,20276,"Redraw(fLt);; 507 ; 508 //--- map slider and list view; 509 SwitchTree(fTreeIndex-1);; 510 fLVContainer->RemoveNonStatic();; 511 MapTree(fTree);; 512 fListView->Layout();; 513 SetFile();; 514}; 515////////////////////////////////////////////////////////////////////////////////; 516/// Allow geting the tree from the context menu.; 517 ; 518void TTreeViewer::SetTreeName(const char* treeName); 519{; 520 if (!treeName) return;; 521 TTree *tree = (TTree *) gROOT->FindObject(treeName);; 522 if (fTreeList) {; 523 if (fTreeList->FindObject(treeName)) {; 524 printf(""Tree found\n"");; 525 TIter next(fTreeList);; 526 Int_t index = 0;; 527 while ((tree = (TTree*)next())) {; 528 if (!strcmp(treeName, tree->GetName())) {printf(""found at index %i\n"", index);break;}; 529 index++;; 530 }; 531 SwitchTree(index);; 532 if (fTree != fMappedTree) {; 533 // switch also the global ""tree"" variable; 534 fLVContainer->RemoveNonStatic();; 535 // map it on the right panel; 536 MapTree(fTree);; 537 fListView->Layout();; 538 TGListTreeItem *base = nullptr;; 539 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 540 TGListTreeItem *item = fLt->FindChildByName(parent, fTree->GetName());; 541 fLt->ClearHighlighted();; 542 fLt->HighlightItem(item);; 543 fClient->NeedRedraw(fLt);; 544 }; 545 return;; 546 }; 547 }; 548 if (!tree) return;; 549// ((TTreePlayer *)tree->GetPlayer())->SetViewer(this);; 550 if (fTree != tree) {; 551 fTree = tree;; 552 // load the tree via the interpreter; 553 // define a global ""tree"" variable for the same tree; 554 TString command = TString::Format(""tv__tree = (TTree *) gROOT->FindObject(\""%s\"");"", treeName);; 555 ExecuteCommand(command.Data());; 556 }; 557 //--- add the tree to the list if it is not already in; 558 if (fTreeList) fTreeList->Add(fTree);; 559 ExecuteCommand(""tv__tree_list->Add(tv__tree);"");; 560 //--- map this tree; 561 TGListTreeItem *base = nullptr;; 562 TGListTreeItem *parent = fLt->FindChildByName(base, ""TreeList"");; 563 if (!parent) parent ",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:97704,Performance,load,loading,97704,,MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:115499,Performance,perform,performed,115499,"tMessageTypes.h:59; kCT_ITEMDBLCLICK@ kCT_ITEMDBLCLICKDefinition WidgetMessageTypes.h:55; kC_CONTAINER@ kC_CONTAINERDefinition WidgetMessageTypes.h:53; GET_SUBMSGInt_t GET_SUBMSG(Long_t val)Definition WidgetMessageTypes.h:111; snprintf#define snprintfDefinition civetweb.c:1540; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TAxisClass to manage histogram axis.Definition TAxis.h:31; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetListOfBranchesTObjArray * GetListOfBranches()Definition TBranch.h:246; TBranch::GetNleavesInt_t GetNleaves() constDefinition TBranch.h:249; TBranch::GetListOfLeavesTObjArray * GetListOfLeaves()Definition TBranch.h:247; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TContextMenu::Actionvirtual void Action(TObject *object, TMethod *method)Action to be performed when this menu item is selected.Definition TContextMenu.cxx:93; TContextMenu::Popupvirtual void Popup(Int_t x, Int_t y, TObject *obj, TVirtualPad *c=nullptr, TVirtualPad *p=nullptr)Popup context menu at given location in canvas c and pad p for selected object.Definition TContextMenu.cxx:411; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::AsStringconst char * AsString() constReturn the date & time as a string (ctime() format).Definition TDatime.cxx:102; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::cdvirtual Bool_t cd()Change current directory to ""this"" directory.Definition TDirectory.cxx:53",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:81616,Safety,abort,aborting,81616,"Picture(""cut-disable_t.xpm""));; 2268 }; 2269 }; 2270 if (*itemType & kLTPackType) {; 2271 fScanMode = true;; 2272 ExecuteDraw();; 2273 }; 2274 }; 2275 }; 2276 break;; 2277 case kButton2:; 2278 break;; 2279 case kButton3:; 2280 break;; 2281 default:; 2282 break;; 2283 }; 2284 break;; 2285 case 4:; 2286// std::cout << ""Dragging Item"" << std::endl;; 2287 default:; 2288 break;; 2289 }; 2290 break;; 2291 default:; 2292 break;; 2293 }; 2294 return true;; 2295}; 2296 ; 2297////////////////////////////////////////////////////////////////////////////////; 2298/// Close the viewer.; 2299 ; 2300void TTreeViewer::CloseWindow(); 2301{; 2302 DeleteWindow();; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Execute all user commands.; 2307 ; 2308void TTreeViewer::ExecuteCommand(const char* command, bool fast); 2309{; 2310 // Execute the command, write it to history file and echo it to output; 2311 if (fBarRec->GetState() == kButtonDown) {; 2312 // show the command on the command line; 2313 //printf(""%s\n"", command);; 2314 char comm[2000];; 2315 comm[0] = 0;; 2316 if (strlen(command) > 1999) {; 2317 Warning(""ExecuteCommand"", ""Command too long: aborting."");; 2318 return;; 2319 }; 2320 snprintf(comm,2000, ""%s"", command);; 2321 // print the command to history file; 2322 Gl_histadd(comm);; 2323 }; 2324 // execute it; 2325 if (fast) {; 2326 gROOT->ProcessLineFast(command);; 2327 } else {; 2328 gROOT->ProcessLine(command);; 2329 }; 2330 // make sure that 'draw on double-click' flag is reset; 2331 fVarDraw = false;; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Scan the selected options from option menu.; 2336 ; 2337void TTreeViewer::MapOptions(Long_t parm1); 2338{; 2339 Int_t ind;; 2340 if (parm1 == kOptionsReset) {; 2341 for (ind=kOptionsGeneral; ind<kOptionsGeneral+16; ind++); 2342 fOptionsGen->UnCheckEntry(ind);; 2343 for (ind=kOptions1D; ind<kOptions1D+12; ind++); 2",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:94885,Safety,abort,abort,94885,"//; 2637/// Find parent tree of a clicked item.; 2638 ; 2639void TTreeViewer::SetParentTree(TGListTreeItem *item); 2640{; 2641 if (!item) return;; 2642 ULong_t *itemType = (ULong_t *)item->GetUserData();; 2643 if (!itemType) return;; 2644 TGListTreeItem *parent = nullptr;; 2645 Int_t index;; 2646 if (!(*itemType & kLTTreeType)) {; 2647 parent = item->GetParent();; 2648 SetParentTree(parent);; 2649 } else {; 2650 index = (Int_t)(*itemType >> 8);; 2651 SwitchTree(index);; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Send a message on the status bar.; 2657 ; 2658void TTreeViewer::Message(const char* msg); 2659{; 2660 fStatusBar->SetText(msg);; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Put error/warning into TMsgBox and also forward to console.; 2665 ; 2666void TTreeViewer::DoError(int level, const char *location, const char *fmt, va_list va) const; 2667{; 2668 TObject::DoError(level, location, fmt, va);; 2669 ; 2670 // in case level will abort we will not come here...; 2671 ; 2672 static const int buf_size = 2048;; 2673 char buf[buf_size], *bp;; 2674 ; 2675 int n = vsnprintf(buf, buf_size, fmt, va);; 2676 // old vsnprintf's return -1 if string is truncated new ones return; 2677 // total number of characters that would have been written; 2678 if (n == -1 || n >= buf_size) {; 2679 TObject::Warning(""DoError"", ""Error message string truncated..."");; 2680 }; 2681 if (level >= kSysError && level < kFatal); 2682 bp = Form(""%s (%s)"", buf, gSystem->GetError());; 2683 else; 2684 bp = buf;; 2685 ; 2686 const char *title = """";; 2687 if (level == kInfo); 2688 title = ""Info"";; 2689 if (level == kWarning); 2690 title = ""Warning"";; 2691 if (level == kError); 2692 title = ""Error"";; 2693 if (level == kSysError); 2694 title = ""System Error"";; 2695 ; 2696 new TGMsgBox(fClient->GetRoot(), this, title, bp, kMBIconExclamation);; 2697}; 2698 ; 2699////////////",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:140128,Security,access,access,140128,"ddRecord(bool fromFile=false)Add a record.Definition TTVSession.cxx:161; TTVSession::PreviousTTVRecord * Previous()Definition TTVSession.h:97; TTVSession::GetEntriesInt_t GetEntries()Definition TTVSession.h:91; TTVSession::FirstTTVRecord * First()Definition TTVSession.h:94; TTVSession::RemoveLastRecordvoid RemoveLastRecord()Remove current record from list.Definition TTVSession.cxx:224; TTVSession::NextTTVRecord * Next()Definition TTVSession.h:96; TTVSession::UpdateRecordvoid UpdateRecord(const char *name)Updates current record according to new X, Y, Z settings.Definition TTVSession.cxx:272; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram...Definition TTreePlayer.h:37; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid U",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:1855,Usability,progress bar,progress bar,1855,"g terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issu",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:2874,Usability,clear,clear,2874,"31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issued and SCAN enables redirecting of TTree::Scan command in; 47 an ASCII file (see -Scanning expressions-);; 48 - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; 49 drawing and stop the current command respectively, two text widgets where; 50 input and output event lists can be specified, a message box and a RESET; 51 button on the right that clear edited expression content (see Editing...); 52 - a tree-type list on the main left panel where you can select among trees or; 53 branches. The tree/branch will be detailed in the right panel.; 54 Mapped trees are provided with context menus, activated by right-clicking;; 55 - a view-type list on the right panel. The first column contain X, Y and; 56 Z expression items, an optional cut and ten optional editable expressions.; 57 Expressions and leaf-type items can be dragged or deleted. A right click on; 58 the list-box or item activates context menus.; 59 ; 60### Opening a new tree and saving a session :; 61 ; 62 To open a new tree in the viewer use `<File/Open tree file>` menu; 63The content of the file (keys) will be listed. Use `<SetTreeName>` function; 64from the context me",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:6927,Usability,clear,clears,6927,"he STOP button; 114from the bottom-left; 115You can toggle recording of the current command in the history file by; 116checking the Rec button from the top-right; 117 ; 118### Context menus; 119 ; 120 You can activate context menus by right-clicking on items or inside the; 121right panel.; 122 ; 123Context menus for mapped items from the left tree-type list :; 124 The items from the left that are provided with context menus are tree and; 125branch items. You can directly activate the *MENU* marked methods of TTree; 126from this menu.; 127 ; 128Context menu for the right panel:; 129 ; 130 A general context menu is activated if the user right-clicks the right panel.; 131 ; 132 Commands are :; 133 - EmptyAll : clears the content of all expressions;; 134 - ExecuteCommand : execute a ROOT command;; 135 - MakeSelector : equivalent of TTree::MakeSelector();; 136 - NewExpression : add an expression item in the right panel;; 137 - Process : equivalent of TTree::Process();; 138 - SaveSource : save the current session as a C++ macro;; 139 - SetScanFileName : define a name for the file where TTree::Scan command; 140 is redirected when the `<Scan>` button is checked;; 141 - SetTreeName : open a new tree with this name in the viewer;; 142 ; 143 A specific context menu is activated if expressions/leaves are right-clicked.; 144 ; 145 Commands are :; 146 - Draw : draw a histogram for this item;; 147 - EditExpression : pops-up the expression editor;; 148 - Empty : empty the name and alias of this item;; 149 - RemoveItem : removes clicked item from the list;; 150 - Scan : scan this expression;; 151 - SetExpression : edit name and alias for this item by hand;; 152 ; 153Starting the viewer; 154 ; 155 1. From the TBrowser: Select a tree in the TBrowser, then call the; 156 StartViewer() method from its context menu (right-click on the tree).; 157 2. From the command line: Start a ROOT session in the directory where you have; 158 your tree. You will need first to load the library for TTree",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:37213,Usability,progress bar,progress bar,37213,,MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:127437,Usability,progress bar,progress bar,127437,"it).Definition TGMenu.cxx:1782; TGPopupMenu::DisableEntryvirtual void DisableEntry(Int_t id)Disable entry (disabled entries appear in a sunken relieve).Definition TGMenu.cxx:1724; TGPopupMenu::UnCheckEntryvirtual void UnCheckEntry(Int_t id)Uncheck menu entry (i.e. remove check mark).Definition TGMenu.cxx:1807; TGPopupMenu::Associatevirtual void Associate(const TGWindow *w)Definition TGMenu.h:206; TGPopupMenu::AddSeparatorvirtual void AddSeparator(TGMenuEntry *before=nullptr)Add a menu separator to the menu.Definition TGMenu.cxx:1060; TGPopupMenu::AddEntryvirtual void AddEntry(TGHotString *s, Int_t id, void *ud=nullptr, const TGPicture *p=nullptr, TGMenuEntry *before=nullptr)Add a menu entry.Definition TGMenu.cxx:990; TGProgressBar::SetPositionvoid SetPosition(Float_t pos)Set progress position between [min,max].Definition TGProgressBar.cxx:92; TGProgressBar::SetFillTypevoid SetFillType(EFillType type)Set fill type.Definition TGProgressBar.cxx:136; TGProgressBar::SetBarColorvirtual void SetBarColor(Pixel_t color)Set progress bar color.Definition TGProgressBar.cxx:156; TGProgressBar::kBlockFill@ kBlockFillDefinition TGProgressBar.h:23; TGSelectBoxThis class represent a specialized expression editor for TTVLVEntry 'true name' and 'alias' data memb...Definition TTVLVContainer.h:157; TGSelectBox::EditedEntryTTVLVEntry * EditedEntry()Definition TTVLVContainer.h:181; TGSelectBox::InsertTextvoid InsertText(const char *text)Insert text in text entry.Definition TTVLVContainer.cxx:825; TGSelectBox::GrabPointervoid GrabPointer()Just focus the cursor inside.Definition TTVLVContainer.cxx:755; TGSelectBox::SetLabelvoid SetLabel(const char *title)Set label of selection box.Definition TTVLVContainer.cxx:769; TGSelectBox::SetEntryvoid SetEntry(TTVLVEntry *entry)Connect one entry.Definition TTVLVContainer.cxx:814; TGSelectBox::GetInstancestatic TGSelectBox * GetInstance()Return the pointer to the instantiated singleton.Definition TTVLVContainer.cxx:747; TGStatusBarProvides a StatusBar w",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:129761,Usability,clear,clears,129761,"utines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextBufferA text buffer is used in several widgets, like TGTextEntry, TGFileDialog, etc.Definition TGTextBuffer.h:17; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextEntryA TGTextEntry is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends text to the end of text entry, clears the selection and moves the cursor to the end of the li...Definition TGTextEntry.cxx:1689; TGTextEntry::SetToolTipTextvirtual void SetToolTipText(const char *text, Long_t delayms=500)Set tool tip text associated with this text entry.Definition TGTextEntry.cxx:1647; TGTextEntry::SetTextvirtual void SetText(const char *text, Bool_t emit=kTRUE)Sets text entry to text, clears the selection and moves the cursor to the end of the line.Definition TGTextEntry.cxx:611; TGTextEntry::HandleButtonBool_t HandleButton(Event_t *event) overrideHandle mouse button event in text entry widget.Definition TGTextEntry.cxx:1342; TGToolBarA toolbar is a composite frame that contains TGPictureButtons.Definition TGToolBar.h:33; TGVSplitterDefinition TGSplitter.h:53; TGVSplitter::SetFramevoid SetFrame(TGFrame *frame, Bool_t left) overrideSet frame to be resized.Definition TGSplitter.cxx:143; TGVertical3DLineA vertical 3D line is a line that can be used to separate groups of widgets",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8cxx_source.html:130136,Usability,clear,clears,130136,"try is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends text to the end of text entry, clears the selection and moves the cursor to the end of the li...Definition TGTextEntry.cxx:1689; TGTextEntry::SetToolTipTextvirtual void SetToolTipText(const char *text, Long_t delayms=500)Set tool tip text associated with this text entry.Definition TGTextEntry.cxx:1647; TGTextEntry::SetTextvirtual void SetText(const char *text, Bool_t emit=kTRUE)Sets text entry to text, clears the selection and moves the cursor to the end of the line.Definition TGTextEntry.cxx:611; TGTextEntry::HandleButtonBool_t HandleButton(Event_t *event) overrideHandle mouse button event in text entry widget.Definition TGTextEntry.cxx:1342; TGToolBarA toolbar is a composite frame that contains TGPictureButtons.Definition TGToolBar.h:33; TGVSplitterDefinition TGSplitter.h:53; TGVSplitter::SetFramevoid SetFrame(TGFrame *frame, Bool_t left) overrideSet frame to be resized.Definition TGSplitter.cxx:143; TGVertical3DLineA vertical 3D line is a line that can be used to separate groups of widgets.Definition TG3DLine.h:33; TGVerticalFrameA composite frame that layout their children in vertical way.Definition TGFrame.h:374; TGWidget::Associatevirtual void Associate(const TGWindow *w)Definition TGWidget.h:72; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(co",MatchSource.WIKI,doc/master/TTreeViewer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:11603,Availability,down,down,11603,"efinition TGWin32VirtualXProxy.cxx:232; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TGButtonA button abstract base class.Definition TGButton.h:68; TGCanvasA frame containing two scrollbars (a horizontal and a vertical) and a viewport.Definition TGCanvas.h:192; TGCheckButtonSelects different options.Definition TGButton.h:264; TGClientWindow client.Definition TGClient.h:37; TGComboBoxA combobox (also known as a drop down listbox) allows the selection of one item out of a list of item...Definition TGComboBox.h:47; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGDoubleVSliderDragging the slider will generate the event:Definition TGDoubleSlider.h:170; TGHProgressBarDefinition TGProgressBar.h:94; TGHorizontalFrameA composite frame that layout their children in horizontal way.Definition TGFrame.h:385; TGLabelThis class handles GUI labels.Definition TGLabel.h:24; TGLayoutHintsThis class describes layout hints used by the layout classes.Definition TGLayout.h:50; TGListTreeItemDefinition TGListTree.h:27; TGListTreeA list tree is a widget that can contain a number of items arranged in a tree structure.Definition TGListTree.h:195; TGListViewA list view is a widget that can contain a number of items arranged in a grid or list.Definition TGListView.h:115; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:4533,Deployability,toggle,toggle,4533,"106/// @name Menu bar, menu bar entries and layouts; 107 TGLayoutHints *fMenuBarLayout;; 108 TGLayoutHints *fMenuBarItemLayout;; 109 TGLayoutHints *fMenuBarHelpLayout;; 110 TGMenuBar *fMenuBar;; 111 TGPopupMenu *fFileMenu;; 112 TGPopupMenu *fEditMenu;; 113 TGPopupMenu *fRunMenu;; 114 TGPopupMenu *fOptionsMenu;; 115 TGPopupMenu *fOptionsGen;; 116 TGPopupMenu *fOptions1D;; 117 TGPopupMenu *fOptions2D;; 118 TGPopupMenu *fHelpMenu;; 119///@}; 120 ; 121///@{; 122/// @name Toolbar and hints; 123 TGToolBar *fToolBar;; 124 TGLayoutHints *fBarLayout;; 125///@}; 126 ; 127///@{; 128/// @name Widgets on the toolbar; 129 TGLabel *fBarLbl1; ///< Label of command text entry; 130 TGLabel *fBarLbl2; ///< Label of option text entry; 131 TGLabel *fBarLbl3; ///< Label of histogram name text entry; 132 TGCheckButton *fBarH; ///< Checked for drawing current histogram with different graphic option; 133 TGCheckButton *fBarScan; ///< Checked for tree scan; 134 TGCheckButton *fBarRec; ///< Command recording toggle; 135 TGTextEntry *fBarCommand; ///< User command entry; 136 TGTextEntry *fBarOption; ///< Histogram drawing option entry; 137 TGTextEntry *fBarHist; ///< Histogram name entry; 138///@}; 139 ; 140///@{; 141/// @name Frames; 142 TGHorizontalFrame *fHf; ///< Main horizontal frame; 143 TGDoubleVSlider *fSlider; ///< Vertical slider to select processed tree entries;; 144 TGVerticalFrame *fV1; ///< List tree mother; 145 TGVerticalFrame *fV2; ///< List view mother; 146 TGCompositeFrame *fTreeHdr; ///< Header for list tree; 147 TGCompositeFrame *fListHdr; ///< Header for list view; 148 TGLabel *fLbl1; ///< Label for list tree; 149 TGLabel *fLbl2; ///< Label for list view; 150 TGHorizontalFrame *fBFrame; ///< Button frame; 151 TGHorizontalFrame *fHpb; ///< Progress bar frame; 152 TGHProgressBar *fProgressBar; ///< Progress bar; 153 TGLabel *fBLbl4; ///< Label for input list entry; 154 TGLabel *fBLbl5; ///< Label for output list entry; 155 TGTextEntry *fBarListIn; ///< Tree input event list n",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:14601,Deployability,toggle,toggle,14601,"n in vertical way.Definition TGFrame.h:374; TListA doubly linked list.Definition TList.h:38; TStringBasic string class.Definition TString.h:139; TTVLVContainerThis class represent the list view container for the TreeView class.Definition TTVLVContainer.h:110; TTVLVEntryThis class represent entries that goes into the TreeViewer listview container.Definition TTVLVContainer.h:56; TTVSessionI/O classes for TreeViewer session handling.Definition TTVSession.h:75; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid UpdateRecord(const char *name=""new name""); TTreeViewer::fBarOptionTGTextEntry * fBarOptionHistogram drawing option entry.Definition TTreeViewer.h:136; TTreeViewer::fBLbl4TGLabel * fBLbl4Label for input list entry.Definition TTreeViewer.h:153; TTreeViewer::fBarCommandTGTextEntry * fBarCommandUser command entry.Definition TTreeViewer.h:135; TTreeViewer::fOptions2DTGPopupMenu * fOptions2DDefinition TTreeViewer.h:117; TTreeViewer::fListViewTGListView * fListViewListView with branches and leaves.Definition TTreeViewer.h:179; TTreeViewer::fComboTGCom",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:11196,Integrability,interface,interface,11196," Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TGButtonA button abstract base class.Definition TGButton.h:68; TGCanvasA frame containing two scrollbars (a horizontal and a vertical) and a viewport.Definition TGCanvas.h:192; TGCheckButtonSelects different options.Definition TGButton.h:264; TGClientWindow client.Definition TGClient.h:37; TGComboBoxA combobox (also known as a drop down listbox) allows the selection of one item out of a list of item...Definition TGComboBox.h:47; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGDoubleVSliderDragging the slider will generate the event:Definition TGDoubleSlider.h:170; TGHProgressBarDefinition TGProgressBar.h:94; TGHorizontalFrameA composite frame that layout their children in horizontal way.Definition TGFrame.h:385; TGLabelThis class handles GUI labels.Definition TGLabel.h:24; TGLayoutHintsThis class describes layout hints used by the layout classes.Definit",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:14106,Integrability,interface,interface,14106,"tainer.h:157; TGStatusBarProvides a StatusBar widget.Definition TGStatusBar.h:21; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextEntryA TGTextEntry is a one line text input widget.Definition TGTextEntry.h:24; TGToolBarA toolbar is a composite frame that contains TGPictureButtons.Definition TGToolBar.h:33; TGVerticalFrameA composite frame that layout their children in vertical way.Definition TGFrame.h:374; TListA doubly linked list.Definition TList.h:38; TStringBasic string class.Definition TString.h:139; TTVLVContainerThis class represent the list view container for the TreeView class.Definition TTVLVContainer.h:110; TTVLVEntryThis class represent entries that goes into the TreeViewer listview container.Definition TTVLVContainer.h:56; TTVSessionI/O classes for TreeViewer session handling.Definition TTVSession.h:75; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid UpdateRecord(const char *name=""new name""); TTreeViewer::fBarOptionTGTextEntry * fBarOptionHistogram drawing option entry.Definition TTreeViewer.h:",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTreeViewer_8h_source.html:6137,Usability,clear,clear,6137," ///< Label for list tree; 149 TGLabel *fLbl2; ///< Label for list view; 150 TGHorizontalFrame *fBFrame; ///< Button frame; 151 TGHorizontalFrame *fHpb; ///< Progress bar frame; 152 TGHProgressBar *fProgressBar; ///< Progress bar; 153 TGLabel *fBLbl4; ///< Label for input list entry; 154 TGLabel *fBLbl5; ///< Label for output list entry; 155 TGTextEntry *fBarListIn; ///< Tree input event list name entry; 156 TGTextEntry *fBarListOut; ///< Pree output event list name entry; 157 TGPictureButton *fDRAW; ///< DRAW button; 158 TGTextButton *fSPIDER; ///< SPIDER button; 159 TGPictureButton *fSTOP; ///< Interrupt current command (not yet); 160 TGPictureButton *fREFR; ///< REFRESH button ///<ia; 161 TGStatusBar *fStatusBar; ///< Status bar; 162 TGComboBox *fCombo; ///< Combo box with session records; 163 TGPictureButton *fBGFirst;; 164 TGPictureButton *fBGPrevious;; 165 TGPictureButton *fBGRecord;; 166 TGPictureButton *fBGNext;; 167 TGPictureButton *fBGLast;; 168 TGTextButton *fReset; ///< clear expression's entries; 169///@}; 170 ; 171///@{; 172/// @name ListTree; 173 TGCanvas *fTreeView; ///< ListTree canvas container; 174 TGListTree *fLt; ///< ListTree with file and tree items; 175///@}; 176 ; 177///@{; 178/// @name ListView; 179 TGListView *fListView; ///< ListView with branches and leaves; 180 TTVLVContainer *fLVContainer; ///< Container for listview; 181 ; 182 TList *fWidgets; ///< List of widgets to be deleted; 183///@}; 184 ; 185 ; 186private:; 187 ; 188 void BuildInterface();; 189 const char *Cut();; 190 Int_t Dimension();; 191 const char *EmptyBrackets(const char* name);; 192 const char *Ex();; 193 const char *Ey();; 194 const char *Ez();; 195 const char *En(Int_t n);; 196 void MapBranch(TBranch *branch, const char *prefix="""", TGListTreeItem *parent = nullptr, bool listIt = true);; 197 void MapOptions(Long_t parm1);; 198 void MapTree(TTree *tree, TGListTreeItem *parent = nullptr, bool listIt = true);; 199 void SetFile();; 200 const char *ScanList();; 201 void SetP",MatchSource.WIKI,doc/master/TTreeViewer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html
https://root.cern/doc/master/TTree_8cxx.html:2083,Integrability,depend,dependency,2083,"st.h""; #include ""TMath.h""; #include ""TMemFile.h""; #include ""TROOT.h""; #include ""TRealData.h""; #include ""TRegexp.h""; #include ""TRefTable.h""; #include ""TStreamerElement.h""; #include ""TStreamerInfo.h""; #include ""TStyle.h""; #include ""TSystem.h""; #include ""TTreeCloner.h""; #include ""TTreeCache.h""; #include ""TTreeCacheUnzip.h""; #include ""TVirtualCollectionProxy.h""; #include ""TEmulatedCollectionProxy.h""; #include ""TVirtualIndex.h""; #include ""TVirtualPerfStats.h""; #include ""TVirtualPad.h""; #include ""TBranchSTL.h""; #include ""TSchemaRuleSet.h""; #include ""TFileMergeInfo.h""; #include ""ROOT/StringConv.hxx""; #include ""TVirtualMutex.h""; #include ""strlcpy.h""; #include ""snprintf.h""; #include ""TBranchIMTHelper.h""; #include ""TNotifyLink.h""; #include <chrono>; #include <cstddef>; #include <iostream>; #include <fstream>; #include <sstream>; #include <string>; #include <cstdio>; #include <climits>; #include <algorithm>; #include <set>; #include ""ROOT/TThreadExecutor.hxx""; #include <thread>. Include dependency graph for TTree.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Functions; boolCheckReshuffling (TTree &mainTree, TTree &friendTree); ; static charDataTypeToChar (EDataType datatype); ; static TBranch *R__FindBranchHelper (TObjArray *list, const char *branchname); Search in the array for a branch matching the branch name, with the branch possibly expressed as a 'full' path name (with dots). ; ; static voidTBranch__SetTree (TTree *tree, TObjArray &branches); Set the fTree member for all branches and sub branches. ; ; voidTFriendElement__SetTree (TTree *tree, TList *frlist); Set the fTree member for all friend elements. ; . Variables; constexpr Int_tkNEntriesResort = 100; ; constexpr Float_tkNEntriesResortInv = 1.f/kNEntriesResort; . Func",MatchSource.WIKI,doc/master/TTree_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx.html
https://root.cern/doc/master/TTree_8cxx_source.html:9237,Availability,avail,available,9237,"dd a column holding objects; 157 ; 158~~~ {.cpp}; 159 MyClass object;; 160 auto branch = tree.Branch(branchname, &object, bufsize, splitlevel); 161~~~; 162Note: The 2nd parameter must be the address of a valid object.; 163 The object must not be destroyed (i.e. be deleted) until the TTree; 164 is deleted or TTree::ResetBranchAddress is called.; 165 ; 166- if splitlevel=0, the object is serialized in the branch buffer.; 167- if splitlevel=1 (default), this branch will automatically be split; 168 into subbranches, with one subbranch for each data member or object; 169 of the object itself. In case the object member is a TClonesArray,; 170 the mechanism described in case C is applied to this array.; 171- if splitlevel=2 ,this branch will automatically be split; 172 into subbranches, with one subbranch for each data member or object; 173 of the object itself. In case the object member is a TClonesArray,; 174 it is processed as a TObject*, only one branch.; 175 ; 176Another available syntax is the following:; 177 ; 178~~~ {.cpp}; 179 auto branch = tree.Branch(branchname, &p_object, bufsize, splitlevel); 180 auto branch = tree.Branch(branchname, className, &p_object, bufsize, splitlevel); 181~~~; 182- p_object is a pointer to an object.; 183- If className is not specified, Branch uses the type of p_object to determine the; 184 type of the object.; 185- If className is used to specify explicitly the object type, the className must; 186 be of a type related to the one pointed to by the pointer. It should be either; 187 a parent or derived class.; 188 ; 189Note: The pointer whose address is passed to TTree::Branch must not; 190 be destroyed (i.e. go out of scope) until the TTree is deleted or; 191 TTree::ResetBranchAddress is called.; 192 ; 193Note: The pointer p_object must be initialized before calling TTree::Branch; 194- Do either:; 195~~~ {.cpp}; 196 MyDataClass* p_object = nullptr;; 197 tree.Branch(branchname, &p_object);; 198~~~; 199- Or:; 200~~~ {.cpp}; 201 auto p_obj",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38038,Availability,error,error,38038,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38453,Availability,avail,available,38453,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38628,Availability,avail,available,38628,"tBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38808,Availability,avail,available,38808," 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TF",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39246,Availability,error,error,39246,"e. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39757,Availability,avail,available,39757,"e. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39932,Availability,avail,available,39932,";; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40112,Availability,avail,available,40112,"94///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40638,Availability,error,error,40638,"eturn -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 11",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41065,Availability,avail,available,41065,"eturn -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 11",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41247,Availability,avail,available,41247,"}; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41434,Availability,avail,available,41434,"ll the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41888,Availability,error,error,41888,"e"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42416,Availability,avail,available,42416,"e"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42598,Availability,avail,available,42598,"ch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClone",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42785,Availability,avail,available,42785,"cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClones->Add(clone);; 1234 }; 1235}; 1236 ; 1237// Check whether mainTree and friendTree can be friends w.r.t. the kEntriesReshuffled bit.; 1238// In particular, if any has the bit set, then friendTree must have a TTreeIndex and the; 1239// branches used for indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false ot",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:53361,Availability,recover,recovered,53361," buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of b",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:53453,Availability,recover,recovered,53453," bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process an",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:54345,Availability,error,error,54345,"cally recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1482/// ~~~; 1483/// script treer.C:; 1484/// ~~~ {.cpp}; 1485/// void treer() {; 1486/// TFile f(""test.root"");; 1487/// TTree *ntuple = (TTree*)f.Get(""ntuple"");; 1488/// TCanvas c1;; 1489/// Int_t first = 0;; 149",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:57128,Availability,error,error,57128,"""AutoSave"", ""calling FlushBaskets \n"");; 1512 FlushBasketsImpl();; 1513 }; 1514 ; 1515 fSavedBytes = GetZipBytes();; 1516 ; 1517 TKey *key = (TKey*)fDirectory->GetListOfKeys()->FindObject(GetName());; 1518 Long64_t nbytes;; 1519 if (opt.Contains(""overwrite"")) {; 1520 nbytes = fDirectory->WriteTObject(this,"""",""overwrite"");; 1521 } else {; 1522 nbytes = fDirectory->WriteTObject(this); //nbytes will be 0 if Write failed (disk space exceeded); 1523 if (nbytes && key && strcmp(ClassName(), key->GetClassName()) == 0) {; 1524 key->Delete();; 1525 delete key;; 1526 }; 1527 }; 1528 // save StreamerInfo; 1529 TFile *file = fDirectory->GetFile();; 1530 if (file) file->WriteStreamerInfo();; 1531 ; 1532 if (opt.Contains(""saveself"")) {; 1533 fDirectory->SaveSelf();; 1534 //the following line is required in case GetUserInfo contains a user class; 1535 //for which the StreamerInfo must be written. One could probably be a bit faster (Rene); 1536 if (file) file->WriteHeader();; 1537 }; 1538 ; 1539 return nbytes;; 1540}; 1541 ; 1542namespace {; 1543 // This error message is repeated several times in the code. We write it once.; 1544 const char* writeStlWithoutProxyMsg = ""The class requested (%s) for the branch \""%s\""""; 1545 "" is an instance of an stl collection and does not have a compiled CollectionProxy.""; 1546 "" Please generate the dictionary for this collection (%s) to avoid to write corrupted data."";; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Same as TTree::Branch() with added check that addobj matches className.; 1551///; 1552/// \see TTree::Branch() for other details.; 1553///; 1554 ; 1555TBranch* TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1556{; 1557 TClass* claim = TClass::GetClass(classname);; 1558 if (!ptrClass) {; 1559 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionPr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:60949,Availability,down,down,60949,"plitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1615 branchname, ptrClass->GetName());; 1616 actualClass = ptrClass;; 1617 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1618 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1619 return nullptr;; 1620 }; 1621 } else {; 1622 actualClass = ptrClass;; 1623 }; 1624 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1625 Error(""Branch"", writeStlWithoutProxyMsg,; 1626 actualClass->GetName(), branchname, actualClass->GetName());; 1627 return nullptr;; 1628 }; 1629 return Branch(branchname, actualClass->GetName(), (void*) addobj, bufsize, splitlevel);; 1630}; 1631 ; 1632////////////////////////////////////////////////////////////////////////////////; 1633/// Same as TTree::Branch but automatic detection of the class name.; 1634/// \see TTree::Branch for other details.; 1635 ; 1636TBranch* TTree::BranchImpRef(const char* branchname, const char *classname, TClass* ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); 1637{; 1638 TClass* claim = TClass::GetClass(classname);; 1639 if (!ptrClass) {; 1640 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1641 Error(""Branch"", writeStlWithoutProxyMsg,; 1642 claim->GetName(), branch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:64455,Availability,down,down,64455," C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 retur",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:66442,Availability,down,down,66442," object (for branch: %s)!"", branchname);; 1710 return nullptr;; 1711 }; 1712 actualClass = ptrClass->GetActualClass(addobj);; 1713 if (!actualClass) {; 1714 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1715 branchname, ptrClass->GetName());; 1716 actualClass = ptrClass;; 1717 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1718 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1719 return nullptr;; 1720 }; 1721 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1722 Error(""Branch"", writeStlWithoutProxyMsg,; 1723 actualClass->GetName(), branchname, actualClass->GetName());; 1724 return nullptr;; 1725 }; 1726 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1727}; 1728 ; 1729////////////////////////////////////////////////////////////////////////////////; 1730// Wrapper to turn Branch call with an std::array into the relevant leaf list; 1731// call; 1732TBranch *TTree::BranchImpArr(const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize,; 1733 Int_t /* splitlevel */); 1734{; 1735 if (datatype == kOther_t || datatype == kNoType_t) {; 1736 Error(""Branch"",; 1737 ""The inner type of the std::array passed specified for %s is not of a class or type known to ROOT"",; 1738 branchname);; 1739 } else {; 1740 TString varname;; 1741 varname.Form(""%s[%d]/%c"", branchname, (int)N, DataTypeToChar(datatype));; 1742 return Branch(branchname, addobj, varname.Data(), bufsize);; 1743 }; 1744 return nullptr;; 1745}; 1746 ; 1747////////////////////////////////////////////////////////////////////////////////; 1748/// Deprecated f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:80965,Availability,avail,available,80965,"splitlevel=0 when the class; 2017/// has a custom Streamer; 2018///; 2019/// Note: if the split level is set to the default (99), TTree::Branch will; 2020/// not issue a warning if the class can not be split.; 2021 ; 2022TBranch* TTree::Branch(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2023{; 2024 if (fgBranchStyle == 1) {; 2025 return Bronch(name, classname, addobj, bufsize, splitlevel);; 2026 } else {; 2027 if (splitlevel < 0) {; 2028 splitlevel = 0;; 2029 }; 2030 return BranchOld(name, classname, addobj, bufsize, splitlevel);; 2031 }; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// Create a new TTree BranchObject.; 2036///; 2037/// Build a TBranchObject for an object of class classname.; 2038/// addobj is the address of a pointer to an object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referen",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:89985,Availability,error,error,89985,";; 2239 }; 2240 nexti.Reset();; 2241 while ((rdi = (TRealData*) nexti())) {; 2242 if (rdi->TestBit(TRealData::kTransient)) continue;; 2243 ; 2244 if (!strcmp(rdi->GetName(), index)) {; 2245 break;; 2246 }; 2247 if (!strcmp(rdi->GetName(), aindex)) {; 2248 index = rdi->GetName();; 2249 break;; 2250 }; 2251 }; 2252 ; 2253 char vcode = DataTypeToChar((EDataType)code);; 2254 // Note that we differentiate between strings and; 2255 // char array by the fact that there is NO specified; 2256 // size for a string (see next if (code == 1); 2257 ; 2258 if (vcode) {; 2259 leaflist.Form(""%s[%s]/%c"", &rdname[0], index, vcode);; 2260 } else {; 2261 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2262 leaflist = """";; 2263 }; 2264 } else {; 2265 // We are possibly a character string.; 2266 if (code == 1) {; 2267 // We are a character string.; 2268 leaflist.Form(""%s/%s"", dname, ""C"");; 2269 } else {; 2270 // Invalid array specification.; 2271 // FIXME: We need an error message here.; 2272 continue;; 2273 }; 2274 }; 2275 // There are '*' in both the branchname and leaflist, remove them.; 2276 TString bname( branchname );; 2277 bname.ReplaceAll(""*"","""");; 2278 leaflist.ReplaceAll(""*"","""");; 2279 // Add the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, bra",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:91220,Availability,error,error,91220," the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, branchname, pointer, leaflist, bufsize);; 2298 branch1->SetTitle(rdname);; 2299 blist->Add(branch1);; 2300 } else {; 2301 // We have a class type.; 2302 // Note: This cannot happen due to the rd->IsObject() test above.; 2303 // FIXME: Put an error message here just in case.; 2304 }; 2305 if (branch1) {; 2306 branch1->SetOffset(offset);; 2307 } else {; 2308 Warning(""BranchOld"", ""Cannot process member: '%s'"", rdname);; 2309 }; 2310 }; 2311 if (delobj) {; 2312 delete obj;; 2313 obj = nullptr;; 2314 }; 2315 return branch;; 2316}; 2317 ; 2318////////////////////////////////////////////////////////////////////////////////; 2319/// Build the optional branch supporting the TRefTable.; 2320/// This branch will keep all the information to find the branches; 2321/// containing referenced objects.; 2322///; 2323/// At each Tree::Fill, the branch numbers containing the; 2324/// referenced objects are saved to the TBranchRef basket.; 2325/// When the Tree header is saved (via TTree::Write), the branch; 2326/// is saved keeping the information with the pointers to the branches; 2327/// having referenced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRef) {; 2332 fBranchRef = new TBranchRef(this);; 2333 }; 2334 retu",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:93539,Availability,avail,available,93539,"anch (whose implementation; 2344/// has been moved to BranchOld).; 2345///; 2346/// NOTE: The 'Bronch' method supports only one possible calls; 2347/// signature (where the object type has to be specified; 2348/// explicitly and the address must be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more me",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:103545,Availability,failure,failure,103545,"/o buffer.; 2591 //; 2592 ; 2593 if (isptrptr) {; 2594 branch->SetAddress(addr);; 2595 } else {; 2596 branch->SetObject(addr);; 2597 }; 2598 ; 2599 if (delobj) {; 2600 cl->Destructor(objptr);; 2601 objptr = nullptr;; 2602 }; 2603 ; 2604 return branch;; 2605}; 2606 ; 2607////////////////////////////////////////////////////////////////////////////////; 2608/// Browse content of the TTree.; 2609 ; 2610void TTree::Browse(TBrowser* b); 2611{; 2612 fBranches.Browse(b);; 2613 if (fUserInfo) {; 2614 if (strcmp(""TList"",fUserInfo->GetName())==0) {; 2615 fUserInfo->SetName(""UserInfo"");; 2616 b->Add(fUserInfo);; 2617 fUserInfo->SetName(""TList"");; 2618 } else {; 2619 b->Add(fUserInfo);; 2620 }; 2621 }; 2622}; 2623 ; 2624////////////////////////////////////////////////////////////////////////////////; 2625/// Build a Tree Index (default is TTreeIndex).; 2626/// See a description of the parameters and functionality in; 2627/// TTreeIndex::TTreeIndex().; 2628///; 2629/// The return value is the number of entries in the Index (< 0 indicates failure).; 2630///; 2631/// A TTreeIndex object pointed by fTreeIndex is created.; 2632/// This object will be automatically deleted by the TTree destructor.; 2633/// If an index is already existing, this is replaced by the new one without being; 2634/// deleted. This behaviour prevents the deletion of a previously external index; 2635/// assigned to the TTree via the TTree::SetTreeIndex() method.; 2636/// \see also comments in TTree::SetTreeIndex().; 2637 ; 2638Int_t TTree::BuildIndex(const char* majorname, const char* minorname /* = ""0"" */); 2639{; 2640 fTreeIndex = GetPlayer()->BuildIndex(this, majorname, minorname);; 2641 if (fTreeIndex->IsZombie()) {; 2642 delete fTreeIndex;; 2643 fTreeIndex = nullptr;; 2644 return 0;; 2645 }; 2646 return fTreeIndex->GetN();; 2647}; 2648 ; 2649////////////////////////////////////////////////////////////////////////////////; 2650/// Build StreamerInfo for class cl.; 2651/// pointer is an optional argument tha",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:112004,Availability,error,error,112004,"tFile(newfile);; 2832 }; 2833 continue;; 2834 }; 2835 // Not a TH1 or a TTree, move object to new file.; 2836 if (newfile) newfile->Append(obj);; 2837 file->Remove(obj);; 2838 }; 2839 file->TObject::Delete();; 2840 file = nullptr;; 2841 delete[] fname;; 2842 fname = nullptr;; 2843 return newfile;; 2844}; 2845 ; 2846////////////////////////////////////////////////////////////////////////////////; 2847/// Check whether or not the address described by the last 3 parameters; 2848/// matches the content of the branch. If a Data Model Evolution conversion; 2849/// is involved, reset the fInfo of the branch.; 2850/// The return values are:; 2851//; 2852/// - kMissingBranch (-5) : Missing branch; 2853/// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); 2854/// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:112772,Availability,avail,available,112772," content of the branch. If a Data Model Evolution conversion; 2849/// is involved, reset the fInfo of the branch.; 2850/// The return values are:; 2851//; 2852/// - kMissingBranch (-5) : Missing branch; 2853/// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); 2854/// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been iss",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:113201,Availability,mask,masked,113201," : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 2887 }; 2888 if (expectedClass && expectedClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(expectedClass->GetCollectionProxy())) {; 2889 Error(""SetBranchAddress"", ""Unable to determine the type given for",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:126293,Availability,error,error,126293," in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAddress().; 3173 TObjArray* branches = newtree->GetListOfBranches();; 3174 Int_t nb = branches->GetEntriesFast();; 3175 for (Int_t i = 0; i < nb; ++i) {; 3176 TBranch* br = (TBranch*) branches->UncheckedAt(i);; 3177 if (br->InheritsFrom(TBranchElement::Class())) {; 3178 ((TBranchElement*) br)->ResetDeleteObject();; 3179 }; 3180 }; 3181 ; 31",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:151026,Availability,error,error,151026,"814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 3833 b->UpdateFile();; 3834 }; 3835 if (fBranchRef) {; 3836 fBranchRef->UpdateFile();; 3837 }; 3838 if (fDirectory) fDirectory->Append(this);; 3839}; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Draw expression varexp for specified entries.; 3843///; 3844/// \return -1 in case of error or number of selected events in case of success.; 3845///; 3846/// This function accepts TCut objects as arguments.; 3847/// Useful to use the string operator +; 3848///; 3849/// Example:; 3850///; 3851/// ~~~ {.cpp}; 3852/// ntuple.Draw(""x"",cut1+cut2+cut3);; 3853/// ~~~; 3854 ; 3855 ; 3856Long64_t TTree::Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 3857{; 3858 return TTree::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 3859}; 3860 ; 3861/////////////////////////////////////////////////////////////////////////////////////////; 3862/// \brief Draw expression varexp for entries and objects that pass a (optional) selection.; 3863///; 3864/// \return -1 in case of error or number of selected events in case of success.; 3865///; 3866/// \param [in] varexp; 3867/// \parblock; 3868/// A string that takes one of these general forms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:151784,Availability,error,error,151784,"f (fDirectory) fDirectory->Append(this);; 3839}; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Draw expression varexp for specified entries.; 3843///; 3844/// \return -1 in case of error or number of selected events in case of success.; 3845///; 3846/// This function accepts TCut objects as arguments.; 3847/// Useful to use the string operator +; 3848///; 3849/// Example:; 3850///; 3851/// ~~~ {.cpp}; 3852/// ntuple.Draw(""x"",cut1+cut2+cut3);; 3853/// ~~~; 3854 ; 3855 ; 3856Long64_t TTree::Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 3857{; 3858 return TTree::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 3859}; 3860 ; 3861/////////////////////////////////////////////////////////////////////////////////////////; 3862/// \brief Draw expression varexp for entries and objects that pass a (optional) selection.; 3863///; 3864/// \return -1 in case of error or number of selected events in case of success.; 3865///; 3866/// \param [in] varexp; 3867/// \parblock; 3868/// A string that takes one of these general forms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; 3871/// on the y-axis versus ""e2"" on the x-axis; 3872/// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3873/// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; 3874/// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3875/// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; 3876/// (to create histograms in the 2, 3, and 4 dimensional case,; 3877/// see section ""Saving the result of Draw to an histogram""); 3878/// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; 3879/// - Any number of variables no fewer than two can be used with the options ""CAND",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:170211,Availability,avail,available,170211,"ith: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:172634,Availability,avail,available,172634,"n use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:173115,Availability,avail,available,173115,"ion with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter sele",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:173493,Availability,error,error,173493,"4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn;",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:174024,Availability,error,error,174024,"array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that optio",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:174820,Availability,error,error,174820,"/; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying th",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:175183,Availability,error,error,175183,"ption=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying the current selection.; 4354/// If option ""entrylist"" is used, a TEntryList object is created; 4355/// If the selection contains arrays, vectors or any container class and option; 4356/// ""entrylistarray"" is used, a TEntryListArray object is created; 4357/// containing also the subentries satisfying the selection, i.e. the indices of; 4358/// the branches which h",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:185324,Availability,error,error,185324,"0 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and A",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:186206,Availability,recover,recoverable,186206,"r of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and Auto Save can be made based either on the number; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:187965,Availability,error,error,187965,"/ file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4609 Int_t nbranches = fBranches.GetEntriesFast();; 4610 ; 4611 // Case of one single super branch. Automatically update; 4612 // all the branch addresses if a new object was created.; 4613 if (nbranches == 1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:188401,Availability,error,error,188401,"1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4656 ++nerror;; 4657 } else {; 4658 nbytes += nwrite;; 4659 }; 4660 }; 4661 ; 4662#ifdef R__USE_IMT; 4663 if (fIMTFlush) {; 4664 imtHelper.Wait();; 4665 fIMTFlush = false;; 4666 const_cast<TTree *>(this)->AddTotBytes(fIMTTotBytes);; 4667 const_cast<TTree *>(this)->AddZipBytes(fIMTZipBytes);; 4668 nbytes += imtHelper.GetNbytes();; 4669 nerror += imtHelper.GetNerrors();; 4670 }; 4671#endif; 4672 ; 4673 if (fBranchRef); 4674 fBranchRef->Fill();; 4675 ; 4676 ++fEntries;; 4677 ; 4678 if (fEntries > fMaxEntries); 4679 KeepCircular();; 4680 ; 4681 if (gD",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:205525,Availability,error,error,205525," say the caller holds mutex A and calls FlushBaskets; while; 5110/// TBB is waiting for the ROOT compression tasks to complete, it may decide to; 5111/// run another one of the user's tasks in this thread. If the second user task; 5112/// tries to acquire A, then a deadlock will occur. The example call sequence; 5113/// looks like this:; 5114///; 5115/// - User acquires mutex A; 5116/// - User calls FlushBaskets.; 5117/// - ROOT launches N tasks and calls wait.; 5118/// - TBB schedules another user task, T2.; 5119/// - T2 tries to acquire mutex A.; 5120///; 5121/// At this point, the thread will deadlock: the code may function with IMT-mode; 5122/// disabled if the user assumed the legacy code never would run their own TBB; 5123/// tasks.; 5124///; 5125/// SO: users of TBB who want to enable IMT-mode should carefully review their; 5126/// locking patterns and make sure they hold no coarse-grained application; 5127/// locks when they invoke ROOT.; 5128///; 5129/// Return the number of bytes written or -1 in case of write error.; 5130Int_t TTree::FlushBaskets(bool create_cluster) const; 5131{; 5132 Int_t retval = FlushBasketsImpl();; 5133 if (retval == -1) return retval;; 5134 ; 5135 if (create_cluster) const_cast<TTree *>(this)->MarkEventCluster();; 5136 return retval;; 5137}; 5138 ; 5139////////////////////////////////////////////////////////////////////////////////; 5140/// Internal implementation of the FlushBaskets algorithm.; 5141/// Unlike the public interface, this does NOT create an explicit event cluster; 5142/// boundary; it is up to the (internal) caller to determine whether that should; 5143/// done.; 5144///; 5145/// Otherwise, the comments for FlushBaskets applies.; 5146///; 5147Int_t TTree::FlushBasketsImpl() const; 5148{; 5149 if (!fDirectory) return 0;; 5150 Int_t nbytes = 0;; 5151 Int_t nerror = 0;; 5152 TObjArray *lb = const_cast<TTree*>(this)->GetListOfBranches();; 5153 Int_t nb = lb->GetEntriesFast();; 5154 ; 5155#ifdef R__USE_IMT; 5156 const auto",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:217163,Availability,error,errors,217163,"->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476 ; 5477////////////////////////////////////////////////////////////////////////////////; 5478/// Return pointer to the current file.; 5479 ; 5480TFile* TTree::GetCurrentFile() const; 5481{; 5482 if (!fDirectory || fDirectory==gROOT) {; 5483 return nullptr;; 5484 }; 5485 return fDirectory->GetFile();; 5486}; 5487 ; 5488////////////////////////////////////////////////////////////////////////////////; 5489/// Return the number of entries matching the selection.; 5490/// Return -1 in case of errors.; 5491///; 5492/// If the selection uses any arrays or containers, we return the number; 5493/// of entries where at least one element match the selection.; 5494/// GetEntries is implemented using the selector class TSelectorEntries,; 5495/// which can be used directly (see code in TTreePlayer::GetEntries) for; 5496/// additional option.; 5497/// If SetEventList was used on the TTree or TChain, only that subset; 5498/// of entries will be considered.; 5499 ; 5500Long64_t TTree::GetEntries(const char *selection); 5501{; 5502 GetPlayer();; 5503 if (fPlayer) {; 5504 return fPlayer->GetEntries(selection);; 5505 }; 5506 return -1;; 5507}; 5508 ; 5509////////////////////////////////////////////////////////////////////////////////; 5510/// Return pointer to the 1st Leaf named name in any Branch of this Tree or; 5511/// any branch in the list of friend trees.; 5512 ; 5513Long64_t TTree::GetEntriesFriend() const; 5514{; 5515 if (fEntries) return fEntries;; 5516 if (!fFriends)",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:218789,Availability,error,error,218789,"n -1;; 5507}; 5508 ; 5509////////////////////////////////////////////////////////////////////////////////; 5510/// Return pointer to the 1st Leaf named name in any Branch of this Tree or; 5511/// any branch in the list of friend trees.; 5512 ; 5513Long64_t TTree::GetEntriesFriend() const; 5514{; 5515 if (fEntries) return fEntries;; 5516 if (!fFriends) return 0;; 5517 TFriendElement *fr = (TFriendElement*)fFriends->At(0);; 5518 if (!fr) return 0;; 5519 TTree *t = fr->GetTree();; 5520 if (t==nullptr) return 0;; 5521 return t->GetEntriesFriend();; 5522}; 5523 ; 5524////////////////////////////////////////////////////////////////////////////////; 5525/// Read all branches of entry and return total number of bytes read.; 5526///; 5527/// - `getall = 0` : get only active branches; 5528/// - `getall = 1` : get all branches; 5529///; 5530/// The function returns the number of bytes read from the input buffer.; 5531/// If entry does not exist the function returns 0.; 5532/// If an I/O error occurs, the function returns -1.; 5533///; 5534/// If the Tree has friends, also read the friends entry.; 5535///; 5536/// To activate/deactivate one or more branches, use TBranch::SetBranchStatus; 5537/// For example, if you have a Tree with several hundred branches, and you; 5538/// are interested only by branches named ""a"" and ""b"", do; 5539/// ~~~ {.cpp}; 5540/// mytree.SetBranchStatus(""*"",0); //disable all branches; 5541/// mytree.SetBranchStatus(""a"",1);; 5542/// mytree.SetBranchStatus(""b"",1);; 5543/// ~~~; 5544/// when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; 5545///; 5546/// __WARNING!!__; 5547/// If your Tree has been created in split mode with a parent branch ""parent."",; 5548/// ~~~ {.cpp}; 5549/// mytree.SetBranchStatus(""parent"",1);; 5550/// ~~~; 5551/// will not activate the sub-branches of ""parent"". You should do:; 5552/// ~~~ {.cpp}; 5553/// mytree.SetBranchStatus(""parent*"",1);; 5554/// ~~~; 5555/// Without the trailing dot in the branch creation yo",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:223131,Availability,avail,available,223131," 2; 5605///; 5606/// The option AutoDelete is set; 5607/// ~~~ {.cpp}; 5608/// TBranch *branch = T.GetBranch(""event"");; 5609/// branch->SetAddress(&event);; 5610/// branch->SetAutoDelete(true);; 5611/// for (Long64_t i=0;i<nentries;i++) {; 5612/// T.GetEntry(i);; 5613/// // the object event has been filled at this point; 5614/// }; 5615/// ~~~; 5616/// In this case, at each iteration, the object event is deleted by GetEntry; 5617/// and a new instance of Event is created and filled.; 5618///; 5619/// ## OPTION 3; 5620///; 5621/// ~~~ {.cpp}; 5622/// Same as option 1, but you delete yourself the event.; 5623///; 5624/// for (Long64_t i=0;i<nentries;i++) {; 5625/// delete event;; 5626/// event = 0; // EXTREMELY IMPORTANT; 5627/// T.GetEntry(i);; 5628/// // the object event has been filled at this point; 5629/// }; 5630/// ~~~; 5631/// It is strongly recommended to use the default option 1. It has the; 5632/// additional advantage that functions like TTree::Draw (internally calling; 5633/// TTree::GetEntry) will be functional even when the classes in the file are; 5634/// not available.; 5635///; 5636/// Note: See the comments in TBranchElement::SetAddress() for the; 5637/// object ownership policy of the underlying (user) data.; 5638 ; 5639Int_t TTree::GetEntry(Long64_t entry, Int_t getall); 5640{; 5641 // We already have been visited while recursively looking; 5642 // through the friends tree, let return; 5643 if (kGetEntry & fFriendLockStatus) return 0;; 5644 ; 5645 if (entry < 0 || entry >= fEntries) return 0;; 5646 Int_t i;; 5647 Int_t nbytes = 0;; 5648 fReadEntry = entry;; 5649 ; 5650 // create cache if wanted; 5651 if (fCacheDoAutoInit); 5652 SetCacheSizeAux();; 5653 ; 5654 Int_t nbranches = fBranches.GetEntriesUnsafe();; 5655 Int_t nb=0;; 5656 ; 5657 auto seqprocessing = [&]() {; 5658 TBranch *branch;; 5659 for (i=0;i<nbranches;i++) {; 5660 branch = (TBranch*)fBranches.UncheckedAt(i);; 5661 nb = branch->GetEntry(entry, getall);; 5662 if (nb < 0) break;; 5663 nb",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:251996,Availability,error,error,251996," (fMaxEntries / 10);; 6420 for (Int_t i = 0; i < nb; ++i) {; 6421 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 6422 branch->KeepCircular(maxEntries);; 6423 }; 6424 if (fNClusterRange) {; 6425 Long64_t entriesOffset = fEntries - maxEntries;; 6426 Int_t oldsize = fNClusterRange;; 6427 for(Int_t i = 0, j = 0; j < oldsize; ++j) {; 6428 if (fClusterRangeEnd[j] > entriesOffset) {; 6429 fClusterRangeEnd[i] = fClusterRangeEnd[j] - entriesOffset;; 6430 ++i;; 6431 } else {; 6432 --fNClusterRange;; 6433 }; 6434 }; 6435 }; 6436 fEntries = maxEntries;; 6437 fReadEntry = -1;; 6438}; 6439 ; 6440////////////////////////////////////////////////////////////////////////////////; 6441/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; 6442///; 6443/// If maxmemory is non null and positive SetMaxVirtualSize is called; 6444/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:252862,Availability,error,error,252862," Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:261294,Availability,error,errors,261294," point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) hte",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:261379,Availability,avail,available,261379," point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) hte",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262374,Availability,avail,available,262374," a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1anal",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:264631,Availability,avail,available,264631,"P, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofilename, const char* cutfilename, const char* option, Int_t maxUnrolling); 6770{; 6771 GetPlayer();; 6772 if (!fPlayer) return 0;; 6773 return fPlayer->MakeProxy(proxyClassname,macrofilename,cutfilename,option,maxUnrolling);; 6774}; 6775 ; 6776////////////////////////////////////////////////////////////////////////////////; 6777/// Generate skeleton selector class for this tree.; 6778///; 6779/// The following files are produced: selector.h and selector.C.; 6780/// If selector is 0, the selector will be called ""nameoftree"".; 6781/// The option can be used to specify the branches that will have a data member.; 6782/// - If option is ""=legacy"", a pre-ROOT6 selector will be generated (data; 6783/// members and branch pointers instead of TTreeRe",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:290012,Availability,error,error,290012,"->GetTree();; 7356 if (t) t->Print(option);; 7357 }; 7358}; 7359 ; 7360////////////////////////////////////////////////////////////////////////////////; 7361/// Print statistics about the TreeCache for this tree.; 7362/// Like:; 7363/// ~~~ {.cpp}; 7364/// ******TreeCache statistics for file: cms2.root ******; 7365/// Reading 73921562 bytes in 716 transactions; 7366/// Average transaction = 103.242405 Kbytes; 7367/// Number of blocks in current cache: 202, total size : 6001193; 7368/// ~~~; 7369/// if option = ""a"" the list of blocks in the cache is printed; 7370 ; 7371void TTree::PrintCacheStats(Option_t* option) const; 7372{; 7373 TFile *f = GetCurrentFile();; 7374 if (!f) return;; 7375 TTreeCache *tc = GetReadCache(f);; 7376 if (tc) tc->Print(option);; 7377}; 7378 ; 7379////////////////////////////////////////////////////////////////////////////////; 7380/// Process this tree executing the TSelector code in the specified filename.; 7381/// The return value is -1 in case of error and TSelector::GetStatus() in; 7382/// in case of success.; 7383///; 7384/// The code in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:293329,Availability,error,error,293329,"= (TTree*)f2->Get(""h1"");; 7433/// h2->Process(selector);; 7434/// }; 7435/// ~~~; 7436/// or use ACLIC to compile the selector; 7437///; 7438/// ### Workaround 2; 7439///; 7440/// ~~~ {.cpp}; 7441/// void stubs2() {; 7442/// TFile *f1 = new TFile(""stubs_nood_le1.root"");; 7443/// TTree *h1 = (TTree*)f1->Get(""h1"");; 7444/// h1->Process(""h1test.C+"");; 7445/// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; 7446/// TTree *h2 = (TTree*)f2->Get(""h1"");; 7447/// h2->Process(""h1test.C+"");; 7448/// }; 7449/// ~~~; 7450 ; 7451Long64_t TTree::Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); 7452{; 7453 GetPlayer();; 7454 if (fPlayer) {; 7455 return fPlayer->Process(filename, option, nentries, firstentry);; 7456 }; 7457 return -1;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Process this tree executing the code in the specified selector.; 7462/// The return value is -1 in case of error and TSelector::GetStatus() in; 7463/// in case of success.; 7464///; 7465/// The TSelector class has the following member functions:; 7466///; 7467/// - `Begin()`: called every time a loop on the tree starts,; 7468/// a convenient place to create your histograms.; 7469/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7470/// slave servers.; 7471/// - `Process()`: called for each event, in this function you decide what; 7472/// to read and fill your histograms.; 7473/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7474/// called only on the slave servers.; 7475/// - `Terminate()`: called at the end of the loop on the tree,; 7476/// a convenient place to draw/fit your histograms.; 7477///; 7478/// If the Tree (Chain) has an associated EventList, the loop is on the nentries; 7479/// of the EventList, starting at firstentry, otherwise the loop is on the; 7480/// specified Tree entries.; 7481 ; 7482Long64_t TTree::Process(TSelector* s",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:306502,Availability,error,error,306502,"eafLen = 1;; 7798 }; 7799 ; 7800 leafData = tok;; 7801 } else {; 7802 // append token to laf data:; 7803 leafData += "" "";; 7804 leafData += tok;; 7805 }; 7806 --remainingLeafLen;; 7807 if (remainingLeafLen) {; 7808 // need more columns for this branch:; 7809 continue;; 7810 }; 7811 ++iBranch;; 7812 ; 7813 // initialize stringstream with token; 7814 sToken.clear();; 7815 sToken.seekp(0, std::ios_base::beg);; 7816 sToken.str(leafData.Data());; 7817 sToken.seekg(0, std::ios_base::beg);; 7818 leaf->ReadValue(sToken, 0 /* 0 = ""all"" */);; 7819 if (gDebug > 3) {; 7820 Info(""ReadStream"", ""%5lld:%3d:%d%d%d%d:%d%d%d%d:%s"",; 7821 nlines, iBranch,; 7822 (int)sToken.good(), (int)sToken.fail(),; 7823 (int)sToken.bad(), (int)sToken.eof(),; 7824 (int)in.good(), (int)in.fail(),; 7825 (int)in.bad(), (int)in.eof(),; 7826 sToken.str().c_str());; 7827 }; 7828 ; 7829 // Error handling; 7830 if (sToken.bad()) {; 7831 // How could that happen for a stringstream?; 7832 Warning(""ReadStream"",; 7833 ""Buffer error while reading data for branch %s on line %lld"",; 7834 branch->GetName(), nlines);; 7835 } else if (!sToken.eof()) {; 7836 if (sToken.fail()) {; 7837 Warning(""ReadStream"",; 7838 ""Couldn't read formatted data in \""%s\"" for branch %s on line %lld; ignoring line"",; 7839 tok.Data(), branch->GetName(), nlines);; 7840 goodLine = false;; 7841 } else {; 7842 std::string remainder;; 7843 std::getline(sToken, remainder, newline);; 7844 if (!remainder.empty()) {; 7845 Warning(""ReadStream"",; 7846 ""Ignoring trailing \""%s\"" while reading data for branch %s on line %lld"",; 7847 remainder.c_str(), branch->GetName(), nlines);; 7848 }; 7849 }; 7850 }; 7851 } // tokenizer loop; 7852 ; 7853 if (iBranch < nbranches) {; 7854 Warning(""ReadStream"",; 7855 ""Read too few columns (%d < %d) in line %lld; ignoring line"",; 7856 iBranch, nbranches, nlines);; 7857 goodLine = false;; 7858 } else if (pos != kNPOS) {; 7859 sLine = sLine.Strip(TString::kTrailing);; 7860 if (pos < sLine.Length()) {; 7861 Warning(""ReadStream",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:324939,Availability,recover,recover,324939,"erSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fClusterSize[i];; 8314 R__ASSERT(size >= 0);; 8315 if (fClusterSize[i] == 0); 8316 continue;; 8317 const auto nClusters = (1 + fClusterRangeEnd[i] - clusterRangeStart) / fClusterSize[i];; 8318 nClustersInRange.emplace_back(nClusters);; 8319 clusterRangeStart = fClusterRangeEnd[i] + 1;; 8320 }; 8321 ; 8322 R__ASSERT(nClustersInRange.size() == clusterSizesPerRange.size());; 8323 const auto medianClusterSize =; 8324 TMath::Median(nClustersInRange.size(), clusterSizesPerRange.data(), nClustersInRange.data());; 8325 return medianClusterSize;; 8326}; 8327 ; 8328////////////////////////////////////////////////////////////////////////////////; 8329/// In case of a program crash, it will be possible to recover the data in the; 8330/// tree up to the last AutoSave point.; 8331/// This function may be called before filling a TTree to specify when the; 8332/// branch buffers and TTree header are flushed to disk as part of; 8333/// TTree::Fill().; 8334/// The default is -300000000, ie the TTree will write data to disk once it; 8335/// exceeds 300 MBytes.; 8336/// CASE 1: If fAutoSave is positive the watermark is reached when a multiple of; 8337/// fAutoSave entries have been filled.; 8338/// CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave; 8339/// bytes can be written to the file.; 8340/// CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically; 8341/// as part of TTree::Fill().; 8342 ; 8343void TTree::SetAutoSave(Long64_t autos); 8344{; 8345 fAutoSave = autos;; 8346}; 8347 ; 8348////////////////////////////////////////////////////////////////////////////////; 8349/// Set a branch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:333245,Availability,error,error,333245,"ranch is prefixed to the sub-branches'; 8508/// name (by adding a dot ('.') at the end of the Branch creation and use the; 8509/// corresponding bname.; 8510///; 8511/// I.e If your Tree has been created in split mode with a parent branch ""parent.""; 8512/// (note the trailing dot).; 8513/// ~~~ {.cpp}; 8514/// T.SetBranchStatus(""parent"",1);; 8515/// ~~~; 8516/// will not activate the sub-branches of ""parent"". You should do:; 8517/// ~~~ {.cpp}; 8518/// T.SetBranchStatus(""parent*"",1);; 8519/// ~~~; 8520/// Without the trailing dot in the branch creation you have no choice but to; 8521/// call SetBranchStatus explicitly for each of the sub branches.; 8522///; 8523/// An alternative to this function is to read directly and only; 8524/// the interesting branches. Example:; 8525/// ~~~ {.cpp}; 8526/// TBranch *brc = T.GetBranch(""c"");; 8527/// TBranch *bre = T.GetBranch(""e"");; 8528/// brc->GetEntry(i);; 8529/// bre->GetEntry(i);; 8530/// ~~~; 8531/// If found is not 0, the number of branch(es) found matching the regular; 8532/// expression is returned in *found AND the error message 'unknown branch'; 8533/// is suppressed.; 8534 ; 8535void TTree::SetBranchStatus(const char* bname, bool status, UInt_t* found); 8536{; 8537 // We already have been visited while recursively looking; 8538 // through the friends tree, let return; 8539 if (kSetBranchStatus & fFriendLockStatus) {; 8540 return;; 8541 }; 8542 ; 8543 if (!bname || !*bname) {; 8544 Error(""SetBranchStatus"", ""Input regexp is an empty string: no match against branch names will be attempted."");; 8545 return;; 8546 }; 8547 ; 8548 TBranch *branch, *bcount, *bson;; 8549 TLeaf *leaf, *leafcount;; 8550 ; 8551 Int_t i,j;; 8552 Int_t nleaves = fLeaves.GetEntriesFast();; 8553 TRegexp re(bname,true);; 8554 Int_t nb = 0;; 8555 ; 8556 // first pass, loop on all branches; 8557 // for leafcount branches activate/deactivate in function of status; 8558 for (i=0;i<nleaves;i++) {; 8559 leaf = (TLeaf*)fLeaves.UncheckedAt(i);; 8560 branch =",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338191,Availability,error,error,338191,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339337,Availability,error,error,339337,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342847,Availability,error,error,342847,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343258,Availability,avail,available,343258,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343433,Availability,avail,available,343433," if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343613,Availability,avail,available,343613," cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:353021,Availability,error,error,353021,"; 9104 ; 9105////////////////////////////////////////////////////////////////////////////////; 9106/// Set number of entries to estimate variable limits.; 9107/// If n is -1, the estimate is set to be the current maximum; 9108/// for the tree (i.e. GetEntries() + 1); 9109/// If n is less than -1, the behavior is undefined.; 9110 ; 9111void TTree::SetEstimate(Long64_t n /* = 1000000 */); 9112{; 9113 if (n == 0) {; 9114 n = 10000;; 9115 } else if (n < 0) {; 9116 n = fEntries - n;; 9117 }; 9118 fEstimate = n;; 9119 GetPlayer();; 9120 if (fPlayer) {; 9121 fPlayer->SetEstimate(n);; 9122 }; 9123}; 9124 ; 9125////////////////////////////////////////////////////////////////////////////////; 9126/// Provide the end-user with the ability to enable/disable various experimental; 9127/// IO features for this TTree.; 9128///; 9129/// Returns all the newly-set IO settings.; 9130 ; 9131ROOT::TIOFeatures TTree::SetIOFeatures(const ROOT::TIOFeatures &features); 9132{; 9133 // Purposely ignore all unsupported bits; TIOFeatures implementation already warned the user about the; 9134 // error of their ways; this is just a safety check.; 9135 UChar_t featuresRequested = features.GetFeatures() & static_cast<UChar_t>(TBasket::EIOBits::kSupported);; 9136 ; 9137 UChar_t curFeatures = fIOFeatures.GetFeatures();; 9138 UChar_t newFeatures = ~curFeatures & featuresRequested;; 9139 curFeatures |= newFeatures;; 9140 fIOFeatures.Set(curFeatures);; 9141 ; 9142 ROOT::TIOFeatures newSettings(newFeatures);; 9143 return newSettings;; 9144}; 9145 ; 9146////////////////////////////////////////////////////////////////////////////////; 9147/// Set fFileNumber to number.; 9148/// fFileNumber is used by TTree::Fill to set the file name; 9149/// for a new file to be created when the current file exceeds fgTreeMaxSize.; 9150/// (see TTree::ChangeFile); 9151/// if fFileNumber=10, the new file name will have a suffix ""_11"",; 9152/// ie, fFileNumber is incremented before setting the file name; 9153 ; 9154void TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:362485,Availability,error,error,362485,"nts is printed.; 9385 ; 9386void TTree::Show(Long64_t entry, Int_t lenmax); 9387{; 9388 if (entry != -1) {; 9389 Int_t ret = LoadTree(entry);; 9390 if (ret == -2) {; 9391 Error(""Show()"", ""Cannot read entry %lld (entry does not exist)"", entry);; 9392 return;; 9393 } else if (ret == -1) {; 9394 Error(""Show()"", ""Cannot read entry %lld (I/O error)"", entry);; 9395 return;; 9396 }; 9397 ret = GetEntry(entry);; 9398 if (ret == -1) {; 9399 Error(""Show()"", ""Cannot read entry %lld (I/O error)"", entry);; 9400 return;; 9401 } else if (ret == 0) {; 9402 Error(""Show()"", ""Cannot read entry %lld (no data read)"", entry);; 9403 return;; 9404 }; 9405 }; 9406 printf(""======> EVENT:%lld\n"", fReadEntry);; 9407 TObjArray* leaves = GetListOfLeaves();; 9408 Int_t nleaves = leaves->GetEntriesFast();; 9409 Int_t ltype;; 9410 for (Int_t i = 0; i < nleaves; i++) {; 9411 TLeaf* leaf = (TLeaf*) leaves->UncheckedAt(i);; 9412 TBranch* branch = leaf->GetBranch();; 9413 if (branch->TestBit(kDoNotProcess)) {; 9414 continue;; 9415 }; 9416 Int_t len = leaf->GetLen();; 9417 if (len <= 0) {; 9418 continue;; 9419 }; 9420 len = TMath::Min(len, lenmax);; 9421 if (leaf->IsA() == TLeafElement::Class()) {; 9422 leaf->PrintValue(lenmax);; 9423 continue;; 9424 }; 9425 if (branch->GetListOfBranches()->GetEntriesFast() > 0) {; 9426 continue;; 9427 }; 9428 ltype = 10;; 9429 if (leaf->IsA() == TLeafF::Class()) {; 9430 ltype = 5;; 9431 }; 9432 if (leaf->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:362627,Availability,error,error,362627,"nts is printed.; 9385 ; 9386void TTree::Show(Long64_t entry, Int_t lenmax); 9387{; 9388 if (entry != -1) {; 9389 Int_t ret = LoadTree(entry);; 9390 if (ret == -2) {; 9391 Error(""Show()"", ""Cannot read entry %lld (entry does not exist)"", entry);; 9392 return;; 9393 } else if (ret == -1) {; 9394 Error(""Show()"", ""Cannot read entry %lld (I/O error)"", entry);; 9395 return;; 9396 }; 9397 ret = GetEntry(entry);; 9398 if (ret == -1) {; 9399 Error(""Show()"", ""Cannot read entry %lld (I/O error)"", entry);; 9400 return;; 9401 } else if (ret == 0) {; 9402 Error(""Show()"", ""Cannot read entry %lld (no data read)"", entry);; 9403 return;; 9404 }; 9405 }; 9406 printf(""======> EVENT:%lld\n"", fReadEntry);; 9407 TObjArray* leaves = GetListOfLeaves();; 9408 Int_t nleaves = leaves->GetEntriesFast();; 9409 Int_t ltype;; 9410 for (Int_t i = 0; i < nleaves; i++) {; 9411 TLeaf* leaf = (TLeaf*) leaves->UncheckedAt(i);; 9412 TBranch* branch = leaf->GetBranch();; 9413 if (branch->TestBit(kDoNotProcess)) {; 9414 continue;; 9415 }; 9416 Int_t len = leaf->GetLen();; 9417 if (len <= 0) {; 9418 continue;; 9419 }; 9420 len = TMath::Min(len, lenmax);; 9421 if (leaf->IsA() == TLeafElement::Class()) {; 9422 leaf->PrintValue(lenmax);; 9423 continue;; 9424 }; 9425 if (branch->GetListOfBranches()->GetEntriesFast() > 0) {; 9426 continue;; 9427 }; 9428 ltype = 10;; 9429 if (leaf->IsA() == TLeafF::Class()) {; 9430 ltype = 5;; 9431 }; 9432 if (leaf->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364608,Availability,error,error,364608,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364995,Availability,avail,available,364995,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365178,Availability,avail,available,365178,"Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->In",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365366,Availability,avail,available,365366," 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528//////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:372377,Availability,error,error,372377,"/// For the fit to be meaningful, the function must be self-normalized.; 9679///; 9680/// i.e. It must have the same integral regardless of the parameter; 9681/// settings. Otherwise the fit will effectively just maximize the; 9682/// area.; 9683///; 9684/// It is mandatory to have a normalization variable; 9685/// which is fixed for the fit. e.g.; 9686/// ~~~ {.cpp}; 9687/// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; 9688/// f1->SetParameters(1, 3.1, 0.01);; 9689/// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; 9690/// data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; 9691/// ~~~; 9692/// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; 9693///; 9694/// Return status:; 9695///; 9696/// - The function return the status of the fit in the following form; 9697/// fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; 9698/// - The fitResult is 0 is the fit is OK.; 9699/// - The fitResult is negative in case of an error not connected with the fit.; 9700/// - The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; 9701/// - If the number of selected entries is null the function returns -1; 9702 ; 9703Int_t TTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 9704{; 9705 GetPlayer();; 9706 if (fPlayer) {; 9707 return fPlayer->UnbinnedFit(funcname, varexp, selection, option, nentries, firstentry);; 9708 }; 9709 return -1;; 9710}; 9711 ; 9712////////////////////////////////////////////////////////////////////////////////; 9713/// Replace current attributes by current style.; 9714 ; 9715void TTree::UseCurrentStyle(); 9716{; 9717 if (gStyle->IsReading()) {; 9718 SetFillColor(gStyle->GetHistFillColor());; 9719 SetFillStyle(gStyle->GetHistFillStyle());; 9720 SetLineColor(gStyle->GetHistLineColor());; 9721 SetLineStyle(gStyle->GetHistLineStyle());; 9722 SetLineWidth(gStyle->GetH",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:380830,Availability,error,error,380830,"TDataType.h:30; kchar@ kcharDefinition TDataType.h:31; kLong_t@ kLong_tDefinition TDataType.h:30; kDouble32_t@ kDouble32_tDefinition TDataType.h:31; kShort_t@ kShort_tDefinition TDataType.h:29; kBool_t@ kBool_tDefinition TDataType.h:32; kBits@ kBitsDefinition TDataType.h:34; kULong_t@ kULong_tDefinition TDataType.h:30; kLong64_t@ kLong64_tDefinition TDataType.h:32; kUShort_t@ kUShort_tDefinition TDataType.h:29; kDouble_t@ kDouble_tDefinition TDataType.h:31; kCharStar@ kCharStarDefinition TDataType.h:34; kChar_t@ kChar_tDefinition TDataType.h:29; kUChar_t@ kUChar_tDefinition TDataType.h:29; kCounter@ kCounterDefinition TDataType.h:34; kUInt_t@ kUInt_tDefinition TDataType.h:30; kFloat16_t@ kFloat16_tDefinition TDataType.h:33; kOther_t@ kOther_tDefinition TDataType.h:32; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEmulatedCollectionProxy.h; TEntryList.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TEventList.h; TFileMergeInfo.h; TFile.h; TFolder.h; TFriendElement.h; N#define N; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; SetLineWidthOption_t Option_t SetLineWidthDefinition TGWin32VirtualXProxy.cxx:56; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:380965,Availability,error,error,380965,"rt_t@ kShort_tDefinition TDataType.h:29; kBool_t@ kBool_tDefinition TDataType.h:32; kBits@ kBitsDefinition TDataType.h:34; kULong_t@ kULong_tDefinition TDataType.h:30; kLong64_t@ kLong64_tDefinition TDataType.h:32; kUShort_t@ kUShort_tDefinition TDataType.h:29; kDouble_t@ kDouble_tDefinition TDataType.h:31; kCharStar@ kCharStarDefinition TDataType.h:34; kChar_t@ kChar_tDefinition TDataType.h:29; kUChar_t@ kUChar_tDefinition TDataType.h:29; kCounter@ kCounterDefinition TDataType.h:34; kUInt_t@ kUInt_tDefinition TDataType.h:30; kFloat16_t@ kFloat16_tDefinition TDataType.h:33; kOther_t@ kOther_tDefinition TDataType.h:32; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEmulatedCollectionProxy.h; TEntryList.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TEventList.h; TFileMergeInfo.h; TFile.h; TFolder.h; TFriendElement.h; N#define N; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; SetLineWidthOption_t Option_t SetLineWidthDefinition TGWin32VirtualXProxy.cxx:56; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetCol",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:423017,Availability,error,error,423017,"rns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns na",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:423153,Availability,error,error,423153,"nst char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::GetDataMemberTDataMember * GetDataMember() constDefinition TRealData.h:53; TRealDa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:447232,Availability,recover,recover,447232," IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Pro",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:12146,Deployability,update,update,12146,"h branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingtree; 234## Add a column to an already existing Tree; 235 ; 236You may want to add a branch to an existing tree. For example,; 237if one variable in the tree was computed with a certain algorithm,; 238you may want to try another algorithm and compare the results.; 239One solution is to add a new branch, fill it, and save the tree.; 240The code below adds a simple branch to an existing tree.; 241Note the kOverwrite option in the Write method, it overwrites the; 242existing tree. If it is not specified, two copies of the tree headers; 243are saved.; 244~~~ {.cpp}; 245 void tree3AddBranch() {; 246 TFile f(""tree3.root"", ""update"");; 247 ; 248 Float_t new_v;; 249 auto t3 = f->Get<TTree>(""t3"");; 250 auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; 251 ; 252 Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; 253 ; 254 for (Long64_t i = 0; i < nentries; i++) {; 255 new_v = gRandom->Gaus(0, 1);; 256 newBranch->Fill();; 257 }; 258 ; 259 t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; 260 }; 261~~~; 262It is not always possible to add branches to existing datasets stored in TFiles: for example,; 263these files might not be writeable, just readable. In addition, modifying in place a TTree; 264causes a new TTree instance to be written and the previous one to be deleted.; 265For this reasons, ROOT offers the concept of friends for TTree and TChain:; 266if is good practice to rely on friend trees rather than adding a branch manually.; 267 ; 268\anchor fullexample; 269## An Example; 270 ; 271Begin_Macro; 272../../../tutorials/tree/tree.C; 273End_Macro; 274 ; 275~~~ {.cpp}; 276 // A simple example with histograms and a tree; 277 //; 278 // This program creates :; 279 // - a one dimensional histogram; 280 // - a two dimensional histogram; 281 // - a profile histogram; 282 // - a tree; 283 //; 284 // These objects are filled with some rando",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:34729,Deployability,release,release,34729,"{; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->C",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:35089,Deployability,release,release,35089,"Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 10",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:132612,Deployability,update,updatedLeafCount,132612,"s());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:133770,Deployability,update,updatedLeafCount,133770,"Leaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:133889,Deployability,update,updatedLeafCount,133889,"h) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(;",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:133936,Deployability,update,updatedLeafCount,133936,"; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and outp",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:187350,Deployability,update,update,187350,"mber; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4609 Int_t nbranches = fBranches.GetEntriesFast();; 4610 ; 4611 // Case of one single super branch. Automatically update; 4612 // all the branch addresses if a new object was created.; 4613 if (nbranches == 1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, ent",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214247,Deployability,configurat,configuration,214247,/////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;,MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:254055,Deployability,release,released,254055,"ited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 6520 needUpdate = true;; 6521 fe->ResetUpdated();; 6522 }; 6523 } // for each friend; 6524 }; 6525 if (needUpdate) {; 6526 //update list of leaves in all TTreeFormula of the TTreePlayer (if any); 6527 if (fPlayer) {; 6528 fPlayer->UpdateFormulaLeaves();; 6529 }; 6530 //Notify user if requested; 6531 if (fNotify) {; 6532 if(!fNotify->Notify()) return -6;; 6533 }; 6534 }; 6535 }; 6536 ; 6537 if ((fReadEntry >= fEntries) && !friendHasEntry) {; 6538 fReadEntry = -1;; 6539 return -2;; 6540 }; 6541 return fReadEntry;; 6542}; 6543 ; 6544////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:254771,Deployability,update,update,254771,"s code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 6520 needUpdate = true;; 6521 fe->ResetUpdated();; 6522 }; 6523 } // for each friend; 6524 }; 6525 if (needUpdate) {; 6526 //update list of leaves in all TTreeFormula of the TTreePlayer (if any); 6527 if (fPlayer) {; 6528 fPlayer->UpdateFormulaLeaves();; 6529 }; 6530 //Notify user if requested; 6531 if (fNotify) {; 6532 if(!fNotify->Notify()) return -6;; 6533 }; 6534 }; 6535 }; 6536 ; 6537 if ((fReadEntry >= fEntries) && !friendHasEntry) {; 6538 fReadEntry = -1;; 6539 return -2;; 6540 }; 6541 return fReadEntry;; 6542}; 6543 ; 6544////////////////////////////////////////////////////////////////////////////////; 6545/// Load entry on behalf of our master tree, we may use an index.; 6546///; 6547/// Called by LoadTree() when the masterTree looks for the entry; 6548/// number in a friend tree (us) corresponding to the passed entry; 6549/// number in the masterTree.; 6550///; 6551/// If we have no index, our entry number and the masterTree entry; 6552/// number are the same.; 6553///; 6554/// If we *do* have an index, we must find the (major, minor) value pair; 6555/// in masterTree to locate our corresponding entry.; 6556///; 6557 ; 6558Long64_t TTree::LoadTreeFriend(Long64_t entry, TTree* masterTree); 6559{; 6560 if",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:261596,Deployability,update,updated,261596,"~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:274073,Deployability,update,update,274073," {; 6966 if (tree==this) continue;; 6967 if (!tree->InheritsFrom(TTree::Class())) {; 6968 Error(""Add"",""Attempt to add object of class: %s to a %s"", tree->ClassName(), ClassName());; 6969 fAutoSave = storeAutoSave;; 6970 return -1;; 6971 }; 6972 ; 6973 CopyEntries(tree, -1, options, true);; 6974 }; 6975 fAutoSave = storeAutoSave;; 6976 return GetEntries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980/// Move a cache from a file to the current file in dir.; 6981/// if src is null no operation is done, if dir is null or there is no; 6982/// current file the cache is deleted.; 6983 ; 6984void TTree::MoveReadCache(TFile *src, TDirectory *dir); 6985{; 6986 if (!src) return;; 6987 TFile *dst = (dir && dir != gROOT) ? dir->GetFile() : nullptr;; 6988 if (src == dst) return;; 6989 ; 6990 TTreeCache *pf = GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003////////////////////////////////////////////////////////////////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""just"" does a call to SetDirectory.; 7012/// Equivalent to an ""in place"" cloning of the TTree.; 7013bool TTree::InPlaceClone(TDirectory *newdirectory, const char *options); 7014{; 7015 if (!newdirectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeC",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:308954,Deployability,update,updated,308954,"sure that obj (which is being deleted or will soon be) is no; 7880/// longer referenced by this TTree.; 7881 ; 7882void TTree::RecursiveRemove(TObject *obj); 7883{; 7884 if (obj == fEventList) {; 7885 fEventList = nullptr;; 7886 }; 7887 if (obj == fEntryList) {; 7888 fEntryList = nullptr;; 7889 }; 7890 if (fUserInfo) {; 7891 fUserInfo->RecursiveRemove(obj);; 7892 }; 7893 if (fPlayer == obj) {; 7894 fPlayer = nullptr;; 7895 }; 7896 if (fTreeIndex == obj) {; 7897 fTreeIndex = nullptr;; 7898 }; 7899 if (fAliases == obj) {; 7900 fAliases = nullptr;; 7901 } else if (fAliases) {; 7902 fAliases->RecursiveRemove(obj);; 7903 }; 7904 if (fFriends == obj) {; 7905 fFriends = nullptr;; 7906 } else if (fFriends) {; 7907 fFriends->RecursiveRemove(obj);; 7908 }; 7909}; 7910 ; 7911////////////////////////////////////////////////////////////////////////////////; 7912/// Refresh contents of this tree and its branches from the current status on disk.; 7913///; 7914/// One can call this function in case the tree file is being; 7915/// updated by another process.; 7916 ; 7917void TTree::Refresh(); 7918{; 7919 if (!fDirectory->GetFile()) {; 7920 return;; 7921 }; 7922 fDirectory->ReadKeys();; 7923 fDirectory->Remove(this);; 7924 TTree* tree; fDirectory->GetObject(GetName(),tree);; 7925 if (!tree) {; 7926 return;; 7927 }; 7928 //copy info from tree header into this Tree; 7929 fEntries = 0;; 7930 fNClusterRange = 0;; 7931 ImportClusterRanges(tree);; 7932 ; 7933 fAutoSave = tree->fAutoSave;; 7934 fEntries = tree->fEntries;; 7935 fTotBytes = tree->GetTotBytes();; 7936 fZipBytes = tree->GetZipBytes();; 7937 fSavedBytes = tree->fSavedBytes;; 7938 fTotalBuffers = tree->fTotalBuffers.load();; 7939 ; 7940 //loop on all branches and update them; 7941 Int_t nleaves = fLeaves.GetEntriesFast();; 7942 for (Int_t i = 0; i < nleaves; i++) {; 7943 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 7944 TBranch* branch = (TBranch*) leaf->GetBranch();; 7945 branch->Refresh(tree->GetBranch(branch->GetName()));; 7",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:309653,Deployability,update,update,309653,"RecursiveRemove(obj);; 7908 }; 7909}; 7910 ; 7911////////////////////////////////////////////////////////////////////////////////; 7912/// Refresh contents of this tree and its branches from the current status on disk.; 7913///; 7914/// One can call this function in case the tree file is being; 7915/// updated by another process.; 7916 ; 7917void TTree::Refresh(); 7918{; 7919 if (!fDirectory->GetFile()) {; 7920 return;; 7921 }; 7922 fDirectory->ReadKeys();; 7923 fDirectory->Remove(this);; 7924 TTree* tree; fDirectory->GetObject(GetName(),tree);; 7925 if (!tree) {; 7926 return;; 7927 }; 7928 //copy info from tree header into this Tree; 7929 fEntries = 0;; 7930 fNClusterRange = 0;; 7931 ImportClusterRanges(tree);; 7932 ; 7933 fAutoSave = tree->fAutoSave;; 7934 fEntries = tree->fEntries;; 7935 fTotBytes = tree->GetTotBytes();; 7936 fZipBytes = tree->GetZipBytes();; 7937 fSavedBytes = tree->fSavedBytes;; 7938 fTotalBuffers = tree->fTotalBuffers.load();; 7939 ; 7940 //loop on all branches and update them; 7941 Int_t nleaves = fLeaves.GetEntriesFast();; 7942 for (Int_t i = 0; i < nleaves; i++) {; 7943 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 7944 TBranch* branch = (TBranch*) leaf->GetBranch();; 7945 branch->Refresh(tree->GetBranch(branch->GetName()));; 7946 }; 7947 fDirectory->Remove(tree);; 7948 fDirectory->Append(this);; 7949 delete tree;; 7950 tree = nullptr;; 7951}; 7952 ; 7953////////////////////////////////////////////////////////////////////////////////; 7954/// Record a TFriendElement that we need to warn when the chain switches to; 7955/// a new file (typically this is because this chain is a friend of another; 7956/// TChain); 7957 ; 7958void TTree::RegisterExternalFriend(TFriendElement *fe); 7959{; 7960 if (!fExternalFriends); 7961 fExternalFriends = new TList();; 7962 fExternalFriends->Add(fe);; 7963}; 7964 ; 7965 ; 7966////////////////////////////////////////////////////////////////////////////////; 7967/// Removes external friend; 7968 ; 7969void TTre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340932,Deployability,update,update,340932,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341725,Deployability,update,update,341725,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:346715,Deployability,update,updateExisting,346715," fBranches.GetEntriesFast();; 8910 for (Int_t i = 0; i < nb; i++) {; 8911 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 8912 branch->SetCompressionSettings(compress);; 8913 }; 8914 }; 8915 } else {; 8916 // Enable circularity.; 8917 fMaxEntries = maxEntries;; 8918 SetBit(kCircular);; 8919 }; 8920}; 8921 ; 8922////////////////////////////////////////////////////////////////////////////////; 8923/// Set the debug level and the debug range.; 8924///; 8925/// For entries in the debug range, the functions TBranchElement::Fill; 8926/// and TBranchElement::GetEntry will print the number of bytes filled; 8927/// or read for each branch.; 8928 ; 8929void TTree::SetDebug(Int_t level, Long64_t min, Long64_t max); 8930{; 8931 fDebug = level;; 8932 fDebugMin = min;; 8933 fDebugMax = max;; 8934}; 8935 ; 8936////////////////////////////////////////////////////////////////////////////////; 8937/// Update the default value for the branch's fEntryOffsetLen.; 8938/// If updateExisting is true, also update all the existing branches.; 8939/// If newdefault is less than 10, the new default value will be 10.; 8940 ; 8941void TTree::SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting); 8942{; 8943 if (newdefault < 10) {; 8944 newdefault = 10;; 8945 }; 8946 fDefaultEntryOffsetLen = newdefault;; 8947 if (updateExisting) {; 8948 TIter next( GetListOfBranches() );; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:346744,Deployability,update,update,346744," fBranches.GetEntriesFast();; 8910 for (Int_t i = 0; i < nb; i++) {; 8911 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 8912 branch->SetCompressionSettings(compress);; 8913 }; 8914 }; 8915 } else {; 8916 // Enable circularity.; 8917 fMaxEntries = maxEntries;; 8918 SetBit(kCircular);; 8919 }; 8920}; 8921 ; 8922////////////////////////////////////////////////////////////////////////////////; 8923/// Set the debug level and the debug range.; 8924///; 8925/// For entries in the debug range, the functions TBranchElement::Fill; 8926/// and TBranchElement::GetEntry will print the number of bytes filled; 8927/// or read for each branch.; 8928 ; 8929void TTree::SetDebug(Int_t level, Long64_t min, Long64_t max); 8930{; 8931 fDebug = level;; 8932 fDebugMin = min;; 8933 fDebugMax = max;; 8934}; 8935 ; 8936////////////////////////////////////////////////////////////////////////////////; 8937/// Update the default value for the branch's fEntryOffsetLen.; 8938/// If updateExisting is true, also update all the existing branches.; 8939/// If newdefault is less than 10, the new default value will be 10.; 8940 ; 8941void TTree::SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting); 8942{; 8943 if (newdefault < 10) {; 8944 newdefault = 10;; 8945 }; 8946 fDefaultEntryOffsetLen = newdefault;; 8947 if (updateExisting) {; 8948 TIter next( GetListOfBranches() );; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:346924,Deployability,update,updateExisting,346924,"bug level and the debug range.; 8924///; 8925/// For entries in the debug range, the functions TBranchElement::Fill; 8926/// and TBranchElement::GetEntry will print the number of bytes filled; 8927/// or read for each branch.; 8928 ; 8929void TTree::SetDebug(Int_t level, Long64_t min, Long64_t max); 8930{; 8931 fDebug = level;; 8932 fDebugMin = min;; 8933 fDebugMax = max;; 8934}; 8935 ; 8936////////////////////////////////////////////////////////////////////////////////; 8937/// Update the default value for the branch's fEntryOffsetLen.; 8938/// If updateExisting is true, also update all the existing branches.; 8939/// If newdefault is less than 10, the new default value will be 10.; 8940 ; 8941void TTree::SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting); 8942{; 8943 if (newdefault < 10) {; 8944 newdefault = 10;; 8945 }; 8946 fDefaultEntryOffsetLen = newdefault;; 8947 if (updateExisting) {; 8948 TIter next( GetListOfBranches() );; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory* dir); 8968{; 8969 if (fDirectory == dir) {; 8970 return;; 8971 }; 8972 if (fDirectory) {; 8973 fDirectory->Remove(this);; 8974 ; 8975 // Delete or move the file cache if it points to this Tree; 8976 TFile *file = fDirectory->GetFile();; 8977 MoveReadCache(file,dir);; 8978 }; 8979 fDirectory = dir;; 8980 if (fDirectory) {; 8981 fDirectory->Append(this);; 8982 }; 8983 TFile* file = nullptr;; 8984 if (fDirectory) {; 89",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:347060,Deployability,update,updateExisting,347060,"bug level and the debug range.; 8924///; 8925/// For entries in the debug range, the functions TBranchElement::Fill; 8926/// and TBranchElement::GetEntry will print the number of bytes filled; 8927/// or read for each branch.; 8928 ; 8929void TTree::SetDebug(Int_t level, Long64_t min, Long64_t max); 8930{; 8931 fDebug = level;; 8932 fDebugMin = min;; 8933 fDebugMax = max;; 8934}; 8935 ; 8936////////////////////////////////////////////////////////////////////////////////; 8937/// Update the default value for the branch's fEntryOffsetLen.; 8938/// If updateExisting is true, also update all the existing branches.; 8939/// If newdefault is less than 10, the new default value will be 10.; 8940 ; 8941void TTree::SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting); 8942{; 8943 if (newdefault < 10) {; 8944 newdefault = 10;; 8945 }; 8946 fDefaultEntryOffsetLen = newdefault;; 8947 if (updateExisting) {; 8948 TIter next( GetListOfBranches() );; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory* dir); 8968{; 8969 if (fDirectory == dir) {; 8970 return;; 8971 }; 8972 if (fDirectory) {; 8973 fDirectory->Remove(this);; 8974 ; 8975 // Delete or move the file cache if it points to this Tree; 8976 TFile *file = fDirectory->GetFile();; 8977 MoveReadCache(file,dir);; 8978 }; 8979 fDirectory = dir;; 8980 if (fDirectory) {; 8981 fDirectory->Append(this);; 8982 }; 8983 TFile* file = nullptr;; 8984 if (fDirectory) {; 89",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:356189,Deployability,update,update,356189," (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9203////////////////////////////////////////////////////////////////////////////////; 9204/// Change the name of this tree.; 9205 ; 9206void TTree::SetName(const char* name); 9207{; 9208 if (gPad) {; 9209 gPad->Modified();; 9210 }; 9211 // Trees are named objects in a THashList.; 9212 // We must update hashlists if we change the name.; 9213 TFile *file = nullptr;; 9214 TTreeCache *pf = nullptr;; 9215 if (fDirectory) {; 9216 fDirectory->Remove(this);; 9217 if ((file = GetCurrentFile())) {; 9218 pf = GetReadCache(file);; 9219 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9220 }; 9221 }; 9222 // This changes our hash value.; 9223 fName = name;; 9224 if (fDirectory) {; 9225 fDirectory->Append(this);; 9226 if (pf) {; 9227 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9228 }; 9229 }; 9230}; 9231 ; 9232void TTree::SetNotify(TObject *obj); 9233{; 9234 if (obj && fNotify && dynamic_cast<TNotifyLinkBase *>(fNotify)) {; 9235 auto *oldLink = static_cast<TNotifyLinkBase *>(fNotify);; 9236 auto *newLink = dynamic_cast<TNotifyLinkBase *>(obj);; 9237 if (!newLink) {; 9238 Warning(""TTree::SetNotify"",; 9239 ""The tree or chain already has a fNotify registered and it is a TNotifyLink, while the new object is ""; 9240 ""not a TNotifyLink. Setting fNotify to the new value will lead to an or",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:358528,Deployability,update,update,358528," 9246 // Otherwise newLink and oldLink are unrelated:; 9247 Warning(""TTree::SetNotify"",; 9248 ""The tree or chain already has a TNotifyLink registered, and the new TNotifyLink `obj` does not link ""; 9249 ""to it. Setting fNotify to the new value will lead to an orphan linked list of TNotifyLinks and it is ""; 9250 ""most likely not intended. If this is the intended goal, please call SetNotify(nullptr) first to ""; 9251 ""silence this warning."");; 9252 }; 9253 }; 9254 ; 9255 fNotify = obj;; 9256}; 9257 ; 9258////////////////////////////////////////////////////////////////////////////////; 9259/// Change the name and title of this tree.; 9260 ; 9261void TTree::SetObject(const char* name, const char* title); 9262{; 9263 if (gPad) {; 9264 gPad->Modified();; 9265 }; 9266 ; 9267 // Trees are named objects in a THashList.; 9268 // We must update hashlists if we change the name; 9269 TFile *file = nullptr;; 9270 TTreeCache *pf = nullptr;; 9271 if (fDirectory) {; 9272 fDirectory->Remove(this);; 9273 if ((file = GetCurrentFile())) {; 9274 pf = GetReadCache(file);; 9275 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9276 }; 9277 }; 9278 // This changes our hash value.; 9279 fName = name;; 9280 fTitle = title;; 9281 if (fDirectory) {; 9282 fDirectory->Append(this);; 9283 if (pf) {; 9284 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9285 }; 9286 }; 9287}; 9288 ; 9289////////////////////////////////////////////////////////////////////////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != d",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:396726,Deployability,update,updateSubBranches,396726," of bytes read.Definition TBranch.cxx:1706; TBranch::IsATClass * IsA() const overrideDefinition TBranch.h:295; TBranch::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranch.cxx:2341; TBranch::ResetCountstatic void ResetCount()Static function resetting fgCount.Definition TBranch.cxx:2674; TBranch::SetObjectvirtual void SetObject(void *objadd)Set object this branch is pointing to.Definition TBranch.cxx:2936; TBranch::FlushBasketsInt_t FlushBaskets()Flush to disk all the baskets of this branch and any of subbranches.Definition TBranch.cxx:1136; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBranch::GetNleavesInt_t GetNleaves() constDefinition TBranch.h:249; TBranch::SetFilevirtual void SetFile(TFile *file=nullptr)Set file where this branch writes/reads its buffers.Definition TBranch.cxx:2863; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::GetReadBasketInt_t GetReadBasket() constDefinition TBranch.h:236; TBranch::GetMaxBasketsInt_t GetMaxBaskets() constDefinition TBranch.h:248; TBranch::GetFilevirtual TFile * GetFile(Int_t mode=0)Return pointer to the file where branch buffers reside, returns 0 in case branch buffers reside in th...Definition TBranch.cxx:1853; TBranch::KeepCircularvirtual void KeepCircular(Long64_t maxEntries)keep a maximum of fMaxEntries in memoryDefinition TBranch.cxx:2283; TBranch::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Reset a Branch.Definition TBranch.cxx:2598; TBranch::FindBran",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:444356,Deployability,update,update,444356,"RangeNumber of Cluster range in addition to the one defined by 'AutoFlush'.Definition TTree.h:95; TTree::PrintCacheStatsvirtual void PrintCacheStats(Option_t *option="""") constPrint statistics about the TreeCache for this tree.Definition TTree.cxx:7370; TTree::BuildIndexvirtual Int_t BuildIndex(const char *majorname, const char *minorname=""0"")Build a Tree Index (default is TTreeIndex).Definition TTree.cxx:2637; TTree::fPlayerTVirtualTreePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::InPlaceClonevirtual bool InPlaceClone(TDirectory *newdirectory, const char *options="""")Copy the content to a new new file, update this TTree with the new location information and attach th...Definition TTree.cxx:7012; TTree::fBranchesTObjArray fBranchesList of Branches.Definition TTree.h:122; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::fCacheDoAutoInitbool fCacheDoAutoInit! true if cache auto creation or resize check is neededDefinition TTree.h:139; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::ChangeFilevirtual TFile * ChangeFile(TFile *file)Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.Definition TTree.cxx:2749; TTree::GetEntryListvirtual TEntryList * GetEntryList()Returns the entry list assigned to this tree.Definition TTree.cxx:5854; TTree::SetWeightvirtual void SetWeight(Double_t w=1, Op",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:451122,Deployability,update,updateExisting,451122,"e.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; TTree::fLeavesTObjArray fLeavesDirect pointers to individual branch leaves.Definition TTree.h:123; TTree::Resetvirtual void Reset(Option_t *option="""")Reset baskets, buffers and entries count in all branches and leaves.Definition TTree.cxx:8003; TTree::KeepCircularvirtual void KeepCircular()Keep a maximum of fMaxEntries in memory.Definition TTree.cxx:6415; TTree::SetDefaultEntryOffsetLenvirtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting=false)Update the default value for the branch's fEntryOffsetLen.Definition TTree.cxx:8940; TTree::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file...Definition TTree.cxx:3819; TTree::fMaxVirtualSizeLong64_t fMaxVirtualSizeMaximum total size of buffers kept in memory.Definition TTree.h:99; TTree::GetTotBytesvirtual Long64_t GetTotBytes() constDefinition TTree.h:556; TTree::MakeSelectorvirtual Int_t MakeSelector(const char *selector=nullptr, Option_t *option="""")Generate skeleton selector class for this tree.Definition TTree.cxx:6822; TTree::SetObjectvirtual void SetObject(const char *name, const char *title)Change the name and title of this tree.Definition TTree.cxx:9260; TTree::fPerfStatsTVirtualPerfStats * fPerfStats! pointer to the current perf stats objectDefinition TTree.h:132; TTree::fWeightDouble_t fWeightTree weight (see TTree::SetWeight)Defini",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:1039,Energy Efficiency,reduce,reduce,1039,"; . master. Reference Guide ; . . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:1768,Energy Efficiency,allocate,allocated,1768,"TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the file compression attribute is set (default).; 39Branches may be written to different files (see TBranch::SetFile).; 40 ; 41The ROOT user can decide to make one single branch and serialize one object into; 42one single I/O buffer or to make several branches.; 43Making several branches is particularly interesting in the data analysis phase,; 44when it is desirable to have a high reading rate and not all columns are equally interesting; 45 ; 46\anchor creatingattreetoc; 47## Create a TTree to store columnar data; 48- [Construct a TTree](\ref creatingattree); 49- [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); 50- [Add a column of a STL Collection instances](\ref addi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:10471,Energy Efficiency,allocate,allocated,10471,"e is not specified, Branch uses the type of p_object to determine the; 184 type of the object.; 185- If className is used to specify explicitly the object type, the className must; 186 be of a type related to the one pointed to by the pointer. It should be either; 187 a parent or derived class.; 188 ; 189Note: The pointer whose address is passed to TTree::Branch must not; 190 be destroyed (i.e. go out of scope) until the TTree is deleted or; 191 TTree::ResetBranchAddress is called.; 192 ; 193Note: The pointer p_object must be initialized before calling TTree::Branch; 194- Do either:; 195~~~ {.cpp}; 196 MyDataClass* p_object = nullptr;; 197 tree.Branch(branchname, &p_object);; 198~~~; 199- Or:; 200~~~ {.cpp}; 201 auto p_object = new MyDataClass;; 202 tree.Branch(branchname, &p_object);; 203~~~; 204Whether the pointer is set to zero or not, the ownership of the object; 205is not taken over by the TTree. I.e. even though an object will be allocated; 206by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; 207be deleted when the TTree is deleted.; 208 ; 209\anchor addingacolumnoftclonesarray; 210## Add a column holding TClonesArray instances; 211 ; 212*It is recommended to use STL containers instead of TClonesArrays*.; 213 ; 214~~~ {.cpp}; 215 // clonesarray is the address of a pointer to a TClonesArray.; 216 auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); 217~~~; 218The TClonesArray is a direct access list of objects of the same class.; 219For example, if the TClonesArray is an array of TTrack objects,; 220this function will create one subbranch for each data member of; 221the object TTrack.; 222 ; 223\anchor fillthetree; 224## Fill the Tree; 225 ; 226A TTree instance is filled with the invocation of the TTree::Fill method:; 227~~~ {.cpp}; 228 tree.Fill(); 229~~~; 230Upon its invocation, a loop on all defined branches takes place that for each branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:34396,Energy Efficiency,allocate,allocated,34396,"fo(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:35116,Energy Efficiency,allocate,allocated,35116,"Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 10",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:81256,Energy Efficiency,efficient,efficient,81256,"size /* = 32000 */, Int_t splitlevel /* = 99 */); 2023{; 2024 if (fgBranchStyle == 1) {; 2025 return Bronch(name, classname, addobj, bufsize, splitlevel);; 2026 } else {; 2027 if (splitlevel < 0) {; 2028 splitlevel = 0;; 2029 }; 2030 return BranchOld(name, classname, addobj, bufsize, splitlevel);; 2031 }; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// Create a new TTree BranchObject.; 2036///; 2037/// Build a TBranchObject for an object of class classname.; 2038/// addobj is the address of a pointer to an object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass ha",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:93076,Energy Efficiency,power,powerful,93076,"renced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRef) {; 2332 fBranchRef = new TBranchRef(this);; 2333 }; 2334 return fBranchRef;; 2335}; 2336 ; 2337////////////////////////////////////////////////////////////////////////////////; 2338/// Create a new TTree BranchElement.; 2339///; 2340/// ## WARNING about this new function; 2341///; 2342/// This function is designed to replace the internal; 2343/// implementation of the old TTree::Branch (whose implementation; 2344/// has been moved to BranchOld).; 2345///; 2346/// NOTE: The 'Bronch' method supports only one possible calls; 2347/// signature (where the object type has to be specified; 2348/// explicitly and the address must be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a differe",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:126906,Energy Efficiency,allocate,allocated,126906,"// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAddress().; 3173 TObjArray* branches = newtree->GetListOfBranches();; 3174 Int_t nb = branches->GetEntriesFast();; 3175 for (Int_t i = 0; i < nb; ++i) {; 3176 TBranch* br = (TBranch*) branches->UncheckedAt(i);; 3177 if (br->InheritsFrom(TBranchElement::Class())) {; 3178 ((TBranchElement*) br)->ResetDeleteObject();; 3179 }; 3180 }; 3181 ; 3182 // Add the new tree to the list of clones so that; 3183 // we can later inform it of changes to branch addresses.; 3184 thistree->AddClone(newtree);; 3185 if (thistree != this) {; 3186 // In case this object is a TChain, add the clone; 3187 // also to the TChain's list of clones.; 3188 AddClone(newtree);; 3189 }; 3190 ; 3191 newtree->Reset();; 3192 ; 3193 TDirectory* ndir = newtree->GetDirectory();; 3194 TFile* nfile = nullptr;; 3195 if (ndir) {; 3196 nfile = ndir->GetFile();; 3197 }; 3198 Int_t newcomp = -1;; 3199 if (nfile) {; 3200 newcomp = nfile->GetCompressionS",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:131785,Energy Efficiency,allocate,allocated,131785,"ches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be copied via the next loop (over the leaf).; 3324 continue;; 3325 }; 3326 }; 3327 // Note: This may cause an object to be allocated.; 3328 branch->SetAddress(nullptr);; 3329 addr = branch->GetAddress();; 3330 }; 3331 TBranch* br = tree->GetBranch(branch->GetFullName());; 3332 if (br) {; 3333 if (br->GetMakeClass() != branch->GetMakeClass()); 3334 br->SetMakeClass(branch->GetMakeClass());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranc",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:132124,Energy Efficiency,allocate,allocated,132124,"cess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be copied via the next loop (over the leaf).; 3324 continue;; 3325 }; 3326 }; 3327 // Note: This may cause an object to be allocated.; 3328 branch->SetAddress(nullptr);; 3329 addr = branch->GetAddress();; 3330 }; 3331 TBranch* br = tree->GetBranch(branch->GetFullName());; 3332 if (br) {; 3333 if (br->GetMakeClass() != branch->GetMakeClass()); 3334 br->SetMakeClass(branch->GetMakeClass());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 };",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:133514,Energy Efficiency,allocate,allocated,133514,"s());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:135144,Energy Efficiency,allocate,allocated,135144,"needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 } else {; 3418 tleaf->SetAddress(leaf->GetValuePointer());; 3419 }; 3420 }; 3421 }; 3422 ; 3423 if (undo &&; 3424 ( tree->IsA()->InheritsFrom(""TNtuple"") || tree->IsA()->InheritsFrom(""TNtupleD"") ); 3425 ) {; 3426 tree->ResetBranchAddresses();; 3427 }; 3428}; 3429 ; 3430namespace {; 3431 ; 3432 enum EOnIndexError { kDrop, kKeep, kBuild };; 3433 ; 3434 bool R__H",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:204970,Energy Efficiency,schedul,schedules,204970,"individually written and; 5100/// create an event cluster boundary (by default).; 5101///; 5102/// If the caller wishes to flush the baskets but not create an event cluster,; 5103/// then set create_cluster to false.; 5104///; 5105/// If ROOT has IMT-mode enabled, this will launch multiple TBB tasks in parallel; 5106/// via TThreadExecutor to do this operation; one per basket compression. If the; 5107/// caller utilizes TBB also, care must be taken to prevent deadlocks.; 5108///; 5109/// For example, let's say the caller holds mutex A and calls FlushBaskets; while; 5110/// TBB is waiting for the ROOT compression tasks to complete, it may decide to; 5111/// run another one of the user's tasks in this thread. If the second user task; 5112/// tries to acquire A, then a deadlock will occur. The example call sequence; 5113/// looks like this:; 5114///; 5115/// - User acquires mutex A; 5116/// - User calls FlushBaskets.; 5117/// - ROOT launches N tasks and calls wait.; 5118/// - TBB schedules another user task, T2.; 5119/// - T2 tries to acquire mutex A.; 5120///; 5121/// At this point, the thread will deadlock: the code may function with IMT-mode; 5122/// disabled if the user assumed the legacy code never would run their own TBB; 5123/// tasks.; 5124///; 5125/// SO: users of TBB who want to enable IMT-mode should carefully review their; 5126/// locking patterns and make sure they hold no coarse-grained application; 5127/// locks when they invoke ROOT.; 5128///; 5129/// Return the number of bytes written or -1 in case of write error.; 5130Int_t TTree::FlushBaskets(bool create_cluster) const; 5131{; 5132 Int_t retval = FlushBasketsImpl();; 5133 if (retval == -1) return retval;; 5134 ; 5135 if (create_cluster) const_cast<TTree *>(this)->MarkEventCluster();; 5136 return retval;; 5137}; 5138 ; 5139////////////////////////////////////////////////////////////////////////////////; 5140/// Internal implementation of the FlushBaskets algorithm.; 5141/// Unlike the public interface",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:207607,Energy Efficiency,schedul,scheduler,207607,"if the size of fSortedBranches is different from the; 5159 // size of the list of branches before triggering the initialisation of the fSortedBranches; 5160 // container to cover two cases:; 5161 // 1. This is the first time we flush. fSortedBranches is empty and we need to fill it.; 5162 // 2. We flushed at least once already but a branch has been be added to the tree since then; 5163 if (fSortedBranches.size() != unsigned(nb)) { const_cast<TTree*>(this)->InitializeBranchLists(false); }; 5164 ; 5165 BoolRAIIToggle sentry(fIMTFlush);; 5166 fIMTZipBytes.store(0);; 5167 fIMTTotBytes.store(0);; 5168 std::atomic<Int_t> nerrpar(0);; 5169 std::atomic<Int_t> nbpar(0);; 5170 std::atomic<Int_t> pos(0);; 5171 ; 5172 auto mapFunction = [&]() {; 5173 // The branch to process is obtained when the task starts to run.; 5174 // This way, since branches are sorted, we make sure that branches; 5175 // leading to big tasks are processed first. If we assigned the; 5176 // branch at task creation time, the scheduler would not necessarily; 5177 // respect our sorting.; 5178 Int_t j = pos.fetch_add(1);; 5179 ; 5180 auto branch = fSortedBranches[j].second;; 5181 if (R__unlikely(!branch)) { return; }; 5182 ; 5183 if (R__unlikely(gDebug > 0)) {; 5184 std::stringstream ss;; 5185 ss << std::this_thread::get_id();; 5186 Info(""FlushBaskets"", ""[IMT] Thread %s"", ss.str().c_str());; 5187 Info(""FlushBaskets"", ""[IMT] Running task for branch #%d: %s"", j, branch->GetName());; 5188 }; 5189 ; 5190 Int_t nbtask = branch->FlushBaskets();; 5191 ; 5192 if (nbtask < 0) { nerrpar++; }; 5193 else { nbpar += nbtask; }; 5194 };; 5195 ; 5196 ROOT::TThreadExecutor pool;; 5197 pool.Foreach(mapFunction, nb);; 5198 ; 5199 fIMTFlush = false;; 5200 const_cast<TTree*>(this)->AddTotBytes(fIMTTotBytes);; 5201 const_cast<TTree*>(this)->AddZipBytes(fIMTZipBytes);; 5202 ; 5203 return nerrpar ? -1 : nbpar.load();; 5204 }; 5205#endif; 5206 for (Int_t j = 0; j < nb; j++) {; 5207 TBranch* branch = (TBranch*) lb->UncheckedAt(j);; ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:220121,Energy Efficiency,allocate,allocated,220121," only by branches named ""a"" and ""b"", do; 5539/// ~~~ {.cpp}; 5540/// mytree.SetBranchStatus(""*"",0); //disable all branches; 5541/// mytree.SetBranchStatus(""a"",1);; 5542/// mytree.SetBranchStatus(""b"",1);; 5543/// ~~~; 5544/// when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; 5545///; 5546/// __WARNING!!__; 5547/// If your Tree has been created in split mode with a parent branch ""parent."",; 5548/// ~~~ {.cpp}; 5549/// mytree.SetBranchStatus(""parent"",1);; 5550/// ~~~; 5551/// will not activate the sub-branches of ""parent"". You should do:; 5552/// ~~~ {.cpp}; 5553/// mytree.SetBranchStatus(""parent*"",1);; 5554/// ~~~; 5555/// Without the trailing dot in the branch creation you have no choice but to; 5556/// call SetBranchStatus explicitly for each of the sub branches.; 5557///; 5558/// An alternative is to call directly; 5559/// ~~~ {.cpp}; 5560/// brancha.GetEntry(i); 5561/// branchb.GetEntry(i);; 5562/// ~~~; 5563/// ## IMPORTANT NOTE; 5564///; 5565/// By default, GetEntry reuses the space allocated by the previous object; 5566/// for each branch. You can force the previous object to be automatically; 5567/// deleted if you call mybranch.SetAutoDelete(true) (default is false).; 5568///; 5569/// Example:; 5570///; 5571/// Consider the example in $ROOTSYS/test/Event.h; 5572/// The top level branch in the tree T is declared with:; 5573/// ~~~ {.cpp}; 5574/// Event *event = 0; //event must be null or point to a valid object; 5575/// //it must be initialized; 5576/// T.SetBranchAddress(""event"",&event);; 5577/// ~~~; 5578/// When reading the Tree, one can choose one of these 3 options:; 5579///; 5580/// ## OPTION 1; 5581///; 5582/// ~~~ {.cpp}; 5583/// for (Long64_t i=0;i<nentries;i++) {; 5584/// T.GetEntry(i);; 5585/// // the object event has been filled at this point; 5586/// }; 5587/// ~~~; 5588/// The default (recommended). At the first entry an object of the class; 5589/// Event will be created and pointed by event. At the following entries,; 5590",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:225031,Energy Efficiency,schedul,scheduler,225031,"k;; 5663 nbytes += nb;; 5664 }; 5665 };; 5666 ; 5667#ifdef R__USE_IMT; 5668 if (nbranches > 1 && ROOT::IsImplicitMTEnabled() && fIMTEnabled && !TTreeCacheUnzip::IsParallelUnzip()) {; 5669 if (fSortedBranches.empty()); 5670 InitializeBranchLists(true);; 5671 ; 5672 // Count branches are processed first and sequentially; 5673 for (auto branch : fSeqBranches) {; 5674 nb = branch->GetEntry(entry, getall);; 5675 if (nb < 0) break;; 5676 nbytes += nb;; 5677 }; 5678 if (nb < 0) return nb;; 5679 ; 5680 // Enable this IMT use case (activate its locks); 5681 ROOT::Internal::TParBranchProcessingRAII pbpRAII;; 5682 ; 5683 Int_t errnb = 0;; 5684 std::atomic<Int_t> pos(0);; 5685 std::atomic<Int_t> nbpar(0);; 5686 ; 5687 auto mapFunction = [&]() {; 5688 // The branch to process is obtained when the task starts to run.; 5689 // This way, since branches are sorted, we make sure that branches; 5690 // leading to big tasks are processed first. If we assigned the; 5691 // branch at task creation time, the scheduler would not necessarily; 5692 // respect our sorting.; 5693 Int_t j = pos.fetch_add(1);; 5694 ; 5695 Int_t nbtask = 0;; 5696 auto branch = fSortedBranches[j].second;; 5697 ; 5698 if (gDebug > 0) {; 5699 std::stringstream ss;; 5700 ss << std::this_thread::get_id();; 5701 Info(""GetEntry"", ""[IMT] Thread %s"", ss.str().c_str());; 5702 Info(""GetEntry"", ""[IMT] Running task for branch #%d: %s"", j, branch->GetName());; 5703 }; 5704 ; 5705 std::chrono::time_point<std::chrono::system_clock> start, end;; 5706 ; 5707 start = std::chrono::system_clock::now();; 5708 nbtask = branch->GetEntry(entry, getall);; 5709 end = std::chrono::system_clock::now();; 5710 ; 5711 Long64_t tasktime = (Long64_t)std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();; 5712 fSortedBranches[j].first += tasktime;; 5713 ; 5714 if (nbtask < 0) errnb = nbtask;; 5715 else nbpar += nbtask;; 5716 };; 5717 ; 5718 ROOT::TThreadExecutor pool;; 5719 pool.Foreach(mapFunction, fSortedBranches.size());; 5",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262513,Energy Efficiency,efficient,efficient,262513,".fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerm",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262706,Energy Efficiency,efficient,efficient,262706,"l cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the pr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:279365,Energy Efficiency,reduce,reduces,279365," 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:313677,Energy Efficiency,allocate,allocate,313677,"ree::ResetAfterMerge(TFileMergeInfo *info); 8036{; 8037 fEntries = 0;; 8038 fNClusterRange = 0;; 8039 fTotBytes = 0;; 8040 fZipBytes = 0;; 8041 fSavedBytes = 0;; 8042 fFlushedBytes = 0;; 8043 fTotalBuffers = 0;; 8044 fChainOffset = 0;; 8045 fReadEntry = -1;; 8046 ; 8047 delete fTreeIndex;; 8048 fTreeIndex = nullptr;; 8049 ; 8050 Int_t nb = fBranches.GetEntriesFast();; 8051 for (Int_t i = 0; i < nb; ++i) {; 8052 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 8053 branch->ResetAfterMerge(info);; 8054 }; 8055 ; 8056 if (fBranchRef) {; 8057 fBranchRef->ResetAfterMerge(info);; 8058 }; 8059}; 8060 ; 8061////////////////////////////////////////////////////////////////////////////////; 8062/// Tell all of our branches to set their addresses to zero.; 8063///; 8064/// Note: If any of our branches own any objects, they are deleted.; 8065 ; 8066void TTree::ResetBranchAddress(TBranch *br); 8067{; 8068 if (br && br->GetTree()) {; 8069 br->ResetAddress();; 8070 }; 8071}; 8072 ; 8073////////////////////////////////////////////////////////////////////////////////; 8074/// Tell all of our branches to drop their current objects and allocate new ones.; 8075 ; 8076void TTree::ResetBranchAddresses(); 8077{; 8078 TObjArray* branches = GetListOfBranches();; 8079 Int_t nbranches = branches->GetEntriesFast();; 8080 for (Int_t i = 0; i < nbranches; ++i) {; 8081 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 8082 branch->ResetAddress();; 8083 }; 8084}; 8085 ; 8086////////////////////////////////////////////////////////////////////////////////; 8087/// Loop over tree entries and print entries passing selection. Interactive; 8088/// pagination break is on by default.; 8089///; 8090/// - If varexp is 0 (or """") then print only first 8 columns.; 8091/// - If varexp = ""*"" print all columns.; 8092///; 8093/// Otherwise a columns selection can be made using ""var1:var2:var3"".; 8094///; 8095/// \param firstentry first entry to scan; 8096/// \param nentries total number of entries to sc",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:319446,Energy Efficiency,allocate,allocated,319446,"at contains all; 8193/// the data for a (consecutive) set of entries and that is stored; 8194/// consecutively on the disk. When reading all the branches, this; 8195/// is the minimum set of baskets that the TTreeCache will read.; 8196 ; 8197void TTree::SetAutoFlush(Long64_t autof /* = -30000000 */ ); 8198{; 8199 // Implementation note:; 8200 //; 8201 // A positive value of autoflush determines the size (in number of entries) of; 8202 // a cluster of baskets.; 8203 //; 8204 // If the value of autoflush is changed over time (this happens in; 8205 // particular when the TTree results from fast merging many trees),; 8206 // we record the values of fAutoFlush in the data members:; 8207 // fClusterRangeEnd and fClusterSize.; 8208 // In the code we refer to a range of entries where the size of the; 8209 // cluster of baskets is the same (i.e the value of AutoFlush was; 8210 // constant) is called a ClusterRange.; 8211 //; 8212 // The 2 arrays (fClusterRangeEnd and fClusterSize) have fNClusterRange; 8213 // active (used) values and have fMaxClusterRange allocated entries.; 8214 //; 8215 // fClusterRangeEnd contains the last entries number of a cluster range.; 8216 // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; 8217 // fClusterSize contains the size in number of entries of all the cluster; 8218 // within the given range.; 8219 // The last range (and the only one if fNClusterRange is zero) start at; 8220 // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; 8221 // size of the cluster in this range is given by the value of fAutoFlush.; 8222 //; 8223 // For example printing the beginning and end of each the ranges can be done by:; 8224 //; 8225 // Printf(""%-16s %-16s %-16s %5s"",; 8226 // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; 8227 // Int_t index= 0;; 8228 // Long64_t clusterRangeStart = 0;; 8229 // if (fNClusterRange) {; 8230 // for( ; index < fNClusterRange; ++index) {; 8231 // Printf(""%-16d %-16l",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:367953,Energy Efficiency,allocate,allocated,367953,"(fDirectory) {; 9551 fDirectory->Remove(this);; 9552 //delete the file cache if it points to this Tree; 9553 TFile *file = fDirectory->GetFile();; 9554 MoveReadCache(file,nullptr);; 9555 }; 9556 fDirectory = nullptr;; 9557 fCacheDoAutoInit = true;; 9558 fCacheUserSet = false;; 9559 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 9560 if (R__v > 4) {; 9561 b.ReadClassBuffer(TTree::Class(), this, R__v, R__s, R__c);; 9562 ; 9563 fBranches.SetOwner(true); // True needed only for R__v < 19 and most R__v == 19; 9564 ; 9565 if (fBranchRef) fBranchRef->SetTree(this);; 9566 TBranch__SetTree(this,fBranches);; 9567 TFriendElement__SetTree(this,fFriends);; 9568 ; 9569 if (fTreeIndex) {; 9570 fTreeIndex->SetTree(this);; 9571 }; 9572 if (fIndex.fN) {; 9573 Warning(""Streamer"", ""Old style index in this tree is deleted. Rebuild the index via TTree::BuildIndex"");; 9574 fIndex.Set(0);; 9575 fIndexValues.Set(0);; 9576 }; 9577 if (fEstimate <= 10000) {; 9578 fEstimate = 1000000;; 9579 }; 9580 ; 9581 if (fNClusterRange) {; 9582 // The I/O allocated just enough memory to hold the; 9583 // current set of ranges.; 9584 fMaxClusterRange = fNClusterRange;; 9585 }; 9586 ; 9587 // Throughs calls to `GetCacheAutoSize` or `EnableCache` (for example; 9588 // by TTreePlayer::Process, the cache size will be automatically; 9589 // determined unless the user explicitly call `SetCacheSize`; 9590 fCacheSize = 0;; 9591 fCacheUserSet = false;; 9592 ; 9593 ResetBit(kMustCleanup);; 9594 return;; 9595 }; 9596 //====process old versions before automatic schema evolution; 9597 Stat_t djunk;; 9598 Int_t ijunk;; 9599 TNamed::Streamer(b);; 9600 TAttLine::Streamer(b);; 9601 TAttFill::Streamer(b);; 9602 TAttMarker::Streamer(b);; 9603 b >> fScanField;; 9604 b >> ijunk; fMaxEntryLoop = (Long64_t)ijunk;; 9605 b >> ijunk; fMaxVirtualSize = (Long64_t)ijunk;; 9606 b >> djunk; fEntries = (Long64_t)djunk;; 9607 b >> djunk; fTotBytes = (Long64_t)djunk;; 9608 b >> djunk; fZipBytes = (Long64_t)djunk;; 9609 b >> ijunk; fAutoSave",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:392290,Energy Efficiency,allocate,allocated,392290,"asket.h:34; TBasket::DropBuffersvirtual Int_t DropBuffers()Drop buffers of this basket if it is not the current basket.Definition TBasket.cxx:173; TBasket::GetBufferSizeInt_t GetBufferSize() constDefinition TBasket.h:122; TBasket::EIOBits::kSupported@ kSupported; TBranchClonesA Branch for the case of an array of clone objects.Definition TBranchClones.h:29; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchElement::IsObjectOwnervirtual bool IsObjectOwner() constDefinition TBranchElement.h:213; TBranchElement::SetBranchFoldervirtual void SetBranchFolder()Definition TBranchElement.h:226; TBranchElement::Classstatic TClass * Class(); TBranchElement::GetClassVersionInt_t GetClassVersion()Definition TBranchElement.h:210; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::UnrollInt_t Unroll(const char *name, TClass *cltop, TClass *cl, char *ptr, Int_t basketsize, Int_t splitlevel, Int_t btype)Split class cl into sub-branches of this branch.Definition TBranchElement.cxx:6212; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRe",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:401114,Energy Efficiency,allocate,allocated,401114,"Definition TBrowser.h:37; TBufferFileThe concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.Definition TBufferFile.h:47; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::BufferSizeInt_t BufferSize() constDefinition TBuffer.h:98; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:45",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:436618,Energy Efficiency,allocate,allocated,436618,"Definition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:464304,Energy Efficiency,allocate,allocate,464304,"d flush.Definition TTree.h:159; TTree::fDirectoryTDirectory * fDirectory! Pointer to directory holding this treeDefinition TTree.h:121; TTree::kNeedEnableDecomposedObj@ kNeedEnableDecomposedObjDefinition TTree.h:244; TTree::kClassMismatch@ kClassMismatchDefinition TTree.h:237; TTree::kVoidPtr@ kVoidPtrDefinition TTree.h:242; TTree::kMatchConversionCollection@ kMatchConversionCollectionDefinition TTree.h:240; TTree::kMissingCompiledCollectionProxy@ kMissingCompiledCollectionProxyDefinition TTree.h:235; TTree::kMismatch@ kMismatchDefinition TTree.h:236; TTree::kMatchConversion@ kMatchConversionDefinition TTree.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:57134,Integrability,message,message,57134,"""AutoSave"", ""calling FlushBaskets \n"");; 1512 FlushBasketsImpl();; 1513 }; 1514 ; 1515 fSavedBytes = GetZipBytes();; 1516 ; 1517 TKey *key = (TKey*)fDirectory->GetListOfKeys()->FindObject(GetName());; 1518 Long64_t nbytes;; 1519 if (opt.Contains(""overwrite"")) {; 1520 nbytes = fDirectory->WriteTObject(this,"""",""overwrite"");; 1521 } else {; 1522 nbytes = fDirectory->WriteTObject(this); //nbytes will be 0 if Write failed (disk space exceeded); 1523 if (nbytes && key && strcmp(ClassName(), key->GetClassName()) == 0) {; 1524 key->Delete();; 1525 delete key;; 1526 }; 1527 }; 1528 // save StreamerInfo; 1529 TFile *file = fDirectory->GetFile();; 1530 if (file) file->WriteStreamerInfo();; 1531 ; 1532 if (opt.Contains(""saveself"")) {; 1533 fDirectory->SaveSelf();; 1534 //the following line is required in case GetUserInfo contains a user class; 1535 //for which the StreamerInfo must be written. One could probably be a bit faster (Rene); 1536 if (file) file->WriteHeader();; 1537 }; 1538 ; 1539 return nbytes;; 1540}; 1541 ; 1542namespace {; 1543 // This error message is repeated several times in the code. We write it once.; 1544 const char* writeStlWithoutProxyMsg = ""The class requested (%s) for the branch \""%s\""""; 1545 "" is an instance of an stl collection and does not have a compiled CollectionProxy.""; 1546 "" Please generate the dictionary for this collection (%s) to avoid to write corrupted data."";; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Same as TTree::Branch() with added check that addobj matches className.; 1551///; 1552/// \see TTree::Branch() for other details.; 1553///; 1554 ; 1555TBranch* TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1556{; 1557 TClass* claim = TClass::GetClass(classname);; 1558 if (!ptrClass) {; 1559 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionPr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:62810,Integrability,interface,interface,62810,"houtProxyMsg,; 1626 actualClass->GetName(), branchname, actualClass->GetName());; 1627 return nullptr;; 1628 }; 1629 return Branch(branchname, actualClass->GetName(), (void*) addobj, bufsize, splitlevel);; 1630}; 1631 ; 1632////////////////////////////////////////////////////////////////////////////////; 1633/// Same as TTree::Branch but automatic detection of the class name.; 1634/// \see TTree::Branch for other details.; 1635 ; 1636TBranch* TTree::BranchImpRef(const char* branchname, const char *classname, TClass* ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); 1637{; 1638 TClass* claim = TClass::GetClass(classname);; 1639 if (!ptrClass) {; 1640 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1641 Error(""Branch"", writeStlWithoutProxyMsg,; 1642 claim->GetName(), branchname, claim->GetName());; 1643 return nullptr;; 1644 } else if (claim == nullptr) {; 1645 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT and %s is not a known class"", branchname, classname);; 1646 return nullptr;; 1647 }; 1648 ptrClass = claim;; 1649 }; 1650 TClass* actualClass = nullptr;; 1651 if (!addobj) {; 1652 Error(""Branch"", ""Reference interface requires a valid object (for branch: %s)!"", branchname);; 1653 return nullptr;; 1654 }; 1655 actualClass = ptrClass->GetActualClass(addobj);; 1656 if (ptrClass && claim) {; 1657 if (!(claim->InheritsFrom(ptrClass) || ptrClass->InheritsFrom(claim))) {; 1658 // Note we currently do not warn in case of splicing or over-expectation).; 1659 if (claim->IsLoaded() && ptrClass->IsLoaded() && strcmp( claim->GetTypeInfo()->name(), ptrClass->GetTypeInfo()->name() ) == 0) {; 1660 // The type is the same according to the C++ type_info, we must be in the case of; 1661 // a template of Double32_t. This is actually a correct case.; 1662 } else {; 1663 Error(""Branch"", ""The class requested (%s) for \""%s\"" is different from the type of the object passed (%s)"",; 166",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:66101,Integrability,interface,interface,66101,"Class->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 return Branch(branchname,addobj,varname.Data(),bufsize);; 1704 }; 1705 return nullptr;; 1706 }; 1707 TClass* actualClass = nullptr;; 1708 if (!addobj) {; 1709 Error(""Branch"", ""Reference interface requires a valid object (for branch: %s)!"", branchname);; 1710 return nullptr;; 1711 }; 1712 actualClass = ptrClass->GetActualClass(addobj);; 1713 if (!actualClass) {; 1714 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1715 branchname, ptrClass->GetName());; 1716 actualClass = ptrClass;; 1717 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1718 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1719 return nullptr;; 1720 }; 1721 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1722 Error(""Branch"", writeStlWithoutProxyMsg,; 1723 actualClass->GetName(), branchname, actualClass->GetName());; 1724 return nullptr;; 1725 }; 1726 return BronchExec(branchname, actualClass->GetNam",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:89991,Integrability,message,message,89991,";; 2239 }; 2240 nexti.Reset();; 2241 while ((rdi = (TRealData*) nexti())) {; 2242 if (rdi->TestBit(TRealData::kTransient)) continue;; 2243 ; 2244 if (!strcmp(rdi->GetName(), index)) {; 2245 break;; 2246 }; 2247 if (!strcmp(rdi->GetName(), aindex)) {; 2248 index = rdi->GetName();; 2249 break;; 2250 }; 2251 }; 2252 ; 2253 char vcode = DataTypeToChar((EDataType)code);; 2254 // Note that we differentiate between strings and; 2255 // char array by the fact that there is NO specified; 2256 // size for a string (see next if (code == 1); 2257 ; 2258 if (vcode) {; 2259 leaflist.Form(""%s[%s]/%c"", &rdname[0], index, vcode);; 2260 } else {; 2261 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2262 leaflist = """";; 2263 }; 2264 } else {; 2265 // We are possibly a character string.; 2266 if (code == 1) {; 2267 // We are a character string.; 2268 leaflist.Form(""%s/%s"", dname, ""C"");; 2269 } else {; 2270 // Invalid array specification.; 2271 // FIXME: We need an error message here.; 2272 continue;; 2273 }; 2274 }; 2275 // There are '*' in both the branchname and leaflist, remove them.; 2276 TString bname( branchname );; 2277 bname.ReplaceAll(""*"","""");; 2278 leaflist.ReplaceAll(""*"","""");; 2279 // Add the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, bra",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:91226,Integrability,message,message,91226," the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, branchname, pointer, leaflist, bufsize);; 2298 branch1->SetTitle(rdname);; 2299 blist->Add(branch1);; 2300 } else {; 2301 // We have a class type.; 2302 // Note: This cannot happen due to the rd->IsObject() test above.; 2303 // FIXME: Put an error message here just in case.; 2304 }; 2305 if (branch1) {; 2306 branch1->SetOffset(offset);; 2307 } else {; 2308 Warning(""BranchOld"", ""Cannot process member: '%s'"", rdname);; 2309 }; 2310 }; 2311 if (delobj) {; 2312 delete obj;; 2313 obj = nullptr;; 2314 }; 2315 return branch;; 2316}; 2317 ; 2318////////////////////////////////////////////////////////////////////////////////; 2319/// Build the optional branch supporting the TRefTable.; 2320/// This branch will keep all the information to find the branches; 2321/// containing referenced objects.; 2322///; 2323/// At each Tree::Fill, the branch numbers containing the; 2324/// referenced objects are saved to the TBranchRef basket.; 2325/// When the Tree header is saved (via TTree::Write), the branch; 2326/// is saved keeping the information with the pointers to the branches; 2327/// having referenced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRef) {; 2332 fBranchRef = new TBranchRef(this);; 2333 }; 2334 retu",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:113733,Integrability,message,message,113733,"ass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 2887 }; 2888 if (expectedClass && expectedClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(expectedClass->GetCollectionProxy())) {; 2889 Error(""SetBranchAddress"", ""Unable to determine the type given for the address for \""%s\"". ""; 2890 ""The class expected (%s) refers to an stl collection and do not have a compiled CollectionProxy. ""; 2891 ""Please generate the dictionary for this class (%s)"",; 2892 branch->GetName(), expectedClass->GetName(), expectedClass->GetName());; 2893 return kMissingComp",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:126299,Integrability,message,message,126299," in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAddress().; 3173 TObjArray* branches = newtree->GetListOfBranches();; 3174 Int_t nb = branches->GetEntriesFast();; 3175 for (Int_t i = 0; i < nb; ++i) {; 3176 TBranch* br = (TBranch*) branches->UncheckedAt(i);; 3177 if (br->InheritsFrom(TBranchElement::Class())) {; 3178 ((TBranchElement*) br)->ResetDeleteObject();; 3179 }; 3180 }; 3181 ; 31",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:134490,Integrability,rout,route,134490," was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 }",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:138263,Integrability,rout,routines,138263,"index);; 3474 break;; 3475 }; 3476 case kBuild:; 3477 if (newtree->GetEntries() == 0) {; 3478 // Start an index.; 3479 TVirtualIndex *index = (TVirtualIndex*) oldtree->GetTree()->GetTreeIndex()->Clone();; 3480 index->SetTree(newtree);; 3481 newtree->SetTreeIndex(index);; 3482 } else {; 3483 // Build the index so far.; 3484 if (newtree->BuildIndex(oldtree->GetTree()->GetTreeIndex()->GetMajorName(), oldtree->GetTree()->GetTreeIndex()->GetMinorName())) {; 3485 newtree->GetTreeIndex()->Append(oldtree->GetTree()->GetTreeIndex(), true);; 3486 }; 3487 }; 3488 break;; 3489 }; 3490 } else if ( onIndexError == kDrop ) {; 3491 // There is no index on this or on tree->GetTree(), we know we have to ignore any further; 3492 // index; 3493 withIndex = false;; 3494 }; 3495 return withIndex;; 3496 }; 3497}; 3498 ; 3499////////////////////////////////////////////////////////////////////////////////; 3500/// Copy nentries from given tree to this tree.; 3501/// This routines assumes that the branches that intended to be copied are; 3502/// already connected. The typical case is that this tree was created using; 3503/// tree->CloneTree(0).; 3504///; 3505/// By default copy all entries.; 3506///; 3507/// Returns number of bytes copied to this tree.; 3508///; 3509/// If 'option' contains the word 'fast' and nentries is -1, the cloning will be; 3510/// done without unzipping or unstreaming the baskets (i.e., a direct copy of the; 3511/// raw bytes on disk).; 3512///; 3513/// When 'fast' is specified, 'option' can also contains a sorting order for the; 3514/// baskets in the output file.; 3515///; 3516/// There are currently 3 supported sorting order:; 3517///; 3518/// - SortBasketsByOffset (the default); 3519/// - SortBasketsByBranch; 3520/// - SortBasketsByEntry; 3521///; 3522/// See TTree::CloneTree for a detailed explanation of the semantics of these 3 options.; 3523///; 3524/// If the tree or any of the underlying tree of the chain has an index, that index and any; 3525/// index in the",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:172462,Integrability,interface,interface,172462,"ed by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or opt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:182381,Integrability,interface,interface,182381," of the Tree and the y points the py values.; 4482///; 4483/// Important note: By default TTree::Draw creates the arrays obtained; 4484/// with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; 4485/// to the parameter fEstimate. The content will be the last `GetSelectedRows() % GetEstimate()`; 4486/// values calculated.; 4487/// By default fEstimate=1000000 and can be modified; 4488/// via TTree::SetEstimate. To keep in memory all the results (in case; 4489/// where there is only one result per entry), use; 4490/// ~~~ {.cpp}; 4491/// tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; 4492/// ~~~; 4493/// You must call SetEstimate if the expected number of selected rows; 4494/// you need to look at is greater than 1000000.; 4495///; 4496/// You can use the option ""goff"" to turn off the graphics output; 4497/// of TTree::Draw in the above example.; 4498///; 4499/// ### Automatic interface to TTree::Draw via the TTreeViewer; 4500///; 4501/// A complete graphical interface to this function is implemented; 4502/// in the class TTreeViewer.; 4503/// To start the TTreeViewer, three possibilities:; 4504/// - select TTree context menu item ""StartViewer""; 4505/// - type the command ""TTreeViewer TV(treeName)""; 4506/// - execute statement ""tree->StartViewer();""; 4507 ; 4508Long64_t TTree::Draw(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 4509{; 4510 GetPlayer();; 4511 if (fPlayer); 4512 return fPlayer->DrawSelect(varexp,selection,option,nentries,firstentry);; 4513 return -1;; 4514}; 4515 ; 4516////////////////////////////////////////////////////////////////////////////////; 4517/// Remove some baskets from memory.; 4518 ; 4519void TTree::DropBaskets(); 4520{; 4521 TBranch* branch = nullptr;; 4522 Int_t nb = fBranches.GetEntriesFast();; 4523 for (Int_t i = 0; i < nb; ++i) {; 4524 branch = (TBranch*) fBranches.UncheckedAt(i);; 4525 branch->DropBaskets(""all"");; 4526 }; 4527}; 452",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:182465,Integrability,interface,interface,182465," of the Tree and the y points the py values.; 4482///; 4483/// Important note: By default TTree::Draw creates the arrays obtained; 4484/// with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; 4485/// to the parameter fEstimate. The content will be the last `GetSelectedRows() % GetEstimate()`; 4486/// values calculated.; 4487/// By default fEstimate=1000000 and can be modified; 4488/// via TTree::SetEstimate. To keep in memory all the results (in case; 4489/// where there is only one result per entry), use; 4490/// ~~~ {.cpp}; 4491/// tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; 4492/// ~~~; 4493/// You must call SetEstimate if the expected number of selected rows; 4494/// you need to look at is greater than 1000000.; 4495///; 4496/// You can use the option ""goff"" to turn off the graphics output; 4497/// of TTree::Draw in the above example.; 4498///; 4499/// ### Automatic interface to TTree::Draw via the TTreeViewer; 4500///; 4501/// A complete graphical interface to this function is implemented; 4502/// in the class TTreeViewer.; 4503/// To start the TTreeViewer, three possibilities:; 4504/// - select TTree context menu item ""StartViewer""; 4505/// - type the command ""TTreeViewer TV(treeName)""; 4506/// - execute statement ""tree->StartViewer();""; 4507 ; 4508Long64_t TTree::Draw(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 4509{; 4510 GetPlayer();; 4511 if (fPlayer); 4512 return fPlayer->DrawSelect(varexp,selection,option,nentries,firstentry);; 4513 return -1;; 4514}; 4515 ; 4516////////////////////////////////////////////////////////////////////////////////; 4517/// Remove some baskets from memory.; 4518 ; 4519void TTree::DropBaskets(); 4520{; 4521 TBranch* branch = nullptr;; 4522 Int_t nb = fBranches.GetEntriesFast();; 4523 for (Int_t i = 0; i < nb; ++i) {; 4524 branch = (TBranch*) fBranches.UncheckedAt(i);; 4525 branch->DropBaskets(""all"");; 4526 }; 4527}; 452",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:205969,Integrability,interface,interface,205969,"mutex A.; 5120///; 5121/// At this point, the thread will deadlock: the code may function with IMT-mode; 5122/// disabled if the user assumed the legacy code never would run their own TBB; 5123/// tasks.; 5124///; 5125/// SO: users of TBB who want to enable IMT-mode should carefully review their; 5126/// locking patterns and make sure they hold no coarse-grained application; 5127/// locks when they invoke ROOT.; 5128///; 5129/// Return the number of bytes written or -1 in case of write error.; 5130Int_t TTree::FlushBaskets(bool create_cluster) const; 5131{; 5132 Int_t retval = FlushBasketsImpl();; 5133 if (retval == -1) return retval;; 5134 ; 5135 if (create_cluster) const_cast<TTree *>(this)->MarkEventCluster();; 5136 return retval;; 5137}; 5138 ; 5139////////////////////////////////////////////////////////////////////////////////; 5140/// Internal implementation of the FlushBaskets algorithm.; 5141/// Unlike the public interface, this does NOT create an explicit event cluster; 5142/// boundary; it is up to the (internal) caller to determine whether that should; 5143/// done.; 5144///; 5145/// Otherwise, the comments for FlushBaskets applies.; 5146///; 5147Int_t TTree::FlushBasketsImpl() const; 5148{; 5149 if (!fDirectory) return 0;; 5150 Int_t nbytes = 0;; 5151 Int_t nerror = 0;; 5152 TObjArray *lb = const_cast<TTree*>(this)->GetListOfBranches();; 5153 Int_t nb = lb->GetEntriesFast();; 5154 ; 5155#ifdef R__USE_IMT; 5156 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 5157 if (useIMT) {; 5158 // ROOT-9668: here we need to check if the size of fSortedBranches is different from the; 5159 // size of the list of branches before triggering the initialisation of the fSortedBranches; 5160 // container to cover two cases:; 5161 // 1. This is the first time we flush. fSortedBranches is empty and we need to fill it.; 5162 // 2. We flushed at least once already but a branch has been be added to the tree since then; 5163 if (fSortedBranches.size() != unsigned(",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:227817,Integrability,depend,depends,227817,"fe->TestBit(TFriendElement::kFromChain)) {; 5752 nb = t->GetEntry(t->GetReadEntry(),getall);; 5753 } else {; 5754 if ( t->LoadTreeFriend(entry,this) >= 0 ) {; 5755 nb = t->GetEntry(t->GetReadEntry(),getall);; 5756 } else nb = 0;; 5757 }; 5758 if (nb < 0) return nb;; 5759 nbytes += nb;; 5760 }; 5761 }; 5762 return nbytes;; 5763}; 5764 ; 5765 ; 5766////////////////////////////////////////////////////////////////////////////////; 5767/// Divides the top-level branches into two vectors: (i) branches to be; 5768/// processed sequentially and (ii) branches to be processed in parallel.; 5769/// Even if IMT is on, some branches might need to be processed first and in a; 5770/// sequential fashion: in the parallelization of GetEntry, those are the; 5771/// branches that store the size of another branch for every entry; 5772/// (e.g. the size of an array branch). If such branches were processed; 5773/// in parallel with the rest, there could be two threads invoking; 5774/// TBranch::GetEntry on one of them at the same time, since a branch that; 5775/// depends on a size (or count) branch will also invoke GetEntry on the latter.; 5776/// This method can be invoked several times during the event loop if the TTree; 5777/// is being written, for example when adding new branches. In these cases, the; 5778/// `checkLeafCount` parameter is false.; 5779/// \param[in] checkLeafCount True if we need to check whether some branches are; 5780/// count leaves.; 5781 ; 5782void TTree::InitializeBranchLists(bool checkLeafCount); 5783{; 5784 Int_t nbranches = fBranches.GetEntriesFast();; 5785 ; 5786 // The special branch fBranchRef needs to be processed sequentially:; 5787 // we add it once only.; 5788 if (fBranchRef && fBranchRef != fSeqBranches[0]) {; 5789 fSeqBranches.push_back(fBranchRef);; 5790 }; 5791 ; 5792 // The branches to be processed sequentially are those that are the leaf count of another branch; 5793 if (checkLeafCount) {; 5794 for (Int_t i = 0; i < nbranches; i++) {; 5795 TBra",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:264459,Integrability,interface,interface,264459,"sProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofilename, const char* cutfilename, const char* option, Int_t maxUnrolling); 6770{; 6771 GetPlayer();; 6772 if (!fPlayer) return 0;; 6773 return fPlayer->MakeProxy(proxyClassname,macrofilename,cutfilename,option,maxUnrolling);; 6774}; 6775 ; 6776////////////////////////////////////////////////////////////////////////////////; 6777/// Generate skeleton selector class for this tree.; 6778///; 6779/// The following files are produced: selector.h and selector.C.; 6780/// If selector is 0, the selector will be called ""nameoftre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:333251,Integrability,message,message,333251,"ranch is prefixed to the sub-branches'; 8508/// name (by adding a dot ('.') at the end of the Branch creation and use the; 8509/// corresponding bname.; 8510///; 8511/// I.e If your Tree has been created in split mode with a parent branch ""parent.""; 8512/// (note the trailing dot).; 8513/// ~~~ {.cpp}; 8514/// T.SetBranchStatus(""parent"",1);; 8515/// ~~~; 8516/// will not activate the sub-branches of ""parent"". You should do:; 8517/// ~~~ {.cpp}; 8518/// T.SetBranchStatus(""parent*"",1);; 8519/// ~~~; 8520/// Without the trailing dot in the branch creation you have no choice but to; 8521/// call SetBranchStatus explicitly for each of the sub branches.; 8522///; 8523/// An alternative to this function is to read directly and only; 8524/// the interesting branches. Example:; 8525/// ~~~ {.cpp}; 8526/// TBranch *brc = T.GetBranch(""c"");; 8527/// TBranch *bre = T.GetBranch(""e"");; 8528/// brc->GetEntry(i);; 8529/// bre->GetEntry(i);; 8530/// ~~~; 8531/// If found is not 0, the number of branch(es) found matching the regular; 8532/// expression is returned in *found AND the error message 'unknown branch'; 8533/// is suppressed.; 8534 ; 8535void TTree::SetBranchStatus(const char* bname, bool status, UInt_t* found); 8536{; 8537 // We already have been visited while recursively looking; 8538 // through the friends tree, let return; 8539 if (kSetBranchStatus & fFriendLockStatus) {; 8540 return;; 8541 }; 8542 ; 8543 if (!bname || !*bname) {; 8544 Error(""SetBranchStatus"", ""Input regexp is an empty string: no match against branch names will be attempted."");; 8545 return;; 8546 }; 8547 ; 8548 TBranch *branch, *bcount, *bson;; 8549 TLeaf *leaf, *leafcount;; 8550 ; 8551 Int_t i,j;; 8552 Int_t nleaves = fLeaves.GetEntriesFast();; 8553 TRegexp re(bname,true);; 8554 Int_t nb = 0;; 8555 ; 8556 // first pass, loop on all branches; 8557 // for leafcount branches activate/deactivate in function of status; 8558 for (i=0;i<nleaves;i++) {; 8559 leaf = (TLeaf*)fLeaves.UncheckedAt(i);; 8560 branch =",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342721,Integrability,interface,interface,342721,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:388475,Integrability,interface,interface,388475,"st TString &source) constReturn True if we have any rule whose source class is 'source'.Definition TSchemaRuleSet.cxx:199; ROOT::Internal::TBranchIMTHelperA helper class for managing IMT work during TTree:Fill operations.Definition TBranchIMTHelper.h:28; ROOT::Internal::TBranchIMTHelper::Waitvoid Wait()Definition TBranchIMTHelper.h:51; ROOT::Internal::TBranchIMTHelper::GetNerrorsLong64_t GetNerrors()Definition TBranchIMTHelper.h:58; ROOT::Internal::TBranchIMTHelper::GetNbytesLong64_t GetNbytes()Definition TBranchIMTHelper.h:57; ROOT::Internal::TParBranchProcessingRAIIDefinition TROOT.h:75; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::Setbool Set(EIOFeatures bits)Set a specific IO feature.Definition TIOFeatures.cxx:139; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::Foreachvoid Foreach(F func, unsigned nTimes, unsigned nChunks=0)Execute a function without arguments several times in parallel, dividing the execution in nChunks.Definition TThreadExecutor.hxx:146; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayI::Setvoid Set(Int_t n) overrideSet size of this array to n ints.Definition TArrayI.cxx:105; TArrayI::Streamervoid Streamer(TBuffer &) overrideStream a TArrayI object.Definition TArrayI.cxx:148; TArray::fNInt_t fNDefinition TArray.h:38; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::Streamervirtual void Streamer(TBuffer &); TAttFill::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TAttFi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:410561,Integrability,interface,interface,410561,"nter(Long64_t entry, TTree *tree=nullptr)Add entry #entry to the list.Definition TEntryList.cxx:631; TEntryList::SetTreevirtual void SetTree(const TTree *tree)If a list for a tree with such name and filename exists, sets it as the current sublist If not,...Definition TEntryList.cxx:1296; TEntryList::GetDirectoryvirtual TDirectory * GetDirectory() constDefinition TEntryList.h:77; TEntryList::SetReapplyCutvirtual void SetReapplyCut(bool apply=false)Definition TEntryList.h:108; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::GetEntryvirtual Long64_t GetEntry(Long64_t index)Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next().Definition TEntryList.cxx:759; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::GetEntryvirtual Long64_t GetEntry(Int_t index) constReturn value of entry at index in the list.Definition TEventList.cxx:227; TEventList::GetReapplyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:413375,Integrability,interface,interface,413375,"nectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::GetListOfFoldersTCollection * GetListOfFolders() constDefinition TFolder.h:55; TFolder::Occurencevirtual Int_t Occurence(const TObject *obj) constReturn occurence number of object in the list of objects of this folder.Definition TFolder.cxx:427; TFolder::Classstatic TClass * Class(); TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::ResetUpdatedvoid ResetUpdated()Definition TFriendElement.h:68; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreeNamevirtual const char * GetTreeName() constGet the actual TTree name of the friend.Definition TFriendElement.h:64; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Definition TFriendElement.cxx:217; TFriendElement::IsUpdatedbool IsUpdated() constDefinition TFriendElement.h:67; TFriendElement::GetFilevirtual TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:422191,Integrability,message,message,422191,"ion TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Notifyvirtual Bool_t Notify()This method must be overridden to handle object notification (the base implementation is no-op).Definition TObject.cxx:599; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::kBitMask@ kBitMaskDefinition TObject.h:86; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:423023,Integrability,message,message,423023,"rns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns na",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:423159,Integrability,message,message,423159,"nst char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::GetDataMemberTDataMember * GetDataMember() constDefinition TRealData.h:53; TRealDa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:423723,Integrability,message,message,423723,"its as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::GetDataMemberTDataMember * GetDataMember() constDefinition TRealData.h:53; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::IsObjectBool_t IsObject() constDefinition TRealData.h:56; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TRefTableA TRefTable maintains the association between a referenced object and the parent object supporting th...Definition TRefTable.h:35; TRefTable::SetRefTablestatic void SetRefTable(TRefTable *table)Static function setting the current TRefTable.Definition TRefTable.cxx:383; TRefTable::GetRefTablestatic TRefTable * GetRefTable()Static function returning the cur",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:460581,Integrability,interface,interface,460581,"dTree@ kLoadTreeDefinition TTree.h:221; TTree::kGetEntry@ kGetEntryDefinition TTree.h:216; TTree::kGetLeaf@ kGetLeafDefinition TTree.h:220; TTree::kRemoveFriend@ kRemoveFriendDefinition TTree.h:223; TTree::kGetFriendAlias@ kGetFriendAliasDefinition TTree.h:219; TTree::kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:467945,Integrability,interface,interface,467945,"ddTotBytes(Int_t tot)Definition TTree.h:331; TTree::CopyEntriesvirtual Long64_t CopyEntries(TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false)Copy nentries from given tree to this tree.Definition TTree.cxx:3534; TTree::fMakeClassInt_t fMakeClass! not zero when processing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:468562,Integrability,interface,interface,468562,"ition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:469406,Integrability,interface,interface,469406,"lCollectionProxy.h:52; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::Scanvirtual Long64_t Scan(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves()=0; TVirtualTreePlayer::DrawSelectvirtual Long64_t DrawSelect(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:469567,Integrability,interface,interface,469567,"erface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::Scanvirtual Long64_t Scan(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves()=0; TVirtualTreePlayer::DrawSelectvirtual Long64_t DrawSelect(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::MakeCodevirtual Int_t MakeCode(const char *filename)=0; TVirtualTreePlayer::UnbinnedFitvirtual Int_t UnbinnedFit(const char *formula, const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::GetEntriesvirtual Long64_t GetEntries(const char *)=0; TVirtualTreePlayer::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnro",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:3355,Modifiability,variab,variables,3355," 43Making several branches is particularly interesting in the data analysis phase,; 44when it is desirable to have a high reading rate and not all columns are equally interesting; 45 ; 46\anchor creatingattreetoc; 47## Create a TTree to store columnar data; 48- [Construct a TTree](\ref creatingattree); 49- [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); 50- [Add a column of a STL Collection instances](\ref addingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appen",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:3733,Modifiability,variab,variables,3733,"rays thereof](\ref addcolumnoffundamentaltypes); 50- [Add a column of a STL Collection instances](\ref addingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string termina",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4073,Modifiability,variab,variable,4073,"e); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`)",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4143,Modifiability,variab,variable,4143,"e); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`)",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4165,Modifiability,variab,variable,4165,"e); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`)",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4217,Modifiability,variab,variable,4217,"nds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating poin",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4414,Modifiability,variab,variable,4414,"bject or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4469,Modifiability,variab,variable,4469,"bject or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:4492,Modifiability,variab,variable,4492,"e creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a z",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:5674,Modifiability,variab,variable,5674,"o effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to r",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:5772,Modifiability,variab,variable,5772,"o effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to r",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:5912,Modifiability,variab,variable,5912,"o effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 93 - `b` : an 8 bit unsigned integer (`UChar_t`); 94 - `S` : a 16 bit signed integer (`Short_t`); 95 - `s` : a 16 bit unsigned integer (`UShort_t`); 96 - `I` : a 32 bit signed integer (`Int_t`); 97 - `i` : a 32 bit unsigned integer (`UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to r",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:6012,Modifiability,variab,variable,6012,"UInt_t`); 98 - `F` : a 32 bit floating point (`Float_t`); 99 - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 100 - `D` : a 64 bit floating point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to read it back on a; 123 platform with a different padding strategy).; 124 We recommend to persistify objects rather than composite leaflists.; 125- In case of the truncated floating point types (Float16_t and Double32_t) you can; 126 furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 127 the type character. For example, for storing a variable size array `myArr` of; 128 `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; 129 in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; 130 be: `myArr[myArrSize]/d[0,twopi]`. Of course the number ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:6181,Modifiability,variab,variable,6181,"g point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to read it back on a; 123 platform with a different padding strategy).; 124 We recommend to persistify objects rather than composite leaflists.; 125- In case of the truncated floating point types (Float16_t and Double32_t) you can; 126 furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 127 the type character. For example, for storing a variable size array `myArr` of; 128 `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; 129 in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; 130 be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; 131 the standard rules of opaque typedefs annotation are valid. For example, if only; 132 18 bits were sufficient, the syntax woul",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:6227,Modifiability,variab,variable,6227,"g point (`Double_t`); 101 - `d` : a 24 bit truncated floating point (`Double32_t`); 102 - `L` : a 64 bit signed integer (`Long64_t`); 103 - `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to read it back on a; 123 platform with a different padding strategy).; 124 We recommend to persistify objects rather than composite leaflists.; 125- In case of the truncated floating point types (Float16_t and Double32_t) you can; 126 furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 127 the type character. For example, for storing a variable size array `myArr` of; 128 `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; 129 in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; 130 be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; 131 the standard rules of opaque typedefs annotation are valid. For example, if only; 132 18 bits were sufficient, the syntax woul",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:6317,Modifiability,portab,portable,6317,"- `l` : a 64 bit unsigned integer (`ULong64_t`); 104 - `G` : a long signed integer, stored as 64 bit (`Long_t`); 105 - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 106 - `O` : [the letter `o`, not a zero] a boolean (`bool`); 107 ; 108 Examples:; 109 - A int: ""myVar/I""; 110 - A float array with fixed size: ""myArrfloat[42]/F""; 111 - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; 112 - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to read it back on a; 123 platform with a different padding strategy).; 124 We recommend to persistify objects rather than composite leaflists.; 125- In case of the truncated floating point types (Float16_t and Double32_t) you can; 126 furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 127 the type character. For example, for storing a variable size array `myArr` of; 128 `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; 129 in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; 130 be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; 131 the standard rules of opaque typedefs annotation are valid. For example, if only; 132 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`; 133 ; 134\anchor addingacolumnofstl; 135## Adding a column holding STL collection instances (e.",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:6729,Modifiability,variab,variable,6729,"6: ""myArr[myvar]/d[0,10]""; 113 - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I).; 114 ; 115- If the address points to a single numerical variable, the leaflist is optional:; 116~~~ {.cpp}; 117 int value;; 118 tree->Branch(branchname, &value);; 119~~~; 120- If the address points to more than one numerical variable, we strongly recommend; 121 that the variable be sorted in decreasing order of size. Any other order will; 122 result in a non-portable TTree (i.e. you will not be able to read it back on a; 123 platform with a different padding strategy).; 124 We recommend to persistify objects rather than composite leaflists.; 125- In case of the truncated floating point types (Float16_t and Double32_t) you can; 126 furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 127 the type character. For example, for storing a variable size array `myArr` of; 128 `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; 129 in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; 130 be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; 131 the standard rules of opaque typedefs annotation are valid. For example, if only; 132 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`; 133 ; 134\anchor addingacolumnofstl; 135## Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map); 136 ; 137~~~ {.cpp}; 138 auto branch = tree.Branch( branchname, STLcollection, buffsize, splitlevel);; 139~~~; 140STLcollection is the address of a pointer to std::vector, std::list,; 141std::deque, std::set or std::multiset containing pointers to objects.; 142If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); 143then the collection will be written in split mode, e.g. if it contains objects of; 144any types deriving from TTrack this function will sort the",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:11658,Modifiability,variab,variable,11658,"212*It is recommended to use STL containers instead of TClonesArrays*.; 213 ; 214~~~ {.cpp}; 215 // clonesarray is the address of a pointer to a TClonesArray.; 216 auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); 217~~~; 218The TClonesArray is a direct access list of objects of the same class.; 219For example, if the TClonesArray is an array of TTrack objects,; 220this function will create one subbranch for each data member of; 221the object TTrack.; 222 ; 223\anchor fillthetree; 224## Fill the Tree; 225 ; 226A TTree instance is filled with the invocation of the TTree::Fill method:; 227~~~ {.cpp}; 228 tree.Fill(); 229~~~; 230Upon its invocation, a loop on all defined branches takes place that for each branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingtree; 234## Add a column to an already existing Tree; 235 ; 236You may want to add a branch to an existing tree. For example,; 237if one variable in the tree was computed with a certain algorithm,; 238you may want to try another algorithm and compare the results.; 239One solution is to add a new branch, fill it, and save the tree.; 240The code below adds a simple branch to an existing tree.; 241Note the kOverwrite option in the Write method, it overwrites the; 242existing tree. If it is not specified, two copies of the tree headers; 243are saved.; 244~~~ {.cpp}; 245 void tree3AddBranch() {; 246 TFile f(""tree3.root"", ""update"");; 247 ; 248 Float_t new_v;; 249 auto t3 = f->Get<TTree>(""t3"");; 250 auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; 251 ; 252 Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; 253 ; 254 for (Long64_t i = 0; i < nentries; i++) {; 255 new_v = gRandom->Gaus(0, 1);; 256 newBranch->Fill();; 257 }; 258 ; 259 t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; 260 }; 261~~~; 262It is not always possible to add branches to existing datasets stored in TFiles: for example,; 263these files might",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:45524,Modifiability,variab,variable,45524,"riesReshuffled bit set and cannot have friends nor can be added as a friend unless the ""; 1254 ""main tree has a TTreeIndex on the friend tree '%s'. You can also unset the bit manually if you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:46053,Modifiability,variab,variables,46053,"////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:46822,Modifiability,variab,variables,46822," branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47025,Modifiability,variab,variablename,47025," a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entrie",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47073,Modifiability,variab,variable,47073," a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entrie",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47207,Modifiability,variab,variable,47207,"6/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entries are not included in the histogram.; 1321/// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; 1322/// When the tree is written to file (TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47256,Modifiability,variab,variable,47256,"6/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entries are not included in the histogram.; 1321/// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; 1322/// When the tree is written to file (TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47288,Modifiability,variab,variable,47288,"6/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entries are not included in the histogram.; 1321/// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; 1322/// When the tree is written to file (TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:59660,Modifiability,inherit,inherit,59660,"le32_t. This is actually a correct case.; 1577 } else {; 1578 Error(""Branch"", ""The class requested (%s) for \""%s\"" is different from the type of the pointer passed (%s)"",; 1579 claim->GetName(), branchname, ptrClass->GetName());; 1580 }; 1581 } else if (actualClass && (claim != actualClass) && !actualClass->InheritsFrom(claim)) {; 1582 if (claim->IsLoaded() && actualClass->IsLoaded() && strcmp( claim->GetTypeInfo()->name(), actualClass->GetTypeInfo()->name() ) == 0) {; 1583 // The type is the same according to the C++ type_info, we must be in the case of; 1584 // a template of Double32_t. This is actually a correct case.; 1585 } else {; 1586 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1587 actualClass->GetName(), branchname, claim->GetName());; 1588 }; 1589 }; 1590 }; 1591 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1592 Error(""Branch"", writeStlWithoutProxyMsg,; 1593 claim->GetName(), branchname, claim->GetName());; 1594 return nullptr;; 1595 }; 1596 return Branch(branchname, classname, (void*) addobj, bufsize, splitlevel);; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Same as TTree::Branch but automatic detection of the class name.; 1601/// \see TTree::Branch for other details.; 1602 ; 1603TBranch* TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:61244,Modifiability,inherit,inherit,61244,"plitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1615 branchname, ptrClass->GetName());; 1616 actualClass = ptrClass;; 1617 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1618 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1619 return nullptr;; 1620 }; 1621 } else {; 1622 actualClass = ptrClass;; 1623 }; 1624 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1625 Error(""Branch"", writeStlWithoutProxyMsg,; 1626 actualClass->GetName(), branchname, actualClass->GetName());; 1627 return nullptr;; 1628 }; 1629 return Branch(branchname, actualClass->GetName(), (void*) addobj, bufsize, splitlevel);; 1630}; 1631 ; 1632////////////////////////////////////////////////////////////////////////////////; 1633/// Same as TTree::Branch but automatic detection of the class name.; 1634/// \see TTree::Branch for other details.; 1635 ; 1636TBranch* TTree::BranchImpRef(const char* branchname, const char *classname, TClass* ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); 1637{; 1638 TClass* claim = TClass::GetClass(classname);; 1639 if (!ptrClass) {; 1640 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1641 Error(""Branch"", writeStlWithoutProxyMsg,; 1642 claim->GetName(), branch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:64162,Modifiability,inherit,inherit,64162,"TypeInfo()->name(), ptrClass->GetTypeInfo()->name() ) == 0) {; 1660 // The type is the same according to the C++ type_info, we must be in the case of; 1661 // a template of Double32_t. This is actually a correct case.; 1662 } else {; 1663 Error(""Branch"", ""The class requested (%s) for \""%s\"" is different from the type of the object passed (%s)"",; 1664 claim->GetName(), branchname, ptrClass->GetName());; 1665 }; 1666 } else if (actualClass && (claim != actualClass) && !actualClass->InheritsFrom(claim)) {; 1667 if (claim->IsLoaded() && actualClass->IsLoaded() && strcmp( claim->GetTypeInfo()->name(), actualClass->GetTypeInfo()->name() ) == 0) {; 1668 // The type is the same according to the C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, buf",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:64750,Modifiability,inherit,inherit,64750," C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 retur",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:66737,Modifiability,inherit,inherit,66737," object (for branch: %s)!"", branchname);; 1710 return nullptr;; 1711 }; 1712 actualClass = ptrClass->GetActualClass(addobj);; 1713 if (!actualClass) {; 1714 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1715 branchname, ptrClass->GetName());; 1716 actualClass = ptrClass;; 1717 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1718 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1719 return nullptr;; 1720 }; 1721 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1722 Error(""Branch"", writeStlWithoutProxyMsg,; 1723 actualClass->GetName(), branchname, actualClass->GetName());; 1724 return nullptr;; 1725 }; 1726 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1727}; 1728 ; 1729////////////////////////////////////////////////////////////////////////////////; 1730// Wrapper to turn Branch call with an std::array into the relevant leaf list; 1731// call; 1732TBranch *TTree::BranchImpArr(const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize,; 1733 Int_t /* splitlevel */); 1734{; 1735 if (datatype == kOther_t || datatype == kNoType_t) {; 1736 Error(""Branch"",; 1737 ""The inner type of the std::array passed specified for %s is not of a class or type known to ROOT"",; 1738 branchname);; 1739 } else {; 1740 TString varname;; 1741 varname.Form(""%s[%d]/%c"", branchname, (int)N, DataTypeToChar(datatype));; 1742 return Branch(branchname, addobj, varname.Data(), bufsize);; 1743 }; 1744 return nullptr;; 1745}; 1746 ; 1747////////////////////////////////////////////////////////////////////////////////; 1748/// Deprecated f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75080,Modifiability,variab,variables,75080,"A() == TFolder::Class()) {; 1899 Branch(curname, bufsize, splitlevel - 1);; 1900 } else {; 1901 void* add = (void*) folder->GetListOfFolders()->GetObjectRef(obj);; 1902 for (Int_t i = 0; i < 1000; ++i) {; 1903 if (curname[i] == 0) {; 1904 break;; 1905 }; 1906 if (curname[i] == '/') {; 1907 curname[i] = '.';; 1908 }; 1909 }; 1910 Int_t noccur = folder->Occurence(obj);; 1911 if (noccur > 0) {; 1912 snprintf(occur,20, ""_%d"", noccur);; 1913 strlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character w",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75135,Modifiability,variab,variables,75135,"A() == TFolder::Class()) {; 1899 Branch(curname, bufsize, splitlevel - 1);; 1900 } else {; 1901 void* add = (void*) folder->GetListOfFolders()->GetObjectRef(obj);; 1902 for (Int_t i = 0; i < 1000; ++i) {; 1903 if (curname[i] == 0) {; 1904 break;; 1905 }; 1906 if (curname[i] == '/') {; 1907 curname[i] = '.';; 1908 }; 1909 }; 1910 Int_t noccur = folder->Occurence(obj);; 1911 if (noccur > 0) {; 1912 snprintf(occur,20, ""_%d"", noccur);; 1913 strlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character w",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75514,Modifiability,variab,variable,75514,"rlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75594,Modifiability,variab,variable,75594,"rlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75616,Modifiability,variab,variable,75616,"rlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75673,Modifiability,variab,variable,75673,"e, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit floating point (`Double_t`); 1952/// - `d` : a 24 bit truncated floating point (`Double32_t`); 1953/// - `L` : a 64 bit signed",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75761,Modifiability,variab,variable,75761,"] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit floating point (`Double_t`); 1952/// - `d` : a 24 bit truncated floating point (`Double32_t`); 1953/// - `L` : a 64 bit signed integer (`Long64_t`); 1954/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 1955/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75821,Modifiability,variab,variable,75821,"] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit floating point (`Double_t`); 1952/// - `d` : a 24 bit truncated floating point (`Double32_t`); 1953/// - `L` : a 64 bit signed integer (`Long64_t`); 1954/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 1955/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75844,Modifiability,variab,variable,75844,"////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit floating point (`Double_t`); 1952/// - `d` : a 24 bit truncated floating point (`Double32_t`); 1953/// - `L` : a 64 bit signed integer (`Long64_t`); 1954/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 1955/// - `G` : a long signed integer, stored as 64 bit (`Long_t`); 1956/// - `g` : a long unsigned integer,",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:77181,Modifiability,variab,variable,77181,"e may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 1944/// - `b` : an 8 bit unsigned integer (`UChar_t`); 1945/// - `S` : a 16 bit signed integer (`Short_t`); 1946/// - `s` : a 16 bit unsigned integer (`UShort_t`); 1947/// - `I` : a 32 bit signed integer (`Int_t`); 1948/// - `i` : a 32 bit unsigned integer (`UInt_t`); 1949/// - `F` : a 32 bit floating point (`Float_t`); 1950/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 1951/// - `D` : a 64 bit floating point (`Double_t`); 1952/// - `d` : a 24 bit truncated floating point (`Double32_t`); 1953/// - `L` : a 64 bit signed integer (`Long64_t`); 1954/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 1955/// - `G` : a long signed integer, stored as 64 bit (`Long_t`); 1956/// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); 1957/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 1958///; 1959/// Arrays of values are supported with the following syntax:; 1960/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 1961/// if nelem is a leaf name, it is used as the variable size of the array,; 1962/// otherwise return 0.; 1963/// The leaf referred to by nelem **MUST** be an int (/I),; 1964/// - If leaf name has the form var[nelem], where nelem is a non-negative integer, then; 1965/// it is used as the fixed size of the array.; 1966/// - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); 1967/// where nelem and nelem2 are non-negative integer) then; 1968/// it is used as a 2 dimensional array of fixed size.; 1969/// - In case of t",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:83249,Modifiability,inherit,inherit,83249,"d B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 1 */); 2076{; 2077 TClass* cl = TClass::GetClass(classname);; 2078 if (!cl) {; 2079 Error(""BranchOld"", ""Cannot find class: '%s'"", classname);; 2080 return nullptr;; 2081 }; 2082 if (!cl->IsTObject()) {; 2083 if (fgBranchStyle == 0) {; 2084 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2085 ""\tfgBranchStyle is set to zero requesting by default to use BranchOld.\n""; 2086 ""\tIf this is intentional use Bronch instead of Branch or BranchOld."", classname);; 2087 } else {; 2088 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2089 ""\tYou can not use BranchOld to store objects of this type."",classname);; 2090 }; 2091 return nullptr;; 2092 }; 2093 TBranch* branch = new TBranchObject(this, name, classname, addobj, bufsize, splitlevel);; 2094 fBranches.Add(branch);; 2095 if (!splitlevel) {; 2096 return branch;; 2097 }; 2098 // We are going to fully split the class now.; 2099 TObjArray* blist = branch->GetListOfBranches();; 2100 const char* rdname = nullptr;; 2101 const char* dname = nullptr;; 2102 TString branchn",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:83521,Modifiability,inherit,inherit,83521," value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 1 */); 2076{; 2077 TClass* cl = TClass::GetClass(classname);; 2078 if (!cl) {; 2079 Error(""BranchOld"", ""Cannot find class: '%s'"", classname);; 2080 return nullptr;; 2081 }; 2082 if (!cl->IsTObject()) {; 2083 if (fgBranchStyle == 0) {; 2084 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2085 ""\tfgBranchStyle is set to zero requesting by default to use BranchOld.\n""; 2086 ""\tIf this is intentional use Bronch instead of Branch or BranchOld."", classname);; 2087 } else {; 2088 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2089 ""\tYou can not use BranchOld to store objects of this type."",classname);; 2090 }; 2091 return nullptr;; 2092 }; 2093 TBranch* branch = new TBranchObject(this, name, classname, addobj, bufsize, splitlevel);; 2094 fBranches.Add(branch);; 2095 if (!splitlevel) {; 2096 return branch;; 2097 }; 2098 // We are going to fully split the class now.; 2099 TObjArray* blist = branch->GetListOfBranches();; 2100 const char* rdname = nullptr;; 2101 const char* dname = nullptr;; 2102 TString branchname;; 2103 char** apointer = (char**) addobj;; 2104 TObject* obj = (TObject*) *apointer;; 2105 bool delobj = false;; 2106 if (!obj) {; 2107 obj = (TObject*) cl->New();; 2108 delobj = true;; 2109 }; 2110 // Build the StreamerInfo if first time for the class.; 2111 BuildStreamerInfo(cl, obj);; 2112 // Loop on all public data members of the class and its base classes.; 2113 Int_t lenName = strlen(name);; 2114 Int_t isDot = 0;; 2115 if (name[lenNa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:105562,Modifiability,variab,variable,105562,"uildStreamerInfo(TClass* cl, void* pointer /* = 0 */, bool canOptimize /* = true */ ); 2654{; 2655 if (!cl) {; 2656 return nullptr;; 2657 }; 2658 cl->BuildRealData(pointer);; 2659 TStreamerInfo* sinfo = (TStreamerInfo*)cl->GetStreamerInfo(cl->GetClassVersion());; 2660 ; 2661 // Create StreamerInfo for all base classes.; 2662 TBaseClass* base = nullptr;; 2663 TIter nextb(cl->GetListOfBases());; 2664 while((base = (TBaseClass*) nextb())) {; 2665 if (base->IsSTLContainer()) {; 2666 continue;; 2667 }; 2668 TClass* clm = TClass::GetClass(base->GetName());; 2669 BuildStreamerInfo(clm, pointer, canOptimize);; 2670 }; 2671 if (sinfo && fDirectory) {; 2672 sinfo->ForceWriteInfo(fDirectory->GetFile());; 2673 }; 2674 return sinfo;; 2675}; 2676 ; 2677////////////////////////////////////////////////////////////////////////////////; 2678/// Enable the TTreeCache unless explicitly disabled for this TTree by; 2679/// a prior call to `SetCacheSize(0)`.; 2680/// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; 2681/// `TTreeCache.Size` has been set to zero, this call will over-ride them with; 2682/// a value of 1.0 (i.e. use a cache size to hold 1 cluster); 2683///; 2684/// Return true if there is a cache attached to the `TTree` (either pre-exisiting; 2685/// or created as part of this call); 2686bool TTree::EnableCache(); 2687{; 2688 TFile* file = GetCurrentFile();; 2689 if (!file); 2690 return false;; 2691 // Check for an existing cache; 2692 TTreeCache* pf = GetReadCache(file);; 2693 if (pf); 2694 return true;; 2695 if (fCacheUserSet && fCacheSize == 0); 2696 return false;; 2697 return (0 == SetCacheSizeAux(true, -1));; 2698}; 2699 ; 2700////////////////////////////////////////////////////////////////////////////////; 2701/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; 2702/// Create a new file. If the original file is named ""myfile.root"",; 2703/// subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc.; 2704///; 2705/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:105608,Modifiability,config,config,105608,"uildStreamerInfo(TClass* cl, void* pointer /* = 0 */, bool canOptimize /* = true */ ); 2654{; 2655 if (!cl) {; 2656 return nullptr;; 2657 }; 2658 cl->BuildRealData(pointer);; 2659 TStreamerInfo* sinfo = (TStreamerInfo*)cl->GetStreamerInfo(cl->GetClassVersion());; 2660 ; 2661 // Create StreamerInfo for all base classes.; 2662 TBaseClass* base = nullptr;; 2663 TIter nextb(cl->GetListOfBases());; 2664 while((base = (TBaseClass*) nextb())) {; 2665 if (base->IsSTLContainer()) {; 2666 continue;; 2667 }; 2668 TClass* clm = TClass::GetClass(base->GetName());; 2669 BuildStreamerInfo(clm, pointer, canOptimize);; 2670 }; 2671 if (sinfo && fDirectory) {; 2672 sinfo->ForceWriteInfo(fDirectory->GetFile());; 2673 }; 2674 return sinfo;; 2675}; 2676 ; 2677////////////////////////////////////////////////////////////////////////////////; 2678/// Enable the TTreeCache unless explicitly disabled for this TTree by; 2679/// a prior call to `SetCacheSize(0)`.; 2680/// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; 2681/// `TTreeCache.Size` has been set to zero, this call will over-ride them with; 2682/// a value of 1.0 (i.e. use a cache size to hold 1 cluster); 2683///; 2684/// Return true if there is a cache attached to the `TTree` (either pre-exisiting; 2685/// or created as part of this call); 2686bool TTree::EnableCache(); 2687{; 2688 TFile* file = GetCurrentFile();; 2689 if (!file); 2690 return false;; 2691 // Check for an existing cache; 2692 TTreeCache* pf = GetReadCache(file);; 2693 if (pf); 2694 return true;; 2695 if (fCacheUserSet && fCacheSize == 0); 2696 return false;; 2697 return (0 == SetCacheSizeAux(true, -1));; 2698}; 2699 ; 2700////////////////////////////////////////////////////////////////////////////////; 2701/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; 2702/// Create a new file. If the original file is named ""myfile.root"",; 2703/// subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc.; 2704///; 2705/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:118044,Modifiability,extend,extend,118044,"amerInfo( expectedClass, bEl->GetClassVersion() ) &&; 2947 !ptrClass->FindConversionStreamerInfo( expectedClass, bEl->GetCheckSum() ) ) {; 2948 Error(""SetBranchAddress"", ""The pointer type given \""%s\"" does not correspond to the type needed \""%s\"" by the branch: %s"", ptrClass->GetName(), bEl->GetClassName(), branch->GetName());; 2949 ; 2950 bEl->SetTargetClass( expectedClass->GetName() );; 2951 return kClassMismatch;; 2952 }; 2953 else {; 2954 ; 2955 bEl->SetTargetClass( ptrClass->GetName() );; 2956 return kMatchConversion;; 2957 }; 2958 ; 2959 } else if (expectedClass && ptrClass && !expectedClass->InheritsFrom(ptrClass)) {; 2960 ; 2961 if (expectedClass->GetCollectionProxy() && ptrClass->GetCollectionProxy() &&; 2962 isBranchElement &&; 2963 expectedClass->GetCollectionProxy()->GetValueClass() &&; 2964 ptrClass->GetCollectionProxy()->GetValueClass() ); 2965 {; 2966 // In case of collection, we know how to convert them, if we know how to convert their content.; 2967 // NOTE: we need to extend this to std::pair ...; 2968 ; 2969 TClass *onfileValueClass = expectedClass->GetCollectionProxy()->GetValueClass();; 2970 TClass *inmemValueClass = ptrClass->GetCollectionProxy()->GetValueClass();; 2971 ; 2972 if (inmemValueClass->GetSchemaRules() &&; 2973 inmemValueClass->GetSchemaRules()->HasRuleWithSourceClass(onfileValueClass->GetName() ) ); 2974 {; 2975 TBranchElement* bEl = (TBranchElement*)branch;; 2976 bEl->SetTargetClass( ptrClass->GetName() );; 2977 return kMatchConversionCollection;; 2978 }; 2979 }; 2980 ; 2981 Error(""SetBranchAddress"", ""The pointer type given (%s) does not correspond to the class needed (%s) by the branch: %s"", ptrClass->GetName(), expectedClass->GetName(), branch->GetName());; 2982 if (isBranchElement) {; 2983 TBranchElement* bEl = (TBranchElement*)branch;; 2984 bEl->SetTargetClass( expectedClass->GetName() );; 2985 }; 2986 return kClassMismatch;; 2987 ; 2988 } else if ((expectedType != kOther_t) && (datatype != kOther_t) && (expectedType != kNoType",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:152729,Modifiability,variab,variables,152729,"orms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; 3871/// on the y-axis versus ""e2"" on the x-axis; 3872/// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3873/// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; 3874/// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3875/// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; 3876/// (to create histograms in the 2, 3, and 4 dimensional case,; 3877/// see section ""Saving the result of Draw to an histogram""); 3878/// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; 3879/// - Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; 3880/// - An arbitrary number of variables can be used with the option ""GOFF""; 3881///; 3882/// Examples:; 3883/// - ""x"": the simplest case, it draws a 1-Dim histogram of column x; 3884/// - ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; 3885/// - ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); 3886/// - ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz; 3887/// and the color number of each marker will be 2.5*E.; 3888/// If the color number is negative it is set to 0.; 3889/// If the color number is greater than the current number of colors; 3890/// it is set to the highest color number. The default number of; 3891/// colors is 50. See TStyle::SetPalette for setting a new color palette.; 3892///; 3893/// The expressions can use all the operations and built-in functions; 3894/// supported by TFormula (see TFormula::Analyze()), including free; 3895/// functions taking numerical arguments (e.g. TMath::Bessel()).; 3896/// In addition, you can call member functions taking numerical; 3897/// arguments. For example, these are two valid expressions:; 38",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:152840,Modifiability,variab,variables,152840,"orms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; 3871/// on the y-axis versus ""e2"" on the x-axis; 3872/// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3873/// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; 3874/// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3875/// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; 3876/// (to create histograms in the 2, 3, and 4 dimensional case,; 3877/// see section ""Saving the result of Draw to an histogram""); 3878/// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; 3879/// - Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; 3880/// - An arbitrary number of variables can be used with the option ""GOFF""; 3881///; 3882/// Examples:; 3883/// - ""x"": the simplest case, it draws a 1-Dim histogram of column x; 3884/// - ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; 3885/// - ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); 3886/// - ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz; 3887/// and the color number of each marker will be 2.5*E.; 3888/// If the color number is negative it is set to 0.; 3889/// If the color number is greater than the current number of colors; 3890/// it is set to the highest color number. The default number of; 3891/// colors is 50. See TStyle::SetPalette for setting a new color palette.; 3892///; 3893/// The expressions can use all the operations and built-in functions; 3894/// supported by TFormula (see TFormula::Analyze()), including free; 3895/// functions taking numerical arguments (e.g. TMath::Bessel()).; 3896/// In addition, you can call member functions taking numerical; 3897/// arguments. For example, these are two valid expressions:; 38",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:158031,Modifiability,variab,variable,158031,"he tree; 3959/// |-----------------|--------------------------------------------------------|; 3960/// | `fMatrix` | the 9 elements of fMatrix |; 3961/// | `fMatrix[][]` | the 9 elements of fMatrix |; 3962/// | `fMatrix[2][2]` | only the elements fMatrix[2][2] |; 3963/// | `fMatrix[1]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3964/// | `fMatrix[1][]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3965/// | `fMatrix[][0]` | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |; 3966///; 3967/// ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; 3968///; 3969/// In summary, if a specific index is not specified for a dimension, TTree::Draw; 3970/// will loop through all the indices along this dimension. Leaving off the; 3971/// last (right most) dimension of specifying then with the two characters '[]'; 3972/// is equivalent. For variable size arrays (and TClonesArray) the range; 3973/// of the first dimension is recalculated for each entry of the tree.; 3974/// You can also specify the index as an expression of any other variables from the; 3975/// tree.; 3976///; 3977/// TTree::Draw also now properly handling operations involving 2 or more arrays.; 3978///; 3979/// Let assume a second matrix fResults[5][2], here are a sample of some; 3980/// of the possible combinations, the number of elements they produce and; 3981/// the loop used:; 3982///; 3983/// | expression | element(s) | Loop |; 3984/// |----------------------------------|------------|--------------------------|; 3985/// | `fMatrix[2][1] - fResults[5][2]` | one | no loop |; 3986/// | `fMatrix[2][] - fResults[5][2]` | three | on 2nd dim fMatrix |; 3987/// | `fMatrix[2][] - fResults[5][]` | two | on both 2nd dimensions |; 3988/// | `fMatrix[][2] - fResults[][1]` | three | on both 1st dimensions |; 3989/// | `fMatrix[][2] - fResults[][]` | six | on both 1st and 2nd dimensions of fResults |; 3990/// | `fMatrix[][2",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:158227,Modifiability,variab,variables,158227,"the 9 elements of fMatrix |; 3961/// | `fMatrix[][]` | the 9 elements of fMatrix |; 3962/// | `fMatrix[2][2]` | only the elements fMatrix[2][2] |; 3963/// | `fMatrix[1]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3964/// | `fMatrix[1][]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3965/// | `fMatrix[][0]` | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |; 3966///; 3967/// ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; 3968///; 3969/// In summary, if a specific index is not specified for a dimension, TTree::Draw; 3970/// will loop through all the indices along this dimension. Leaving off the; 3971/// last (right most) dimension of specifying then with the two characters '[]'; 3972/// is equivalent. For variable size arrays (and TClonesArray) the range; 3973/// of the first dimension is recalculated for each entry of the tree.; 3974/// You can also specify the index as an expression of any other variables from the; 3975/// tree.; 3976///; 3977/// TTree::Draw also now properly handling operations involving 2 or more arrays.; 3978///; 3979/// Let assume a second matrix fResults[5][2], here are a sample of some; 3980/// of the possible combinations, the number of elements they produce and; 3981/// the loop used:; 3982///; 3983/// | expression | element(s) | Loop |; 3984/// |----------------------------------|------------|--------------------------|; 3985/// | `fMatrix[2][1] - fResults[5][2]` | one | no loop |; 3986/// | `fMatrix[2][] - fResults[5][2]` | three | on 2nd dim fMatrix |; 3987/// | `fMatrix[2][] - fResults[5][]` | two | on both 2nd dimensions |; 3988/// | `fMatrix[][2] - fResults[][1]` | three | on both 1st dimensions |; 3989/// | `fMatrix[][2] - fResults[][]` | six | on both 1st and 2nd dimensions of fResults |; 3990/// | `fMatrix[][2] - fResults[3][]` | two | on 1st dim of fMatrix and 2nd of fResults (at the same time) |; 3991/// | `fMatrix[][] - f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:159876,Modifiability,variab,variable,159876,"`fMatrix[][2] - fResults[][1]` | three | on both 1st dimensions |; 3989/// | `fMatrix[][2] - fResults[][]` | six | on both 1st and 2nd dimensions of fResults |; 3990/// | `fMatrix[][2] - fResults[3][]` | two | on 1st dim of fMatrix and 2nd of fResults (at the same time) |; 3991/// | `fMatrix[][] - fResults[][]` | six | on 1st dim then on 2nd dim |; 3992/// | `fMatrix[][fResult[][]]` | 30 | on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second index of fMatrix.|; 3993///; 3994///; 3995/// In summary, TTree::Draw loops through all unspecified dimensions. To; 3996/// figure out the range of each loop, we match each unspecified dimension; 3997/// from left to right (ignoring ALL dimensions for which an index has been; 3998/// specified), in the equivalent loop matched dimensions use the same index; 3999/// and are restricted to the smallest range (of only the matched dimensions).; 4000/// When involving variable arrays, the range can of course be different; 4001/// for each entry of the tree.; 4002///; 4003/// So the loop equivalent to ""fMatrix[][2] - fResults[3][]"" is:; 4004/// ~~~ {.cpp}; 4005/// for (Int_t i0; i < min(3,2); i++) {; 4006/// use the value of (fMatrix[i0][2] - fMatrix[3][i0]); 4007/// }; 4008/// ~~~; 4009/// So the loop equivalent to ""fMatrix[][2] - fResults[][]"" is:; 4010/// ~~~ {.cpp}; 4011/// for (Int_t i0; i < min(3,5); i++) {; 4012/// for (Int_t i1; i1 < 2; i1++) {; 4013/// use the value of (fMatrix[i0][2] - fMatrix[i0][i1]); 4014/// }; 4015/// }; 4016/// ~~~; 4017/// So the loop equivalent to ""fMatrix[][] - fResults[][]"" is:; 4018/// ~~~ {.cpp}; 4019/// for (Int_t i0; i < min(3,5); i++) {; 4020/// for (Int_t i1; i1 < min(3,2); i1++) {; 4021/// use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); 4022/// }; 4023/// }; 4024/// ~~~; 4025/// So the loop equivalent to ""fMatrix[][fResults[][]]"" is:; 4026/// ~~~ {.cpp}; 4027/// for (Int_t i0; i0 < 3; i0++) {; 4028/// for (Int_t j2; j2 < 5; j2++) {; 4",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:163276,Modifiability,variab,variable,163276," 4060/// calling; 4061///; 4062/// ~~~ {.cpp}; 4063/// auto graph = (TGraph*)gPad->GetPrimitive(""Graph"");; 4064/// ~~~; 4065///; 4066/// For the three and four dimensional cases, with the default drawing option, an unnamed; 4067/// TPolyMarker3D is produced, and therefore cannot be retrieved.; 4068///; 4069/// In all cases `htemp` can be used to access the axes. For instance in the 2D case:; 4070///; 4071/// ~~~ {.cpp}; 4072/// auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; 4073/// auto xaxis = htemp->GetXaxis();; 4074/// ~~~; 4075///; 4076/// When the option `""A""` is used (with TGraph painting option) to draw a 2D; 4077/// distribution:; 4078/// ~~~ {.cpp}; 4079/// tree.Draw(""e1:e2"","""",""A*"");; 4080/// ~~~; 4081/// a scatter plot is produced (with stars in that case) but the axis creation is; 4082/// delegated to TGraph and `htemp` is not created.; 4083///; 4084/// ### Saving the result of Draw to a histogram; 4085///; 4086/// If `varexp` contains `>>hnew` (following the variable(s) name(s)),; 4087/// the new histogram called `hnew` is created and it is kept in the current; 4088/// directory (and also the current pad). This works for all dimensions.; 4089///; 4090/// Example:; 4091/// ~~~ {.cpp}; 4092/// tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); 4093/// ~~~; 4094/// will draw `sqrt(x)` and save the histogram as ""hsqrt"" in the current; 4095/// directory. To retrieve it do:; 4096/// ~~~ {.cpp}; 4097/// TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");; 4098/// ~~~; 4099/// The binning information is taken from the environment variables; 4100/// ~~~ {.cpp}; 4101/// Hist.Binning.?D.?; 4102/// ~~~; 4103/// In addition, the name of the histogram can be followed by up to 9; 4104/// numbers between '(' and ')', where the numbers describe the; 4105/// following:; 4106///; 4107/// - 1 - bins in x-direction; 4108/// - 2 - lower limit in x-direction; 4109/// - 3 - upper limit in x-direction; 4110/// - 4-6 same for y-direction; 4111/// - 7-9 same for z-direction; 4112///; 4113/// When a",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:163830,Modifiability,variab,variables,163830,"// auto xaxis = htemp->GetXaxis();; 4074/// ~~~; 4075///; 4076/// When the option `""A""` is used (with TGraph painting option) to draw a 2D; 4077/// distribution:; 4078/// ~~~ {.cpp}; 4079/// tree.Draw(""e1:e2"","""",""A*"");; 4080/// ~~~; 4081/// a scatter plot is produced (with stars in that case) but the axis creation is; 4082/// delegated to TGraph and `htemp` is not created.; 4083///; 4084/// ### Saving the result of Draw to a histogram; 4085///; 4086/// If `varexp` contains `>>hnew` (following the variable(s) name(s)),; 4087/// the new histogram called `hnew` is created and it is kept in the current; 4088/// directory (and also the current pad). This works for all dimensions.; 4089///; 4090/// Example:; 4091/// ~~~ {.cpp}; 4092/// tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); 4093/// ~~~; 4094/// will draw `sqrt(x)` and save the histogram as ""hsqrt"" in the current; 4095/// directory. To retrieve it do:; 4096/// ~~~ {.cpp}; 4097/// TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");; 4098/// ~~~; 4099/// The binning information is taken from the environment variables; 4100/// ~~~ {.cpp}; 4101/// Hist.Binning.?D.?; 4102/// ~~~; 4103/// In addition, the name of the histogram can be followed by up to 9; 4104/// numbers between '(' and ')', where the numbers describe the; 4105/// following:; 4106///; 4107/// - 1 - bins in x-direction; 4108/// - 2 - lower limit in x-direction; 4109/// - 3 - upper limit in x-direction; 4110/// - 4-6 same for y-direction; 4111/// - 7-9 same for z-direction; 4112///; 4113/// When a new binning is used the new value will become the default.; 4114/// Values can be skipped.; 4115///; 4116/// Example:; 4117/// ~~~ {.cpp}; 4118/// tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); 4119/// // plot sqrt(x) between 10 and 20 using 500 bins; 4120/// tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); 4121/// // plot sqrt(x) against sin(y); 4122/// // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60; 4123/// // 50 bins in y-direction; lower limit on y-",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:166096,Modifiability,variab,variable,166096,"/// tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); 4133/// ~~~; 4134/// will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D; 4135/// and 3-D histograms.; 4136///; 4137/// ### Accessing collection objects; 4138///; 4139/// TTree::Draw default's handling of collections is to assume that any; 4140/// request on a collection pertain to it content. For example, if fTracks; 4141/// is a collection of Track objects, the following:; 4142/// ~~~ {.cpp}; 4143/// tree->Draw(""event.fTracks.fPx"");; 4144/// ~~~; 4145/// will plot the value of fPx for each Track objects inside the collection.; 4146/// Also; 4147/// ~~~ {.cpp}; 4148/// tree->Draw(""event.fTracks.size()"");; 4149/// ~~~; 4150/// would plot the result of the member function Track::size() for each; 4151/// Track object inside the collection.; 4152/// To access information about the collection itself, TTree::Draw support; 4153/// the '@' notation. If a variable which points to a collection is prefixed; 4154/// or postfixed with '@', the next part of the expression will pertain to; 4155/// the collection object. For example:; 4156/// ~~~ {.cpp}; 4157/// tree->Draw(""event.@fTracks.size()"");; 4158/// ~~~; 4159/// will plot the size of the collection referred to by `fTracks` (i.e the number; 4160/// of Track objects).; 4161///; 4162/// ### Drawing 'objects'; 4163///; 4164/// When a class has a member function named AsDouble or AsString, requesting; 4165/// to directly draw the object will imply a call to one of the 2 functions.; 4166/// If both AsDouble and AsString are present, AsDouble will be used.; 4167/// AsString can return either a char*, a std::string or a TString.s; 4168/// For example, the following; 4169/// ~~~ {.cpp}; 4170/// tree->Draw(""event.myTTimeStamp"");; 4171/// ~~~; 4172/// will draw the same histogram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeStamp.AsDouble()"");; 4175/// ~~~; 4176/// In addition, when the object is a type TString or std::string, TTree::Draw; 4177/// will call res",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:167924,Modifiability,variab,variables,167924,"ram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeStamp.AsDouble()"");; 4175/// ~~~; 4176/// In addition, when the object is a type TString or std::string, TTree::Draw; 4177/// will call respectively `TString::Data` and `std::string::c_str()`; 4178///; 4179/// If the object is a TBits, the histogram will contain the index of the bit; 4180/// that are turned on.; 4181///; 4182/// ### Retrieving information about the tree itself.; 4183///; 4184/// You can refer to the tree (or chain) containing the data by using the; 4185/// string 'This'.; 4186/// You can then could any TTree methods. For example:; 4187/// ~~~ {.cpp}; 4188/// tree->Draw(""This->GetReadEntry()"");; 4189/// ~~~; 4190/// will display the local entry numbers be read.; 4191/// ~~~ {.cpp}; 4192/// tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; 4193/// ~~~; 4194/// will display the name of the first 'user info' object.; 4195///; 4196/// ### Special functions and variables; 4197///; 4198/// `Entry$`: A TTree::Draw formula can use the special variable `Entry$`; 4199/// to access the entry number being read. For example to draw every; 4200/// other entry use:; 4201/// ~~~ {.cpp}; 4202/// tree.Draw(""myvar"",""Entry$%2==0"");; 4203/// ~~~; 4204/// - `Entry$` : return the current entry number (`== TTree::GetReadEntry()`); 4205/// - `LocalEntry$` : return the current entry number in the current tree of a; 4206/// chain (`== GetTree()->GetReadEntry()`); 4207/// - `Entries$` : return the total number of entries (== TTree::GetEntries()); 4208/// - `LocalEntries$` : return the total number of entries in the current tree; 4209/// of a chain (== GetTree()->TTree::GetEntries()); 4210/// - `Length$` : return the total number of element of this formula for this; 4211/// entry (`==TTreeFormula::GetNdata()`); 4212/// - `Iteration$` : return the current iteration over this formula for this; 4213/// entry (i.e. varies from 0 to `Length$`).; 4214/// - `Length$(formula )` : return the total number of element of the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:168004,Modifiability,variab,variable,168004,"ram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeStamp.AsDouble()"");; 4175/// ~~~; 4176/// In addition, when the object is a type TString or std::string, TTree::Draw; 4177/// will call respectively `TString::Data` and `std::string::c_str()`; 4178///; 4179/// If the object is a TBits, the histogram will contain the index of the bit; 4180/// that are turned on.; 4181///; 4182/// ### Retrieving information about the tree itself.; 4183///; 4184/// You can refer to the tree (or chain) containing the data by using the; 4185/// string 'This'.; 4186/// You can then could any TTree methods. For example:; 4187/// ~~~ {.cpp}; 4188/// tree->Draw(""This->GetReadEntry()"");; 4189/// ~~~; 4190/// will display the local entry numbers be read.; 4191/// ~~~ {.cpp}; 4192/// tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; 4193/// ~~~; 4194/// will display the name of the first 'user info' object.; 4195///; 4196/// ### Special functions and variables; 4197///; 4198/// `Entry$`: A TTree::Draw formula can use the special variable `Entry$`; 4199/// to access the entry number being read. For example to draw every; 4200/// other entry use:; 4201/// ~~~ {.cpp}; 4202/// tree.Draw(""myvar"",""Entry$%2==0"");; 4203/// ~~~; 4204/// - `Entry$` : return the current entry number (`== TTree::GetReadEntry()`); 4205/// - `LocalEntry$` : return the current entry number in the current tree of a; 4206/// chain (`== GetTree()->GetReadEntry()`); 4207/// - `Entries$` : return the total number of entries (== TTree::GetEntries()); 4208/// - `LocalEntries$` : return the total number of entries in the current tree; 4209/// of a chain (== GetTree()->TTree::GetEntries()); 4210/// - `Length$` : return the total number of element of this formula for this; 4211/// entry (`==TTreeFormula::GetNdata()`); 4212/// - `Iteration$` : return the current iteration over this formula for this; 4213/// entry (i.e. varies from 0 to `Length$`).; 4214/// - `Length$(formula )` : return the total number of element of the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:170507,Modifiability,variab,variable,170507,"within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->D",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:172145,Modifiability,variab,variable,172145," unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:174353,Modifiability,variab,variables,174353,"7/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is norm",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:174729,Modifiability,variab,variables,174729,"/; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying th",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:175092,Modifiability,variab,variables,175092,"ption=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying the current selection.; 4354/// If option ""entrylist"" is used, a TEntryList object is created; 4355/// If the selection contains arrays, vectors or any container class and option; 4356/// ""entrylistarray"" is used, a TEntryListArray object is created; 4357/// containing also the subentries satisfying the selection, i.e. the indices of; 4358/// the branches which h",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:175568,Modifiability,variab,variable,175568,"328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying the current selection.; 4354/// If option ""entrylist"" is used, a TEntryList object is created; 4355/// If the selection contains arrays, vectors or any container class and option; 4356/// ""entrylistarray"" is used, a TEntryListArray object is created; 4357/// containing also the subentries satisfying the selection, i.e. the indices of; 4358/// the branches which hold containers classes.; 4359/// Example:; 4360/// ~~~ {.cpp}; 4361/// tree.Draw("">>yplus"",""y>0""); 4362/// ~~~; 4363/// will create a TEventList object named ""yplus"" in the current directory.; 4364/// In an interactive session, one can type (after TTree::Draw); 4365/// ~~~ {.cpp}; 4366/// yplus.Print(""all""); 4367/// ~~~; 436",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214247,Modifiability,config,configuration,214247,/////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;,MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:258692,Modifiability,variab,variables,258692,"rated for a single TTree which is part; 6602/// of a TChain to process that entire TChain. The maximum dimensions; 6603/// calculated for arrays on the basis of a single TTree from the TChain; 6604/// might be (will be!) too small when processing all of the TTrees in; 6605/// the TChain. You must use myChain.MakeClass() to generate the code,; 6606/// not myTree.MakeClass(...).; 6607 ; 6608Int_t TTree::MakeClass(const char* classname, Option_t* option); 6609{; 6610 GetPlayer();; 6611 if (!fPlayer) {; 6612 return 0;; 6613 }; 6614 return fPlayer->MakeClass(classname, option);; 6615}; 6616 ; 6617////////////////////////////////////////////////////////////////////////////////; 6618/// Generate a skeleton function for this tree.; 6619///; 6620/// The function code is written on filename.; 6621/// If filename is 0, filename will be called nameoftree.C; 6622///; 6623/// The generated code includes the following:; 6624/// - Identification of the original Tree and Input file name,; 6625/// - Opening the Tree file,; 6626/// - Declaration of Tree variables,; 6627/// - Setting of branches addresses,; 6628/// - A skeleton for the entry loop.; 6629///; 6630/// To use this function:; 6631///; 6632/// - Open your Tree file (eg: TFile f(""myfile.root"");); 6633/// - T->MakeCode(""MyAnalysis.C"");; 6634///; 6635/// where T is the name of the TTree in file myfile.root; 6636/// and MyAnalysis.C the name of the file created by this function.; 6637///; 6638/// NOTE: Since the implementation of this function, a new and better; 6639/// function TTree::MakeClass() has been developed.; 6640 ; 6641Int_t TTree::MakeCode(const char* filename); 6642{; 6643 Warning(""MakeCode"", ""MakeCode is obsolete. Use MakeClass or MakeSelector instead"");; 6644 ; 6645 GetPlayer();; 6646 if (!fPlayer) return 0;; 6647 return fPlayer->MakeCode(filename);; 6648}; 6649 ; 6650////////////////////////////////////////////////////////////////////////////////; 6651/// Generate a skeleton analysis class for this Tree using TBra",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262393,Modifiability,variab,variables,262393," a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1anal",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262485,Modifiability,variab,variable,262485,".fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerm",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:263906,Modifiability,variab,variable,263906,"7/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:282392,Modifiability,variab,variables,282392,"han 8 bytes (we use this number; 7160 // so that the calculation of the number of basket is consistent; 7161 // but in fact SetBasketSize will not let the size go below; 7162 // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName()); 7163 // (The 2nd part being a slight over estimate of the key length.; 7164 static const UInt_t hardmin = 8;; 7165 bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );; 7166 bmax = (bmax_new > hardmax) ? bmin : (UInt_t)bmax_new;; 7167 }; 7168 if (pDebug) {; 7169 Info(""OptimizeBaskets"", ""oldMemsize = %d, newMemsize = %d\n"",oldMemsize, newMemsize);; 7170 Info(""OptimizeBaskets"", ""oldBaskets = %d, newBaskets = %d\n"",oldBaskets, newBaskets);; 7171 }; 7172}; 7173 ; 7174////////////////////////////////////////////////////////////////////////////////; 7175/// Interface to the Principal Components Analysis class.; 7176///; 7177/// Create an instance of TPrincipal; 7178///; 7179/// Fill it with the selected variables; 7180///; 7181/// - if option ""n"" is specified, the TPrincipal object is filled with; 7182/// normalized variables.; 7183/// - If option ""p"" is specified, compute the principal components; 7184/// - If option ""p"" and ""d"" print results of analysis; 7185/// - If option ""p"" and ""h"" generate standard histograms; 7186/// - If option ""p"" and ""c"" generate code of conversion functions; 7187/// - return a pointer to the TPrincipal object. It is the user responsibility; 7188/// - to delete this object.; 7189/// - The option default value is ""np""; 7190///; 7191/// see TTree::Draw for explanation of the other parameters.; 7192///; 7193/// The created object is named ""principal"" and a reference to it; 7194/// is added to the list of specials Root objects.; 7195/// you can retrieve a pointer to the created object via:; 7196/// ~~~ {.cpp}; 7197/// TPrincipal *principal =; 7198/// (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");; 7199/// ~~~; 7200 ; 7201TPrincipal* TTree::Principal(const c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:282507,Modifiability,variab,variables,282507,"han 8 bytes (we use this number; 7160 // so that the calculation of the number of basket is consistent; 7161 // but in fact SetBasketSize will not let the size go below; 7162 // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName()); 7163 // (The 2nd part being a slight over estimate of the key length.; 7164 static const UInt_t hardmin = 8;; 7165 bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );; 7166 bmax = (bmax_new > hardmax) ? bmin : (UInt_t)bmax_new;; 7167 }; 7168 if (pDebug) {; 7169 Info(""OptimizeBaskets"", ""oldMemsize = %d, newMemsize = %d\n"",oldMemsize, newMemsize);; 7170 Info(""OptimizeBaskets"", ""oldBaskets = %d, newBaskets = %d\n"",oldBaskets, newBaskets);; 7171 }; 7172}; 7173 ; 7174////////////////////////////////////////////////////////////////////////////////; 7175/// Interface to the Principal Components Analysis class.; 7176///; 7177/// Create an instance of TPrincipal; 7178///; 7179/// Fill it with the selected variables; 7180///; 7181/// - if option ""n"" is specified, the TPrincipal object is filled with; 7182/// normalized variables.; 7183/// - If option ""p"" is specified, compute the principal components; 7184/// - If option ""p"" and ""d"" print results of analysis; 7185/// - If option ""p"" and ""h"" generate standard histograms; 7186/// - If option ""p"" and ""c"" generate code of conversion functions; 7187/// - return a pointer to the TPrincipal object. It is the user responsibility; 7188/// - to delete this object.; 7189/// - The option default value is ""np""; 7190///; 7191/// see TTree::Draw for explanation of the other parameters.; 7192///; 7193/// The created object is named ""principal"" and a reference to it; 7194/// is added to the list of specials Root objects.; 7195/// you can retrieve a pointer to the created object via:; 7196/// ~~~ {.cpp}; 7197/// TPrincipal *principal =; 7198/// (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");; 7199/// ~~~; 7200 ; 7201TPrincipal* TTree::Principal(const c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:296359,Modifiability,variab,variable,296359,"/////////////////////////////////; 7512/// Loop over entries and return a TSQLResult object containing entries following selection.; 7513 ; 7514TSQLResult* TTree::Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:296447,Modifiability,variab,variable,296447,"/////////////////////////////////; 7512/// Loop over entries and return a TSQLResult object containing entries following selection.; 7513 ; 7514TSQLResult* TTree::Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:296508,Modifiability,variab,variable,296508,"/////////////////////////////////; 7512/// Loop over entries and return a TSQLResult object containing entries following selection.; 7513 ; 7514TSQLResult* TTree::Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:296556,Modifiability,variab,variables,296556," nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines in the input file starting with ""#"" are ignored. Leading whitespace; 7551/// for each column data is skipped. Empty lines are skipped.; 7552///; 7553/// A TBranch object is created for each variable in the expression.; 7554/// The total ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:296617,Modifiability,variab,variables,296617," nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines in the input file starting with ""#"" are ignored. Leading whitespace; 7551/// for each column data is skipped. Empty lines are skipped.; 7552///; 7553/// A TBranch object is created for each variable in the expression.; 7554/// The total ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:297198,Modifiability,variab,variables,297198,"// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines in the input file starting with ""#"" are ignored. Leading whitespace; 7551/// for each column data is skipped. Empty lines are skipped.; 7552///; 7553/// A TBranch object is created for each variable in the expression.; 7554/// The total number of rows read from the file is returned.; 7555///; 7556/// ## FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; 7557///; 7558/// To fill a TTree with multiple input text files, proceed as indicated above; 7559/// for the first input file and omit the second argument for subsequent calls; 7560/// ~~~ {.cpp}; 7561/// T.ReadFile(""file1.dat"",""branch descriptor"");; 7562/// T.ReadFile(""file2.dat"");; 7563/// ~~~; 7564 ; 7565Long64_t TTree::ReadFile(const char* filename, const char* branchDescriptor, char ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:297612,Modifiability,variab,variable,297612,"// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besides whitespace.; 7541/// This provides support for direct import of common data file formats; 7542/// like csv. If delimiter != ' ' and branchDescriptor == """", then the; 7543/// branch description is taken from the first line in the file, but; 7544/// delimiter is used for the branch names tokenization rather than ':'.; 7545/// Note however that if the values in the first line do not use the; 7546/// /[type] syntax, all variables are assumed to be of type ""F"".; 7547/// If the filename ends with extensions .csv or .CSV and a delimiter is; 7548/// not specified (besides ' '), the delimiter is automatically set to ','.; 7549///; 7550/// Lines in the input file starting with ""#"" are ignored. Leading whitespace; 7551/// for each column data is skipped. Empty lines are skipped.; 7552///; 7553/// A TBranch object is created for each variable in the expression.; 7554/// The total number of rows read from the file is returned.; 7555///; 7556/// ## FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; 7557///; 7558/// To fill a TTree with multiple input text files, proceed as indicated above; 7559/// for the first input file and omit the second argument for subsequent calls; 7560/// ~~~ {.cpp}; 7561/// T.ReadFile(""file1.dat"",""branch descriptor"");; 7562/// T.ReadFile(""file2.dat"");; 7563/// ~~~; 7564 ; 7565Long64_t TTree::ReadFile(const char* filename, const char* branchDescriptor, char delimiter); 7566{; 7567 if (!filename || !*filename) {; 7568 Error(""ReadFile"",""File name not specified"");; 7569 return 0;; 7570 }; 7571 ; 7572 std::ifstream in;; 7573 in.open(filename);; 7574 if (!in.good()) {; 7575 Error(""ReadFile"",""Cannot open file: %s"",filename);; 7576 return 0;; 7577 }; 7578 const char* ext = strrchr(filename, '.');; 7579 if(ext && ((strcmp(ext, "".csv"") == 0) || (strcmp(ext, "".CSV"") == 0)) && delimiter == ' ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:315177,Modifiability,variab,variable,315177,"i) {; 8081 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 8082 branch->ResetAddress();; 8083 }; 8084}; 8085 ; 8086////////////////////////////////////////////////////////////////////////////////; 8087/// Loop over tree entries and print entries passing selection. Interactive; 8088/// pagination break is on by default.; 8089///; 8090/// - If varexp is 0 (or """") then print only first 8 columns.; 8091/// - If varexp = ""*"" print all columns.; 8092///; 8093/// Otherwise a columns selection can be made using ""var1:var2:var3"".; 8094///; 8095/// \param firstentry first entry to scan; 8096/// \param nentries total number of entries to scan (starting from firstentry). Defaults to all entries.; 8097/// \see TTree::SetScanField to control how many lines are printed between pagination breaks (Use 0 to disable pagination); 8098/// \see TTreePlayer::Scan for more information; 8099 ; 8100Long64_t TTree::Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 8101{; 8102 GetPlayer();; 8103 if (fPlayer) {; 8104 return fPlayer->Scan(varexp, selection, option, nentries, firstentry);; 8105 }; 8106 return -1;; 8107}; 8108 ; 8109////////////////////////////////////////////////////////////////////////////////; 8110/// Set a tree variable alias.; 8111///; 8112/// Set an alias for an expression/formula based on the tree 'variables'.; 8113///; 8114/// The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; 8115/// TTree::Scan, TTreeViewer) and will be evaluated as the content of; 8116/// 'aliasFormula'.; 8117///; 8118/// If the content of 'aliasFormula' only contains symbol names, periods and; 8119/// array index specification (for example event.fTracks[3]), then; 8120/// the content of 'aliasName' can be used as the start of symbol.; 8121///; 8122/// If the alias 'aliasName' already existed, it is replaced by the new; 8123/// value.; 8124///; 8125/// When being used, the alias can be preceded by an eventual 'Frien",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:315269,Modifiability,variab,variables,315269,"// - If varexp is 0 (or """") then print only first 8 columns.; 8091/// - If varexp = ""*"" print all columns.; 8092///; 8093/// Otherwise a columns selection can be made using ""var1:var2:var3"".; 8094///; 8095/// \param firstentry first entry to scan; 8096/// \param nentries total number of entries to scan (starting from firstentry). Defaults to all entries.; 8097/// \see TTree::SetScanField to control how many lines are printed between pagination breaks (Use 0 to disable pagination); 8098/// \see TTreePlayer::Scan for more information; 8099 ; 8100Long64_t TTree::Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 8101{; 8102 GetPlayer();; 8103 if (fPlayer) {; 8104 return fPlayer->Scan(varexp, selection, option, nentries, firstentry);; 8105 }; 8106 return -1;; 8107}; 8108 ; 8109////////////////////////////////////////////////////////////////////////////////; 8110/// Set a tree variable alias.; 8111///; 8112/// Set an alias for an expression/formula based on the tree 'variables'.; 8113///; 8114/// The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; 8115/// TTree::Scan, TTreeViewer) and will be evaluated as the content of; 8116/// 'aliasFormula'.; 8117///; 8118/// If the content of 'aliasFormula' only contains symbol names, periods and; 8119/// array index specification (for example event.fTracks[3]), then; 8120/// the content of 'aliasName' can be used as the start of symbol.; 8121///; 8122/// If the alias 'aliasName' already existed, it is replaced by the new; 8123/// value.; 8124///; 8125/// When being used, the alias can be preceded by an eventual 'Friend Alias'; 8126/// (see TTree::GetFriendAlias); 8127///; 8128/// Return true if it was added properly.; 8129///; 8130/// For example:; 8131/// ~~~ {.cpp}; 8132/// tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; 8133/// tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; 8134/// tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; 8135/// tree->SetAlias(""y2"",",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:330626,Modifiability,variab,variables,330626," See the comments in TBranchElement::SetAddress() for the; 8444/// meaning of the addr parameter and the object ownership policy.; 8445 ; 8446Int_t TTree::SetBranchAddressImp(TBranch *branch, void* addr, TBranch** ptr); 8447{; 8448 if (ptr) {; 8449 *ptr = branch;; 8450 }; 8451 if (fClones) {; 8452 void* oldAddr = branch->GetAddress();; 8453 TIter next(fClones);; 8454 TTree* clone = nullptr;; 8455 const char *bname = branch->GetName();; 8456 while ((clone = (TTree*) next())) {; 8457 TBranch* cloneBr = clone->GetBranch(bname);; 8458 if (cloneBr && (cloneBr->GetAddress() == oldAddr)) {; 8459 cloneBr->SetAddress(addr);; 8460 }; 8461 }; 8462 }; 8463 branch->SetAddress(addr);; 8464 return kVoidPtr;; 8465}; 8466 ; 8467////////////////////////////////////////////////////////////////////////////////; 8468/// Set branch status to Process or DoNotProcess.; 8469///; 8470/// When reading a Tree, by default, all branches are read.; 8471/// One can speed up considerably the analysis phase by activating; 8472/// only the branches that hold variables involved in a query.; 8473///; 8474/// bname is the name of a branch.; 8475///; 8476/// - if bname=""*"", apply to all branches.; 8477/// - if bname=""xxx*"", apply to all branches with name starting with xxx; 8478///; 8479/// see TRegexp for wildcarding options; 8480///; 8481/// - status = 1 branch will be processed; 8482/// - = 0 branch will not be processed; 8483///; 8484/// Example:; 8485///; 8486/// Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..; 8487/// when doing T.GetEntry(i) all branches are read for entry i.; 8488/// to read only the branches c and e, one can do; 8489/// ~~~ {.cpp}; 8490/// T.SetBranchStatus(""*"",0); //disable all branches; 8491/// T.SetBranchStatus(""c"",1);; 8492/// T.setBranchStatus(""e"",1);; 8493/// T.GetEntry(i);; 8494/// ~~~; 8495/// bname is interpreted as a wild-carded TRegexp (see TRegexp::MakeWildcard).; 8496/// Thus, ""a*b"" or ""a.*b"" matches branches starting with ""a"" and ending with; 8497/// ""b"", but",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:352076,Modifiability,variab,variable,352076,"eted. This TEntryList can be returned by GetEntryList() function.; 9069 ; 9070void TTree::SetEventList(TEventList *evlist); 9071{; 9072 fEventList = evlist;; 9073 if (fEntryList){; 9074 if (fEntryList->TestBit(kCanDelete)) {; 9075 TEntryList *tmp = fEntryList;; 9076 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 9077 delete tmp;; 9078 } else {; 9079 fEntryList = nullptr;; 9080 }; 9081 }; 9082 ; 9083 if (!evlist) {; 9084 fEntryList = nullptr;; 9085 fEventList = nullptr;; 9086 return;; 9087 }; 9088 ; 9089 fEventList = evlist;; 9090 char enlistname[100];; 9091 snprintf(enlistname,100, ""%s_%s"", evlist->GetName(), ""entrylist"");; 9092 fEntryList = new TEntryList(enlistname, evlist->GetTitle());; 9093 fEntryList->SetDirectory(nullptr); // We own this.; 9094 Int_t nsel = evlist->GetN();; 9095 fEntryList->SetTree(this);; 9096 Long64_t entry;; 9097 for (Int_t i=0; i<nsel; i++){; 9098 entry = evlist->GetEntry(i);; 9099 fEntryList->Enter(entry);; 9100 }; 9101 fEntryList->SetReapplyCut(evlist->GetReapplyCut());; 9102 fEntryList->SetBit(kCanDelete, true);; 9103}; 9104 ; 9105////////////////////////////////////////////////////////////////////////////////; 9106/// Set number of entries to estimate variable limits.; 9107/// If n is -1, the estimate is set to be the current maximum; 9108/// for the tree (i.e. GetEntries() + 1); 9109/// If n is less than -1, the behavior is undefined.; 9110 ; 9111void TTree::SetEstimate(Long64_t n /* = 1000000 */); 9112{; 9113 if (n == 0) {; 9114 n = 10000;; 9115 } else if (n < 0) {; 9116 n = fEntries - n;; 9117 }; 9118 fEstimate = n;; 9119 GetPlayer();; 9120 if (fPlayer) {; 9121 fPlayer->SetEstimate(n);; 9122 }; 9123}; 9124 ; 9125////////////////////////////////////////////////////////////////////////////////; 9126/// Provide the end-user with the ability to enable/disable various experimental; 9127/// IO features for this TTree.; 9128///; 9129/// Returns all the newly-set IO settings.; 9130 ; 9131ROOT::TIOFeatures TTree::SetIOFeatures(",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:354698,Modifiability,variab,variable,354698,"to be created when the current file exceeds fgTreeMaxSize.; 9150/// (see TTree::ChangeFile); 9151/// if fFileNumber=10, the new file name will have a suffix ""_11"",; 9152/// ie, fFileNumber is incremented before setting the file name; 9153 ; 9154void TTree::SetFileNumber(Int_t number); 9155{; 9156 if (fFileNumber < 0) {; 9157 Warning(""SetFileNumber"", ""file number must be positive. Set to 0"");; 9158 fFileNumber = 0;; 9159 return;; 9160 }; 9161 fFileNumber = number;; 9162}; 9163 ; 9164////////////////////////////////////////////////////////////////////////////////; 9165/// Set all the branches in this TTree to be in decomposed object mode; 9166/// (also known as MakeClass mode).; 9167///; 9168/// For MakeClass mode 0, the TTree expects the address where the data is stored; 9169/// to be set by either the user or the TTree to the address of a full object; 9170/// through the top level branch.; 9171/// For MakeClass mode 1, this address is expected to point to a numerical type; 9172/// or C-style array (variable or not) of numerical type, representing the; 9173/// primitive data members.; 9174/// The function's primary purpose is to allow the user to access the data; 9175/// directly with numerical type variable rather than having to have the original; 9176/// set of classes (or a reproduction thereof).; 9177 ; 9178void TTree::SetMakeClass(Int_t make); 9179{; 9180 fMakeClass = make;; 9181 ; 9182 Int_t nb = fBranches.GetEntriesFast();; 9183 for (Int_t i = 0; i < nb; ++i) {; 9184 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file wit",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:354902,Modifiability,variab,variable,354902,"e setting the file name; 9153 ; 9154void TTree::SetFileNumber(Int_t number); 9155{; 9156 if (fFileNumber < 0) {; 9157 Warning(""SetFileNumber"", ""file number must be positive. Set to 0"");; 9158 fFileNumber = 0;; 9159 return;; 9160 }; 9161 fFileNumber = number;; 9162}; 9163 ; 9164////////////////////////////////////////////////////////////////////////////////; 9165/// Set all the branches in this TTree to be in decomposed object mode; 9166/// (also known as MakeClass mode).; 9167///; 9168/// For MakeClass mode 0, the TTree expects the address where the data is stored; 9169/// to be set by either the user or the TTree to the address of a full object; 9170/// through the top level branch.; 9171/// For MakeClass mode 1, this address is expected to point to a numerical type; 9172/// or C-style array (variable or not) of numerical type, representing the; 9173/// primitive data members.; 9174/// The function's primary purpose is to allow the user to access the data; 9175/// directly with numerical type variable rather than having to have the original; 9176/// set of classes (or a reproduction thereof).; 9177 ; 9178void TTree::SetMakeClass(Int_t make); 9179{; 9180 fMakeClass = make;; 9181 ; 9182 Int_t nb = fBranches.GetEntriesFast();; 9183 for (Int_t i = 0; i < nb; ++i) {; 9184 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:370021,Modifiability,variab,variable,370021,"fAutoSave = (Long64_t)ijunk;; 9610 b >> ijunk; fEstimate = (Long64_t)ijunk;; 9611 if (fEstimate <= 10000) fEstimate = 1000000;; 9612 fBranches.Streamer(b);; 9613 if (fBranchRef) fBranchRef->SetTree(this);; 9614 TBranch__SetTree(this,fBranches);; 9615 fLeaves.Streamer(b);; 9616 fSavedBytes = fTotBytes;; 9617 if (R__v > 1) fIndexValues.Streamer(b);; 9618 if (R__v > 2) fIndex.Streamer(b);; 9619 if (R__v > 3) {; 9620 TList OldInfoList;; 9621 OldInfoList.Streamer(b);; 9622 OldInfoList.Delete();; 9623 }; 9624 fNClusterRange = 0;; 9625 fDefaultEntryOffsetLen = 1000;; 9626 ResetBit(kMustCleanup);; 9627 b.CheckByteCount(R__s, R__c, TTree::IsA());; 9628 //====end of old versions; 9629 } else {; 9630 if (fBranchRef) {; 9631 fBranchRef->Clear();; 9632 }; 9633 TRefTable *table = TRefTable::GetRefTable();; 9634 if (table) TRefTable::SetRefTable(nullptr);; 9635 ; 9636 b.WriteClassBuffer(TTree::Class(), this);; 9637 ; 9638 if (table) TRefTable::SetRefTable(table);; 9639 }; 9640}; 9641 ; 9642////////////////////////////////////////////////////////////////////////////////; 9643/// Unbinned fit of one or more variable(s) from a tree.; 9644///; 9645/// funcname is a TF1 function.; 9646///; 9647/// \see TTree::Draw for explanations of the other parameters.; 9648///; 9649/// Fit the variable varexp using the function funcname using the; 9650/// selection cuts given by selection.; 9651///; 9652/// The list of fit options is given in parameter option.; 9653///; 9654/// - option = ""Q"" Quiet mode (minimum printing); 9655/// - option = ""V"" Verbose mode (default is between Q and V); 9656/// - option = ""E"" Perform better Errors estimation using Minos technique; 9657/// - option = ""M"" More. Improve fit results; 9658///; 9659/// You can specify boundary limits for some or all parameters via; 9660/// ~~~ {.cpp}; 9661/// func->SetParLimits(p_number, parmin, parmax);; 9662/// ~~~; 9663/// if parmin>=parmax, the parameter is fixed; 9664///; 9665/// Note that you are not forced to fix the limits for a",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:370195,Modifiability,variab,variable,370195," > 1) fIndexValues.Streamer(b);; 9618 if (R__v > 2) fIndex.Streamer(b);; 9619 if (R__v > 3) {; 9620 TList OldInfoList;; 9621 OldInfoList.Streamer(b);; 9622 OldInfoList.Delete();; 9623 }; 9624 fNClusterRange = 0;; 9625 fDefaultEntryOffsetLen = 1000;; 9626 ResetBit(kMustCleanup);; 9627 b.CheckByteCount(R__s, R__c, TTree::IsA());; 9628 //====end of old versions; 9629 } else {; 9630 if (fBranchRef) {; 9631 fBranchRef->Clear();; 9632 }; 9633 TRefTable *table = TRefTable::GetRefTable();; 9634 if (table) TRefTable::SetRefTable(nullptr);; 9635 ; 9636 b.WriteClassBuffer(TTree::Class(), this);; 9637 ; 9638 if (table) TRefTable::SetRefTable(table);; 9639 }; 9640}; 9641 ; 9642////////////////////////////////////////////////////////////////////////////////; 9643/// Unbinned fit of one or more variable(s) from a tree.; 9644///; 9645/// funcname is a TF1 function.; 9646///; 9647/// \see TTree::Draw for explanations of the other parameters.; 9648///; 9649/// Fit the variable varexp using the function funcname using the; 9650/// selection cuts given by selection.; 9651///; 9652/// The list of fit options is given in parameter option.; 9653///; 9654/// - option = ""Q"" Quiet mode (minimum printing); 9655/// - option = ""V"" Verbose mode (default is between Q and V); 9656/// - option = ""E"" Perform better Errors estimation using Minos technique; 9657/// - option = ""M"" More. Improve fit results; 9658///; 9659/// You can specify boundary limits for some or all parameters via; 9660/// ~~~ {.cpp}; 9661/// func->SetParLimits(p_number, parmin, parmax);; 9662/// ~~~; 9663/// if parmin>=parmax, the parameter is fixed; 9664///; 9665/// Note that you are not forced to fix the limits for all parameters.; 9666/// For example, if you fit a function with 6 parameters, you can do:; 9667/// ~~~ {.cpp}; 9668/// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; 9669/// func->SetParLimits(4,-10,-4);; 9670/// func->SetParLimits(5, 1,1);; 9671/// ~~~; 9672/// With this setup:; 9673///; 9674/// - Parameters 0->3 ca",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:371666,Modifiability,variab,variable,371666,"undary limits for some or all parameters via; 9660/// ~~~ {.cpp}; 9661/// func->SetParLimits(p_number, parmin, parmax);; 9662/// ~~~; 9663/// if parmin>=parmax, the parameter is fixed; 9664///; 9665/// Note that you are not forced to fix the limits for all parameters.; 9666/// For example, if you fit a function with 6 parameters, you can do:; 9667/// ~~~ {.cpp}; 9668/// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; 9669/// func->SetParLimits(4,-10,-4);; 9670/// func->SetParLimits(5, 1,1);; 9671/// ~~~; 9672/// With this setup:; 9673///; 9674/// - Parameters 0->3 can vary freely; 9675/// - Parameter 4 has boundaries [-10,-4] with initial value -8; 9676/// - Parameter 5 is fixed to 100.; 9677///; 9678/// For the fit to be meaningful, the function must be self-normalized.; 9679///; 9680/// i.e. It must have the same integral regardless of the parameter; 9681/// settings. Otherwise the fit will effectively just maximize the; 9682/// area.; 9683///; 9684/// It is mandatory to have a normalization variable; 9685/// which is fixed for the fit. e.g.; 9686/// ~~~ {.cpp}; 9687/// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; 9688/// f1->SetParameters(1, 3.1, 0.01);; 9689/// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; 9690/// data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; 9691/// ~~~; 9692/// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; 9693///; 9694/// Return status:; 9695///; 9696/// - The function return the status of the fit in the following form; 9697/// fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; 9698/// - The fitResult is 0 is the fit is OK.; 9699/// - The fitResult is negative in case of an error not connected with the fit.; 9700/// - The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; 9701/// - If the number of selected entries is null the function returns -1; 9702 ; 9703Int_t TTree::UnbinnedFit(const char* funcname, const char* varex",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:402661,Modifiability,inherit,inherits,402661,"pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:403044,Modifiability,inherit,inherits,403044,"taTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Defini",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:416277,Modifiability,variab,variable-sized,416277,"tes() constDefinition TKey.h:86; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TLeafC::Classstatic TClass * Class(); TLeafD::Classstatic TClass * Class(); TLeafElement::Classstatic TClass * Class(); TLeafF::Classstatic TClass * Class(); TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetValuevirtual Double_t GetValue(Int_t i=0) constDefinition TLeaf.h:183; TLeaf::GetValuePointervirtual void * GetValuePointer() constDefinition TLeaf.h:138; TLeaf::GetLenTypevirtual Int_t GetLenType() constDefinition TLeaf.h:133; TLeaf::ReadValuevirtual void ReadValue(std::istream &, Char_t=' ')Definition TLeaf.h:156; TLeaf::GetMaximumvirtual Int_t GetMaximum() constDefinition TLeaf.h:134; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::IsATClass * IsA() const overrideDefinition TLeaf.h:168; TLeaf::IncludeRangevirtual bool IncludeRange(TLeaf *)Definition TLeaf.h:146; TLeaf::SetAddressvirtual void SetAddress(void *add=nullptr)Definition TLeaf.h:185; TLeaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::kIndirectAddress@ kIndirectAddressData member is a pointer to an array of basic types.Definition TLeaf.h:95; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TListA doubly linked list.Definition TList.h:38; TList::Streamervoid S",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:422869,Modifiability,inherit,inherits,422869,"itR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::kBitMask@ kBitMaskDefinition TObject.h:86; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:428576,Modifiability,variab,variable,428576," TStyle.h:379; TStyle::GetHistLineColorColor_t GetHistLineColor() constDefinition TStyle.h:233; TStyle::IsReadingBool_t IsReading() constDefinition TStyle.h:296; TStyle::SetHistLineStylevoid SetHistLineStyle(Style_t styl=0)Definition TStyle.h:382; TStyle::GetHistFillStyleStyle_t GetHistFillStyle() constDefinition TStyle.h:234; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
