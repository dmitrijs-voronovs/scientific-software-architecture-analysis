id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:32867,Performance,optimiz,optimization,32867,"ates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:32945,Performance,optimiz,optimized,32945,"olecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +----------------",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:33145,Performance,Optimiz,Optimizations,33145,"re the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+--------------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:34921,Performance,perform,performed,34921,"P2) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o``",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35026,Performance,perform,performs,35026,"----------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35331,Performance,optimiz,optimization,35331,"---------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. wh",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35407,Performance,optimiz,optimization,35407,"---------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. wh",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35807,Performance,optimiz,optimization,35807,"`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; r",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35829,Performance,perform,performed,35829,"`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; r",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36013,Performance,optimiz,optimization,36013,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); Psi",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36031,Performance,optimiz,optimize,36031,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); Psi",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36080,Performance,optimiz,optimization,36080,"; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); if",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36150,Performance,optimiz,optimization,36150,"alls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(Ps",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36168,Performance,optimiz,optimize,36168,"alls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(Ps",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:38009,Performance,Optimiz,Optimizer,38009,"IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(PsiMod.me() == 0):; shutil.copy(restartfile, get_psifile(1)). # print 'full_hess_every', full_hess_every; # print 'steps_since_last_hessian', steps_since_last_hessian; # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = PsiMod.get_gradient(); PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print 'Optimizer: Optimization complete!'; PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(); return thisenergy. # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level in",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:38020,Performance,Optimiz,Optimization,38020,"IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(PsiMod.me() == 0):; shutil.copy(restartfile, get_psifile(1)). # print 'full_hess_every', full_hess_every; # print 'steps_since_last_hessian', steps_since_last_hessian; # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = PsiMod.get_gradient(); PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print 'Optimizer: Optimization complete!'; PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(); return thisenergy. # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level in",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:38505,Performance,Optimiz,Optimization,38505,"Mod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print 'Optimizer: Optimization complete!'; PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(); return thisenergy. # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCSDT' },; 'sdtq' : { 'method' : 1, 'order' : 4, 'fullname' : 'CCSDTQ' },; 'sdtqp' : { 'method' : 1, 'order' : 5, 'fullname' : 'CCSDTQP' },; 'sdtqph",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:38879,Performance,optimiz,optimize,38879," 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print 'Optimizer: Optimization complete!'; PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(); return thisenergy. # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCSDT' },; 'sdtq' : { 'method' : 1, 'order' : 4, 'fullname' : 'CCSDTQ' },; 'sdtqp' : { 'method' : 1, 'order' : 5, 'fullname' : 'CCSDTQP' },; 'sdtqph' : { 'method' : 1, 'order' : 6, 'fullname' : 'CCSDTQPH' },; 'sd(t)' : { 'method' : 3, 'order' : -3, 'fullname' : 'CCSD(T)' },; 'sdt(q)' : { 'method' : 3, 'order' : -4, 'fullname' : 'CCSDT(Q)' },; 'sdtq(p)' : { 'method' : 3, 'order' : -5, 'fullname' : 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method' : 3, 'order' : -6, 'fullname' : 'CCSDTQP(H)' },; 'sd(t)_l' : ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:42966,Performance,perform,performed,42966,"; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Make frequency look analogous to gradient, especially in matching derivative levels. Make dertype actually a dertype type. .. _`table:freq_gen`:. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; mole",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:45166,Performance,Perform,Performing,45166," if not (lowername in procedures[types[dertype]]):; print 'Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype; dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculati",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:45860,Performance,Load,Loading,45860,"hod?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacement",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46006,Performance,Load,Load,46006,"efunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmet",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46115,Performance,Perform,Perform,46115," by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This ve",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46728,Performance,perform,perform,46728,"n enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when c",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46775,Performance,Perform,Performing,46775,"n enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when c",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47398,Performance,Load,Loading,47398,"rent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47544,Performance,Load,Load,47544,"n(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to fre",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47632,Performance,Perform,Perform,47632,"molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28774,Safety,Abort,Aborting,28774,"put file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_v",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28939,Safety,Abort,Aborting,28939,"'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]de",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:20285,Security,Validat,ValidationError,20285,"l| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into requested basis; >>> energy('sapt0-ct',cast_up=True). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'de",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21455,Security,Validat,ValidationError,21455,"c or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21822,Security,validat,validation,21822,"f lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22056,Security,Validat,ValidationError,22056,"f lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22849,Security,Validat,ValidationError,22849,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is prett",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22942,Security,Validat,ValidationError,22942,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23335,Security,Validat,ValidationError,23335,"molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (O",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:24838,Security,access,accessed,24838,"tty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28757,Security,Validat,ValidationError,28757,"put file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_v",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28922,Security,Validat,ValidationError,28922,"'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]de",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29161,Security,Validat,ValidationError,29161,"t_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29329,Security,Validat,ValidationError,29329,"me__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further pro",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:32695,Security,Validat,ValidationError,32695,"he system. :type properties: array of strings; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:34969,Security,access,accesses,34969,"----------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:41405,Security,Validat,ValidationError,41405,"tqph-1a' : { 'method' : 5, 'order' : 6, 'fullname' : 'CCSDTQPH-1a' },; 'sdt-1b' : { 'method' : 6, 'order' : 3, 'fullname' : 'CCSDT-1b' },; 'sdtq-1b' : { 'method' : 6, 'order' : 4, 'fullname' : 'CCSDTQ-1b' },; 'sdtqp-1b' : { 'method' : 6, 'order' : 5, 'fullname' : 'CCSDTQP-1b' },; 'sdtqph-1b' : { 'method' : 6, 'order' : 6, 'fullname' : 'CCSDTQPH-1b' },; '2' : { 'method' : 7, 'order' : 2, 'fullname' : 'CC2' },; '3' : { 'method' : 7, 'order' : 3, 'fullname' : 'CC3' },; '4' : { 'method' : 7, 'order' : 4, 'fullname' : 'CC4' },; '5' : { 'method' : 7, 'order' : 5, 'fullname' : 'CC5' },; '6' : { 'method' : 7, 'order' : 6, 'fullname' : 'CC6' },; 'sdt-3' : { 'method' : 8, 'order' : 3, 'fullname' : 'CCSDT-3' },; 'sdtq-3' : { 'method' : 8, 'order' : 4, 'fullname' : 'CCSDTQ-3' },; 'sdtqp-3' : { 'method' : 8, 'order' : 5, 'fullname' : 'CCSDTQP-3' },; 'sdtqph-3' : { 'method' : 8, 'order' : 6, 'fullname' : 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (namelower)). elif re.match(r'^[a-z]+\d+$', namelower):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(namelower); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if (namestump == 'mp') or (namestump == 'zapt') or (namestump == 'ci'):; # Let 'mp2' pass through as itself; if (namestump == 'mp') and (namelevel == 2):; return namelower, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. -",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:48839,Security,validat,validated,48839,"ores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep),",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:49774,Security,Validat,ValidationError,49774,"tting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46397,Usability,Clear,Clear,46397,"tation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displace",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47976,Usability,Clear,Clear,47976,"; # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': ",MatchSource.WIKI,psi4manual/4.0b2/_modules/driver.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10390,Availability,down,down,10390,"ilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):;",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:13820,Availability,Error,Error,13820," copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOr = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; PsiMod.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys,exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; PsiMod.set_global_option(""GUESS"",""READ""); ; # Left endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOl = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1);",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:15095,Availability,Error,Error,15095,".set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOl = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; PsiMod.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys,exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl); ; converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step + 1;; ; # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; PsiMod.set_global_option('DFT_OMEGA',omega). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; PsiMod.",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:18300,Deployability,update,updated,18300," % omega); E1 = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;; ; omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP); ; # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True;; break. PsiMod.IO.set_default_namespace(""""). PsiMod.print_out('\n\t==> IP Fitting Results <==\n\n'). PsiMod.print_out('\t => Occupation Determination <= \n\n'); PsiMod.print_out('\t %6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); PsiMod.print_out('\t Neutral: %6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge0, mult0, HOMO)); PsiMod.print_out('\t Cation: %6d %6d %6d %6d %6d\n\n' %(N-1, Na1, Nb1, charge1, mult1)). PsiMod.print_out('\t => Regula Falsi Iterations <=\n\n'); PsiMod.print_out('\t%3s %11s %14s %14s %14s %s\n' % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; PsiMod.print_out('\t%3d %11.3E %14.6E %14.6E %14.6E %s\n' % (k+1,omegas[k],IPs[k],kIPs[k],IPs[k] - kIPs[k], types[k])); if (converged):; PsiMod.print_out('\n\tIP Fitting Converged\n'); PsiMod.print_out('\tFinal omega = %14.6E\n' % ((omega_l + omega_r) / 2)); PsiMod.print_out('\n\t""M,I. does the dying. Fleet just does the flying.""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). else:; PsiMod.print_out('\n\tIP Fitting did not converge!\n'); ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""); PsiMod.set_global_option(""GUESS"", old_guess). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:542,Energy Efficiency,charge,chargep,542,". frac  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for frac; import PsiMod; import os; import input; import math; from molutil import * ; from driver import * ; from procutil import *; from util import *. # Scan from +1 electron to -1 electron; [docs]def frac_traverse(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . chargep = charge0 + 1; chargem = charge0 - 1; ; # By default, the multiplicity of the cation/anion are mult0 + 1; # These are overridden with the cation_mult and anion_mult kwargs; multp = mult0 + 1; multm = mult0 + 1; if kwargs.has_key('cation_mult'):; multp = kwargs['cation_mult'] ; if kwargs.has_key('anion_mult'):; multm = kwargs['anion_mult'] ; ; # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; LUMO_occs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; HOMO_occs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('HOMO_occs'):; HOMO_occs = kwargs['HOMO_occs'] ; if kwargs.has_key('LUMO_occs'):; LUMO_occs = kwargs['LUMO_occs'] . # By default, HOMO and LUMO are both in alpha; Z = 0;; for A in range(mol.natom()):; Z += mol.Z(A); Z -= charge0; if (Z%2):; HOMO = Z/2+1; else:; HOMO = Z/2; LUMO = HOMO+1; if kwargs.has_key('HOMO'):; HOMO = kwargs['HOMO']; if kwargs.has_key('LUMO'):; LUMO = kwargs['LUMO']. # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, use the neutral orbitals as a guess for the anion; neutral_guess = True; if kwargs.has_key('neutral_guess'):; neutral_guess = kwargs['neutral_guess']. # By defaul",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:565,Energy Efficiency,charge,chargem,565,". frac  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for frac; import PsiMod; import os; import input; import math; from molutil import * ; from driver import * ; from procutil import *; from util import *. # Scan from +1 electron to -1 electron; [docs]def frac_traverse(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . chargep = charge0 + 1; chargem = charge0 - 1; ; # By default, the multiplicity of the cation/anion are mult0 + 1; # These are overridden with the cation_mult and anion_mult kwargs; multp = mult0 + 1; multm = mult0 + 1; if kwargs.has_key('cation_mult'):; multp = kwargs['cation_mult'] ; if kwargs.has_key('anion_mult'):; multm = kwargs['anion_mult'] ; ; # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; LUMO_occs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; HOMO_occs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('HOMO_occs'):; HOMO_occs = kwargs['HOMO_occs'] ; if kwargs.has_key('LUMO_occs'):; LUMO_occs = kwargs['LUMO_occs'] . # By default, HOMO and LUMO are both in alpha; Z = 0;; for A in range(mol.natom()):; Z += mol.Z(A); Z -= charge0; if (Z%2):; HOMO = Z/2+1; else:; HOMO = Z/2; LUMO = HOMO+1; if kwargs.has_key('HOMO'):; HOMO = kwargs['HOMO']; if kwargs.has_key('LUMO'):; LUMO = kwargs['LUMO']. # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, use the neutral orbitals as a guess for the anion; neutral_guess = True; if kwargs.has_key('neutral_guess'):; neutral_guess = kwargs['neutral_guess']. # By defaul",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:2876,Energy Efficiency,energy,energy,2876," guess for the anion; neutral_guess = True; if kwargs.has_key('neutral_guess'):; neutral_guess = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); ",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3038,Energy Efficiency,charge,chargem,3038,"; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.s",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3191,Energy Efficiency,energy,energy,3191,"]. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3613,Energy Efficiency,energy,energy,3613,"equested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUES",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3690,Energy Efficiency,ENERGY,ENERGY,3690,"""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False)",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4537,Energy Efficiency,energy,energy,4537,"lobal_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_g",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4911,Energy Efficiency,energy,energy,4911,"]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] =",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4988,Energy Efficiency,ENERGY,ENERGY,4988,". PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a h",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:5743,Energy Efficiency,Energy,Energy,5743,"option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not rea",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:5758,Energy Efficiency,Energy,Energy,5758,"option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not rea",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:6214,Energy Efficiency,Energy,Energy,6214,"occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mul",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:6229,Energy Efficiency,Energy,Energy,6229,"occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mul",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:7207,Energy Efficiency,charge,charge,7207,"for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO >",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:7878,Energy Efficiency,energy,energy,7878,"By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.appe",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8222,Energy Efficiency,charge,charge,8222,"charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_g",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8293,Energy Efficiency,charge,charge,8293,"; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_cha",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8302,Energy Efficiency,charge,charge,8302,"; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_cha",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8681,Energy Efficiency,energy,energy,8681,"+ '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8758,Energy Efficiency,ENERGY,ENERGY,8758,"tion(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = cha",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9254,Energy Efficiency,charge,charge,9254," 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9292,Energy Efficiency,charge,charge,9292,"- 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'M",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9669,Energy Efficiency,charge,charge,9669,"option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(N",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9740,Energy Efficiency,charge,charge,9740,"le('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], con",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9749,Energy Efficiency,charge,charge,9749,"le('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], con",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:9997,Energy Efficiency,Energy,Energy,9997,"occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10012,Energy Efficiency,Energy,Energy,10012,"occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10278,Energy Efficiency,Charge,Charge,10278,"molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwarg",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10591,Energy Efficiency,Energy,Energy,10591,"stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity()",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10606,Energy Efficiency,Energy,Energy,10606,"stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1; ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity()",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:10852,Energy Efficiency,Charge,Charge,10852,"ults out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. PsiMod.print_out('\n'); PsiMod.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; PsiMod.print_out(line). PsiMod.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats: ; fh.write(line); fh.close(). return E . [docs]def ip_fitting(mol, omega_l, omega_r, **kwargs):; kwargs = kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = 1.0E-3;; if (kwargs.has_key('omega_tolerance')): ; omega_tol = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot"")",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:12154,Energy Efficiency,energy,energy,12154,"l = kwargs['omega_tolerance']. # By default, do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_H",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:13032,Energy Efficiency,energy,energy,13032," = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOr = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; PsiMod.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys,exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Us",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:13642,Energy Efficiency,energy,energy,13642,"= Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOr = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; PsiMod.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys,exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; PsiMod.set_global_option(""GUESS"",""READ""); ; # Left endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; el",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:14360,Energy Efficiency,energy,energy,14360,"O.change_file_namespace(180,""ot"",""neutral""); ; # Cation; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n'); E1r = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if (IPr > kIPr):; PsiMod.print_out('\n***IP Fitting Error: Right Omega limit should have kIP > IP'); sys,exit(1). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; PsiMod.set_global_option(""GUESS"",""READ""); ; # Left endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOl = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; PsiMod.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys,exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl); ; converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:14917,Energy Efficiency,energy,energy,14917,"end(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; PsiMod.set_global_option(""GUESS"",""READ""); ; # Left endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_l). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n'); E0l = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; E_HOMOl = E_HOMO;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; PsiMod.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys,exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl); ; converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step + 1;; ; # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; PsiMod.set_global_option('DFT_OMEGA',omega). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:15827,Energy Efficiency,energy,energy,15827,"y(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n'); E1l = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IPl = E1l - E0l;; kIPl = -E_HOMOl;; delta_l = IPl - kIPl;. if (IPl < kIPl):; PsiMod.print_out('\n***IP Fitting Error: Left Omega limit should have kIP < IP'); sys,exit(1). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl); ; converged = False; repeat_l = 0;; repeat_r = 0;; step = 0;; while True:. step = step + 1;; ; # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; PsiMod.set_global_option('DFT_OMEGA',omega). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n' % omega); E1 = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;; ; omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:16373,Energy Efficiency,energy,energy,16373,"; # Regula Falsi (modified); if (repeat_l > 1):; delta_l = delta_l / 2.0;; if (repeat_r > 1):; delta_r = delta_r / 2.0;; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l;; PsiMod.set_global_option('DFT_OMEGA',omega). # Neutral; PsiMod.IO.change_file_namespace(180,""neutral"",""ot""); mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n' % omega); E0 = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; E_HOMO = E_a;; else: ; E_HOMO = E_b;; PsiMod.IO.change_file_namespace(180,""ot"",""neutral""); ; # Cation; PsiMod.IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n' % omega); E1 = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;; ; omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP); ; # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True;; break. PsiMod.IO.set_default_namespace(""""). PsiMod.print_out('\n\t==> IP Fitting Results <==\n\n'). PsiMod.print_out('\t => Occupation Determination <= \n\n'); PsiMod.print_out('\t %6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); PsiMod.print_out('\t Neutral: %6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge0, mult0, HOMO)); PsiMod.print_out('\t Cation: %6d %6d %6d %6d %6d\n\n' %(N-1,",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:17191,Energy Efficiency,Charge,Charge,17191,"IO.change_file_namespace(180,""cation"",""ot""); mol.set_molecular_charge(charge1); mol.set_multiplicity(mult1); PsiMod.print_out('\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n' % omega); E1 = energy('scf'); PsiMod.IO.change_file_namespace(180,""ot"",""cation""). IP = E1 - E0;; kIP = -E_HOMO;; delta = IP - kIP;. if (kIP > IP):; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0;; repeat_l = repeat_l + 1;; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1;; ; omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP); ; # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True;; break. PsiMod.IO.set_default_namespace(""""). PsiMod.print_out('\n\t==> IP Fitting Results <==\n\n'). PsiMod.print_out('\t => Occupation Determination <= \n\n'); PsiMod.print_out('\t %6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); PsiMod.print_out('\t Neutral: %6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge0, mult0, HOMO)); PsiMod.print_out('\t Cation: %6d %6d %6d %6d %6d\n\n' %(N-1, Na1, Nb1, charge1, mult1)). PsiMod.print_out('\t => Regula Falsi Iterations <=\n\n'); PsiMod.print_out('\t%3s %11s %14s %14s %14s %s\n' % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; PsiMod.print_out('\t%3d %11.3E %14.6E %14.6E %14.6E %s\n' % (k+1,omegas[k],IPs[k],kIPs[k],IPs[k] - kIPs[k], types[k])); if (converged):; PsiMod.print_out('\n\tIP Fitting Converged\n'); PsiMod.print_out('\tFinal omega = %14.6E\n' % ((omega_l + omega_r) / 2)); PsiMod.print_out('\n\t""M,I. does the dying. Fleet just does the flying.""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). else:; PsiMod.print_out('\n\tIP Fitting did not converge!\n'); ; PsiMod.set_global_option(""DF_INTS_IO"", ""NONE""); PsiMod.set_global_option(""GUESS"", old_guess). Quick search. Enter search terms or a module, class",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:2974,Performance,LOAD,LOAD,2974,"s = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.appen",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4205,Performance,LOAD,LOAD,4205,"nergy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); pot",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:5509,Performance,LOAD,LOAD,5509,"od.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). PsiMod.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; PsiMod.print_out('\n ==> Fractional Occupation Traverse Results <==\n\n'); PsiMod.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; PsiMod.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. PsiMod.print_out('\n\t""You trying to be a hero Watkins?""\n'); PsiMod.print_out('\t""Just trying to kill some bugs sir!""\n'); PsiMod.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwarg",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:8374,Performance,LOAD,LOAD,8374," DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.refe",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/frac.html:12209,Performance,LOAD,LOAD,12209,"nty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; els",MatchSource.WIKI,psi4manual/4.0b2/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:62191,Deployability,update,updated,62191,". points.append(point). N = len(points); rho_a = PsiMod.Vector(N); rho_b = PsiMod.Vector(N); gamma_aa = PsiMod.Vector(N); gamma_ab = PsiMod.Vector(N); gamma_bb = PsiMod.Vector(N); tau_a = PsiMod.Vector(N); tau_b = PsiMod.Vector(N). index = 0; for point in points:; rho_a[index] = point['rho_a']; rho_b[index] = point['rho_b']; gamma_aa[index] = point['gamma_aa']; gamma_ab[index] = point['gamma_ab']; gamma_bb[index] = point['gamma_bb']; index = index + 1. super = build_superfunctional(functional, N, 1); super.test_functional(rho_a, rho_b, gamma_aa, gamma_ab, gamma_bb, tau_a, tau_b). v = super.value('V'); v_rho_a = super.value('V_RHO_A'); v_rho_b = super.value('V_RHO_B'); v_gamma_aa = super.value('V_GAMMA_AA'); v_gamma_ab = super.value('V_GAMMA_AB'); v_gamma_bb = super.value('V_GAMMA_BB'). if not v_gamma_aa:; v_gamma_aa = tau_a; v_gamma_ab = tau_a; v_gamma_bb = tau_a. tasks = ['v', 'v_rho_a', 'v_rho_b', 'v_gamma_aa', 'v_gamma_ab', 'v_gamma_bb']; mapping = {; 'v': v,; 'v_rho_a': v_rho_a,; 'v_rho_b': v_rho_b,; 'v_gamma_aa': v_gamma_aa,; 'v_gamma_ab': v_gamma_ab,; 'v_gamma_bb': v_gamma_bb,; }. super.print_detail(3); index = 0; for point in points:; PsiMod.print_out('rho_a= %11.3E, rho_b= %11.3E, gamma_aa= %11.3E, gamma_ab= %11.3E, gamma_bb= %11.3E\n' % (rho_a[index], rho_b[index], gamma_aa[index], gamma_ab[index], gamma_bb[index])). for task in tasks:; v_ref = point[task]; v_obs = mapping[task][index]; delta = v_obs - v_ref; if (v_ref == 0.0):; epsilon = 0.0; else:; epsilon = abs(delta / v_ref); if (epsilon < 1.0E-11):; passed = 'PASSED'; else:; passed = 'FAILED'; check = False. PsiMod.print_out('\t%-15s %24.16E %24.16E %24.16E %24.16E %6s\n' % (task, v_ref, v_obs, delta, epsilon, passed)). index = index + 1. PsiMod.print_out('\n'); return check. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:17279,Energy Efficiency,allocate,allocate,17279,"functional,; }. [docs]def build_functional(alias):; name = alias.lower(); return functionals[name](name). [docs]def functional_list():; val = []; for key in functionals.keys():; val.append(functionals[key](key)); return val. ## ==> SuperFunctionals <== ##. [docs]def build_ws_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wS_X'); # Tab in, trailing newlines; sup.set_description(' Slater Short-Range LSDA Exchange\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_X'); # Tab in, trailing newlines; sup.set_description(' PBE Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(n",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:18124,Energy Efficiency,allocate,allocate,18124,"sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_X'); # Tab in, trailing newlines; sup.set_description(' PBE Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:18981,Energy Efficiency,allocate,allocate,18981,"ega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB88_X'); # Tab in, trailing newlines; sup.set_description(' B88 Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoint",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:19826,Energy Efficiency,allocate,allocate,19826,"sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB88_X'); # Tab in, trailing newlines; sup.set_description(' B88 Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SVWN'); # Tab in, trailing newlines; sup.set_description(' SVWN3 (RPA) LSDA Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('S_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Custom",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:20629,Energy Efficiency,allocate,allocate,20629,"). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SVWN'); # Tab in, trailing newlines; sup.set_description(' SVWN3 (RPA) LSDA Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('S_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunction",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:21511,Energy Efficiency,allocate,allocate,21511,"(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv).",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:22331,Energy Efficiency,allocate,allocate,22331,"fter adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:23094,Energy Efficiency,allocate,allocate,23094,"_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(de",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:23920,Energy Efficiency,allocate,allocate,23920,"dding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybri",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:24738,Energy Efficiency,allocate,allocate,24738," after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid GGA Exchange-Correlation Functional\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); s",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:25959,Energy Efficiency,allocate,allocate,25959,"n'); sup.set_x_alpha(0.25); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def bu",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:26935,Energy Efficiency,allocate,allocate,26935,"is last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b970_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-0'); # Tab in, trailing newlines; sup.set_description(' B97-0 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:28293,Energy Efficiency,allocate,allocate,28293," Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.1737); C.set_parameter('B97_ss_a1', 2.3487); C.set_parameter('B97_ss_a2', -2.4868). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.1943); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b971_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-1'); # Tab in, trailing newlines; sup.set_description(' B97-1 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_s",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:29675,Energy Efficiency,allocate,allocate,29675,"nctional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.0820011); C.set_parameter('B97_ss_a1', 2.71681); C.set_parameter('B97_ss_a2', -2.87103). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b972_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-2'); # Tab in, trailing newlines; sup.set_description(' B97-2 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_ga",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:31054,Energy Efficiency,allocate,allocate,31054," Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.585808); C.set_parameter('B97_ss_a1', -0.691682); C.set_parameter('B97_ss_a2', 0.394796). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-D'); # Tab in, trailing newlines; sup.set_description(' B97-D Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_paramet",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:32488,Energy Efficiency,allocate,allocate,32488,"ation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.22340); C.set_parameter('B97_ss_a1', -1.56208); C.set_parameter('B97_ss_a2', 3.25429). sup.add_x_functional(X); sup.add_c_functional(C). # => -D2 (s = 1.25) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.25)). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH'); # Tab in, trailing newlines; sup.set_description(' HCTH Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09320); X.set_parameter('B97_a1', -0.744056); X.set_parameter('B97_a2', 5.59920); X.set_parameter('B97_a3', -6.78549); X.set_parameter('B97_a4', 4.49357). C = build_functional('B_C'); C.set_name('HCTH_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.729974); C.set_parameter('B97_os_a1', 3.35287); C.set_para",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:34084,Energy Efficiency,allocate,allocate,34084,".0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09320); X.set_parameter('B97_a1', -0.744056); X.set_parameter('B97_a2', 5.59920); X.set_parameter('B97_a3', -6.78549); X.set_parameter('B97_a4', 4.49357). C = build_functional('B_C'); C.set_name('HCTH_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.729974); C.set_parameter('B97_os_a1', 3.35287); C.set_parameter('B97_os_a2', -11.5430); C.set_parameter('B97_os_a3', 8.08564); C.set_parameter('B97_os_a4', -4.47857). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.222601); C.set_parameter('B97_ss_a1', -0.0338622); C.set_parameter('B97_ss_a2', -0.0125170); C.set_parameter('B97_ss_a3', -0.802496); C.set_parameter('B97_ss_a4', 1.55396). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth120_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH120'); # Tab in, trailing newlines; sup.set_description(' HCTH120 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese, et. al., J. Chem. Phys., 112(4), 1670-1678, 2000\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH120_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09163); X.set_parameter('B97_a1', -0.747215); X.set_parameter('B97_a2', 5.07833); X.set_parameter('B97_a3', -4.10746); X.set_parameter('B97_a4', 1.17173). C = build_functional('B_C'); C.set_name('HCTH120_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.514730); C.set_parameter('B97_os_a1', 6.9",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:35693,Energy Efficiency,allocate,allocate,35693,"1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09163); X.set_parameter('B97_a1', -0.747215); X.set_parameter('B97_a2', 5.07833); X.set_parameter('B97_a3', -4.10746); X.set_parameter('B97_a4', 1.17173). C = build_functional('B_C'); C.set_name('HCTH120_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.514730); C.set_parameter('B97_os_a1', 6.92982); C.set_parameter('B97_os_a2', -24.7073); C.set_parameter('B97_os_a3', 23.1098); C.set_parameter('B97_os_a4', -11.3234). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.489508); C.set_parameter('B97_ss_a1', -0.260699); C.set_parameter('B97_ss_a2', 0.432917); C.set_parameter('B97_ss_a3', -1.99247); C.set_parameter('B97_ss_a4', 2.48531). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth147_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH147'); # Tab in, trailing newlines; sup.set_description(' HCTH147 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese, et. al., J. Chem. Phys., 112(4), 1670-1678, 2000\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH147_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09025); X.set_parameter('B97_a1', -0.799194); X.set_parameter('B97_a2', 5.57212); X.set_parameter('B97_a3', -5.86760); X.set_parameter('B97_a4', 3.04544). C = build_functional('B_C'); C.set_name('HCTH147_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.542352); C.set_parameter('B97_os_a1', 7.0",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:37302,Energy Efficiency,allocate,allocate,37302,"1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09025); X.set_parameter('B97_a1', -0.799194); X.set_parameter('B97_a2', 5.57212); X.set_parameter('B97_a3', -5.86760); X.set_parameter('B97_a4', 3.04544). C = build_functional('B_C'); C.set_name('HCTH147_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.542352); C.set_parameter('B97_os_a1', 7.01464); C.set_parameter('B97_os_a2', -28.3822); C.set_parameter('B97_os_a3', 35.0329); C.set_parameter('B97_os_a4', -20.4284). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.562576); C.set_parameter('B97_ss_a1', 0.0171436); C.set_parameter('B97_ss_a2', -1.30636); C.set_parameter('B97_ss_a3', 1.05747); C.set_parameter('B97_ss_a4', 0.885429). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth407_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH407'); # Tab in, trailing newlines; sup.set_description(' HCTH407 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese and N.C. Handy, J. Chem. Phys., 114(13), 5497-5503, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH407_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:38915,Energy Efficiency,allocate,allocate,38915,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.20)). return sup. [docs]def build_b3lypd_superfunctional(name, npoints, deriv):. sup = build_b3lyp_superfunctional(name, npoints, deriv); sup.set_name('B3LYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_b3lyp5d_superfunctional(name, npoints, deriv):. sup = build_b3lyp5_superfunctional(name, npoints, deriv); sup.set_name('B3LYP5-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_bp86d_superfunctional(name, npoints, deriv):. sup = build_bp86_superfunctional(name, npoints, deriv); sup.set_name('BP86-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_pbed_superfunctional(name, npoints, deriv):. sup = buil",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:40856,Energy Efficiency,allocate,allocate,40856,"uild_pbed_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 0.75)). return sup. [docs]def build_wsvwn_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wSVWN'); # Tab in, trailing newlines; sup.set_description(' LSDA SR-XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe0_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoin",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:41738,Energy Efficiency,allocate,allocate,41738,"(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe0_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE0'); sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:42891,Energy Efficiency,allocate,allocate,42891," sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol0_superfunctional(name, npoints, deriv):. sup = build_wpbesol_superfunctional(name, npoints, deriv); sup.set_name('wPBEsol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:44047,Energy Efficiency,allocate,allocate,44047,"ol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97'); # Tab in, trailing newlines; sup.set_description(' Parameterized LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_par",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:45646,Energy Efficiency,allocate,allocate,45646,"). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_parameter('B97_os_a2', -1.70066E1); C.set_parameter('B97_os_a3', 1.07292E0); C.set_parameter('B97_os_a4', 8.88211E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -2.55352E0); C.set_parameter('B97_ss_a2', 1.18926E1); C.set_parameter('B97_ss_a3', -2.69452E1); C.set_parameter('B97_ss_a4', 1.70927E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.157706)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_paramet",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:47288,Energy Efficiency,allocate,allocate,47288,"eter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1;; omega = 0.2;; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:49550,Energy Efficiency,allocate,allocate,49550,"alpha\beta,1}; C.set_parameter('B97_os_a2', -1.20477E1) # Table 1: c_{c\alpha\beta,2}; C.set_parameter('B97_os_a3', 1.40847E1) # Table 1: c_{c\alpha\beta,3}; C.set_parameter('B97_os_a4', -8.50809E0) # Table 1: c_{c\alpha\beta,4}. C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0) # Table 1: c_{c\sigma\sigma,0}; C.set_parameter('B97_ss_a1', -6.90539E0) # Table 1: c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-CHG', 1.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3 # Should be reported/implemented to more digits; C2 = 4.49267E-3 # Should be reported/implemented to more digits; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:50717,Energy Efficiency,power,power,50717,"(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3 # Should be reported/implemented to more digits; C2 = 4.49267E-3 # Should be reported/implemented to more digits; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', 0.08151); X.set_parameter('Meta_a2', -0.43956); X.set_parameter('Meta_a3', -3.22422); X.set_parameter('Meta_a4', 2.01819); X.set_parameter('Meta_a5', 8.79431); X.set_parameter('Meta_a6', -0.00295); X.set_parameter('Meta_a7', 9.82029); X.set_parameter('Meta_a8', -4.82351); X.set_parameter('Meta_a9', -48.17574); X.set_parameter('Meta_a10', 3.64802); X.set_parameter('Meta_a11', 34.02248). C = build_functional('M_C'); C.set_name('M05_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0) # This makes me mad. Truhlar is too lazy to report the B97 gradient expansion formula, but then does not use the canonical definition.; C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.78569); C.set_parameter('B97_os_a2', -14.15261); C.set_parameter('B97_os_a3', -7.46589); C.set_parameter('B97_os_a4', 17.94491). C.set_paramet",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:52276,Energy Efficiency,allocate,allocate,52276," # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0) # This makes me mad. Truhlar is too lazy to report the B97 gradient expansion formula, but then does not use the canonical definition.; C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.78569); C.set_parameter('B97_os_a2', -14.15261); C.set_parameter('B97_os_a3', -7.46589); C.set_parameter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04463); C.set_parameter('B97_ss_a3', 30.69913); C.set_parameter('B97_ss_a4', -9.22695). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.28) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; # Should be reported/implemented to more digits; C2 = 4.49267E-3; # Should be reported/implemented to more digits; K0 = 3.0/2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0/3.0);; k0 = math.pow(6.0 * math.pi * math.pi, 1.0/3.0);; kp = C1 / (C2 * K0);; mu = 4.0 * k0 * ",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:53458,Energy Efficiency,power,power,53458,"up.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; # Should be reported/implemented to more digits; C2 = 4.49267E-3; # Should be reported/implemented to more digits; K0 = 3.0/2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0/3.0);; k0 = math.pow(6.0 * math.pi * math.pi, 1.0/3.0);; kp = C1 / (C2 * K0);; mu = 4.0 * k0 * k0 * kp * C2;; X.set_parameter('PBE_kp', kp); # Different effective kp; X.set_parameter('PBE_mu', mu); # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0' , 1.0); X.set_parameter('Meta_a1' ,-0.56833); X.set_parameter('Meta_a2' ,-1.30057); X.set_parameter('Meta_a3' , 5.50070); X.set_parameter('Meta_a4' , 9.06402); X.set_parameter('Meta_a5' ,-32.21075); X.set_parameter('Meta_a6' ,-23.73298); X.set_parameter('Meta_a7' , 70.22996); X.set_parameter('Meta_a8' , 29.88614); X.set_parameter('Meta_a9' ,-60.25778); X.set_parameter('Meta_a10',-13.22205); X.set_parameter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0) # This makes me mad. Truhlar is too lazy to report the B97 gradient expansion formula, but then does not use the canonical definition.; C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2',-3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4',-10.58909).",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:55032,Energy Efficiency,allocate,allocate,55032," GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0) # This makes me mad. Truhlar is too lazy to report the B97 gradient expansion formula, but then does not use the canonical definition.; C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2',-3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4',-10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1',-3.05430); C.set_parameter('B97_ss_a2', 7.61854); C.set_parameter('B97_ss_a3', 1.47665); C.set_parameter('B97_ss_a4',-11.92365). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_primitive_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. key = name.upper(); fun = build_functional(key). # No spaces, keep it short and according to convention; sup.set_name(key); # Tab in, trailing newlines; sup.set_description(fun.description()); # Tab in, trailing newlines; sup.set_citation(fun.citation()). # Add member functionals. if (key[-1] == 'X'):; sup.add_x_functional(fun); else:; sup.add_c_functional(fun). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. # Superfunctional lookup table; superfunctionals = {; 's_x' : build_primitive_superfunctional,; 'b88_x' : build_primitive_superfunctional,; 'b3_x' : build_primitive_superfunctional,; 'pbe_x' : build_primitive_sup",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:55808,Energy Efficiency,allocate,allocate,55808," Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_primitive_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. key = name.upper(); fun = build_functional(key). # No spaces, keep it short and according to convention; sup.set_name(key); # Tab in, trailing newlines; sup.set_description(fun.description()); # Tab in, trailing newlines; sup.set_citation(fun.citation()). # Add member functionals. if (key[-1] == 'X'):; sup.add_x_functional(fun); else:; sup.add_c_functional(fun). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. # Superfunctional lookup table; superfunctionals = {; 's_x' : build_primitive_superfunctional,; 'b88_x' : build_primitive_superfunctional,; 'b3_x' : build_primitive_superfunctional,; 'pbe_x' : build_primitive_superfunctional,; 'pbesol_x' : build_primitive_superfunctional,; 'pw91_x' : build_primitive_superfunctional,; 'ws_x' : build_ws_x_superfunctional,; 'wpbe_x' : build_wpbe_x_superfunctional,; 'wpbesol_x' : build_wpbesol_x_superfunctional,; 'wb88_x' : build_wb88_x_superfunctional,; 'lyp_c' : build_primitive_superfunctional,; 'ft97b_x' : build_primitive_superfunctional,; 'pz81_c' : build_primitive_superfunctional,; 'p86_c' : build_primitive_superfunctional,; 'pw91_c' : build_primitive_superfunctional,; 'pw92_c' : build_primitive_superfunctional,; 'pbe_c' : build_primitive_superfunctional,; 'ft97_c' : build_primitive_superfunctional,; 'vwn5rpa_c' : build_primitive_superfunctional,; 'vwn5_c' : build_primitive_superfunctional,; 'vwn3rpa_c' : build_primitive_superfunctional,; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:4073,Modifiability,Parameteriz,Parameterized,4073,"functional(name):. # Call this first; fun = PsiMod.Functional.build_base('PBE_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PBEsol_X'); # Tab in, trailing newlines; fun.set_description(' PBEsol GGA Exchange Hole (Parameter Free)\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('PBE_kp', 0.804); fun.set_parameter('PBE_mu', 10.0 / 81.0). # => End User-Customization <= #. return fun. [docs]def build_pw91_x_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('PW91_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('PW91_X'); # Tab in, trailing newlines; fun.set_description(' PW91 Parameterized GGA Exchange\n'); # Tab in, trailing newlines; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; k01 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); k02 = k01 * k01; k04 = k02 * k02; fun.set_parameter('PW91_a1', 0.19645 / (2.0 * k01)); fun.set_parameter('PW91_a2', 7.79560 / (2.0 * k01)); fun.set_parameter('PW91_a3', 0.27430 / (4.0 * k02)); fun.set_parameter('PW91_a4', 0.15080 / (4.0 * k02)); fun.set_parameter('PW91_a5', 100.000 / (4.0 * k02)); fun.set_parameter('PW91_a6', 0.00400 / (16.0 * k04)). # => End User-Customization <= #. return fun. [docs]def build_b97_x_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('B97_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('B97_X'); # Tab in, trailing newlines; fun.set_d",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:5111,Modifiability,Parameteriz,Parameterized,5111,"; fun.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; k01 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); k02 = k01 * k01; k04 = k02 * k02; fun.set_parameter('PW91_a1', 0.19645 / (2.0 * k01)); fun.set_parameter('PW91_a2', 7.79560 / (2.0 * k01)); fun.set_parameter('PW91_a3', 0.27430 / (4.0 * k02)); fun.set_parameter('PW91_a4', 0.15080 / (4.0 * k02)); fun.set_parameter('PW91_a5', 100.000 / (4.0 * k02)); fun.set_parameter('PW91_a6', 0.00400 / (16.0 * k04)). # => End User-Customization <= #. return fun. [docs]def build_b97_x_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('B97_X'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('B97_X'); # Tab in, trailing newlines; fun.set_description(' B97 Parameterized GGA Exchange\n'); # Tab in, trailing newlines; fun.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(True); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('B97_gamma', 0.004). # => End User-Customization <= #. return fun. [docs]def build_vwn5_c_functional(name):. # Call this first; fun = PsiMod.Functional.build_base('VWN5_C'). # => User-Customization <= #. # No spaces, keep it short and according to convention; fun.set_name('VWN5_C'); # Tab in, trailing newlines; fun.set_description(' VWN5 LSDA Correlation\n'); # Tab in, trailing newlines; fun.set_citation(' S.H. Vosko, L. Wilk, and M. Nusair, Can. J. Phys., 58, 1200-1211, 1980\n'). # These should be set by build_base, but prove that you know what's up; fun.set_gga(False); fun.set_meta(False); fun.set_alpha(1.0); fun.set_omega(0.0). # Custom parameters; fun.set_parameter('EcP_2', -0.104",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:44399,Modifiability,Parameteriz,Parameterized,44399," convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97'); # Tab in, trailing newlines; sup.set_description(' Parameterized LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_parameter('B97_os_a2', -1.70066E1); C.set_parameter('B97_os_a3', 1.07292E0); C.set_parameter('B97_os_a4', 8.88211E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -2.55352E0); C.set_parameter('B97_ss_a2', 1.18926E1); C.set_parameter('B97_ss_a3', -2.69452E1); C.set_parameter('B97_ss_a4', 1.70927E1). sup.add_x_functi",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:46000,Modifiability,Parameteriz,Parameterized,46000,"a1', 3.99051E0); C.set_parameter('B97_os_a2', -1.70066E1); C.set_parameter('B97_os_a3', 1.07292E0); C.set_parameter('B97_os_a4', 8.88211E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -2.55352E0); C.set_parameter('B97_ss_a2', 1.18926E1); C.set_parameter('B97_ss_a3', -2.69452E1); C.set_parameter('B97_ss_a4', 1.70927E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.157706)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:47645,Modifiability,Parameteriz,Parameterized,47645,"C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1;; omega = 0.2;; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter('B97_a4', 1.16386E1) # Table 1: c_{x\sigma,4}. C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0) # Table 1: c_{c\alpha\beta,0}; C.set_parameter('B97_os_a1', 1.79413E0) # Table 1: c_{c\alpha\beta,1}; C.set_parameter('B97_os_a2', -1.20477E1) # Table 1: c_{c\alpha\beta,2}; C.set_parameter('B97_os_a3', 1.40847E1)",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:49908,Modifiability,Parameteriz,Parameterized,49908,"# Table 1: c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(PsiMod.Dispersion.build('-CHG', 1.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3 # Should be reported/implemented to more digits; C2 = 4.49267E-3 # Should be reported/implemented to more digits; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', 0.08151); X.set_parameter('Meta_a2', -0.43956); X.set_parameter('Meta_a3', -3.22422); X.set_parameter('Meta_a4', 2.01819); X.set_parame",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/functional.html:52640,Modifiability,Parameteriz,Parameterized,52640,"ter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04463); C.set_parameter('B97_ss_a3', 30.69913); C.set_parameter('B97_ss_a4', -9.22695). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.28) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; # Should be reported/implemented to more digits; C2 = 4.49267E-3; # Should be reported/implemented to more digits; K0 = 3.0/2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0/3.0);; k0 = math.pow(6.0 * math.pi * math.pi, 1.0/3.0);; kp = C1 / (C2 * K0);; mu = 4.0 * k0 * k0 * kp * C2;; X.set_parameter('PBE_kp', kp); # Different effective kp; X.set_parameter('PBE_mu', mu); # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0' , 1.0); X.set_parameter('Meta_a1' ,-0.56833); X.set_parameter('Meta_a2' ,-1.30057); X.set_parameter('Meta_a3' , 5.50070); X.set_parameter('Meta_a4' , 9.06402); ",MatchSource.WIKI,psi4manual/4.0b2/_modules/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html
https://psicode.org/psi4manual/4.0b2/_modules/index.html:132,Availability,avail,available,132,". Overview: module code  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  . All modules for which code is available; aliases; driver; frac; functional; input; molutil; proc; procutil; psiexceptions; pubchem; qmmm; text; util; wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/index.html
https://psicode.org/psi4manual/4.0b2/_modules/index.html:420,Deployability,update,updated,420,". Overview: module code  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  . All modules for which code is available; aliases; driver; frac; functional; input; molutil; proc; procutil; psiexceptions; pubchem; qmmm; text; util; wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/index.html
https://psicode.org/psi4manual/4.0b2/_modules/index.html:252,Integrability,wrap,wrappers,252,". Overview: module code  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  . All modules for which code is available; aliases; driver; frac; functional; input; molutil; proc; procutil; psiexceptions; pubchem; qmmm; text; util; wrappers. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/index.html
https://psicode.org/psi4manual/4.0b2/_modules/input.html:376,Deployability,update,updated,376,". input  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for input; """"""Module import"""""". [docs]def process_input(raw_input, print_level=1):; pass. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/input.html
https://psicode.org/psi4manual/4.0b2/_modules/molutil.html:5237,Deployability,update,updated,5237," k + 1; break. # do the promotion; reals[rank] = reals[rank] + 1. # demote the right portion of the register; val = 1; for k in range(nreal - 1, rank, -1):; reals[k] = val; val = val + 1. # boundary condition is promotion into; # [nfrag+1 nfrag-1 ...]; if (reals[0] > nfrag):; break. return clusters. [docs]def new_set_attr(self, name, value):; """"""Function to redefine set_attr method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name); if isvar:; fxn = object.__getattribute__(self, ""set_variable""); fxn(name, value); return. object.__setattr__(self, name, value). [docs]def new_get_attr(self, name):; """"""Function to redefine get_attr method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def dynamic_variable_bind(cls):; """"""Function to bind PsiMod.Molecule class.""""""; # class specific; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr. dynamic_variable_bind(PsiMod.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. """"""; molecule = PsiMod.Molecule.create_molecule_from_string(geom); molecule.set_name(name). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.""""""; PsiMod.set_active_molecule(mol); #PsiMod.IO.set_default_namespace(mol.get_name()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/molutil.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:3042,Availability,avail,available,3042,"ion('SCF', 'REFERENCE') == 'UKS':; PsiMod.set_global_option('REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uhf':; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'rohf':; PsiMod.set_global_option('REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'RKS'); else:; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'UKS'); else:; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_global_option('REFERENCE', 'ROHF'). returnvalue = scf_helper(name, **kwargs). PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('SCF_TYPE', user_scftype); if not b_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'). return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". run_scf(name, **kwargs). if (PsiMod.get_global_option('SCF_TYPE') == 'DF'):; PsiMod.scfgrad(); else:; PsiMod.deriv(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17117,Availability,avail,available,17117,"""""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise Validat",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17212,Availability,avail,available,17212,"tion:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF ref",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18102,Availability,avail,available,18102,"ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_opti",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18197,Availability,avail,available,18197,"raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_globa",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:21412,Availability,checkpoint,checkpoint,21412,"_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); returnvalue = PsiMod.detci(). if (name.lower() != 'detci'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('MPN', 'FALSE'); PsiMod.revoke_global_option_changed('MPN'); PsiMod.set_global_option('MAX_NUM_VECS', 12); PsiMod.revoke_global_option_changed('MAX_NUM_VECS'); PsiMod.set_global_option('MPN_ORDER_SAVE', 0); PsiMod.revoke_global_option_changed('MPN_ORDER_SAVE'); PsiMod.set_global_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_option('EX_LEVEL', 2); PsiMod.revoke_global_option_changed('EX_LEVEL'). return returnvalue. [docs]def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. .. caution:: Get rid of madness-era restart file. """"""; if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'); e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'); if (name.upper() == 'SCS-DFMP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a referenc",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35360,Availability,error,errored,35360,"======\n'). # Close output file; PsiMod.close_outfile(). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(PsiMod.get_option('MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we'",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18675,Deployability,configurat,configuration,18675,"gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); el",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:37036,Deployability,update,updated,37036,"l('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. junk = 1; return junk. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:230,Energy Efficiency,energy,energy,230,". proc  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for proc; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """""". import PsiMod; import shutil; import os; import subprocess; import re; import input; import physconst; from molutil import *; from text import *; from procutil import *; # never import driver, wrappers, or aliases into this file. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; PsiMod.scf(); return PsiMod.dcft(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_dcft(name, **kwargs); PsiMod.deriv(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp2(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'); user_scftype = PsiMod.get_local_option('SCF', 'SCF_TYPE'); b_user_scftype = PsiMod.has_option_changed('SCF_TYPE'). if lowername == 'df-scf':; PsiMod.set_global_option('SCF_TYPE', 'DF'); elif lowername == 'hf':; if PsiMod.get_local_option('SCF', 'REFERENCE') == 'RKS':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif PsiMod.get_local_option('SCF', '",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:8691,Energy Efficiency,energy,energy,8691,"; """"""Function encoding sequence of PSI module calls for; a MP2 gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_mp2(name, **kwargs); PsiMod.set_global_option('WFN', 'MP2'). PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; PsiMod.set_global_option('WFN', 'CCSD_T'); elif (name.lower() == 'cc2'):; PsiMod.set_global_option('WFN', 'CC2'); elif (name.lower() == 'cc3'):; PsiMod.set_global_option('WFN', 'CC3'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); elif (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options,; # incl. wfn; elif(name.lower() == 'ccenergy'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); PsiMod.ccsort(); returnvalue = PsiMod.ccenergy(). if (name.lower() != 'ccenergy'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'). return returnvalue. [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; PsiM",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:15461,Energy Efficiency,energy,energy,15461,"tion encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('cc2', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CC2'); elif (name.lower() == 'eom-cc3'):; PsiMod.set_global_option('WFN', 'EOM_CC3'); run_ccenergy('cc3', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CC3'). PsiMod.cchbar(); returnvalue = PsiMod.cceom(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'). return returnvalue. [docs]def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); energy = run_eom_cc(name, **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'). PsiMod.set_global_option('WFN', 'EOM_CCSD'); PsiMod.set_global_option('ZETA', 'FALSE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'TRUE'); PsiMod.ccdensity(); PsiMod.set_global_option('ZETA', 'TRUE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'FALSE'); PsiMod.ccdensity(); PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(na",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:16236,Energy Efficiency,energy,energy,16236,"n_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); energy = run_eom_cc(name, **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'). PsiMod.set_global_option('WFN', 'EOM_CCSD'); PsiMod.set_global_option('ZETA', 'FALSE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'TRUE'); PsiMod.ccdensity(); PsiMod.set_global_option('ZETA', 'TRUE'); PsiMod.cclambda(); PsiMod.set_global_option('XI', 'FALSE'); PsiMod.ccdensity(); PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:20051,Energy Efficiency,energy,energy,20051,"ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); elif (name.lower() == 'cisdt'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 3); elif (name.lower() == 'cisdtq'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 4); elif (name.lower() == 'ci'):; PsiMod.set_global_option('WFN', 'DETCI'); level = kwargs['level']; PsiMod.set_global_option('EX_LEVEL', level); # Call a plain energy('detci') and have full control over options; elif(name.lower() == 'detci'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); returnvalue = PsiMod.detci(). if (name.lower() != 'detci'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('MPN', 'FALSE'); PsiMod.revoke_global_option_changed('MPN'); PsiMod.set_global_option('MAX_NUM_VECS', 12); PsiMod.revoke_global_option_changed('MAX_NUM_VECS'); PsiMod.set_global_option('MPN_ORDER_SAVE', 0); PsiMod.revoke_global_option_changed('MPN_ORDER_SAVE'); PsiMod.set_global_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:21965,Energy Efficiency,ENERGY,ENERGY,21965,"obal_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_option('EX_LEVEL', 2); PsiMod.revoke_global_option_changed('EX_LEVEL'). return returnvalue. [docs]def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. .. caution:: Get rid of madness-era restart file. """"""; if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'); e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'); if (name.upper() == 'SCS-DFMP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespa",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:24672,Energy Efficiency,ENERGY,ENERGY,24672,"Monomer A DFMP2'); PsiMod.print_out('\n'); e_monomerA_mp2 = PsiMod.dfmp2(). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1)",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:24735,Energy Efficiency,ENERGY,ENERGY,24735,"Mod.dfmp2(). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:24801,Energy Efficiency,ENERGY,ENERGY,24801,"hange_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_su",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:28209,Energy Efficiency,charge,charge-transfer,28209,"imer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:31352,Energy Efficiency,Charge,Charge,31352,"ce('monomerBm'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF (Monomer Basis)'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * p",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:31648,Energy Efficiency,ENERGY,ENERGY,31648,"PT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_gr",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:31915,Energy Efficiency,ENERGY,ENERGY,31915," (name.lower() == 'sapt2+-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, ",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:31991,Energy Efficiency,Charge,Charge,31991,"+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information;",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:32396,Energy Efficiency,Charge,Charge,32396,"('\n'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC s",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:32605,Energy Efficiency,ENERGY,ENERGY,32605,"iMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separat",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35699,Energy Efficiency,energy,energy,35699,"und == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(PsiMod.get_option('MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC')",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35841,Energy Efficiency,ENERGY,ENERGY,35841,"changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(PsiMod.get_option('MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. ",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35887,Energy Efficiency,ENERGY,ENERGY,35887,"; os.environ['OMP_NUM_THREADS'] = str(PsiMod.get_option('MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. junk = 1; return junk. Quick search. Ent",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:489,Integrability,wrap,wrappers,489,". proc  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for proc; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """""". import PsiMod; import shutil; import os; import subprocess; import re; import input; import physconst; from molutil import *; from text import *; from procutil import *; # never import driver, wrappers, or aliases into this file. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; PsiMod.scf(); return PsiMod.dcft(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_dcft(name, **kwargs); PsiMod.deriv(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp2(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'); user_scftype = PsiMod.get_local_option('SCF', 'SCF_TYPE'); b_user_scftype = PsiMod.has_option_changed('SCF_TYPE'). if lowername == 'df-scf':; PsiMod.set_global_option('SCF_TYPE', 'DF'); elif lowername == 'hf':; if PsiMod.get_local_option('SCF', 'REFERENCE') == 'RKS':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif PsiMod.get_local_option('SCF', '",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:7137,Integrability,rout,routine,7137,"print_out('\n'). # Perform the guess scf; PsiMod.scf(). # Move files to proper namespace; PsiMod.IO.change_file_namespace(180, (namespace + '.guess'), namespace); PsiMod.IO.set_default_namespace(namespace). # Set to read and project, and reset bases; PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.set_local_option('SCF', 'BASIS', basis); if (scf_type == 'DF'):; PsiMod.set_local_option('SCF', 'DF_BASIS_SCF', df_basis_scf); PsiMod.set_global_option('DF_INTS_IO', df_ints). # Print the banner for the standard operation; PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). # Do the full scf; e_scf = PsiMod.scf(precallback, postcallback). PsiMod.set_local_option('SCF', 'GUESS', guess_type). else:. e_scf = PsiMod.scf(precallback, postcallback). return e_scf. [docs]def run_mp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 calculation. """"""; PsiMod.set_global_option('WFN', 'MP2'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); PsiMod.ccsort(); returnvalue = PsiMod.mp2(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'). return returnvalue. [docs]def run_mp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_mp2(name, **kwargs); PsiMod.set_global_option('WFN', 'MP2'). PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:8810,Integrability,rout,routine,8810,"iMod.set_global_option('WFN', 'MP2'). PsiMod.deriv(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; PsiMod.set_global_option('WFN', 'CCSD_T'); elif (name.lower() == 'cc2'):; PsiMod.set_global_option('WFN', 'CC2'); elif (name.lower() == 'cc3'):; PsiMod.set_global_option('WFN', 'CC3'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); elif (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options,; # incl. wfn; elif(name.lower() == 'ccenergy'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); PsiMod.ccsort(); returnvalue = PsiMod.ccenergy(). if (name.lower() != 'ccenergy'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'). return returnvalue. [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; PsiMod.set_global_option('WFN', 'CCSD_T'). PsiMod.cchbar(); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.deriv(). if (name.lower() != 'ccenergy'):; PsiMod.set_global_",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:10224,Integrability,rout,routine,10224,"obal_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'). return returnvalue. [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'ccsd(t)'):; PsiMod.set_global_option('WFN', 'CCSD_T'). PsiMod.cchbar(); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.deriv(). if (name.lower() != 'ccenergy'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; if (name.lower() == 'bccd'):; PsiMod.set_global_option('WFN', 'BCCD'). # Bypass routine scf if user did something special to get it to; # converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.set_global_option('DELETE_TEI', 'false'). while True:; PsiMod.transqt2(); PsiMod.ccsort(); returnvalue = PsiMod.ccenergy(); PsiMod.print_out('Brueckner convergence check: %d\n' % PsiMod.get_variable('BRUECKNER CONVERGED')); if (PsiMod.get_variable('BRUECKNER CONVERGED') == True):; break. return returnvalue. [docs]def run_bccd_t(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. """"""; PsiMod.set_global_option('WFN', 'BCCD_T'); run_bccd(name, **kwargs). return PsiMod.cctriples(). [docs]def run_scf_property(name, **kwargs):. run_scf(name, **kwargs). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:20150,Integrability,rout,routine,20150,"['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); elif (name.lower() == 'cisdt'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 3); elif (name.lower() == 'cisdtq'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 4); elif (name.lower() == 'ci'):; PsiMod.set_global_option('WFN', 'DETCI'); level = kwargs['level']; PsiMod.set_global_option('EX_LEVEL', level); # Call a plain energy('detci') and have full control over options; elif(name.lower() == 'detci'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and input.yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_local_option('scf', 'scf_type') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.transqt2(); returnvalue = PsiMod.detci(). if (name.lower() != 'detci'):; PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('MPN', 'FALSE'); PsiMod.revoke_global_option_changed('MPN'); PsiMod.set_global_option('MAX_NUM_VECS', 12); PsiMod.revoke_global_option_changed('MAX_NUM_VECS'); PsiMod.set_global_option('MPN_ORDER_SAVE', 0); PsiMod.revoke_global_option_changed('MPN_ORDER_SAVE'); PsiMod.set_global_option('FCI', 'FALSE'); PsiMod.revoke_global_option_changed('FCI'); PsiMod.set_global_option('EX_LEVEL', 2); PsiMod.revoke_global_option_changed('EX_LEVEL'). return returnvalue. [docs]def run_dfmp2(name, **kwargs):; """"""Function enco",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:36764,Integrability,wrap,wrapper,36764,"l('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. junk = 1; return junk. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18675,Modifiability,config,configuration,18675,"gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'fci'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('FCI', 'TRUE'); elif (name.lower() == 'cisd'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('EX_LEVEL', 2); el",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:240,Performance,optimiz,optimize,240,". proc  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for proc; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """""". import PsiMod; import shutil; import os; import subprocess; import re; import input; import physconst; from molutil import *; from text import *; from procutil import *; # never import driver, wrappers, or aliases into this file. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; PsiMod.scf(); return PsiMod.dcft(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_dcft(name, **kwargs); PsiMod.deriv(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp2(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'); user_scftype = PsiMod.get_local_option('SCF', 'SCF_TYPE'); b_user_scftype = PsiMod.has_option_changed('SCF_TYPE'). if lowername == 'df-scf':; PsiMod.set_global_option('SCF_TYPE', 'DF'); elif lowername == 'hf':; if PsiMod.get_local_option('SCF', 'REFERENCE') == 'RKS':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif PsiMod.get_local_option('SCF', '",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:1033,Performance,optimiz,optimized,1033,". proc  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for proc; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """""". import PsiMod; import shutil; import os; import subprocess; import re; import input; import physconst; from molutil import *; from text import *; from procutil import *; # never import driver, wrappers, or aliases into this file. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; PsiMod.scf(); return PsiMod.dcft(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; PsiMod.set_global_option('DERTYPE', 'FIRST'). run_dcft(name, **kwargs); PsiMod.deriv(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp2(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'); user_scftype = PsiMod.get_local_option('SCF', 'SCF_TYPE'); b_user_scftype = PsiMod.has_option_changed('SCF_TYPE'). if lowername == 'df-scf':; PsiMod.set_global_option('SCF_TYPE', 'DF'); elif lowername == 'hf':; if PsiMod.get_local_option('SCF', 'REFERENCE') == 'RKS':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif PsiMod.get_local_option('SCF', '",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:6205,Performance,Perform,Perform,6205,"custom = 'Custom'; guessbasis = cast. # Hack to ensure cartesian or pure are used throughout; # This touches the option, as if the user set it; puream = PsiMod.get_global_option('PUREAM'); PsiMod.set_global_option('PUREAM', puream). # Switch to the guess namespace; namespace = PsiMod.IO.get_default_namespace(); PsiMod.IO.set_default_namespace((namespace + '.guess')). # Are we in a DF algorithm here?; scf_type = PsiMod.get_option('SCF_TYPE'); guess_type = PsiMod.get_option('GUESS'); df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); df_ints = PsiMod.get_option('DF_INTS_IO'). # Which basis is the final one; basis = PsiMod.get_option('BASIS'). # Setup initial SCF; PsiMod.set_local_option('SCF', 'BASIS', guessbasis); if (scf_type == 'DF'):; PsiMod.set_local_option('SCF', 'DF_BASIS_SCF', 'cc-pvdz-ri'); PsiMod.set_global_option('DF_INTS_IO', 'none'). # Print some info about the guess; PsiMod.print_out('\n'); banner('Guess SCF, %s Basis' % (guessbasis)); PsiMod.print_out('\n'). # Perform the guess scf; PsiMod.scf(). # Move files to proper namespace; PsiMod.IO.change_file_namespace(180, (namespace + '.guess'), namespace); PsiMod.IO.set_default_namespace(namespace). # Set to read and project, and reset bases; PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.set_local_option('SCF', 'BASIS', basis); if (scf_type == 'DF'):; PsiMod.set_local_option('SCF', 'DF_BASIS_SCF', df_basis_scf); PsiMod.set_global_option('DF_INTS_IO', df_ints). # Print the banner for the standard operation; PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). # Do the full scf; e_scf = PsiMod.scf(precallback, postcallback). PsiMod.set_local_option('SCF', 'GUESS', guess_type). else:. e_scf = PsiMod.scf(precallback, postcallback). return e_scf. [docs]def run_mp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 calculation. """"""; PsiMod.set_global_option('WFN', 'MP2'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:23322,Performance,LOAD,LOAD,23322,"psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); return PsiMod.psimrcc(). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Dimer DFMP2'); PsiMod.print_out('\n'); e_dimer_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer A DFMP2'); PsiMod.print_out('\n'); e_monomerA_mp2 = PsiMod.dfmp2(). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespa",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:26337,Performance,LOAD,LOAD,26337,"ive molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_loc",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:29337,Performance,LOAD,LOAD,29337,"enflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). activate(monomerAm); PsiMod.IO.set_default_namespace('monomerAm'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Monomer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerBm); Psi",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:34142,Performance,Load,Load,34142,"onError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = PsiMod.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); PsiMod.mrcc_generate_input(level). # Load the fort.56 file; # and dump a copy into the outfile; PsiMod.print_out('\n===== Begin fort.56 input for MRCC ======\n'); PsiMod.print_out(open('fort.56', 'r').read()); PsiMod.print_out('===== End fort.56 input for MRCC ======\n'). # Close output file; PsiMod.close_outfile(). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(PsiMod.get_option('MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.cal",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35902,Performance,Load,Load,35902,"'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. junk = 1; return junk. Quick search. Enter search terms or a module, class or function name.; . N",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:2995,Security,Validat,ValidationError,2995,"ion('SCF', 'REFERENCE') == 'UKS':; PsiMod.set_global_option('REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uhf':; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'rohf':; PsiMod.set_global_option('REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'RKS'); else:; PsiMod.set_global_option('REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_global_option('REFERENCE', 'UKS'); else:; PsiMod.set_global_option('REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_local_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_global_option('REFERENCE', 'ROHF'). returnvalue = scf_helper(name, **kwargs). PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('SCF_TYPE', user_scftype); if not b_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'). return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". run_scf(name, **kwargs). if (PsiMod.get_global_option('SCF_TYPE') == 'DF'):; PsiMod.scfgrad(); else:; PsiMod.deriv(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17070,Security,Validat,ValidationError,17070,"""""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise Validat",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17165,Security,Validat,ValidationError,17165,"tion:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF ref",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18055,Security,Validat,ValidationError,18055,"ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_opti",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18150,Security,Validat,ValidationError,18150,"raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_globa",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:18269,Security,Validat,ValidationError,18269,"lobal_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_global_option('SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). run_scf_gradient(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); PsiMod.revoke_global_option_changed('REFERENCE'). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; if (name.lower() == 'zapt'):; PsiMod.set_global_option('WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_option('MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_global_option('MPN_ORDER_SAVE', 2); else:; PsiMod.set_global_option('MPN_ORDER_SAVE', 1); elif (name.lower() == 'mp'):; PsiMod.set_global_option('WFN', 'DETCI'); PsiMod.set_global_option('MPN', 'TRUE'). level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_global_opti",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:25290,Security,Validat,ValidationError,25290,"ce(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; PsiMod.set_gl",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:28554,Security,Validat,ValidationError,28554,"'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('M",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/proc.html:33139,Security,Validat,ValidationError,33139,"ion (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = PsiMod.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); PsiMod.mrcc_generate_input(level). # Lo",MatchSource.WIKI,psi4manual/4.0b2/_modules/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html
https://psicode.org/psi4manual/4.0b2/_modules/procutil.html:3569,Deployability,update,updated,3569,"d options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (PsiMod.get_memory()); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/procutil.html
https://psicode.org/psi4manual/4.0b2/_modules/procutil.html:3036,Performance,load,loads,3036,"d options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (PsiMod.get_memory()); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/procutil.html
https://psicode.org/psi4manual/4.0b2/_modules/procutil.html:2403,Security,Validat,ValidationError,2403,"string_xyz(); commands += 'units angstrom\n}\n"""""", 0)\n'; return eval(commands). [docs]def format_options_for_input():; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (PsiMod.get_memory()); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. Quick search. Enter ",MatchSource.WIKI,psi4manual/4.0b2/_modules/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/procutil.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:247,Availability,Error,Error,247,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:325,Availability,Error,Error,325,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:380,Availability,error,error,380,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:749,Deployability,update,updated,749,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:386,Integrability,message,message,386,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html:290,Security,Validat,ValidationError,290,". psiexceptions  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for psiexceptions; """"""Module with non-generic exceptions classes.""""""; import PsiMod. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.msg = msg; PsiMod.print_out('\nPsiException: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/psiexceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/psiexceptions.html
https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html:2281,Availability,avail,available,2281,"urllib2.urlopen(url); except urllib2.URLError, e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); print ""\tRetrieved entry for chemical ID %d\n"" % self.cid; self.dataSDF = location.read(); #f = open(""TEST"", ""w""); #f.write(self.dataSDF); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if (self.natom == 0):; raise Exception(""PubchemError\n Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s",MatchSource.WIKI,psi4manual/4.0b2/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html:5024,Deployability,update,updated,5024,"unction to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % (urllib2.quote(name)); print ""\tSearching PubChem database for %s"" % (name); try:; loc = urllib2.urlopen(url); except urllib2.URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(""<pre>""); l = data.find(""\n"", l); for i in range(1, 21):; l = data.find(""%s. "" % (i), l); if l == -1:; break; l = data.find(""MF: "", l) + 4; mf = data[l:data.find(""\n"", l)]; l = data.find(""IUPAC: "", l) + 7; iupac = data[l:data.find(""\n"", l)]; l = data.find(""CID: "", l) + 5; #if l == 4:; # break; cid = int(data[l:data.find(""\n"", l)]); l = data.find(""\t"", l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj). print ""\tFound %d results"" % (len(ans)); return ans. if __name__ == ""__main__"":; try:; obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); except Exception as e:; print e.message. for r in obj:; print r; print r.getMoleculeString(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html:3509,Integrability,message,message,3509,"pile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % (urllib2.quote(name)); print ""\tSearching PubChem database for %s"" % (name); try:; loc = urllib2.urlopen(url); except urllib2.URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(""<pre>""); l = data.find(""\n"", l); for i in range(1, 21):; l = data.find(""%s. "" % (i), l); if l == -1:; break; l = data.find(""MF: "", l) + 4; mf = data[l:data.find(""\n"", l)]; l = data.find(""IUPAC: "", l) + 7; iupac = data[l:data.find(""\n"", l)]; l = data.find(""CID: "", l) + 5; #if l == 4:; # break; cid = int(data[l:data.find(""\n"", l)]); l = data.find(""\t"", l) + 1. pubobj = PubChemOb",MatchSource.WIKI,psi4manual/4.0b2/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html:4789,Integrability,message,message,4789,"unction to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % (urllib2.quote(name)); print ""\tSearching PubChem database for %s"" % (name); try:; loc = urllib2.urlopen(url); except urllib2.URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); data = loc.read(). ans = []; l = data.find(""<pre>""); l = data.find(""\n"", l); for i in range(1, 21):; l = data.find(""%s. "" % (i), l); if l == -1:; break; l = data.find(""MF: "", l) + 4; mf = data[l:data.find(""\n"", l)]; l = data.find(""IUPAC: "", l) + 7; iupac = data[l:data.find(""\n"", l)]; l = data.find(""CID: "", l) + 5; #if l == 4:; # break; cid = int(data[l:data.find(""\n"", l)]); l = data.find(""\t"", l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj). print ""\tFound %d results"" % (len(ans)); return ans. if __name__ == ""__main__"":; try:; obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); except Exception as e:; print e.message. for r in obj:; print r; print r.getMoleculeString(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html:1610,Testability,TEST,TEST,1610,"ng() => returns a string compatible; with PSI4's Molecule creation. """"""; import urllib2; import re. [docs]class PubChemObj(object):. def __init__(self, cid, mf, iupac):; self.url = 'http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi'; self.cid = cid; self.mf = mf; self.iupac = iupac; self.natom = 0; self.dataSDF = ''. def __str__(self):; return ""%17d %s\n"" % (self.cid, self.iupac). [docs] def getSDF(self):; """"""Function to return the SDF (structure-data file) of the PubChem object.""""""; if (len(self.dataSDF) == 0):; # When completed uncomment the following:; url = self.url + '?cid=' + urllib2.quote(str(self.cid)) + '&disopt=3DDisplaySDF'; try:; location = urllib2.urlopen(url); except urllib2.URLError, e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise Exception(msg); print ""\tRetrieved entry for chemical ID %d\n"" % self.cid; self.dataSDF = location.read(); #f = open(""TEST"", ""w""); #f.write(self.dataSDF); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if (self.natom == 0):; raise Exception(""PubchemError\n Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/pubchem.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:148,Deployability,integrat,integrate,148,". qmmm  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for qmmm; """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import PsiMod; import re; import os; import input; import math; import physconst; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:4291,Deployability,update,updated,4291,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:161,Energy Efficiency,charge,charges,161,". qmmm  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for qmmm; """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import PsiMod; import re; import os; import input; import math; import physconst; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:849,Energy Efficiency,charge,charges,849,". qmmm  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for qmmm; """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import PsiMod; import re; import os; import input; import math; import physconst; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1414,Energy Efficiency,energy,energy,1414,"):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1903,Energy Efficiency,charge,charges,1903,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diff",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1972,Energy Efficiency,Charge,Charge,1972,"BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:2718,Energy Efficiency,charge,charges,2718,"option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:2862,Energy Efficiency,charge,charge,2862,"General(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:2993,Energy Efficiency,charge,charge,2993,"g (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.add",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3062,Energy Efficiency,charge,charges,3062," self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in s",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3168,Energy Efficiency,charge,charge,3168,"elf.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a modul",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3242,Energy Efficiency,charge,charges,3242,"r = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module c",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3423,Energy Efficiency,Charge,Charges,3423,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3531,Energy Efficiency,charge,charges,3531,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3592,Energy Efficiency,charge,charges,3592,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3612,Energy Efficiency,charge,charges,3612,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3632,Energy Efficiency,charge,charges,3632,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3652,Energy Efficiency,charge,charges,3652,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3852,Energy Efficiency,charge,charge,3852,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3917,Energy Efficiency,charge,charges,3917,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3933,Energy Efficiency,Charge,Charges,3933,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3946,Energy Efficiency,charge,charge,3946,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3961,Energy Efficiency,charge,charges,3961,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:3993,Energy Efficiency,charge,charge,3993,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:4004,Energy Efficiency,charge,charge,4004,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:4015,Energy Efficiency,charge,charge,4015,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:4026,Energy Efficiency,charge,charge,4026,"setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:148,Integrability,integrat,integrate,148,". qmmm  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for qmmm; """"""Module with classes to integrate MM charges into; a QM calculation. """"""; import PsiMod; import re; import os; import input; import math; import physconst; from molutil import *; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1870,Performance,perform,perform,1870,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diff",MatchSource.WIKI,psi4manual/4.0b2/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html
https://psicode.org/psi4manual/4.0b2/_modules/text.html:4216,Availability,error,error,4216," each column of the Table object; such that the lowest value is zero. A scaling factor of *Factor* is applied. """"""; import copy. if len(self.data) == 0:; return. current_min = list(copy.deepcopy(self.data[0][1])); for datarow in self.data:; for col in range(0, len(datarow[1])):; if current_min[col] > datarow[1][col]:; current_min[col] = datarow[1][col]. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = (datarow[1][col] - current_min[col]) * Factor. [docs] def scale(self, Factor=physconst.psi_hartree2kcalmol):; """"""Function to apply a scaling factor *Factor* to the; data of the Table object. """"""; if len(self.data) == 0:; return. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = datarow[1][col] * Factor. [docs]def banner(text, type=1, width=35):; """"""Function to print *text* to output file in a banner of; minimum width *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). PsiMod.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print >> sys.stdout, stuff. [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print >> sys.stderr, stuff. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/text.html
https://psicode.org/psi4manual/4.0b2/_modules/text.html:4435,Deployability,update,updated,4435," each column of the Table object; such that the lowest value is zero. A scaling factor of *Factor* is applied. """"""; import copy. if len(self.data) == 0:; return. current_min = list(copy.deepcopy(self.data[0][1])); for datarow in self.data:; for col in range(0, len(datarow[1])):; if current_min[col] > datarow[1][col]:; current_min[col] = datarow[1][col]. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = (datarow[1][col] - current_min[col]) * Factor. [docs] def scale(self, Factor=physconst.psi_hartree2kcalmol):; """"""Function to apply a scaling factor *Factor* to the; data of the Table object. """"""; if len(self.data) == 0:; return. for datarow in self.data:; for col in range(0, len(datarow[1])):; #print datarow[1][col]; datarow[1][col] = datarow[1][col] * Factor. [docs]def banner(text, type=1, width=35):; """"""Function to print *text* to output file in a banner of; minimum width *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). PsiMod.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print >> sys.stdout, stuff. [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print >> sys.stderr, stuff. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/text.html
https://psicode.org/psi4manual/4.0b2/_modules/text.html:328,Modifiability,flexible,flexible,328,". text  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for text; """"""Module with utility classes and functions related; to data tables and text. """"""; import PsiMod; import sys; import physconst; from psiexceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, value):; self.labels.append(name); label = self.format_label(); self.labels = []. if isinstance(value, list):; self.data.append((label, value)); else:; self.data.append((label, [value])). [docs] def save(self, file):; """"""Function to save string of the Table object to *file*.""""""; import pickle; pickle_str = pickle.dumps(self); fileobj = open(file, ""w""); fileobj.write(str(self)); fileobj.close(). def __str__(self):; rowstr = lambda x: '%%%ds' % self.row_label_width % x; colstr = lambda x: '%%%ds' % self.width % x. lines = []. table_header = """"; if isinstance(self.rows, str):; table_header += ""%%%ds"" % self.row_label_width % self.rows; else:; table_header += "" "".join(map(row",MatchSource.WIKI,psi4manual/4.0b2/_modules/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/text.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1192,Availability,failure,failure,1192," import PsiMod; import sys; import os; from psiexceptions import *. [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; PsiMod.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return PsiMod.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; PsiMod.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, co",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1631,Availability,failure,failure,1631,"_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() !=",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2035,Availability,failure,failure,2035,":; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2484,Availability,failure,failure,2484,"mpare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print ""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep)); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = ex",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:4251,Availability,failure,failure,4251,"pected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col)); failed = 1; break. if(failed):; PsiMod.print_out(""The Failed Test Matrices\n""); computed.print_out(); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print ""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep)); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry)); failed = 1; break. if(failed):; PsiMod.print_out(""The computed vector\n""); computed.print_out(); PsiMod.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [doc",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:7945,Deployability,update,updated,7945," copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. """""". pid = str(os.getpid()); scratch = PsiMod.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit . command = ('%s %s %s/%s' % (cp, filename, scratch, target)); ; os.system(command); #print command. [docs]def copy_file_from_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file out of scratch with correct naming; convention. Arguments:. @arg filename full path to target file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32 ; @arg move copy or move? (default copy). Example:; ; Assume PID is 12345 and SCRATCH is /scratch/parrish/ . copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp /scratch/parrish/psi.12345.h2o.32 .temp ; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp ; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /scratch/parrish/psi.12345.32 /tmp/temp ; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = PsiMod.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit . command = ('%s %s/%s %s' % (cp, scratch, target, filename)); ; os.system(command); #print command. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1166,Performance,Perform,Performs,1166," import PsiMod; import sys; import os; from psiexceptions import *. [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; PsiMod.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return PsiMod.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; PsiMod.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, co",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1605,Performance,Perform,Performs,1605,"_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() !=",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2009,Performance,Perform,Performs,2009,":; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2458,Performance,Perform,Performs,2458,"mpare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print ""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep)); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = ex",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:4225,Performance,Perform,Performs,4225,"pected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col)); failed = 1; break. if(failed):; PsiMod.print_out(""The Failed Test Matrices\n""); computed.print_out(); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print ""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep)); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry)); failed = 1; break. if(failed):; PsiMod.print_out(""The computed vector\n""); computed.print_out(); PsiMod.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [doc",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:950,Testability,Test,Test,950,"til  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for util; """"""Module with utility functions for use in input files.""""""; import PsiMod; import sys; import os; from psiexceptions import *. [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; PsiMod.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return PsiMod.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; PsiMod.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1228,Testability,test,test,1228,"; from psiexceptions import *. [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; PsiMod.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return PsiMod.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; PsiMod.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); succes",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:1667,Testability,test,test,1667,"e number of threads to parallelize across.""""""; return PsiMod.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print '\t{0:.<66}PASSED'.format(label); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has ",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2071,Testability,test,test,2071," Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(ex",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:2580,Testability,test,test,2580,"puted* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print ""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep)); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed ",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:3907,Testability,Test,Test,3907,"y(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print ""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep)); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col)); failed = 1; break. if(failed):; PsiMod.print_out(""The Failed Test Matrices\n""); computed.print_out(); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print ""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep)); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - comput",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/util.html:4346,Testability,test,test,4346,"; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col)); failed = 1; break. if(failed):; PsiMod.print_out(""The Failed Test Matrices\n""); computed.print_out(); expected.print_out(); sys.exit(1); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; print ""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep)); sys.exit(1); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry)); failed = 1; break. if(failed):; PsiMod.print_out(""The computed vector\n""); computed.print_out(); PsiMod.print_out(""The reference vector\n""); expected.print_out(); sys.exit(1); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move ",MatchSource.WIKI,psi4manual/4.0b2/_modules/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17998,Availability,error,error,17998," - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs an",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:23923,Availability,avail,available,23923,"IATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25125,Availability,avail,available,25125,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25151,Availability,avail,availableDatabases,25151,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25414,Availability,avail,available,25414," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25440,Availability,avail,availableDatabases,25440," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26302,Availability,avail,available,26302,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databas",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26327,Availability,avail,availableDatabases,26327,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databas",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26386,Availability,error,error,26386,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databas",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26605,Availability,Avail,Available,26605,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26895,Availability,Avail,Available,26895,"boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and lon",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26921,Availability,avail,available,26921,"boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and lon",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:27438,Availability,avail,available,27438,"ings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tab",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:27715,Availability,avail,available,27715,"bset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', '",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28139,Availability,Error,Error,28139,"r; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34355,Availability,error,error,34355,"tionError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34683,Availability,avail,available,34683,"try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; t",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35284,Availability,avail,available,35284,"idationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35496,Availability,avail,available,35496,"; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write in",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35720,Availability,avail,available,35720,"lable for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagen",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35910,Availability,avail,available,35910,"y energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n""""""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48068,Availability,error,error,48068,"db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tabl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48249,Availability,error,error,48249,"ables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' %",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48388,Availability,error,error,48388,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48426,Availability,error,error,48426,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48440,Availability,error,error,48440,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48478,Availability,error,error,48478,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48497,Availability,error,error,48497,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48520,Availability,error,error,48520,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48541,Availability,error,error,48541,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:48549,Availability,error,error,48549,"maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; act",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:50312,Availability,Error,Error,50312,"ctivate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55950,Availability,avail,available,55950,"asis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param mole",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55998,Availability,avail,available,55998," corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4877,Deployability,configurat,configuration,4877,"(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24500,Deployability,continuous,continuous,24500,"` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complex",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24647,Deployability,continuous,continuous,24647,":func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whet",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30797,Deployability,Configurat,Configuration,30797,"module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:31474,Deployability,Configurat,Configuration,31474,"'DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mo",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:31979,Deployability,continuous,continuous,31979,cept AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_C,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32188,Deployability,continuous,continuous,32188,ll if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-fr,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32254,Deployability,continuous,continuous,32254,else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if i,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36520,Deployability,continuous,continuous,36520,"lif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single inpu",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36622,Deployability,continuous,continuous,36622,"lif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single inpu",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38694,Deployability,continuous,continuous,38694,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_ou",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:42253,Deployability,continuous,continuous,42253," == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UKS')\n"""""". # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freage",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:42574,Deployability,continuous,continuous,42574,"s_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UKS')\n"""""". # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.p",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51851,Deployability,configurat,configuration,51851,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:86857,Deployability,update,updated,86857,"e'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:224,Energy Efficiency,energy,energy,224,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:660,Energy Efficiency,energy,energy,660,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:794,Energy Efficiency,energy,energy,794,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4305,Energy Efficiency,energy,energy,4305,"cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:6138,Energy Efficiency,Energy,Energy,6138,"ne; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].a",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:6321,Energy Efficiency,Energy,Energy,6321,"'external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:6791,Energy Efficiency,Energy,Energy,6791,"et_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:8970,Energy Efficiency,Energy,Energy,8970,"romotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right portion of the register; val = 1; for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = PsiMod.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). # Run the clusters in the minimal cluster bases; PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the e",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:9845,Energy Efficiency,Energy,Energy,9845,"xtern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). # Run the clusters in the minimal cluster bases; PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.clean(). # Report the energies; PsiMod.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). PsiMod.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; PsiMod.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; PsiMod.print_out('%-3d ' % (l)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:10145,Energy Efficiency,Energy,Energy,10145,"on_python(""EXTERN"", externNone); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). # Run the clusters in the minimal cluster bases; PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.clean(). # Report the energies; PsiMod.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). PsiMod.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; PsiMod.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; PsiMod.print_out('%-3d ' % (l)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; physconst.psi_hartree2kcalmol * energies_full[n][k])); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:10511,Energy Efficiency,Energy,Energy,10511,"usters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.clean(). # Report the energies; PsiMod.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). PsiMod.print_out(' %6s %6s | %-24s\n' % (""N-Body"", ""Combo"", ""Monomers"")); for n in Ns:; for k in range(len(combos[n])):; PsiMod.print_out(' %6d %6d | ' % (n, k + 1)); for l in combos[n][k]:; PsiMod.print_out('%-3d ' % (l)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: Total Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_full[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; physconst.psi_hartree2kcalmol * energies_full[n][k])); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_mon[n][k],; physconst.psi_hartree2kcalmol * energies_mon[n][k])); PsiMod.print_out('\n'). if bsse == 'both':; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:11817,Energy Efficiency,Energy,Energy,11817,".16E %24.16E\n' % (n, k + 1, energies_full[n][k],; physconst.psi_hartree2kcalmol * energies_full[n][k])); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_mon[n][k],; physconst.psi_hartree2kcalmol * energies_mon[n][k])); PsiMod.print_out('\n'). if bsse == 'both':; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k] - energies_mon[n][k],; physconst.psi_hartree2kcalmol * (energies_full[n][k] - energies_mon[n][k]))); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: N-Body Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); energies_n_full = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_full[n])):; E = energies_full[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, physconst.psi_hartree2kcalmol * E)); En += E; energies_n_full[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_full[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); PsiMod.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_full[n],; physconst.psi_hartree2kcalmol * energies_n_full[n])); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); Psi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:14534,Energy Efficiency,Energy,Energy,14534,"ergies_n_mon[n])); PsiMod.print_out('\n'). if bsse == 'both':; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); energies_n_bsse = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_mon[n])):; E = energies_full[n][k] - energies_mon[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; E += energies_mon[1][combos[n][k][l] - 1]; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, physconst.psi_hartree2kcalmol * E)); En += E; energies_n_bsse[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_bsse[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); PsiMod.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_bsse[n],; physconst.psi_hartree2kcalmol * energies_n_bsse[n])); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: Non-Additivities <==\n\n'). if bsse == 'on' or bsse == 'both':; energies_n_full[1] = 0.0; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_full[Ns[k]] - energies_n_full[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; energies_n_mon[1] = 0.0; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_mon[Ns[k]] - energies_n_mon[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). if bsse == 'both':; energies_n_bsse[1] = 0.0; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16555,Energy Efficiency,energy,energy,16555,"' %6s %24s %24s\n' % (""N-Body"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16660,Energy Efficiency,ENERGY,ENERGY,16660,"_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16752,Energy Efficiency,ENERGY,ENERGY,16752,"_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercall",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16907,Energy Efficiency,energy,energy,16907,"_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17209,Energy Efficiency,energy,energy,17209," Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17318,Energy Efficiency,energy,energy,17318,"e cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any pos",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17492,Energy Efficiency,energy,energy,17492,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17623,Energy Efficiency,energy,energy,17623,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18204,Energy Efficiency,energy,energy,18204,":py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_ac",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18602,Energy Efficiency,energy,energy,18602,"erforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:19699,Energy Efficiency,energy,energy,19699,"ror('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:20162,Energy Efficiency,energy,energy,20162,"t_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full -",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:20699,Energy Efficiency,energy,energy,20699,"). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluste",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:20932,Energy Efficiency,Energy,Energy,20932,"tation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:21305,Energy Efficiency,ENERGY,ENERGY,21305,"e):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##;",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:21372,Energy Efficiency,Energy,Energy,21372,"e = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; ####",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:21390,Energy Efficiency,Energy,Energy,21390,"e = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; ####",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:21956,Energy Efficiency,ENERGY,ENERGY,21956,"full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:23662,Energy Efficiency,energy,energy,23662,"an absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or a",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24035,Energy Efficiency,energy,energy,24035,"SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24191,Energy Efficiency,energy,energy,24191,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24324,Energy Efficiency,energy,energy,24324,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25352,Energy Efficiency,energy,energy,25352,"ython functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are emp",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25998,Energy Efficiency,energy,energy,25998,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26047,Energy Efficiency,energy,energy,26047,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26489,Energy Efficiency,energy,energy,26489,") only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular sy",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26597,Energy Efficiency,energy,energy,26597,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * `",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28032,Energy Efficiency,energy,energy,28032,"ted database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwarg",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28451,Energy Efficiency,energy,energy,28451,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28528,Energy Efficiency,energy,energy,28528,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28545,Energy Efficiency,energy,energy,28545,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28699,Energy Efficiency,energy,energy,28699," list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdataba",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28719,Energy Efficiency,energy,energy,28719," list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdataba",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29241,Energy Efficiency,energy,energy,29241,",subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL;",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32634,Energy Efficiency,energy,energy,32634,gs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33141,Energy Efficiency,energy,energy,33141,rgs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34862,Energy Efficiency,energy,energy,34862,"correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:42302,Energy Efficiency,energy,energy,42302," == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UKS')\n"""""". # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freage",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:42447,Energy Efficiency,energy,energy,42447," == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""PsiMod.set_global_option('REFERENCE', 'UKS')\n"""""". # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freage",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:43802,Energy Efficiency,energy,energy,43802,"es_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database su",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45285,Energy Efficiency,energy,energy,45285,"; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::e",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45369,Energy Efficiency,energy,energy,45369,"ners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate,",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46484,Energy Efficiency,ENERGY,ENERGY,46484,"rgy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:47427,Energy Efficiency,energy,energy,47427," weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:47611,Energy Efficiency,Energy,Energy,47611,"bles += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:50302,Energy Efficiency,Energy,Energy,50302,"ctivate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psiv",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51117,Energy Efficiency,energy,energy,51117,"the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more ex",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51325,Energy Efficiency,energy,energy,51325,"ror'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment o",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51408,Energy Efficiency,ENERGY,ENERGY,51408,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51459,Energy Efficiency,ENERGY,ENERGY,51459,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51516,Energy Efficiency,ENERGY,ENERGY,51516,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51567,Energy Efficiency,ENERGY,ENERGY,51567,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51621,Energy Efficiency,ENERGY,ENERGY,51621,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51686,Energy Efficiency,ENERGY,ENERGY,51686,"', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. incl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52215,Energy Efficiency,energy,energy,52215,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only referenc",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52337,Energy Efficiency,energy,energy,52337,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only referenc",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52361,Energy Efficiency,energy,energy,52361,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only referenc",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52408,Energy Efficiency,energy,energy,52408,"Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only referenc",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52575,Energy Efficiency,Energy,Energy,52575,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_w",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52758,Energy Efficiency,energy,energy,52758,"RRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_w",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52974,Energy Efficiency,energy,energy,52974,"ified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53280,Energy Efficiency,energy,energy,53280,"overing treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53500,Energy Efficiency,energy,energy,53500,"ng stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53540,Energy Efficiency,energy,energy,53540,"ng stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set se",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53760,Energy Efficiency,energy,energy,53760,"es, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53823,Energy Efficiency,energy,energy,53823,"es, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53971,Energy Efficiency,energy,energy,53971,"up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54034,Energy Efficiency,energy,energy,54034,"up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54166,Energy Efficiency,energy,energy,54166,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54236,Energy Efficiency,energy,energy,54236,"ent, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54389,Energy Efficiency,energy,energy,54389,": string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54459,Energy Efficiency,energy,energy,54459,": string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54828,Energy Efficiency,energy,energy,54828,"ion; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55133,Energy Efficiency,energy,energy,55133,": ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_h",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55378,Energy Efficiency,energy,energy,55378," |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55632,Energy Efficiency,energy,energy,55632,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta c",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:55674,Energy Efficiency,energy,energy,55674,"|| ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1``",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56199,Energy Efficiency,energy,energy,56199,":`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replica",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56394,Energy Efficiency,energy,energy,56394," to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56616,Energy Efficiency,energy,energy,56616,"ets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtp",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56847,Energy Efficiency,energy,energy,56847,"; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57095,Energy Efficiency,energy,energy,57095,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57245,Energy Efficiency,energy,energy,57245,"e: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57348,Energy Efficiency,energy,energy,57348,"be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57476,Energy Efficiency,energy,energy,57476,"|| etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57687,Energy Efficiency,energy,energy,57687,"etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58018,Energy Efficiency,energy,energy,58018,"s cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58745,Energy Efficiency,energy,energy,58745,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scf",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58914,Energy Efficiency,energy,energy,58914,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scf",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59097,Energy Efficiency,energy,energy,59097," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59211,Energy Efficiency,energy,energy,59211," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59376,Energy Efficiency,ENERGY,ENERGY,59376,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59426,Energy Efficiency,ENERGY,ENERGY,59426,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59473,Energy Efficiency,ENERGY,ENERGY,59473,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59511,Energy Efficiency,ENERGY,ENERGY,59511,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59561,Energy Efficiency,ENERGY,ENERGY,59561,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59605,Energy Efficiency,ENERGY,ENERGY,59605,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59652,Energy Efficiency,ENERGY,ENERGY,59652,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59690,Energy Efficiency,ENERGY,ENERGY,59690,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59728,Energy Efficiency,ENERGY,ENERGY,59728,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59776,Energy Efficiency,ENERGY,ENERGY,59776,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59814,Energy Efficiency,ENERGY,ENERGY,59814,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59854,Energy Efficiency,ENERGY,ENERGY,59854,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59902,Energy Efficiency,ENERGY,ENERGY,59902,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59940,Energy Efficiency,ENERGY,ENERGY,59940,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59980,Energy Efficiency,ENERGY,ENERGY,59980,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60027,Energy Efficiency,ENERGY,ENERGY,60027,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60065,Energy Efficiency,ENERGY,ENERGY,60065,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60103,Energy Efficiency,ENERGY,ENERGY,60103,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60154,Energy Efficiency,ENERGY,ENERGY,60154,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60192,Energy Efficiency,ENERGY,ENERGY,60192,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60232,Energy Efficiency,ENERGY,ENERGY,60232,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60278,Energy Efficiency,ENERGY,ENERGY,60278,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60327,Energy Efficiency,ENERGY,ENERGY,60327,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60369,Energy Efficiency,ENERGY,ENERGY,60369,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60419,Energy Efficiency,ENERGY,ENERGY,60419,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60463,Energy Efficiency,ENERGY,ENERGY,60463,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60514,Energy Efficiency,ENERGY,ENERGY,60514,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60560,Energy Efficiency,ENERGY,ENERGY,60560,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60607,Energy Efficiency,ENERGY,ENERGY,60607,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:60645,Energy Efficiency,ENERGY,ENERGY,60645,"; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY',; 'ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; #VARH['cisd'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdcorl': 'CISD CORRELATION ENERGY'}; #VARH['cisdt'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtcorl': 'CISDT CORRELATION ENERGY'}; #VARH['cisdtq'] = { 'scftot': 'SCF TOTAL ENERGY',; # 'cisdtqcorl': 'CISDTQ CORRELATION ENERGY'}; VARH['fci'] = { 'scftot': 'SCF TOTAL ENERGY',; 'fcicorl': 'FCI CORRELATION ENERGY'}. finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_opt",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:61602,Energy Efficiency,energy,energy,61602,". finalenergy = 0.0; do_scf = 1; do_corl = 0; do_delta = 0; do_delta2 = 0. # Must collect (here) and set (below) basis sets after every new molecule activation; b_user_basis = PsiMod.has_global_option_changed('BASIS'); user_basis = PsiMod.get_option('BASIS'); #user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Est",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62056,Energy Efficiency,energy,energy,62056," #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62696,Energy Efficiency,energy,energy,62696,orl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + ,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63867,Energy Efficiency,energy,energy,63867,"t recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_ba",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64133,Energy Efficiency,energy,energy,64133,"se ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 's",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64493,Energy Efficiency,energy,energy,64493,"elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. #",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64784,Energy Efficiency,energy,energy,64784,"2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65047,Energy Efficiency,energy,energy,65047,"is sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta',",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65257,Energy Efficiency,energy,energy,65257,"se:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=Z",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65407,Energy Efficiency,energy,energy,65407,"ablish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65562,Energy Efficiency,energy,energy,65562,"basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(d",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65925,Energy Efficiency,energy,energy,65925,"t long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; GRAND_NEED = []; MODELCHEM = []; bstring = ''; if do_scf:; NEED = call_function_in_1st_argument(cbs_scf_scheme,; mode='requisition', basisname=BSTR, basiszeta=ZETR, wfnname='scf'); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme, reconstitute_bracketed_basis(NEED), 'scf', NEED, +1, 0.0]))). if do_corl:; NEED = call_function_in_1st_argument(cbs_corl_scheme,; mode='requisition', basisname=BSTC, basiszeta=ZETC, wfnname=cbs_corl_wfn); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme, reconstitute_bracketed_basis(NEED), cbs_corl_wfn, NEED, +1, 0.0]))). if do_delta:; NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnname=cbs_delta_wfn); GRAND_NEED.append(dict(zip(d_fields, ['delta', cbs_delta_scheme, reconstitute_bracketed_basis(NEED), cbs_delta_wfn, NEED, +1, 0.0]))). NEED = call_function_in_1st_argument(cbs_delta_scheme,; mode='requisition', basisname=BSTD, basiszeta=ZETD, wfnn",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:70159,Energy Efficiency,energy,energy,70159,"temp_wfn, temp_portion = split_menial(menial); JOBS_EXT.append(dict(zip(f_fields, [temp_wfn, temp_portion, job['f_basis'], job['f_zeta'], 0.0]))). #instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; #for mc in JOBS_EXT:; # instructions += """""" %12s / %-24s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); PsiMod.print_out(instructions). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\nPsiMod.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); exec commands. # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = PsiMod.get_variable(VARH[temp_wfn][menial]). PsiMod.clean(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:71576,Energy Efficiency,Energy,Energy,71576,"n(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:72132,Energy Efficiency,Energy,Energy,72132,"ergy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:72573,Energy Efficiency,Energy,Energy,72573,", 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[2]['d_stage'], GRAND_NEED[2]['d_wfn'] + ' - ' + GRAND_NEED[3]['d_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74125,Energy Efficiency,ENERGY,ENERGY,74125,"D_NEED[2]['d_stage'], GRAND_NEED[2]['d_wfn'] + ' - ' + GRAND_NEED[3]['d_wfn'],; '/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74199,Energy Efficiency,ENERGY,ENERGY,74199,"'/', GRAND_NEED[2]['d_basis'], '', GRAND_NEED[2]['d_energy'] - GRAND_NEED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrapper",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74281,Energy Efficiency,ENERGY,ENERGY,74281,"ED[3]['d_energy'], GRAND_NEED[2]['d_scheme'].__name__); if do_delta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74343,Energy Efficiency,ENERGY,ENERGY,74343,"ta2:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[4]['d_stage'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74421,Energy Efficiency,ENERGY,ENERGY,74421,"'], GRAND_NEED[4]['d_wfn'] + ' - ' + GRAND_NEED[5]['d_wfn'],; '/', GRAND_NEED[4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74501,Energy Efficiency,ENERGY,ENERGY,74501,"4]['d_basis'], '', GRAND_NEED[4]['d_energy'] - GRAND_NEED[5]['d_energy'], GRAND_NEED[4]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:77428,Energy Efficiency,energy,energypiece,77428,"rom array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (s",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78173,Energy Efficiency,energy,energy,78173," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78181,Energy Efficiency,energy,energypiece,78181," + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78409,Energy Efficiency,Energy,Energy,78409,"n array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'r",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78459,Energy Efficiency,energy,energypiece,78459,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (funct",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78522,Energy Efficiency,Energy,Energy,78522,".f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (funct",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78572,Energy Efficiency,energy,energypiece,78572,"mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78622,Energy Efficiency,energy,energypiece,78622,"ionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; '",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79091,Energy Efficiency,energy,energypiece,79091,"tract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79931,Energy Efficiency,energy,energy,79931," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionna",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79939,Energy Efficiency,energy,energypiece,79939," by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionna",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80222,Energy Efficiency,Energy,Energy,80222,".co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80303,Energy Efficiency,Energy,Energy,80303,"me_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnn",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80384,Energy Efficiency,Energy,Energy,80384,"s on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80407,Energy Efficiency,energy,energypiece,80407,"\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0]",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80522,Energy Efficiency,energy,energypiece,80522," the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80783,Energy Efficiency,energy,energypiece,80783,"ay; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81748,Energy Efficiency,energy,energy,81748,"-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81886,Energy Efficiency,energy,energypiece,81886,"'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_nam",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82101,Energy Efficiency,Energy,Energy,82101," # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82182,Energy Efficiency,Energy,Energy,82182,"s sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82263,Energy Efficiency,Energy,Energy,82263,"s; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Retu",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82344,Energy Efficiency,Energy,Energy,82344,"MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname,",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82367,Energy Efficiency,energy,energypiece,82367,"ct(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82546,Energy Efficiency,energy,energypiece,82546,"y; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy'];",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82820,Energy Efficiency,energy,energypiece,82820," = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); ener",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:83719,Energy Efficiency,energy,energy,83719,"plete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:83821,Energy Efficiency,energy,energypiece,83821,"ypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations nee",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84036,Energy Efficiency,Energy,Energy,84036,"NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = l",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84117,Energy Efficiency,Energy,Energy,84117," zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84198,Energy Efficiency,Energy,Energy,84198,"alid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84221,Energy Efficiency,energy,energypiece,84221,"hat logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84400,Energy Efficiency,energy,energypiece,84400,"ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3,Integrability,wrap,wrappers,3,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:120,Integrability,wrap,wrappers,120,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:648,Integrability,wrap,wrappers,648,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3984,Integrability,Wrap,Wrap,3984,"emove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4048,Integrability,wrap,wrappers,4048,"emove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4427,Integrability,wrap,wrapper,4427,"cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4505,Integrability,Wrap,Wrapper,4505,"""""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18293,Integrability,Wrap,Wrap,18293,". Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18357,Integrability,wrap,wrappers,18357,". Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18720,Integrability,wrap,wrapper,18720,"erforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18812,Integrability,Wrap,Wrapper,18812,"_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monome",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:25060,Integrability,wrap,wrappers,25060,"|dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-poin",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28861,Integrability,Wrap,Wrap,28861,"r; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28925,Integrability,wrap,wrappers,28925,"r; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29359,Integrability,wrap,wrapper,29359,",subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL;",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29439,Integrability,Wrap,Wrapper,29439,"f and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:37014,Integrability,wrap,wrapper,37014,"tabase %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38673,Integrability,wrap,wrapper,38673,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_ou",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38871,Integrability,wrap,wrapper,38871,"n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbs",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:40799,Integrability,wrap,wrapper,40799,"= ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:40872,Integrability,depend,dependent,40872,"n]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:43267,Integrability,wrap,wrapper,43267,"rent purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagen",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46518,Integrability,Depend,Depending,46518,"print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSD",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58568,Integrability,Wrap,Wrap,58568,"orrection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 's",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58632,Integrability,wrap,wrappers,58632,"orrection atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 's",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59033,Integrability,wrap,wrapper,59033,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scf",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59130,Integrability,Wrap,Wrapper,59130," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:61973,Integrability,wrap,wrapper,61973,"; #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62280,Integrability,wrap,wrapper,62280,"ion('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62598,Integrability,wrap,wrapper,62598,rrelation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62926,Integrability,wrap,wrapper,62926,"L method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC,",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63251,Integrability,wrap,wrapper,63251," not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:70012,Integrability,depend,dependent,70012,"]][mc['f_wfn'] + mc['f_portion']]). # Expand listings to all that will be obtained; JOBS_EXT = []; for indx_job, job in enumerate(JOBS):; for menial in VARH[job['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); JOBS_EXT.append(dict(zip(f_fields, [temp_wfn, temp_portion, job['f_basis'], job['f_zeta'], 0.0]))). #instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; #for mc in JOBS_EXT:; # instructions += """""" %12s / %-24s for %s\n"""""" % (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']+mc['f_portion']]); PsiMod.print_out(instructions). # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Computation: %s / %s ')\n"""""" % (mc['f_wfn'].upper(), mc['f_basis'].upper()); cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\nPsiMod.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); exec commands. # Make energy() call; mc['f_energy'] = call_function_in_1st_argument(func, **kwargs). # Fill in energies for subsumed methods; for menial in VARH[mc['f_wfn']]:; temp_wfn, temp_portion = split_menial(menial); for job in JOBS_EXT:; if (temp_wfn == job['f_wfn']) and (temp_portion == job['f_portion']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = PsiMod.get_variable(VARH[temp_wfn][menial]). PsiMod.clean(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_port",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75206,Integrability,wrap,wrappers,75206,"NERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:76561,Integrability,wrap,wrappers,76561," ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:77356,Integrability,wrap,wrappers,77356," basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78999,Integrability,wrap,wrappers,78999,"rtion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:80682,Integrability,wrap,wrappers,80682,"SET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = N",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:82704,Integrability,wrap,wrappers,82704,"LO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. #",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84532,Integrability,wrap,wrappers,84532,"red energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:86271,Integrability,wrap,wrappers,86271,"e'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:894,Modifiability,variab,variable,894,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4877,Modifiability,config,configuration,4877,"(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16580,Modifiability,variab,variables,16580," ""Delta E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_bsse[Ns[k]] - energies_n_bsse[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). # Put everything back the way it was; PsiMod.set_global_option('DF_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and `",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16980,Modifiability,variab,variables,16980,"ean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:22722,Modifiability,variab,variables,22722," in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26553,Modifiability,variab,variables,26553,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * `",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26627,Modifiability,variab,variable,26627,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26759,Modifiability,flexible,flexible,26759,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sens",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30797,Modifiability,Config,Configuration,30797,"module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:31474,Modifiability,Config,Configuration,31474,"'DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mo",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34833,Modifiability,variab,variables,34833,"correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationErr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:44087,Modifiability,variab,variable,44087,"eference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:44114,Modifiability,variab,variable,44114,"_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != r",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45424,Modifiability,variab,variable,45424,"; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values acco",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45578,Modifiability,variab,variable,45578,"ts place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may n",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46291,Modifiability,variab,variables,46291,"rgy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46325,Modifiability,VARIAB,VARIABLE,46325,"rgy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:46549,Modifiability,variab,variable,46549,"print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSD",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:47434,Modifiability,variab,variable,47434," weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for envv in db_tabulate:; tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s"""""" % (db_rxn, '', '****', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %8s"""""" % (db_rxn, BIND[db_rxn], '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = physconst.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %8.4f"""""" % (db_rxn, BIND[db_rxn], physconst.psi_hartree2kcalmol * ERXN[db_rxn], error); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51350,Modifiability,variab,variables,51350,"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the corr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51840,Modifiability,variab,variables,51840,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:51851,Modifiability,config,configuration,51851,"###################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Not all methods hooked in through PSI variables, configuration interaction and arbitrary order MP in particular. - No scheme defaults for given basis zeta number, so scheme must be specified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:71590,Modifiability,Variab,Variable,71590,"n(). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Results ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].iteritems():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; if ((lvl[1]['f_wfn'] == job['f_wfn']) and (lvl[1]['f_portion'] == job['f_portion']) and; (lvl[1]['f_basis'] == job['f_basis'])):; lvl[1]['f_energy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:249,Performance,optimiz,optimize,249,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:670,Performance,optimiz,optimize,670,". wrappers  PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2]  ; Module code . Source code for wrappers; """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import PsiMod; import re; import os; import input; import math; import warnings; import pickle; import copy; import physconst; from driver import *; from molutil import *; from text import *; from collections import defaultdict; from procutil import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2218,Performance,Queue,Queue,2218,"if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # li",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2534,Performance,Queue,Queue,2534,"[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2619,Performance,Queue,Queue,2619,"uto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom);",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2676,Performance,Queue,Queue,2676,"uto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom);",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2723,Performance,Queue,Queue,2723,"uto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom);",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2988,Performance,Queue,Queue,2988,"tivate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3099,Performance,Queue,Queue,3099," [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in k",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3135,Performance,Queue,Queue,3135,"mbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). #",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3300,Performance,Queue,Queue,3300,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3324,Performance,Queue,Queue,3324,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:7193,Performance,LOAD,LOAD,7193,"BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # Append the current combo; combos[n].append(copy.deepcopy(reals)). #reset rank; rank = 0. #look for lexical promotion opportunity; #i.e.: [4 2 1] has a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right p",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:9225,Performance,LOAD,LOAD,9225," for k in range(n - 1, rank, -1):; reals[k] = val; val = val + 1. #boundary condition is promotion into; #[nfrag+1 nfrag-1 ...]; if (reals[0] > N):; break. # Hack for external; externNone = PsiMod.ExternalPotential(). # Run the clusters in the full basis; if bsse == 'on' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_full[n] = []; clusters = extract_clusters(molecule, True, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Full Basis) <=\n' % (n, k + 1)); energies_full[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). # Run the clusters in the minimal cluster bases; PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if bsse == 'off' or bsse == 'both':; for n in range(max_effective, 0, -1):; energies_mon[n] = []; clusters = extract_clusters(molecule, False, n); for k in range(len(clusters)):; activate(clusters[k]); # Do the external field for this cluster or not?; if (external):; do_extern = False; for mon in combos[n][k]:; if (mon in external_indices):; do_extern = True; break; if do_extern:; PsiMod.set_global_option_python(""EXTERN"", external); PsiMod.print_out('\n => Cluster (N-Body %4d, Combination %4d) Energy (Cluster Basis) <=\n' % (n, k + 1)); energies_mon[n].append(call_function_in_1st_argument(func, **kwargs)); # Turn the external field off; if (external):; PsiMod.set_global_option_python(""EXTERN"", externNone); PsiMod.clean(). # Report the energies; PsiMod.print_out('\n ==> N-Body Interaction Energy Analysis: Combination Definitions <==\n\n'). PsiMod.print_out(' ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17337,Performance,optimiz,optimize,17337,"e cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any pos",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17400,Performance,perform,performed,17400,"of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17465,Performance,perform,performs,17465,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17518,Performance,optimiz,optimize,17518,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17548,Performance,optimiz,optimization,17548,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:17590,Performance,perform,performs,17590,"d interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kw",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:19779,Performance,LOAD,LOAD,19779,"_)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_globa",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24054,Performance,optimiz,optimize,24054,"SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24117,Performance,perform,performed,24117,"yz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24165,Performance,perform,performs,24165,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24218,Performance,optimiz,optimize,24218,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24248,Performance,optimiz,optimization,24248,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24291,Performance,perform,performs,24291,"e features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28384,Performance,Optimiz,Optimize,28384,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28486,Performance,optimiz,optimize,28486,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29581,Performance,load,load,29581,"ems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_E",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29876,Performance,load,load,29876," any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supra",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30039,Performance,load,loading,30039,"['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:43500,Performance,load,loads,43500,"llects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiM",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53321,Performance,perform,performed,53321,"overing treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85797,Performance,perform,performs,85797,"tion fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:1602,Safety,detect,detect,1602,"calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # It",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:1741,Safety,Detect,Detects,1741,"args):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4363,Security,Validat,ValidationError,4363,"cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4488,Security,Validat,ValidationError,4488,"""""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:5441,Security,Validat,ValidationError,5441,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:5536,Security,Validat,ValidationError,5536,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:5640,Security,Validat,ValidationError,5640,"vate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nf",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18656,Security,Validat,ValidationError,18656,"erforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18795,Security,Validat,ValidationError,18795,"_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monome",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:22545,Security,access,access,22545,"key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicate",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29295,Security,Validat,ValidationError,29295,",subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL;",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29422,Security,Validat,ValidationError,29422,"f and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30008,Security,Validat,ValidationError,30008,"['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30975,Security,Validat,ValidationError,30975,"ath))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #i",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:31828,Security,Validat,ValidationError,31828,"db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise Validati",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32420,Security,Validat,ValidationError,32420,rence; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise Valid,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32513,Security,Validat,ValidationError,32513, symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = da,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32824,Security,Validat,ValidationError,32824,('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:;,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33003,Security,Validat,ValidationError,33003,e')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33408,Security,Validat,ValidationError,33408,r('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'def,MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33670,Security,Validat,ValidationError,33670," 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not availa",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33851,Security,Validat,ValidationError,33851,"ion mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34121,Security,Validat,ValidationError,34121,"ergy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34251,Security,Validat,ValidationError,34251," if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34637,Security,Validat,ValidationError,34637,"try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; t",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35238,Security,Validat,ValidationError,35238,"idationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35450,Security,Validat,ValidationError,35450,"; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write in",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35668,Security,Validat,ValidationError,35668,"lable for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagen",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35867,Security,Validat,ValidationError,35867,"y energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n""""""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36096,Security,Validat,ValidationError,36096,"stance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:36958,Security,access,accessed,36958,"tabase %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38617,Security,access,accessed,38617,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_ou",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:40690,Security,Validat,ValidationError,40690,"= ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:44976,Security,Validat,ValidationError,44976,"in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45134,Security,Validat,ValidationError,45134,"ble %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HR",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58969,Security,Validat,ValidationError,58969,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scf",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59113,Security,Validat,ValidationError,59113," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:61890,Security,Validat,ValidationError,61890,"user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62196,Security,Validat,ValidationError,62196,"lobal_option_changed('WFN'); user_wfn = PsiMod.get_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62507,Security,Validat,ValidationError,62507,"od.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:62841,Security,Validat,ValidationError,62841,"in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63159,Security,Validat,ValidationError,63159,":; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validat",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63654,Security,Validat,ValidationError,63654,"or('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'de",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63998,Security,Validat,ValidationError,63998,"lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Es",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64301,Security,Validat,ValidationError,64301,"er)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if '",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64627,Security,Validat,ValidationError,64627,"ise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme =",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64923,Security,Validat,ValidationError,64923,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place order",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74560,Security,validat,validate,74560,"s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:74714,Security,validat,validate,74714,"s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; PsiMod.print_out(tables). # Restore molecule and options; #PsiMod.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; PsiMod.set_global_option('BASIS', user_basis). PsiMod.set_global_option('WFN', user_wfn); if not b_user_wfn:; PsiMod.revoke_global_option_changed('WFN'). PsiMod.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CBS TOTAL ENERGY', finalenergy); PsiMod.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); PsiMod.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75517,Security,Validat,ValidationError,75517,"finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NE",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75683,Security,Validat,ValidationError,75683,"orm and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q'",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75995,Security,Validat,ValidationError,75995,"' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[ze",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:77740,Security,Validat,ValidationError,77740,"] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79403,Security,Validat,ValidationError,79403,") Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81095,Security,Validat,ValidationError,81095,"ion parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Corr",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:83132,Security,Validat,ValidationError,83132,"O), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84992,Security,Validat,ValidationError,84992,"); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Ca",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85146,Security,Validat,ValidationError,85146,"sscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionnam",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85312,Security,Validat,ValidationError,85312,"ficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scft",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85478,Security,Validat,ValidationError,85478,"tion called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85631,Security,Validat,ValidationError,85631,"t; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Compl",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85972,Security,Validat,ValidationError,85972,"e'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:86071,Security,Validat,ValidationError,86071,"e'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2]  ; Module code .  Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:16924,Testability,test,tested,16924,"_INTS_IO', ri_ints_io); psioh.set_specific_retention(97, False); PsiMod.clean(); activate(molecule). if bsse == 'on' or bsse == 'both':; return energies_n_full[Ns[0]]; else:; return energies_n_mon[Ns[0]]. ## Aliases ##; nbody = n_body. #####################; ## End of n_body ##; #####################. ###################; ## Start of cp ##; ###################. [docs]def cp(name, **kwargs):; r""""""The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. :aliases: counterpoise_correct(), counterpoise_correction(). :returns: (*float*) Counterpoise-corrected interaction energy in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CP-CORRECTED 2-BODY INTERACTION ENERGY <CP-CORRECTED2-BODYINTERACTIONENERGY>`; * :psivar:`UNCP-CORRECTED 2-BODY INTERACTION ENERGY <UNCP-CORRECTED2-BODYINTERACTIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No values of func besides energy have been tested. - Table print-out needs improving. Add some PSI variables. :type name: string; :param name: ``'scf'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; :py:func:`~driver.energy`; however, SAPT is not appropriate. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; ``energy('name')``, while ``optimize`` perfoms a geometry optimization; on each system, and ``cbs`` performs a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26156,Testability,benchmark,benchmark,26156," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:26182,Testability,benchmark,benchmark,26182," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28176,Testability,benchmark,benchmark,28176,"r; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28242,Testability,benchmark,benchmark,28242,"r; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || etc.; For databases composed of dissociation curves, individual; curves can be called by name. Consult the database python; files for available molecular systems. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs)",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34336,Testability,benchmark,benchmark,34336,"tionError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34445,Testability,benchmark,benchmark,34445,"tionError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34491,Testability,benchmark,benchmark,34491,"tionError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34662,Testability,benchmark,benchmark,34662,"try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; t",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38966,Testability,benchmark,benchmark,38966,"ut file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:39281,Testability,log,logic,39281," will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(ch",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:77857,Testability,log,logs,77857,"= BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energi",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79520,Testability,log,logs,79520,"']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helg",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81212,Testability,log,logs,81212,"zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:81809,Testability,log,log,81809,"me().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypie",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:83249,Testability,log,logs,83249,"str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n""""",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:50120,Usability,simpl,simple,50120,"% (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57041,Usability,simpl,simple,57041,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57183,Usability,simpl,simple,57183,"e: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4manual/4.0b2/_modules/wrappers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html:562,Deployability,update,updated,562,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html:169,Performance,CACHE,CACHELEVEL,169,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html:189,Performance,cache,cache,189,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html:562,Deployability,update,updated,562,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html:169,Performance,CACHE,CACHELEVEL,169,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html:189,Performance,cache,cache,189,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Previous topic; ADC; Next topic; MEMORY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html:195,Availability,avail,available,195,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html:568,Deployability,update,updated,568,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html:260,Performance,CACHE,CACHELEVEL,260,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html:195,Availability,avail,available,195,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html:568,Deployability,update,updated,568,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html:260,Performance,CACHE,CACHELEVEL,260,". MEMORY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . MEMORY. The amount of memory available (in Mb). Type: integer; Default: 1000. Previous topic; CACHELEVEL; Next topic; NEWTON_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__memory.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__newton_convergence-1.html:599,Deployability,update,updated,599,". NEWTON_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Previous topic; MEMORY; Next topic; NORM_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__newton_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__newton_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__newton_convergence.html:599,Deployability,update,updated,599,". NEWTON_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NEWTON_CONVERGENCE. The convergence criterion for pole searching step. Type: conv double; Default: 1e-7. Previous topic; MEMORY; Next topic; NORM_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__newton_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__newton_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance-1.html:600,Deployability,update,updated,600,". NORM_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Previous topic; NEWTON_CONVERGENCE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance.html:600,Deployability,update,updated,600,". NORM_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NORM_TOLERANCE. The cutoff norm of residual vector in SEM step. Type: conv double; Default: 1e-6. Previous topic; NEWTON_CONVERGENCE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__norm_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__num_amps_print-1.html:594,Deployability,update,updated,594,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Previous topic; NORM_TOLERANCE; Next topic; POLE_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__num_amps_print.html:594,Deployability,update,updated,594,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . NUM_AMPS_PRINT. Number of components of transition amplitudes printed. Type: integer; Default: 5. Previous topic; NORM_TOLERANCE; Next topic; POLE_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__num_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter-1.html:570,Deployability,update,updated,570,". POLE_MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Previous topic; NUM_AMPS_PRINT; Next topic; PR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter.html:570,Deployability,update,updated,570,". POLE_MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . POLE_MAXITER. Maximum iteration number in pole searching. Type: integer; Default: 20. Previous topic; NUM_AMPS_PRINT; Next topic; PR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pole_maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pr-1.html:592,Deployability,update,updated,592,". PR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Previous topic; POLE_MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__pr-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pr-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pr.html:592,Deployability,update,updated,592,". PR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . PR. Do use the partial renormalization scheme for the ground state wavefunction?. Type: boolean; Default: false. Previous topic; POLE_MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__pr.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__pr.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__reference-1.html:557,Deployability,update,updated,557,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . REFERENCE. Reference wavefunction type. Type: string; Default: No Default. Previous topic; PR; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__reference.html:557,Deployability,update,updated,557,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . REFERENCE. Reference wavefunction type. Type: string; Default: No Default. Previous topic; PR; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep-1.html:570,Deployability,update,updated,570,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; SEM_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep.html:570,Deployability,update,updated,570,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . ROOTS_PER_IRREP. The poles per irrep vector. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; SEM_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter-1.html:591,Deployability,update,updated,591,". SEM_MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Previous topic; ROOTS_PER_IRREP; Next topic; CCDENSITY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter.html:591,Deployability,update,updated,591,". SEM_MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC . SEM_MAXITER. Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. Previous topic; ROOTS_PER_IRREP; Next topic; CCDENSITY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; ADC .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/adc__sem_maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ael-1.html:616,Deployability,update,updated,616,". AEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Previous topic; CCDENSITY; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ael-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ael-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ael.html:616,Deployability,update,updated,616,". AEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AEL. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. Previous topic; CCDENSITY; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ael.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ael.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html:601,Deployability,update,updated,601,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html:601,Deployability,update,updated,601,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; AEL; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html:573,Deployability,update,updated,573,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html:175,Performance,CACHE,CACHELEVEL,175,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html:202,Performance,cache,cacheing,202,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html:222,Performance,perform,perform,222,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html:573,Deployability,update,updated,573,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html:175,Performance,CACHE,CACHELEVEL,175,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html:202,Performance,cache,cacheing,202,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html:222,Performance,perform,perform,222,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . CACHELEVEL. The amount of cacheing of data to perform. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html:576,Deployability,update,updated,576,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html:266,Performance,CACHE,CACHELEVEL,266,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html:576,Deployability,update,updated,576,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html:266,Performance,CACHE,CACHELEVEL,266,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . GAUGE. The type of gauge to use for properties. Type: string; Default: LENGTH. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__gauge.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance-1.html:604,Deployability,update,updated,604,". INTS_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; GAUGE; Next topic; ONEPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance.html:604,Deployability,update,updated,604,". INTS_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; GAUGE; Next topic; ONEPDM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__ints_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm-1.html:586,Deployability,update,updated,586,". ONEPDM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; ONEPDM_GRID_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm.html:586,Deployability,update,updated,586,". ONEPDM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM. Do compute one-particle density matrix?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; ONEPDM_GRID_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html:634,Deployability,update,updated,634,". ONEPDM_GRID_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Previous topic; ONEPDM; Next topic; ONEPDM_GRID_DUMP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff.html:634,Deployability,update,updated,634,". ONEPDM_GRID_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_CUTOFF. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. Previous topic; ONEPDM; Next topic; ONEPDM_GRID_DUMP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump-1.html:632,Deployability,update,updated,632,". ONEPDM_GRID_DUMP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_CUTOFF; Next topic; ONEPDM_GRID_STEPSIZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump.html:632,Deployability,update,updated,632,". ONEPDM_GRID_DUMP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_DUMP. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_CUTOFF; Next topic; ONEPDM_GRID_STEPSIZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_dump.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html:634,Deployability,update,updated,634,". ONEPDM_GRID_STEPSIZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_STEPSIZE. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Previous topic; ONEPDM_GRID_DUMP; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize.html:634,Deployability,update,updated,634,". ONEPDM_GRID_STEPSIZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ONEPDM_GRID_STEPSIZE. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. Previous topic; ONEPDM_GRID_DUMP; Next topic; OPDM_RELAX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__onepdm_grid_stepsize.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax-1.html:592,Deployability,update,updated,592,". OPDM_RELAX  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_STEPSIZE; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax.html:592,Deployability,update,updated,592,". OPDM_RELAX  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . OPDM_RELAX. Do relax the one-particle density matrix?. Type: boolean; Default: false. Previous topic; ONEPDM_GRID_STEPSIZE; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__opdm_relax.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all-1.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Previous topic; OPDM_RELAX; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ALL. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. Previous topic; OPDM_RELAX; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_all.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root-1.html:588,Deployability,update,updated,588,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root.html:588,Deployability,update,updated,588,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym-1.html:555,Deployability,update,updated,555,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym.html:555,Deployability,update,updated,555,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__prop_sym.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__reference-1.html:568,Deployability,update,updated,568,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROP_SYM; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__reference.html:568,Deployability,update,updated,568,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROP_SYM; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep-1.html:623,Deployability,update,updated,623,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep.html:623,Deployability,update,updated,623,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__wfn-1.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; ROOTS_PER_IRREP; Next topic; XI; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__wfn.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; ROOTS_PER_IRREP; Next topic; XI; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi-1.html:534,Deployability,update,updated,534,". XI  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . XI. Do compute Xi?. Type: boolean; Default: false. Previous topic; WFN; Next topic; XI_CONNECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__xi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi.html:534,Deployability,update,updated,534,". XI  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . XI. Do compute Xi?. Type: boolean; Default: false. Previous topic; WFN; Next topic; XI_CONNECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__xi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect-1.html:560,Deployability,update,updated,560,". XI_CONNECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . XI_CONNECT. Do require and to be connected?. Type: boolean; Default: false. Previous topic; XI; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect.html:560,Deployability,update,updated,560,". XI_CONNECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . XI_CONNECT. Do require and to be connected?. Type: boolean; Default: false. Previous topic; XI; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__xi_connect.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__zeta-1.html:541,Deployability,update,updated,541,". ZETA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; XI_CONNECT; Next topic; CCENERGY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__zeta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__zeta-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__zeta.html:541,Deployability,update,updated,541,". ZETA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; XI_CONNECT; Next topic; CCENERGY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCDENSITY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccdensity__zeta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccdensity__zeta.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__abcd-1.html:583,Deployability,update,updated,583,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCENERGY; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__abcd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__abcd.html:583,Deployability,update,updated,583,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCENERGY; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__abcd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__analyze-1.html:551,Deployability,update,updated,551,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__analyze-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__analyze.html:551,Deployability,update,updated,551,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . ANALYZE. Do analyze T2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__analyze.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis-1.html:1216,Deployability,update,updated,1216,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . AO_BASIS. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ANALYZE; Next topic; BRUECKNER_ORBS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis.html:1216,Deployability,update,updated,1216,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . AO_BASIS. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ANALYZE; Next topic; BRUECKNER_ORBS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:684,Deployability,update,updated,684,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html:403,Performance,CACHE,CACHELEVEL,403,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:684,Deployability,update,updated,684,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html:403,Performance,CACHE,CACHELEVEL,403,". BRUECKNER_ORBS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . BRUECKNER_ORBS_R_CONVERGENCE. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. Previous topic; AO_BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__brueckner_orbs_r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:1013,Deployability,update,updated,1013,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html:733,Performance,CACHE,CACHETYPE,733,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:1013,Deployability,update,updated,1013,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html:733,Performance,CACHE,CACHETYPE,733,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; BRUECKNER_ORBS_R_CONVERGENCE; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:915,Deployability,update,updated,915,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:173,Performance,CACHE,CACHETYPE,173,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:248,Performance,cache,cache,248,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:367,Performance,cache,cache,367,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:498,Performance,cache,cache,498,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html:606,Performance,CACHE,CACHELEVEL,606,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:915,Deployability,update,updated,915,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:173,Performance,CACHE,CACHETYPE,173,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:248,Performance,cache,cache,248,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:367,Performance,cache,cache,367,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:498,Performance,cache,cache,498,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html:606,Performance,CACHE,CACHELEVEL,606,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a low priority scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a least recently used scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Previous topic; CACHELEVEL; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html:257,Performance,CACHE,CACHETYPE,257,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html:257,Performance,CACHE,CACHETYPE,257,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CACHETYPE; Next topic; CC_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_num_threads.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale-1.html:589,Deployability,update,updated,589,". CC_OS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_OS_SCALE. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. Previous topic; CC_NUM_THREADS; Next topic; CC_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale.html:589,Deployability,update,updated,589,". CC_OS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_OS_SCALE. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. Previous topic; CC_NUM_THREADS; Next topic; CC_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_os_scale.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale-1.html:575,Deployability,update,updated,575,". CC_SS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_SS_SCALE. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. Previous topic; CC_OS_SCALE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale.html:575,Deployability,update,updated,575,". CC_SS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . CC_SS_SCALE. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. Previous topic; CC_OS_SCALE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__cc_ss_scale.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__diis-1.html:584,Deployability,update,updated,584,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CC_SS_SCALE; Next topic; FORCE_RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__diis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__diis.html:584,Deployability,update,updated,584,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CC_SS_SCALE; Next topic; FORCE_RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__diis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart-1.html:611,Deployability,update,updated,611,". FORCE_RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . FORCE_RESTART. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart.html:611,Deployability,update,updated,611,". FORCE_RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . FORCE_RESTART. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__force_restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local-1.html:597,Deployability,update,updated,597,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FORCE_RESTART; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local.html:597,Deployability,update,updated,597,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FORCE_RESTART; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff-1.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff-1.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_method-1.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_method.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef-1.html:640,Deployability,update,updated,640,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_PAIRDEF. Definition of local pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef.html:640,Deployability,update,updated,640,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_PAIRDEF. Definition of local pair domains, default is BP, Boughton-Pulay. Type: string; Possible Values: BP, RESPONSE; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_pairdef.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html:874,Deployability,update,updated,874,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html:446,Energy Efficiency,energy,energy,446,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html:874,Deployability,update,updated,874,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html:446,Energy Efficiency,energy,energy,446,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter-1.html:591,Deployability,update,updated,591,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MAXITER. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter.html:591,Deployability,update,updated,591,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MAXITER. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; MP2_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print-1.html:643,Deployability,update,updated,643,". MP2_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_AMPS_PRINT. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Previous topic; MAXITER; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print.html:643,Deployability,update,updated,643,". MP2_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_AMPS_PRINT. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Previous topic; MAXITER; Next topic; MP2_OS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale-1.html:580,Deployability,update,updated,580,". MP2_OS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_OS_SCALE. MP2 opposite-spin scaling value. Type: double; Default: 1.20. Previous topic; MP2_AMPS_PRINT; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale.html:580,Deployability,update,updated,580,". MP2_OS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_OS_SCALE. MP2 opposite-spin scaling value. Type: double; Default: 1.20. Previous topic; MP2_AMPS_PRINT; Next topic; MP2_SS_SCALE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_os_scale.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale-1.html:576,Deployability,update,updated,576,". MP2_SS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_SS_SCALE. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale.html:576,Deployability,update,updated,576,". MP2_SS_SCALE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . MP2_SS_SCALE. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Previous topic; MP2_OS_SCALE; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__mp2_ss_scale.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples-1.html:567,Deployability,update,updated,567,". NEW_TRIPLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MP2_SS_SCALE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples.html:567,Deployability,update,updated,567,". NEW_TRIPLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MP2_SS_SCALE; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__new_triples.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print-1.html:599,Deployability,update,updated,599,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . NUM_AMPS_PRINT. Number of important and amplitudes to print. Type: integer; Default: 10. Previous topic; NEW_TRIPLES; Next topic; PAIR_ENERGIES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print.html:599,Deployability,update,updated,599,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . NUM_AMPS_PRINT. Number of important and amplitudes to print. Type: integer; Default: 10. Previous topic; NEW_TRIPLES; Next topic; PAIR_ENERGIES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__num_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print-1.html:616,Deployability,update,updated,616,". PAIR_ENERGIES_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . PAIR_ENERGIES_PRINT. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print.html:616,Deployability,update,updated,616,". PAIR_ENERGIES_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . PAIR_ENERGIES_PRINT. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__pair_energies_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__property-1.html:827,Deployability,update,updated,827,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. Previous topic; PAIR_ENERGIES_PRINT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__property-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__property.html:827,Deployability,update,updated,827,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. Previous topic; PAIR_ENERGIES_PRINT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__property.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__reference-1.html:596,Deployability,update,updated,596,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__reference.html:596,Deployability,update,updated,596,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html:478,Deployability,update,updates,478,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html:924,Deployability,update,updated,924,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html:261,Performance,optimiz,optimizations,261,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html:478,Deployability,update,updates,478,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html:924,Deployability,update,updated,924,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html:261,Performance,optimiz,optimizations,261,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . RESTART. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SCS_CCSD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence-1.html:620,Deployability,update,updated,620,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence.html:620,Deployability,update,updated,620,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html:592,Deployability,update,updated,592,". SCSN_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html:210,Performance,optimiz,optimized,210,". SCSN_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html:592,Deployability,update,updated,592,". SCSN_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html:210,Performance,optimiz,optimized,210,". SCSN_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Previous topic; SCS_MP2; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scsn_mp2.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd-1.html:560,Deployability,update,updated,560,". SCS_CCSD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_CCSD. Do spin-component-scaled CCSD. Type: boolean; Default: false. Previous topic; RESTART; Next topic; SCS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd.html:560,Deployability,update,updated,560,". SCS_CCSD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_CCSD. Do spin-component-scaled CCSD. Type: boolean; Default: false. Previous topic; RESTART; Next topic; SCS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_ccsd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2-1.html:570,Deployability,update,updated,570,". SCS_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_MP2. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCS_CCSD; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2.html:570,Deployability,update,updated,570,". SCS_MP2  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SCS_MP2. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. Previous topic; SCS_CCSD; Next topic; SCSN_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__scs_mp2.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical-1.html:589,Deployability,update,updated,589,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCSN_MP2; Next topic; SPINADAPT_ENERGIES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical.html:589,Deployability,update,updated,589,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCSN_MP2; Next topic; SPINADAPT_ENERGIES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__semicanonical.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html:596,Deployability,update,updated,596,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html:217,Energy Efficiency,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html:217,Modifiability,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html:596,Deployability,update,updated,596,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html:217,Energy Efficiency,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html:217,Modifiability,adapt,adapted,217,". SPINADAPT_ENERGIES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . SPINADAPT_ENERGIES. Do print spin-adapted pair energies?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; T2_COUPLED; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__spinadapt_energies.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled-1.html:549,Deployability,update,updated,549,". T2_COUPLED  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . T2_COUPLED. Type: boolean; Default: false. Previous topic; SPINADAPT_ENERGIES; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled.html:549,Deployability,update,updated,549,". T2_COUPLED  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . T2_COUPLED. Type: boolean; Default: false. Previous topic; SPINADAPT_ENERGIES; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t2_coupled.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore-1.html:595,Deployability,update,updated,595,". T3_WS_INCORE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . T3_WS_INCORE. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Previous topic; T2_COUPLED; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore.html:595,Deployability,update,updated,595,". T3_WS_INCORE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . T3_WS_INCORE. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Previous topic; T2_COUPLED; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__t3_ws_incore.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__wfn-1.html:643,Deployability,update,updated,643,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . WFN. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. Previous topic; T3_WS_INCORE; Next topic; CCEOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__wfn.html:643,Deployability,update,updated,643,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY . WFN. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. Previous topic; T3_WS_INCORE; Next topic; CCEOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCENERGY .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccenergy__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccenergy__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html:577,Deployability,update,updated,577,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html:299,Performance,CACHE,CACHELEVEL,299,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd.html:577,Deployability,update,updated,577,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd.html:299,Performance,CACHE,CACHELEVEL,299,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ABCD. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. Previous topic; CCEOM; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__abcd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:983,Deployability,update,updated,983,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:171,Performance,CACHE,CACHELEVEL,171,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:184,Performance,Cache,Cacheing,184,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:335,Performance,cache,cache,335,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:397,Performance,cache,cache,397,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:638,Performance,cache,cache,638,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html:706,Performance,CACHE,CACHETYPE,706,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:983,Deployability,update,updated,983,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:171,Performance,CACHE,CACHELEVEL,171,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:184,Performance,Cache,Cacheing,184,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:335,Performance,cache,cache,335,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:397,Performance,cache,cache,397,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:638,Performance,cache,cache,638,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html:706,Performance,CACHE,CACHETYPE,706,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; ABCD; Next topic; CACHETYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:211,Deployability,release,release,211,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:610,Deployability,update,updated,610,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:170,Performance,CACHE,CACHETYPE,170,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:219,Performance,cache,cached,219,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html:303,Performance,CACHE,CACHELEVEL,303,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:211,Deployability,release,release,211,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:610,Deployability,update,updated,610,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:3,Performance,CACHE,CACHETYPE,3,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:170,Performance,CACHE,CACHETYPE,170,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:219,Performance,cache,cached,219,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html:303,Performance,CACHE,CACHELEVEL,303,". CACHETYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Previous topic; CACHELEVEL; Next topic; CC3_FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cachetype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html:581,Deployability,update,updated,581,". CC3_FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html:276,Performance,CACHE,CACHETYPE,276,". CC3_FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html:581,Deployability,update,updated,581,". CC3_FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html:276,Performance,CACHE,CACHETYPE,276,". CC3_FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC3_FOLLOW_ROOT. Do turn on root following for CC3. Type: boolean; Default: false. Previous topic; CACHETYPE; Next topic; CC_NUM_THREADS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc3_follow_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads-1.html:569,Deployability,update,updated,569,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CC3_FOLLOW_ROOT; Next topic; COLLAPSE_WITH_LAST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads.html:569,Deployability,update,updated,569,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CC3_FOLLOW_ROOT; Next topic; COLLAPSE_WITH_LAST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__cc_num_threads.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last-1.html:590,Deployability,update,updated,590,". COLLAPSE_WITH_LAST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COLLAPSE_WITH_LAST. Do collapse with last vector?. Type: boolean; Default: true. Previous topic; CC_NUM_THREADS; Next topic; COMPLEX_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last.html:590,Deployability,update,updated,590,". COLLAPSE_WITH_LAST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COLLAPSE_WITH_LAST. Do collapse with last vector?. Type: boolean; Default: true. Previous topic; CC_NUM_THREADS; Next topic; COMPLEX_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__collapse_with_last.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html:206,Availability,toler,tolerance,206,". COMPLEX_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html:611,Deployability,update,updated,611,". COMPLEX_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html:206,Availability,toler,tolerance,206,". COMPLEX_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html:611,Deployability,update,updated,611,". COMPLEX_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . COMPLEX_TOLERANCE. Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. Previous topic; COLLAPSE_WITH_LAST; Next topic; E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__complex_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html:578,Availability,avail,available,578,". EOM_GUESS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html:984,Deployability,update,updated,984,". EOM_GUESS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html:578,Availability,avail,available,578,". EOM_GUESS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html:984,Deployability,update,updated,984,". EOM_GUESS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_GUESS. Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specified in user input. The latter method is not currently available. Type: string; Possible Values: SINGLES, DISK, INPUT; Default: SINGLES. Previous topic; E_CONVERGENCE; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_guess.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_reference-1.html:624,Deployability,update,updated,624,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; EOM_GUESS; Next topic; EXCITATION_RANGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_reference.html:624,Deployability,update,updated,624,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; EOM_GUESS; Next topic; EXCITATION_RANGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__eom_reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__excitation_range-1.html:891,Deployability,update,updated,891,". EXCITATION_RANGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EXCITATION_RANGE. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. Previous topic; EOM_REFERENCE; Next topic; FULL_MATRIX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__excitation_range-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__excitation_range-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__excitation_range.html:891,Deployability,update,updated,891,". EXCITATION_RANGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . EXCITATION_RANGE. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. Previous topic; EOM_REFERENCE; Next topic; FULL_MATRIX; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__excitation_range.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__excitation_range.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html:639,Deployability,update,updated,639,". E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html:227,Energy Efficiency,energy,energy,227,". E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html:639,Deployability,update,updated,639,". E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html:227,Energy Efficiency,energy,energy,227,". E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. Previous topic; COMPLEX_TOLERANCE; Next topic; EOM_GUESS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__e_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__full_matrix-1.html:579,Deployability,update,updated,579,". FULL_MATRIX  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . FULL_MATRIX. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. Previous topic; EXCITATION_RANGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__full_matrix-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__full_matrix-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__full_matrix.html:579,Deployability,update,updated,579,". FULL_MATRIX  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . FULL_MATRIX. Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. Previous topic; EXCITATION_RANGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__full_matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__full_matrix.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local-1.html:584,Deployability,update,updated,584,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FULL_MATRIX; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local.html:584,Deployability,update,updated,584,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; FULL_MATRIX; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff-1.html:810,Deployability,update,updated,810,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL; Next topic; LOCAL_DO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff.html:810,Deployability,update,updated,810,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL; Next topic; LOCAL_DO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles-1.html:556,Deployability,update,updated,556,". LOCAL_DO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_DO_SINGLES. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles.html:556,Deployability,update,updated,556,". LOCAL_DO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_DO_SINGLES. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_do_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles-1.html:608,Deployability,update,updated,608,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_FILTER_SINGLES. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_DO_SINGLES; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles.html:608,Deployability,update,updated,608,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_FILTER_SINGLES. Do apply local filtering to singles amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_DO_SINGLES; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_filter_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_ghost-1.html:661,Deployability,update,updated,661,". LOCAL_GHOST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_GHOST. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_ghost-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_ghost-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_ghost.html:661,Deployability,update,updated,661,". LOCAL_GHOST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_GHOST. Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations. Type: integer; Default: -1. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_ghost.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_ghost.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_method-1.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PRECONDITIONER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_method.html:791,Deployability,update,updated,791,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type: string; Possible Values: WERNER, AOBASIS; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_PRECONDITIONER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner-1.html:637,Deployability,update,updated,637,". LOCAL_PRECONDITIONER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_PRECONDITIONER. Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner.html:637,Deployability,update,updated,637,". LOCAL_PRECONDITIONER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_PRECONDITIONER. Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_preconditioner.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html:875,Deployability,update,updated,875,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html:443,Energy Efficiency,energy,energy,443,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html:875,Deployability,update,updated,875,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html:443,Energy Efficiency,energy,energy,443,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. Previous topic; LOCAL_PRECONDITIONER; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__maxiter-1.html:556,Deployability,update,updated,556,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . MAXITER. Maximum number of iterations. Type: integer; Default: 80. Previous topic; LOCAL_WEAKP; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__maxiter.html:556,Deployability,update,updated,556,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . MAXITER. Maximum number of iterations. Type: integer; Default: 80. Previous topic; LOCAL_WEAKP; Next topic; NEW_TRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__new_triples-1.html:556,Deployability,update,updated,556,". NEW_TRIPLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MAXITER; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__new_triples-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__new_triples-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__new_triples.html:556,Deployability,update,updated,556,". NEW_TRIPLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . NEW_TRIPLES. Do use new triples?. Type: boolean; Default: true. Previous topic; MAXITER; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__new_triples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__new_triples.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print-1.html:581,Deployability,update,updated,581,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . NUM_AMPS_PRINT. Number of important CC amplitudes to print. Type: integer; Default: 5. Previous topic; NEW_TRIPLES; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print.html:581,Deployability,update,updated,581,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . NUM_AMPS_PRINT. Number of important CC amplitudes to print. Type: integer; Default: 5. Previous topic; NEW_TRIPLES; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__num_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_root-1.html:622,Deployability,update,updated,622,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . PROP_ROOT. Root number (within its irrep) for computing properties. Defaults to highest root requested. Type: integer; Default: 0. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_root.html:622,Deployability,update,updated,622,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . PROP_ROOT. Root number (within its irrep) for computing properties. Defaults to highest root requested. Type: integer; Default: 0. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_sym-1.html:627,Deployability,update,updated,627,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . PROP_SYM. Symmetry of the state to compute properties. Defaults to last irrep for which states are requested. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_sym-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_sym.html:627,Deployability,update,updated,627,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . PROP_SYM. Symmetry of the state to compute properties. Defaults to last irrep for which states are requested. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__prop_sym.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__reference-1.html:598,Deployability,update,updated,598,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART_EOM_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__reference.html:598,Deployability,update,updated,598,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART_EOM_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3-1.html:570,Deployability,update,updated,570,". RESTART_EOM_CC3  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . RESTART_EOM_CC3. Do restart from on-disk?. Type: boolean; Default: false. Previous topic; REFERENCE; Next topic; RHF_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3.html:570,Deployability,update,updated,570,". RESTART_EOM_CC3  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . RESTART_EOM_CC3. Do restart from on-disk?. Type: boolean; Default: false. Previous topic; REFERENCE; Next topic; RHF_TRIPLETS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__restart_eom_cc3.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets-1.html:592,Deployability,update,updated,592,". RHF_TRIPLETS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . RHF_TRIPLETS. Do form a triplet state from RHF reference?. Type: boolean; Default: false. Previous topic; RESTART_EOM_CC3; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets.html:592,Deployability,update,updated,592,". RHF_TRIPLETS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . RHF_TRIPLETS. Do form a triplet state from RHF reference?. Type: boolean; Default: false. Previous topic; RESTART_EOM_CC3; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__rhf_triplets.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep-1.html:735,Deployability,update,updated,735,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ROOTS_PER_IRREP. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. Previous topic; RHF_TRIPLETS; Next topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep.html:735,Deployability,update,updated,735,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . ROOTS_PER_IRREP. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. Previous topic; RHF_TRIPLETS; Next topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__r_convergence-1.html:631,Deployability,update,updated,631,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. Previous topic; PROP_SYM; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__r_convergence.html:631,Deployability,update,updated,631,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. Previous topic; PROP_SYM; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html:714,Deployability,update,updated,714,". SCHMIDT_ADD_RESIDUAL_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SCHMIDT_ADD_RESIDUAL_TOLERANCE. Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. Previous topic; ROOTS_PER_IRREP; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance.html:714,Deployability,update,updated,714,". SCHMIDT_ADD_RESIDUAL_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SCHMIDT_ADD_RESIDUAL_TOLERANCE. Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. Previous topic; ROOTS_PER_IRREP; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__schmidt_add_residual_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__semicanonical-1.html:600,Deployability,update,updated,600,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; Next topic; SINGLES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__semicanonical-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__semicanonical.html:600,Deployability,update,updated,600,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; SCHMIDT_ADD_RESIDUAL_TOLERANCE; Next topic; SINGLES_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__semicanonical.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__singles_print-1.html:668,Deployability,update,updated,668,". SINGLES_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SINGLES_PRINT. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; SS_E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__singles_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__singles_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__singles_print.html:668,Deployability,update,updated,668,". SINGLES_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SINGLES_PRINT. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. Previous topic; SEMICANONICAL; Next topic; SS_E_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__singles_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__singles_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html:665,Deployability,update,updated,665,". SS_E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html:233,Energy Efficiency,energy,energy,233,". SS_E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html:665,Deployability,update,updated,665,". SS_E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html:233,Energy Efficiency,energy,energy,233,". SS_E_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_E_CONVERGENCE. Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SINGLES_PRINT; Next topic; SS_R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_e_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence-1.html:665,Deployability,update,updated,665,". SS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SS_E_CONVERGENCE; Next topic; SS_SKIP_DIAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence.html:665,Deployability,update,updated,665,". SS_R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_R_CONVERGENCE. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. Previous topic; SS_E_CONVERGENCE; Next topic; SS_SKIP_DIAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag-1.html:592,Deployability,update,updated,592,". SS_SKIP_DIAG  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_SKIP_DIAG. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. Previous topic; SS_R_CONVERGENCE; Next topic; SS_VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag.html:592,Deployability,update,updated,592,". SS_SKIP_DIAG  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_SKIP_DIAG. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. Previous topic; SS_R_CONVERGENCE; Next topic; SS_VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_skip_diag.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root-1.html:573,Deployability,update,updated,573,". SS_VECS_PER_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_VECS_PER_ROOT. SS vectors stored per root. Type: integer; Default: 5. Previous topic; SS_SKIP_DIAG; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root.html:573,Deployability,update,updated,573,". SS_VECS_PER_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . SS_VECS_PER_ROOT. SS vectors stored per root. Type: integer; Default: 5. Previous topic; SS_SKIP_DIAG; Next topic; T3_WS_INCORE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__ss_vecs_per_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore-1.html:604,Deployability,update,updated,604,". T3_WS_INCORE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . T3_WS_INCORE. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. Previous topic; SS_VECS_PER_ROOT; Next topic; VECS_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore.html:604,Deployability,update,updated,604,". T3_WS_INCORE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . T3_WS_INCORE. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. Previous topic; SS_VECS_PER_ROOT; Next topic; VECS_CC3; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__t3_ws_incore.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3-1.html:567,Deployability,update,updated,567,". VECS_CC3  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . VECS_CC3. Vectors stored in CC3 computations. Type: integer; Default: 10. Previous topic; T3_WS_INCORE; Next topic; VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3.html:567,Deployability,update,updated,567,". VECS_CC3  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . VECS_CC3. Vectors stored in CC3 computations. Type: integer; Default: 10. Previous topic; T3_WS_INCORE; Next topic; VECS_PER_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_cc3.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root-1.html:552,Deployability,update,updated,552,". VECS_PER_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . VECS_PER_ROOT. Vectors stored per root. Type: integer; Default: 12. Previous topic; VECS_CC3; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root.html:552,Deployability,update,updated,552,". VECS_PER_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . VECS_PER_ROOT. Vectors stored per root. Type: integer; Default: 12. Previous topic; VECS_CC3; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__vecs_per_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__wfn-1.html:584,Deployability,update,updated,584,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . WFN. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Previous topic; VECS_PER_ROOT; Next topic; CCHBAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__wfn.html:584,Deployability,update,updated,584,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM . WFN. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Previous topic; VECS_PER_ROOT; Next topic; CCHBAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCEOM .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cceom__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cceom__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:991,Deployability,update,updated,991,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:991,Deployability,update,updated,991,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; CCHBAR; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html:584,Deployability,update,updated,584,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html:584,Deployability,update,updated,584,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; T_AMPS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__eom_reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__t_amps-1.html:586,Deployability,update,updated,586,". T_AMPS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . T_AMPS. Do compute the Tamplitude equation matrix elements?. Type: boolean; Default: false. Previous topic; EOM_REFERENCE; Next topic; WABEI_LOWDISK; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__t_amps-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__t_amps-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__t_amps.html:586,Deployability,update,updated,586,". T_AMPS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . T_AMPS. Do compute the Tamplitude equation matrix elements?. Type: boolean; Default: false. Previous topic; EOM_REFERENCE; Next topic; WABEI_LOWDISK; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__t_amps.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__t_amps.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk-1.html:592,Deployability,update,updated,592,". WABEI_LOWDISK  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . WABEI_LOWDISK. Do use the minimal-disk algorithm for Wabei? Its VERY slow!. Type: boolean; Default: false. Previous topic; T_AMPS; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk.html:592,Deployability,update,updated,592,". WABEI_LOWDISK  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . WABEI_LOWDISK. Do use the minimal-disk algorithm for Wabei? Its VERY slow!. Type: boolean; Default: false. Previous topic; T_AMPS; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wabei_lowdisk.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wfn-1.html:538,Deployability,update,updated,538,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; WABEI_LOWDISK; Next topic; CCLAMBDA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wfn.html:538,Deployability,update,updated,538,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; WABEI_LOWDISK; Next topic; CCLAMBDA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCHBAR .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cchbar__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cchbar__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__abcd-1.html:557,Deployability,update,updated,557,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCLAMBDA; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__abcd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__abcd.html:557,Deployability,update,updated,557,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCLAMBDA; Next topic; AO_BASIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__abcd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html:600,Deployability,update,updated,600,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html:600,Deployability,update,updated,600,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:988,Deployability,update,updated,988,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:988,Deployability,update,updated,988,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:174,Performance,CACHE,CACHELEVEL,174,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:187,Performance,Cache,Cacheing,187,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:338,Performance,cache,cache,338,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:400,Performance,cache,cache,400,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html:641,Performance,cache,cache,641,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html:577,Deployability,update,updated,577,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html:275,Performance,CACHE,CACHELEVEL,275,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis.html:577,Deployability,update,updated,577,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis.html:275,Performance,CACHE,CACHELEVEL,275,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; JOBTYPE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__diis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html:555,Deployability,update,updated,555,". JOBTYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html:199,Performance,perform,performed,199,". JOBTYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html:555,Deployability,update,updated,555,". JOBTYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html:199,Performance,perform,performed,199,". JOBTYPE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . JOBTYPE. Type of job being performed. Type: string; Default: No Default. Previous topic; DIIS; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__jobtype.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local-1.html:591,Deployability,update,updated,591,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; JOBTYPE; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local.html:591,Deployability,update,updated,591,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; JOBTYPE; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff-1.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff.html:603,Deployability,update,updated,603,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff-1.html:832,Deployability,update,updated,832,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff.html:832,Deployability,update,updated,832,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles-1.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_FILTER_SINGLES. Do apply local filtering to single de-excitation ( amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_FILTER_SINGLES. Do apply local filtering to single de-excitation ( amplitudes?. Type: boolean; Default: true. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_filter_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_method-1.html:693,Deployability,update,updated,693,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_method.html:693,Deployability,update,updated,693,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef-1.html:586,Deployability,update,updated,586,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: No Default. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef.html:586,Deployability,update,updated,586,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: No Default. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_pairdef.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp-1.html:697,Deployability,update,updated,697,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp.html:697,Deployability,update,updated,697,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__maxiter-1.html:565,Deployability,update,updated,565,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__maxiter.html:565,Deployability,update,updated,565,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . MAXITER. Maximum number of iterations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print-1.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. Previous topic; MAXITER; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. Previous topic; MAXITER; Next topic; PROP_ALL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__num_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_all-1.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ALL. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_all-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_all-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_all.html:590,Deployability,update,updated,590,". PROP_ALL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ALL. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. Previous topic; NUM_AMPS_PRINT; Next topic; PROP_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_all.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_root-1.html:586,Deployability,update,updated,586,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_root.html:586,Deployability,update,updated,586,". PROP_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_ROOT. Root number (within its irrep) for computing properties. Type: integer; Default: 1. Previous topic; PROP_ALL; Next topic; PROP_SYM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym-1.html:557,Deployability,update,updated,557,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym.html:557,Deployability,update,updated,557,". PROP_SYM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . PROP_SYM. The symmetry of states. Type: integer; Default: 1. Previous topic; PROP_ROOT; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__prop_sym.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__restart-1.html:609,Deployability,update,updated,609,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . RESTART. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__restart.html:609,Deployability,update,updated,609,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . RESTART. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep-1.html:622,Deployability,update,updated,622,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep.html:622,Deployability,update,updated,622,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; RESTART; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence-1.html:625,Deployability,update,updated,625,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROP_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence.html:625,Deployability,update,updated,625,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . R_CONVERGENCE. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. Previous topic; PROP_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__sekino-1.html:575,Deployability,update,updated,575,". SEKINO  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__sekino-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__sekino-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__sekino.html:575,Deployability,update,updated,575,". SEKINO  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; ROOTS_PER_IRREP; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__sekino.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__sekino.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__wfn-1.html:531,Deployability,update,updated,531,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__wfn.html:531,Deployability,update,updated,531,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; ZETA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__zeta-1.html:534,Deployability,update,updated,534,". ZETA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; WFN; Next topic; CCRESPONSE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__zeta-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__zeta-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__zeta.html:534,Deployability,update,updated,534,". ZETA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA . ZETA. Do use zeta?. Type: boolean; Default: false. Previous topic; WFN; Next topic; CCRESPONSE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCLAMBDA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cclambda__zeta.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cclambda__zeta.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__abcd-1.html:562,Deployability,update,updated,562,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCRESPONSE; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__abcd-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__abcd-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__abcd.html:562,Deployability,update,updated,562,". ABCD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ABCD. Type of ABCD algorithm will be used. Type: string; Default: NEW. Previous topic; CCRESPONSE; Next topic; ANALYZE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__abcd.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__abcd.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html:557,Deployability,update,updated,557,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html:274,Performance,CACHE,CACHELEVEL,274,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html:557,Deployability,update,updated,557,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html:274,Performance,CACHE,CACHELEVEL,274,". ANALYZE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . ANALYZE. Do analyze X2 amplitudes. Type: boolean; Default: false. Previous topic; ABCD; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__analyze.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html:557,Deployability,update,updated,557,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html:176,Performance,CACHE,CACHELEVEL,176,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html:189,Performance,Cache,Cacheing,189,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html:557,Deployability,update,updated,557,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html:176,Performance,CACHE,CACHELEVEL,176,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html:189,Performance,Cache,Cacheing,189,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . CACHELEVEL. Cacheing level for libdpd. Type: integer; Default: 2. Previous topic; ANALYZE; Next topic; DIIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html:579,Deployability,update,updated,579,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html:277,Performance,CACHE,CACHELEVEL,277,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html:579,Deployability,update,updated,579,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html:277,Performance,CACHE,CACHELEVEL,277,". DIIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . DIIS. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. Previous topic; CACHELEVEL; Next topic; GAUGE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__diis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html:997,Deployability,update,updated,997,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html:463,Integrability,depend,dependent,463,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html:997,Deployability,update,updated,997,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html:463,Integrability,depend,dependent,463,". GAUGE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . GAUGE. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Previous topic; DIIS; Next topic; LINEAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__gauge.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__linear-1.html:567,Deployability,update,updated,567,". LINEAR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LINEAR. Do Bartlett size-extensive linear model?. Type: boolean; Default: false. Previous topic; GAUGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__linear-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__linear-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__linear.html:567,Deployability,update,updated,567,". LINEAR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LINEAR. Do Bartlett size-extensive linear model?. Type: boolean; Default: false. Previous topic; GAUGE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__linear.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__linear.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local-1.html:568,Deployability,update,updated,568,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL. Do simulate local correlation?. Type: boolean; Default: false. Previous topic; LINEAR; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local.html:568,Deployability,update,updated,568,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL. Do simulate local correlation?. Type: boolean; Default: false. Previous topic; LINEAR; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff-1.html:607,Deployability,update,updated,607,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff.html:607,Deployability,update,updated,607,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff-1.html:836,Deployability,update,updated,836,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff.html:836,Deployability,update,updated,836,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.01. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles-1.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles.html:626,Deployability,update,updated,626,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_filter_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_method-1.html:697,Deployability,update,updated,697,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_method.html:697,Deployability,update,updated,697,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef-1.html:584,Deployability,update,updated,584,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: NONE. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef.html:584,Deployability,update,updated,584,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_PAIRDEF. Definition of local pair domains. Type: string; Default: NONE. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_pairdef.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp-1.html:701,Deployability,update,updated,701,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp.html:701,Deployability,update,updated,701,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter-1.html:611,Deployability,update,updated,611,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . MAXITER. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter.html:611,Deployability,update,updated,611,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . MAXITER. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. Previous topic; LOCAL_WEAKP; Next topic; NUM_AMPS_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print-1.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. Previous topic; MAXITER; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print.html:633,Deployability,update,updated,633,". NUM_AMPS_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . NUM_AMPS_PRINT. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. Previous topic; MAXITER; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__num_amps_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__omega-1.html:857,Deployability,update,updated,857,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . OMEGA. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__omega-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__omega.html:857,Deployability,update,updated,857,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . OMEGA. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. Previous topic; NUM_AMPS_PRINT; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__omega.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__property-1.html:800,Deployability,update,updated,800,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__property-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__property.html:800,Deployability,update,updated,800,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . PROPERTY. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__property.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__reference-1.html:567,Deployability,update,updated,567,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__reference.html:567,Deployability,update,updated,567,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__restart-1.html:568,Deployability,update,updated,568,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . RESTART. Do restart from on-disk amplitudes?. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__restart-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__restart-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__restart.html:568,Deployability,update,updated,568,". RESTART  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . RESTART. Do restart from on-disk amplitudes?. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; SEKINO; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__restart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__restart.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence-1.html:624,Deployability,update,updated,624,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . R_CONVERGENCE. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence.html:624,Deployability,update,updated,624,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . R_CONVERGENCE. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. Previous topic; PROPERTY; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__sekino-1.html:571,Deployability,update,updated,571,". SEKINO  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; RESTART; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__sekino-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__sekino-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__sekino.html:571,Deployability,update,updated,571,". SEKINO  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . SEKINO. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Previous topic; RESTART; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__sekino.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__sekino.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__wfn-1.html:537,Deployability,update,updated,537,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; CCSORT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__wfn.html:537,Deployability,update,updated,537,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEKINO; Next topic; CCSORT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCRESPONSE .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccresponse__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccresponse__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html:598,Deployability,update,updated,598,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html:598,Deployability,update,updated,598,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html:319,Performance,CACHE,CACHELEVEL,319,". AO_BASIS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . AO_BASIS. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. Previous topic; CCSORT; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ao_basis.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:993,Deployability,update,updated,993,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:993,Deployability,update,updated,993,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:3,Performance,CACHE,CACHELEVEL,3,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:172,Performance,CACHE,CACHELEVEL,172,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:185,Performance,Cache,Cacheing,185,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:336,Performance,cache,cache,336,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:398,Performance,cache,cache,398,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html:639,Performance,cache,cache,639,". CACHELEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . CACHELEVEL. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. Previous topic; AO_BASIS; Next topic; EOM_REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__cachelevel.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html:592,Deployability,update,updated,592,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html:592,Deployability,update,updated,592,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html:285,Performance,CACHE,CACHELEVEL,285,". EOM_REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . EOM_REFERENCE. Reference wavefunction type for EOM computations. Type: string; Default: RHF. Previous topic; CACHELEVEL; Next topic; INTS_TOLERANCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__eom_reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance-1.html:612,Deployability,update,updated,612,". INTS_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; EOM_REFERENCE; Next topic; KEEP_OEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance.html:612,Deployability,update,updated,612,". INTS_TOLERANCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . INTS_TOLERANCE. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. Previous topic; EOM_REFERENCE; Next topic; KEEP_OEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__ints_tolerance.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile-1.html:590,Deployability,update,updated,590,". KEEP_OEIFILE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_OEIFILE. Do retain the input one-electron integrals?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; KEEP_TEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile.html:590,Deployability,update,updated,590,". KEEP_OEIFILE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_OEIFILE. Do retain the input one-electron integrals?. Type: boolean; Default: false. Previous topic; INTS_TOLERANCE; Next topic; KEEP_TEIFILE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_oeifile.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile-1.html:581,Deployability,update,updated,581,". KEEP_TEIFILE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_TEIFILE. Do retain the input two-electron integrals?. Type: boolean; Default: false. Previous topic; KEEP_OEIFILE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile.html:581,Deployability,update,updated,581,". KEEP_TEIFILE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . KEEP_TEIFILE. Do retain the input two-electron integrals?. Type: boolean; Default: false. Previous topic; KEEP_OEIFILE; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__keep_teifile.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local-1.html:592,Deployability,update,updated,592,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; KEEP_TEIFILE; Next topic; LOCAL_CORE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local.html:592,Deployability,update,updated,592,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; KEEP_TEIFILE; Next topic; LOCAL_CORE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff-1.html:574,Deployability,update,updated,574,". LOCAL_CORE_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CORE_CUTOFF. Local core cutoff value. Type: double; Default: 0.05. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff.html:574,Deployability,update,updated,574,". LOCAL_CORE_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CORE_CUTOFF. Local core cutoff value. Type: double; Default: 0.05. Previous topic; LOCAL; Next topic; LOCAL_CPHF_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_core_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff-1.html:611,Deployability,update,updated,611,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_CORE_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff.html:611,Deployability,update,updated,611,". LOCAL_CPHF_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CPHF_CUTOFF. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. Previous topic; LOCAL_CORE_CUTOFF; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cphf_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff-1.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_DOMAIN_MAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff.html:824,Deployability,update,updated,824,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_CPHF_CUTOFF; Next topic; LOCAL_DOMAIN_MAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag-1.html:614,Deployability,update,updated,614,". LOCAL_DOMAIN_MAG  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_MAG. Do generate magnetic-field CPHF solutions for local-CC?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_DOMAIN_POLAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag.html:614,Deployability,update,updated,614,". LOCAL_DOMAIN_MAG  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_MAG. Do generate magnetic-field CPHF solutions for local-CC?. Type: boolean; Default: false. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_DOMAIN_POLAR; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_mag.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar-1.html:612,Deployability,update,updated,612,". LOCAL_DOMAIN_POLAR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_POLAR. Do use augment domains with polarized orbitals?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_MAG; Next topic; LOCAL_DOMAIN_SEP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar.html:612,Deployability,update,updated,612,". LOCAL_DOMAIN_POLAR  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_POLAR. Do use augment domains with polarized orbitals?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_MAG; Next topic; LOCAL_DOMAIN_SEP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_polar.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep-1.html:565,Deployability,update,updated,565,". LOCAL_DOMAIN_SEP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_SEP. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_POLAR; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep.html:565,Deployability,update,updated,565,". LOCAL_DOMAIN_SEP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_DOMAIN_SEP. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_POLAR; Next topic; LOCAL_FILTER_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_domain_sep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles-1.html:622,Deployability,update,updated,622,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_SEP; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles.html:622,Deployability,update,updated,622,". LOCAL_FILTER_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_FILTER_SINGLES. Do apply local filtering to single excitation amplitudes?. Type: boolean; Default: false. Previous topic; LOCAL_DOMAIN_SEP; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_filter_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_method-1.html:689,Deployability,update,updated,689,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_method.html:689,Deployability,update,updated,689,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_METHOD. Type of local-CCSD scheme to be simulated. WERNER (unique avaliable option) selects the method developed by H.-J. Werner and co-workers. Type: string; Default: WERNER. Previous topic; LOCAL_FILTER_SINGLES; Next topic; LOCAL_PAIRDEF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef-1.html:621,Deployability,update,updated,621,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_PAIRDEF. Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef.html:621,Deployability,update,updated,621,". LOCAL_PAIRDEF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_PAIRDEF. Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. Previous topic; LOCAL_METHOD; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_pairdef.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp-1.html:691,Deployability,update,updated,691,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp.html:691,Deployability,update,updated,691,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. Previous topic; LOCAL_PAIRDEF; Next topic; OMEGA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html:580,Deployability,update,updated,580,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html:175,Energy Efficiency,Energy,Energy,175,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega.html:580,Deployability,update,updated,580,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega.html:175,Energy Efficiency,Energy,Energy,175,". OMEGA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . OMEGA. Energy of applied field [au] for dynamic properties. Type: array; Default: No Default. Previous topic; LOCAL_WEAKP; Next topic; PROPERTY; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__omega.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__omega.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__property-1.html:639,Deployability,update,updated,639,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . PROPERTY. The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__property-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__property-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__property.html:639,Deployability,update,updated,639,". PROPERTY  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . PROPERTY. The response property desired. The unique acceptable values is POLARIZABILITY for dipole-polarizabilitie. Type: string; Default: POLARIZABILITY. Previous topic; OMEGA; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__property.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__property.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__reference-1.html:560,Deployability,update,updated,560,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROPERTY; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__reference.html:560,Deployability,update,updated,560,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; PROPERTY; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical-1.html:571,Deployability,update,updated,571,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical.html:571,Deployability,update,updated,571,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__semicanonical.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__wfn-1.html:546,Deployability,update,updated,546,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . WFN. Wavefunction type. Type: string; Default: No Default. Previous topic; SEMICANONICAL; Next topic; CCTRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__wfn.html:546,Deployability,update,updated,546,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT . WFN. Wavefunction type. Type: string; Default: No Default. Previous topic; SEMICANONICAL; Next topic; CCTRIPLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCSORT .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/ccsort__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/ccsort__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads-1.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CCTRIPLES; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads.html:562,Deployability,update,updated,562,". CC_NUM_THREADS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . CC_NUM_THREADS. Number of threads. Type: integer; Default: 1. Previous topic; CCTRIPLES; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__cc_num_threads.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__reference-1.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; CC_NUM_THREADS; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__reference.html:572,Deployability,update,updated,572,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . REFERENCE. Reference wavefunction type. Type: string; Default: RHF. Previous topic; CC_NUM_THREADS; Next topic; SEMICANONICAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical-1.html:577,Deployability,update,updated,577,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical.html:577,Deployability,update,updated,577,". SEMICANONICAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . SEMICANONICAL. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__semicanonical.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__wfn-1.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEMICANONICAL; Next topic; CEPA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__wfn.html:540,Deployability,update,updated,540,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES . WFN. Wavefunction type. Type: string; Default: SCF. Previous topic; SEMICANONICAL; Next topic; CEPA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CCTRIPLES .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cctriples__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cctriples__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_level-1.html:683,Deployability,update,updated,683,". CEPA_LEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_LEVEL. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value wont have any effect on the procedure. Type: string; Default: CEPA(0). Previous topic; CEPA; Next topic; CEPA_NO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_level-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_level-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_level.html:683,Deployability,update,updated,683,". CEPA_LEVEL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_LEVEL. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value wont have any effect on the procedure. Type: string; Default: CEPA(0). Previous topic; CEPA; Next topic; CEPA_NO_SINGLES; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_level.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_level.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html:224,Deployability,configurat,configurations,224,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html:685,Deployability,update,updated,685,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html:224,Modifiability,config,configurations,224,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html:293,Performance,optimiz,optimized,293,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html:224,Deployability,configurat,configurations,224,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html:685,Deployability,update,updated,685,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html:224,Modifiability,config,configurations,224,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html:293,Performance,optimiz,optimized,293,". CEPA_NO_SINGLES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_NO_SINGLES. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Previous topic; CEPA_LEVEL; Next topic; CEPA_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_no_singles.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os-1.html:587,Deployability,update,updated,587,". CEPA_SCALE_OS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_SCALE_OS. Oppposite-spin scaling factor for SCS-CEPA. Type: double; Default: 1.27. Previous topic; CEPA_NO_SINGLES; Next topic; CEPA_SCALE_SS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os.html:587,Deployability,update,updated,587,". CEPA_SCALE_OS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_SCALE_OS. Oppposite-spin scaling factor for SCS-CEPA. Type: double; Default: 1.27. Previous topic; CEPA_NO_SINGLES; Next topic; CEPA_SCALE_SS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_os.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss-1.html:584,Deployability,update,updated,584,". CEPA_SCALE_SS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_SCALE_SS. Same-spin scaling factor for SCS-CEPA. Type: double; Default: 1.13. Previous topic; CEPA_SCALE_OS; Next topic; CEPA_VABCD_DIRECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss.html:584,Deployability,update,updated,584,". CEPA_SCALE_SS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_SCALE_SS. Same-spin scaling factor for SCS-CEPA. Type: double; Default: 1.13. Previous topic; CEPA_SCALE_OS; Next topic; CEPA_VABCD_DIRECT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_scale_ss.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html:819,Deployability,update,updated,819,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html:256,Integrability,contract,contraction,256,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html:456,Safety,avoid,avoided,456,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html:819,Deployability,update,updated,819,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html:256,Integrability,contract,contraction,256,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html:456,Safety,avoid,avoided,456,". CEPA_VABCD_DIRECT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . CEPA_VABCD_DIRECT. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Previous topic; CEPA_SCALE_SS; Next topic; DIIS_MAX_VECS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__cepa_vabcd_direct.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs-1.html:587,Deployability,update,updated,587,". DIIS_MAX_VECS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . DIIS_MAX_VECS. Number of vectors to store for DIIS extrapolation. Type: integer; Default: 8. Previous topic; CEPA_VABCD_DIRECT; Next topic; DIPMOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs.html:587,Deployability,update,updated,587,". DIIS_MAX_VECS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . DIIS_MAX_VECS. Number of vectors to store for DIIS extrapolation. Type: integer; Default: 8. Previous topic; CEPA_VABCD_DIRECT; Next topic; DIPMOM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__diis_max_vecs.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__dipmom-1.html:616,Deployability,update,updated,616,". DIPMOM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . DIPMOM. Compute the dipole moment? Note that quadrupole moments will also be computed if PRINT >= 2. Type: boolean; Default: false. Previous topic; DIIS_MAX_VECS; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__dipmom-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__dipmom-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__dipmom.html:616,Deployability,update,updated,616,". DIPMOM  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . DIPMOM. Compute the dipole moment? Note that quadrupole moments will also be computed if PRINT >= 2. Type: boolean; Default: false. Previous topic; DIIS_MAX_VECS; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__dipmom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__dipmom.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__maxiter-1.html:588,Deployability,update,updated,588,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MAXITER. Maximum number of iterations to converge the t1 and t2 amplitudes. Type: integer; Default: 100. Previous topic; DIPMOM; Next topic; MP2_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__maxiter.html:588,Deployability,update,updated,588,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MAXITER. Maximum number of iterations to converge the t1 and t2 amplitudes. Type: integer; Default: 100. Previous topic; DIPMOM; Next topic; MP2_SCALE_OS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os-1.html:574,Deployability,update,updated,574,". MP2_SCALE_OS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MP2_SCALE_OS. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. Previous topic; MAXITER; Next topic; MP2_SCALE_SS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os.html:574,Deployability,update,updated,574,". MP2_SCALE_OS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MP2_SCALE_OS. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. Previous topic; MAXITER; Next topic; MP2_SCALE_SS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_os.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss-1.html:579,Deployability,update,updated,579,". MP2_SCALE_SS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MP2_SCALE_SS. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. Previous topic; MP2_SCALE_OS; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss.html:579,Deployability,update,updated,579,". MP2_SCALE_SS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . MP2_SCALE_SS. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. Previous topic; MP2_SCALE_OS; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__mp2_scale_ss.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__r_convergence-1.html:664,Deployability,update,updated,664,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . R_CONVERGENCE. Desired convergence for the t1 and t2 amplitudes, defined as the norm of the change in the amplitudes between iterations. Type: conv double; Default: 1.0e-7. Previous topic; MP2_SCALE_SS; Next topic; SCS_CEPA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__r_convergence.html:664,Deployability,update,updated,664,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . R_CONVERGENCE. Desired convergence for the t1 and t2 amplitudes, defined as the norm of the change in the amplitudes between iterations. Type: conv double; Default: 1.0e-7. Previous topic; MP2_SCALE_SS; Next topic; SCS_CEPA; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html:653,Deployability,update,updated,653,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html:179,Performance,Perform,Perform,179,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html:278,Performance,optimiz,optimized,278,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html:653,Deployability,update,updated,653,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html:179,Performance,Perform,Perform,179,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html:278,Performance,optimiz,optimized,278,". SCS_CEPA  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA . SCS_CEPA. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Previous topic; R_CONVERGENCE; Next topic; CIS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CEPA .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cepa__scs_cepa.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__diag_method-1.html:603,Deployability,update,updated,603,". DIAG_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DIAG_METHOD. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. Previous topic; CIS; Next topic; DOMAIN_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__diag_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__diag_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__diag_method.html:603,Deployability,update,updated,603,". DIAG_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DIAG_METHOD. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. Previous topic; CIS; Next topic; DOMAIN_PRINT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__diag_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__diag_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domains-1.html:523,Deployability,update,updated,523,". DOMAINS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DOMAINS. Type: array; Default: No Default. Previous topic; DOMAIN_PRINT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__domains-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domains-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domains.html:523,Deployability,update,updated,523,". DOMAINS  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DOMAINS. Type: array; Default: No Default. Previous topic; DOMAIN_PRINT; Next topic; LOCAL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__domains.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domains.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domain_print-1.html:554,Deployability,update,updated,554,". DOMAIN_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DOMAIN_PRINT. Do print the domains?. Type: boolean; Default: false. Previous topic; DIAG_METHOD; Next topic; DOMAINS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__domain_print-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domain_print-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domain_print.html:554,Deployability,update,updated,554,". DOMAIN_PRINT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . DOMAIN_PRINT. Do print the domains?. Type: boolean; Default: false. Previous topic; DIAG_METHOD; Next topic; DOMAINS; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__domain_print.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__domain_print.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local-1.html:587,Deployability,update,updated,587,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; DOMAINS; Next topic; LOCAL_AMPS_PRINT_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local.html:587,Deployability,update,updated,587,". LOCAL  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. Previous topic; DOMAINS; Next topic; LOCAL_AMPS_PRINT_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff-1.html:594,Deployability,update,updated,594,". LOCAL_AMPS_PRINT_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_AMPS_PRINT_CUTOFF. Cutoff value for printing local amplitudes. Type: double; Default: 0.60. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff.html:594,Deployability,update,updated,594,". LOCAL_AMPS_PRINT_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_AMPS_PRINT_CUTOFF. Cutoff value for printing local amplitudes. Type: double; Default: 0.60. Previous topic; LOCAL; Next topic; LOCAL_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_amps_print_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_cutoff-1.html:819,Deployability,update,updated,819,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_AMPS_PRINT_CUTOFF; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_cutoff-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_cutoff-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_cutoff.html:819,Deployability,update,updated,819,". LOCAL_CUTOFF  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_CUTOFF. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. Previous topic; LOCAL_AMPS_PRINT_CUTOFF; Next topic; LOCAL_GHOST; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_cutoff.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_cutoff.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_ghost-1.html:532,Deployability,update,updated,532,". LOCAL_GHOST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_GHOST. Type: integer; Default: -1. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_ghost-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_ghost-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_ghost.html:532,Deployability,update,updated,532,". LOCAL_GHOST  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_GHOST. Type: integer; Default: -1. Previous topic; LOCAL_CUTOFF; Next topic; LOCAL_METHOD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_ghost.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_ghost.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_method-1.html:753,Deployability,update,updated,753,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_METHOD. Type of local-CIS scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers. Type: string; Possible Values: AOBASIS, WERNER; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_method-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_method-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_method.html:753,Deployability,update,updated,753,". LOCAL_METHOD  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_METHOD. Type of local-CIS scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers. Type: string; Possible Values: AOBASIS, WERNER; Default: WERNER. Previous topic; LOCAL_GHOST; Next topic; LOCAL_WEAKP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_method.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_method.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html:860,Deployability,update,updated,860,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_METHOD; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html:439,Energy Efficiency,energy,energy,439,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_METHOD; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html:860,Deployability,update,updated,860,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_METHOD; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html:439,Energy Efficiency,energy,energy,439,". LOCAL_WEAKP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . LOCAL_WEAKP. Desired treatment of weak pairs in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. Previous topic; LOCAL_METHOD; Next topic; MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__local_weakp.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__maxiter-1.html:555,Deployability,update,updated,555,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . MAXITER. Maximum number of iterations. Type: integer; Default: 500. Previous topic; LOCAL_WEAKP; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__maxiter-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__maxiter-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__maxiter.html:555,Deployability,update,updated,555,". MAXITER  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . MAXITER. Maximum number of iterations. Type: integer; Default: 500. Previous topic; LOCAL_WEAKP; Next topic; R_CONVERGENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__maxiter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__maxiter.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__reference-1.html:594,Deployability,update,updated,594,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__reference-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__reference-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__reference.html:594,Deployability,update,updated,594,". REFERENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . REFERENCE. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. Previous topic; R_CONVERGENCE; Next topic; ROOTS_PER_IRREP; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__reference.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__reference.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep-1.html:611,Deployability,update,updated,611,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep.html:611,Deployability,update,updated,611,". ROOTS_PER_IRREP  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . ROOTS_PER_IRREP. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. Previous topic; REFERENCE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__roots_per_irrep.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__r_convergence-1.html:578,Deployability,update,updated,578,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . R_CONVERGENCE. Convergence criterion for CIS wavefunction. Type: conv double; Default: 1e-7. Previous topic; MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__r_convergence-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__r_convergence-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__r_convergence.html:578,Deployability,update,updated,578,". R_CONVERGENCE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . R_CONVERGENCE. Convergence criterion for CIS wavefunction. Type: conv double; Default: 1e-7. Previous topic; MAXITER; Next topic; REFERENCE; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__r_convergence.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__r_convergence.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__wfn-1.html:576,Deployability,update,updated,576,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . WFN. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, CIS; Default: CIS. Previous topic; ROOTS_PER_IRREP; Next topic; CLAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__wfn.html:576,Deployability,update,updated,576,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS . WFN. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, CIS; Default: CIS. Previous topic; ROOTS_PER_IRREP; Next topic; CLAG; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CIS .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cis__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cis__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__cas_files_write-1.html:626,Deployability,update,updated,626,". CAS_FILES_WRITE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CLAG; Next topic; FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__cas_files_write-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__cas_files_write-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__cas_files_write.html:626,Deployability,update,updated,626,". CAS_FILES_WRITE  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . CAS_FILES_WRITE. Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. Previous topic; CLAG; Next topic; FOLLOW_ROOT; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__cas_files_write.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__cas_files_write.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__follow_root-1.html:545,Deployability,update,updated,545,". FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . FOLLOW_ROOT. Root to get OPDM. Type: integer; Default: 1. Previous topic; CAS_FILES_WRITE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__follow_root-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__follow_root-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__follow_root.html:545,Deployability,update,updated,545,". FOLLOW_ROOT  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . FOLLOW_ROOT. Root to get OPDM. Type: integer; Default: 1. Previous topic; CAS_FILES_WRITE; Next topic; WFN; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__follow_root.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__follow_root.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__wfn-1.html:529,Deployability,update,updated,529,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . WFN. Wavefunction type. Type: string; Default: NONE. Previous topic; FOLLOW_ROOT; Next topic; CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__wfn-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__wfn-1.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__wfn.html:529,Deployability,update,updated,529,". WFN  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG . WFN. Wavefunction type. Type: string; Default: NONE. Previous topic; FOLLOW_ROOT; Next topic; CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CLAG .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/clag__wfn.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/clag__wfn.html
https://psicode.org/psi4manual/4.0b3/autodir_options_c/cphf__cis_ad_states-1.html:629,Deployability,update,updated,629,". CIS_AD_STATES  PSI4 [beta3] documentation. Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CPHF . CIS_AD_STATES. Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. Previous topic; CPHF; Next topic; CIS_AMPLITUDE_CUTOFF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  . toc  . next  . previous  ; PSI4 [beta3]  ; Appendices ; Keywords by Module ; CPHF .  Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4manual/4.0b3/autodir_options_c/cphf__cis_ad_states-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/cphf__cis_ad_states-1.html
